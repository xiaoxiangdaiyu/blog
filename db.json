{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/sourcemap/index.js.map","path":"sourcemap/index.js.map","modified":1,"renderable":0},{"_id":"source/img/bfc/1.png","path":"img/bfc/1.png","modified":1,"renderable":0},{"_id":"source/img/bfc/2.png","path":"img/bfc/2.png","modified":1,"renderable":0},{"_id":"source/img/bfc/4.png","path":"img/bfc/4.png","modified":1,"renderable":0},{"_id":"source/img/bfc/3.png","path":"img/bfc/3.png","modified":1,"renderable":0},{"_id":"source/img/redux/middleware.jpg","path":"img/redux/middleware.jpg","modified":1,"renderable":0},{"_id":"source/pwa/asset/sw.jpg","path":"pwa/asset/sw.jpg","modified":1,"renderable":0},{"_id":"themes/hexo-theme-next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"source/img/jstype/2.png","path":"img/jstype/2.png","modified":1,"renderable":0},{"_id":"source/img/performance/1.png","path":"img/performance/1.png","modified":1,"renderable":0},{"_id":"source/img/performance/2.png","path":"img/performance/2.png","modified":1,"renderable":0},{"_id":"source/img/jstype/3.png","path":"img/jstype/3.png","modified":1,"renderable":0},{"_id":"source/img/jstype/1.png","path":"img/jstype/1.png","modified":1,"renderable":0},{"_id":"source/img/pwa/3.png","path":"img/pwa/3.png","modified":1,"renderable":0},{"_id":"source/img/pwa/4.png","path":"img/pwa/4.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"source/img/pwa/2.png","path":"img/pwa/2.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"source/img/pwa/1.png","path":"img/pwa/1.png","modified":1,"renderable":0},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/img/watchfile/md51.gif","path":"img/watchfile/md51.gif","modified":1,"renderable":0},{"_id":"source/img/watchfile/watch1.gif","path":"img/watchfile/watch1.gif","modified":1,"renderable":0},{"_id":"source/img/watchfile/watchFile.gif","path":"img/watchfile/watchFile.gif","modified":1,"renderable":0}],"Cache":[{"_id":"source/CNAME","hash":"8962578830ff3908b06d264d46ed7a0c287ebc2e","modified":1535096899000},{"_id":"source/.DS_Store","hash":"8983992a301632f377142eb0de9b7125c7a7c97a","modified":1555424015906},{"_id":"themes/hexo-theme-next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1535099702000},{"_id":"themes/hexo-theme-next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1535099702000},{"_id":"themes/hexo-theme-next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1535099702000},{"_id":"themes/hexo-theme-next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1535099702000},{"_id":"themes/hexo-theme-next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1535099702000},{"_id":"themes/hexo-theme-next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1535099702000},{"_id":"themes/hexo-theme-next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1535099702000},{"_id":"themes/hexo-theme-next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1535099702000},{"_id":"themes/hexo-theme-next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1535099702000},{"_id":"themes/hexo-theme-next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1535099702000},{"_id":"themes/hexo-theme-next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1535099702000},{"_id":"themes/hexo-theme-next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1535099702000},{"_id":"themes/hexo-theme-next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1535099702000},{"_id":"themes/hexo-theme-next/_config.yml","hash":"54fcd5125c6f837d3c69e263c26356dc4746ea2b","modified":1535100007000},{"_id":"themes/hexo-theme-next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1535099702000},{"_id":"themes/hexo-theme-next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1535099702000},{"_id":"source/_posts/AOP.md","hash":"b259608ed38249344ab5f489f1c5c66d76806336","modified":1540554589000},{"_id":"source/_posts/CORS.md","hash":"5e217a07bb7256b696d5affbf7847553a5cba9c4","modified":1562031922392},{"_id":"source/_posts/Di.md","hash":"c5398f53bf6d7e33b35690dfe75cde7c0b60369e","modified":1540455746000},{"_id":"source/_posts/babelplugin.md","hash":"fafc7da1d1f3728ab169125bf347e5cd3ecc688f","modified":1569229705446},{"_id":"source/_posts/bfc.md","hash":"1a5e2e1e2f40922d04302eec9a7a0c63efa07313","modified":1535096899000},{"_id":"source/_posts/content-type.md","hash":"0c70a10f4464844de934b587978a227377cef10b","modified":1555386468777},{"_id":"source/_posts/debug.md","hash":"afb1feb7e7eabf0c29dc6d9bbbbd9d3c9e276877","modified":1577689566339},{"_id":"source/_posts/data-structure.md","hash":"58a120bf55f6bb205a22387125db38fa8bf7b7b5","modified":1572953951749},{"_id":"source/_posts/gitcheckout.md","hash":"26570108e1d9092875da1e34936d8e7e088c503a","modified":1577763880728},{"_id":"source/_posts/event.md","hash":"c1bc81839df0abe6ed108ceb7747e95e6fd97db4","modified":1535247085000},{"_id":"source/_posts/f5.md","hash":"356224297bbbba0c6486a7995aeea5d7e0428844","modified":1543548007903},{"_id":"source/_posts/domevent.md","hash":"ee817893d03d75326bb237838a3d3b77e4dd51d5","modified":1535096899000},{"_id":"source/_posts/index.md","hash":"15cc52b747f3986742b3a69dc0db2088b390fff9","modified":1535096899000},{"_id":"source/_posts/header.md","hash":"a38228ecdadb35b3023c847300610f3b30b44361","modified":1543548002474},{"_id":"source/_posts/ifelse.md","hash":"7f7c30753981bdf98147a8a4a8cb64ea7a50a3ea","modified":1547090489867},{"_id":"source/_posts/jstype.md","hash":"18b1b7b20b3e4db015f528806c81fcf6fbb6e7f5","modified":1535096899000},{"_id":"source/_posts/ioc.md","hash":"e67d6cfd0bdeca9851d1808ea026422bd6e1c5b4","modified":1540455271000},{"_id":"source/_posts/normalize.md","hash":"7df2e088ff5c80272d3b84191d9cf7a5f0e3d4be","modified":1550565436487},{"_id":"source/_posts/performance.md","hash":"74036855e631757b1bb1e7335de93d3f4d037dd0","modified":1535096899000},{"_id":"source/_posts/review.md","hash":"82b69e7b3e6685e28e987cf8d45304ba52d6eed2","modified":1535096899000},{"_id":"source/_posts/pwa.md","hash":"2cdfa819224a8b0d4d862f393c92c10f384e0955","modified":1535096899000},{"_id":"source/_posts/react-redux.md","hash":"e7bc2ffea513d65a179232aa09c83ef8b5bbed64","modified":1558345623292},{"_id":"source/_posts/react-router.md","hash":"b58d020e3444ef599953271dcb4323d64d18a121","modified":1541768203848},{"_id":"source/_posts/watchfile.md","hash":"54cbb97c9ca6766380431c83233750a7eea8c8f0","modified":1555424351683},{"_id":"source/_posts/scroll.md","hash":"c83ed21de7a7ee9c577929fa259ce60d8ea619de","modified":1535099922000},{"_id":"source/canvas/cav.html","hash":"f3fcb4d11912f08afece2a4a49868cdd05055992","modified":1547716407134},{"_id":"source/_posts/webpack.md","hash":"34d37cb052b409973c04ee86d589722bb879cb19","modified":1570709556869},{"_id":"source/canvas/demo1.js","hash":"99b4a4d64250d79016b3808e4f6894e00d2154f6","modified":1545141546710},{"_id":"source/canvas/demo2.js","hash":"aaceef8f2ce0022e80544f27c430b4340c62d547","modified":1545382488916},{"_id":"source/canvas/index.js","hash":"59f28bea344a9c32e881b48c50c0d7ece120fd05","modified":1545140864367},{"_id":"source/event/index.html","hash":"46fa01858f5adffc6732baaa04c4fc5b3c5fcbf7","modified":1535206977000},{"_id":"source/img/.DS_Store","hash":"de9d6fc26a61acb29c9392f3bc6e655d3a314dc0","modified":1558429186180},{"_id":"source/ioc/index.js","hash":"089dd152adb09ce8bda49e4dfe3ef79f7924edab","modified":1540382778000},{"_id":"source/pwa/index.js","hash":"192300dc1d7d5f3d501085e60775528a4d2ea71c","modified":1535096899000},{"_id":"source/pwa/mainfest.json","hash":"3231742038985fbf47796e6100e570242239b108","modified":1535096899000},{"_id":"source/pwa/sw1.js","hash":"13af6af10204ff87872fa13e836f87554c998f44","modified":1535096899000},{"_id":"source/pwa/demo.html","hash":"7e805b18e6116094cd2180d04156ff6e0e34b56c","modified":1535096899000},{"_id":"source/sourcemap/index.html","hash":"aa4287e9e1b33a3751da82bafab9ebb534664b09","modified":1568615060348},{"_id":"source/structure/linklist.js","hash":"6dd9933850bc9b76c06e0643fe086af553dd12f9","modified":1576485175377},{"_id":"source/structure/data.js","hash":"9cc5dc6ed949b96f4a9aabc1562656bfb633cea6","modified":1576487374647},{"_id":"source/sourcemap/index.js","hash":"81eb5b2195cca80e92f1b1b6b0865a3051bfa854","modified":1568615060349},{"_id":"source/sourcemap/index.js.map","hash":"9742a7afb4b2e606939c98c41d0db95883ab8b6e","modified":1568615060351},{"_id":"themes/hexo-theme-next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1535099702000},{"_id":"themes/hexo-theme-next/.git/COMMIT_EDITMSG","hash":"92beb40d1a86a6509c300d948703802d656b31c9","modified":1535206609000},{"_id":"themes/hexo-theme-next/.git/config","hash":"a33539305f85ea695520b496f67659d5751acff8","modified":1535099702000},{"_id":"source/structure/sort.js","hash":"a314f88a4f97500b252d32048ec9d41000929096","modified":1576487320407},{"_id":"themes/hexo-theme-next/.git/index","hash":"8153416512e36ce7b263b337f0c4249eafa2c8a9","modified":1535206609000},{"_id":"themes/hexo-theme-next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/packed-refs","hash":"69237944e31c16fe545d1f47b0b1e5b1d99660da","modified":1535099702000},{"_id":"themes/hexo-theme-next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1535099702000},{"_id":"themes/hexo-theme-next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1535099702000},{"_id":"themes/hexo-theme-next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1535099702000},{"_id":"themes/hexo-theme-next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1535099702000},{"_id":"themes/hexo-theme-next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1535099702000},{"_id":"themes/hexo-theme-next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1535099702000},{"_id":"themes/hexo-theme-next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1535099702000},{"_id":"themes/hexo-theme-next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1535099702000},{"_id":"themes/hexo-theme-next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1535099702000},{"_id":"themes/hexo-theme-next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535099702000},{"_id":"source/_posts/css/postcss.md","hash":"0191b0790a7ada76777f6b8add267a203e4d9f32","modified":1535096899000},{"_id":"source/_posts/redux/redux1.md","hash":"c455cdb9bfbd8e33fe62a811571664adf7ccd787","modified":1535096899000},{"_id":"source/_posts/redux/redux2.md","hash":"7d293ee71056284a29ca4833f694768ae183cd4e","modified":1558425279972},{"_id":"source/_posts/webpack/code-splitting.md","hash":"6bca00c152249bc7bde8bb30b2563dfc4e1b0016","modified":1535096899000},{"_id":"source/_posts/webpack/loader.md","hash":"fb996f7834812b4ffb71c80f03bb51e3101d6b1f","modified":1535096899000},{"_id":"source/_posts/webpack/plugin.md","hash":"bce074830c7163f37f1417b20ba30e4cde58126c","modified":1535096899000},{"_id":"source/_posts/websocket/node.md","hash":"4dd3bd961e3018e1d0c4907c3dbc5dc3d86e45ea","modified":1535096899000},{"_id":"source/_posts/websocket/frame.md","hash":"e830c299edc51c914fb387fc1fe0945687ebd7e0","modified":1535096899000},{"_id":"source/img/bfc/1.png","hash":"073a5170e8ea6b34853b9c13d4cdcb7f3fc1dc08","modified":1535096899000},{"_id":"source/img/bfc/2.png","hash":"dcdc1c2294a080b12b25d3d6180a00c9dc1f1046","modified":1535096899000},{"_id":"source/img/bfc/4.png","hash":"e60e1ef6ae9141a6fbe082c0738e2b710dea4f23","modified":1535096899000},{"_id":"source/img/bfc/3.png","hash":"ea2033a704bca3c71c6b2930c922c048f37dda0a","modified":1535096899000},{"_id":"source/img/redux/.DS_Store","hash":"247c43e5c384cb8325cfefd652724eddcfadcdc4","modified":1558424964069},{"_id":"source/img/redux/middleware.jpg","hash":"66ec46bd39239d4772e841c33b89407ab00f6612","modified":1558424914024},{"_id":"source/ioc/v1/player.js","hash":"55a50f1f1de4b280f91c1cba88069c1a13ab3d58","modified":1540382512000},{"_id":"source/ioc/v1/team.js","hash":"48a24182fa4272297687fb37a8a33e9dc8a7a84a","modified":1540382472000},{"_id":"source/pwa/asset/sw.jpg","hash":"55965b91726892f738ba56643f2eaeb8af7fd762","modified":1535096899000},{"_id":"source/sourcemap/src/main.js","hash":"7a9252308df7754de2f63a9929a5681426c6699f","modified":1568615060353},{"_id":"source/theme/part1/index.html","hash":"c483e1c613ff5d152180c083c9212782be659deb","modified":1568951482789},{"_id":"source/sourcemap/src/log.js","hash":"11acdb3cb01a1e174f7028e7a7a14115c6d3204c","modified":1568615060352},{"_id":"themes/hexo-theme-next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1535099616000},{"_id":"themes/hexo-theme-next/.git/logs/HEAD","hash":"98a99a4b18cf2befbe23e239d117dde1b491ad7e","modified":1535206609000},{"_id":"themes/hexo-theme-next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1535099702000},{"_id":"themes/hexo-theme-next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1535099702000},{"_id":"themes/hexo-theme-next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1535099702000},{"_id":"themes/hexo-theme-next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1535099702000},{"_id":"themes/hexo-theme-next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1535099702000},{"_id":"themes/hexo-theme-next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1535099702000},{"_id":"themes/hexo-theme-next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1535099702000},{"_id":"themes/hexo-theme-next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1535099702000},{"_id":"themes/hexo-theme-next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1535099702000},{"_id":"source/img/jstype/2.png","hash":"08957b47ee972258c8aab3d5e4c9abd49010db26","modified":1535096899000},{"_id":"source/img/performance/1.png","hash":"2051f0f5801d2e336fc95e0052ecedba7fb08a0f","modified":1535096899000},{"_id":"source/img/performance/2.png","hash":"a7e1421f5df1fcb8203c76d457fb813221aa3e85","modified":1535096899000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1535099702000},{"_id":"source/img/jstype/3.png","hash":"70f96b01ef09e050a5c179f40342c3179eca714d","modified":1535096899000},{"_id":"source/img/jstype/1.png","hash":"313fa0d1e78fc4fbcf5d7f1e71681a3466f4a81a","modified":1535096899000},{"_id":"source/img/pwa/3.png","hash":"cb936733f999e28e9349d189fb3d26b1b6c86929","modified":1535096899000},{"_id":"source/img/pwa/4.png","hash":"ea21e2618ecf07e76d81e24977d4f379bed83b38","modified":1535096899000},{"_id":"themes/hexo-theme-next/.git/objects/a2/e3d850aae3f8f1b6c67ff3002f7ce41892ecd0","hash":"241306ed5176a17f88de21151fcf05e6ab929a31","modified":1535206609000},{"_id":"themes/hexo-theme-next/.git/objects/d2/5721aca4e06a41237bafec5fc934cdf9cccacf","hash":"654eb59b25445797f50bb97bad03df5f8d4b63a5","modified":1535206609000},{"_id":"themes/hexo-theme-next/.git/refs/heads/master","hash":"c713f141967fa31143d1f75f69d7c4964fc75b22","modified":1535206609000},{"_id":"themes/hexo-theme-next/.git/objects/91/eb989e04f79998fd924c335513b040b4551cac","hash":"91183616612f806cccff90e32ff15af1a4d2474e","modified":1535206609000},{"_id":"themes/hexo-theme-next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1535099702000},{"_id":"source/img/pwa/2.png","hash":"3d8170ef49e9c7a6eb717abb7e6ff506a8fb0222","modified":1535096899000},{"_id":"themes/hexo-theme-next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1535099702000},{"_id":"themes/hexo-theme-next/.git/logs/refs/heads/master","hash":"98a99a4b18cf2befbe23e239d117dde1b491ad7e","modified":1535206609000},{"_id":"themes/hexo-theme-next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1535099702000},{"_id":"themes/hexo-theme-next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1535099702000},{"_id":"source/img/pwa/1.png","hash":"59f1ce1a903ed76b8434af748258d6172da506d1","modified":1535096899000},{"_id":"themes/hexo-theme-next/.git/logs/refs/remotes/origin/HEAD","hash":"3fa8302e1213bb25857d86f680d8ef390dce85bc","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1535099702000},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-c612b977fdee8f070a000761134eeb6350850a38.idx","hash":"baccc333989b5a1b1719965c6c3a9891cce61ff6","modified":1535099701000},{"_id":"themes/hexo-theme-next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1535099702000},{"_id":"themes/hexo-theme-next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1535099702000},{"_id":"themes/hexo-theme-next/.git/objects/pack/pack-c612b977fdee8f070a000761134eeb6350850a38.pack","hash":"1310fd9358c94811f585a7fa3724d7431f130898","modified":1535099701000},{"_id":"source/img/watchfile/md51.gif","hash":"ee8ed90f330134ef4c46db69ca9af77fd4771d51","modified":1555423100800},{"_id":"source/img/watchfile/watch1.gif","hash":"d183ad2f874747b2839416f3b9abb2cd4fb73447","modified":1555421766608},{"_id":"source/img/watchfile/watchFile.gif","hash":"619ccaa8479ca06c946814252ea3a86e2737f8a3","modified":1555468761053}],"Category":[],"Data":[],"Page":[{"_content":"<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src https://*;\">\n    <title>canvas</title>\n</head>\n\n<body>\n\n    \n    <div id='root'>\n    </div>\n    <canvas id=\"tutorial\" width=\"150\" height=\"150\">current stock price: $3.15 +0.15</canvas>\n    <!-- <script src=\"./index.js\"></script> -->\n    <script src=\"./demo2.js\"></script>\n</body>\n\n</html>\n","source":"canvas/cav.html","raw":"<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src https://*;\">\n    <title>canvas</title>\n</head>\n\n<body>\n\n    \n    <div id='root'>\n    </div>\n    <canvas id=\"tutorial\" width=\"150\" height=\"150\">current stock price: $3.15 +0.15</canvas>\n    <!-- <script src=\"./index.js\"></script> -->\n    <script src=\"./demo2.js\"></script>\n</body>\n\n</html>\n","date":"2019-01-17T09:13:27.134Z","updated":"2019-01-17T09:13:27.134Z","path":"canvas/cav.html","title":"","comments":1,"layout":"page","_id":"ck4tbvt120001gw92m7bcb8o8","content":"<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src https://*;\">\n    <title>canvas</title>\n</head>\n\n<body>\n\n    \n    <div id=\"root\">\n    </div>\n    <canvas id=\"tutorial\" width=\"150\" height=\"150\">current stock price: $3.15 +0.15</canvas>\n    <!-- <script src=\"./index.js\"></script> -->\n    <script src=\"./demo2.js\"></script>\n</body>\n\n</html>\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta http-equiv=\"Content-Security-Policy\" content=\"default-src https://*;\">\n    <title>canvas</title>\n</head>\n\n<body>\n\n    \n    <div id=\"root\">\n    </div>\n    <canvas id=\"tutorial\" width=\"150\" height=\"150\">current stock price: $3.15 +0.15</canvas>\n    <!-- <script src=\"./index.js\"></script> -->\n    <script src=\"./demo2.js\"></script>\n</body>\n\n</html>\n"},{"_content":"var Demo1 =  {\n    init(){\n        var canvas = document.querySelector('#tutorial');\n        var ctx = canvas.getContext('2d');\n        if(ctx){\n            var ctx = canvas.getContext(\"2d\");\n\n            ctx.fillStyle = \"rgb(200,0,0)\";\n            ctx.fillRect(10, 10, 55, 50);\n\n            ctx.fillStyle = \"rgba(0, 0, 200, 0.5)\";\n            ctx.fillRect(30, 30, 55, 50);\n        }else{\n            alert('暂时不支持')\n        }\n    }\n    \n}\nDemo1.init()","source":"canvas/demo1.js","raw":"var Demo1 =  {\n    init(){\n        var canvas = document.querySelector('#tutorial');\n        var ctx = canvas.getContext('2d');\n        if(ctx){\n            var ctx = canvas.getContext(\"2d\");\n\n            ctx.fillStyle = \"rgb(200,0,0)\";\n            ctx.fillRect(10, 10, 55, 50);\n\n            ctx.fillStyle = \"rgba(0, 0, 200, 0.5)\";\n            ctx.fillRect(30, 30, 55, 50);\n        }else{\n            alert('暂时不支持')\n        }\n    }\n    \n}\nDemo1.init()","date":"2018-12-18T13:59:06.710Z","updated":"2018-12-18T13:59:06.710Z","path":"canvas/demo1.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt140003gw92dy6pmwl5","content":"var Demo1 =  {\n    init(){\n        var canvas = document.querySelector('#tutorial');\n        var ctx = canvas.getContext('2d');\n        if(ctx){\n            var ctx = canvas.getContext(\"2d\");\n\n            ctx.fillStyle = \"rgb(200,0,0)\";\n            ctx.fillRect(10, 10, 55, 50);\n\n            ctx.fillStyle = \"rgba(0, 0, 200, 0.5)\";\n            ctx.fillRect(30, 30, 55, 50);\n        }else{\n            alert('暂时不支持')\n        }\n    }\n    \n}\nDemo1.init()","site":{"data":{}},"excerpt":"","more":"var Demo1 =  {\n    init(){\n        var canvas = document.querySelector('#tutorial');\n        var ctx = canvas.getContext('2d');\n        if(ctx){\n            var ctx = canvas.getContext(\"2d\");\n\n            ctx.fillStyle = \"rgb(200,0,0)\";\n            ctx.fillRect(10, 10, 55, 50);\n\n            ctx.fillStyle = \"rgba(0, 0, 200, 0.5)\";\n            ctx.fillRect(30, 30, 55, 50);\n        }else{\n            alert('暂时不支持')\n        }\n    }\n    \n}\nDemo1.init()"},{"_content":"var Demo1 =  {\n    init(){\n        var canvas = document.querySelector('#tutorial');\n        var ctx = canvas.getContext('2d');\n        if(ctx){\n            ctx.beginPath();\n            ctx.lineWidth = 10;\n            ctx.moveTo(20, 20);\n            ctx.lineTo(100, 50);\n            ctx.lineTo(20, 100);\n            ctx.stroke();\n\n            ctx.beginPath();\n            ctx.moveTo(100, 100);\n            ctx.lineTo(100, 150);\n            ctx.strokeStyle = \"red\";\n            ctx.stroke();\n        }else{\n            alert('暂时不支持')\n        }\n    }\n    \n}\nDemo1.init()","source":"canvas/demo2.js","raw":"var Demo1 =  {\n    init(){\n        var canvas = document.querySelector('#tutorial');\n        var ctx = canvas.getContext('2d');\n        if(ctx){\n            ctx.beginPath();\n            ctx.lineWidth = 10;\n            ctx.moveTo(20, 20);\n            ctx.lineTo(100, 50);\n            ctx.lineTo(20, 100);\n            ctx.stroke();\n\n            ctx.beginPath();\n            ctx.moveTo(100, 100);\n            ctx.lineTo(100, 150);\n            ctx.strokeStyle = \"red\";\n            ctx.stroke();\n        }else{\n            alert('暂时不支持')\n        }\n    }\n    \n}\nDemo1.init()","date":"2018-12-21T08:54:48.916Z","updated":"2018-12-21T08:54:48.916Z","path":"canvas/demo2.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt160005gw928a9ophpe","content":"var Demo1 =  {\n    init(){\n        var canvas = document.querySelector('#tutorial');\n        var ctx = canvas.getContext('2d');\n        if(ctx){\n            ctx.beginPath();\n            ctx.lineWidth = 10;\n            ctx.moveTo(20, 20);\n            ctx.lineTo(100, 50);\n            ctx.lineTo(20, 100);\n            ctx.stroke();\n\n            ctx.beginPath();\n            ctx.moveTo(100, 100);\n            ctx.lineTo(100, 150);\n            ctx.strokeStyle = \"red\";\n            ctx.stroke();\n        }else{\n            alert('暂时不支持')\n        }\n    }\n    \n}\nDemo1.init()","site":{"data":{}},"excerpt":"","more":"var Demo1 =  {\n    init(){\n        var canvas = document.querySelector('#tutorial');\n        var ctx = canvas.getContext('2d');\n        if(ctx){\n            ctx.beginPath();\n            ctx.lineWidth = 10;\n            ctx.moveTo(20, 20);\n            ctx.lineTo(100, 50);\n            ctx.lineTo(20, 100);\n            ctx.stroke();\n\n            ctx.beginPath();\n            ctx.moveTo(100, 100);\n            ctx.lineTo(100, 150);\n            ctx.strokeStyle = \"red\";\n            ctx.stroke();\n        }else{\n            alert('暂时不支持')\n        }\n    }\n    \n}\nDemo1.init()"},{"_content":"import Demo1 from './demo1'\nfunction draw(){\n    var d1 = new Demo1()\n}\ndraw()","source":"canvas/index.js","raw":"import Demo1 from './demo1'\nfunction draw(){\n    var d1 = new Demo1()\n}\ndraw()","date":"2018-12-18T13:47:44.367Z","updated":"2018-12-18T13:47:44.367Z","path":"canvas/index.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt180007gw92zrw21dd2","content":"import Demo1 from './demo1'\nfunction draw(){\n    var d1 = new Demo1()\n}\ndraw()","site":{"data":{}},"excerpt":"","more":"import Demo1 from './demo1'\nfunction draw(){\n    var d1 = new Demo1()\n}\ndraw()"},{"_content":"const  Player = require('./v1/player');\nplayer.info()","source":"ioc/index.js","raw":"const  Player = require('./v1/player');\nplayer.info()","date":"2018-10-24T12:06:18.000Z","updated":"2018-10-24T12:06:18.000Z","path":"ioc/index.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt1a0009gw920chphn7r","content":"const  Player = require('./v1/player');\nplayer.info()","site":{"data":{}},"excerpt":"","more":"const  Player = require('./v1/player');\nplayer.info()"},{"_content":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n<head>\n    <title>\n        自定义事件\n    </title>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta name=\"keywords\" content=\"react.js, react, component, components, ui, framework\">\n</head>\n\n<body>\n    <div>一本书的价格：<input type='text' id='el' value=10 /></div>\n    <div>5本书的价格：<span id='el2'>50</span>元</div>\n</body>\n<script>\n    // 事件系统\n    class Event1 {\n        constructor() {\n            // 事件队列\n            this._events = {}\n        }\n        // type对应事件名称，call回调\n        on(type, call) {\n            let funs = this._events[type]\n            // 首次直接赋值，同种类型事件可能多个回调所以数组\n            // 否则push进入队列即可\n            if (funs) {\n                funs.push(call)\n            } else {\n                this._events.type = []\n                this._events.type.push(call)\n            }\n        }\n        // 触发事件\n        trigger(type) {\n            let funs = this._events.type,\n                [first, ...other] = Array.from(arguments)\n            //对应事件类型存在，循环执行回调队列  \n            if (funs) {\n                let i = 0,\n                    j = funs.length;\n                for (i = 0; i < j; i++) {\n                    let cb = funs[i];\n                    cb.apply(this, other);\n                }\n            }\n        }\n        // 取消绑定，还是循环\n        off(type, func) {\n            let funs = this._events.type\n            if (funs) {\n                let i = 0,\n                    j = funs.length;\n                for (i = 0; i < j; i++) {\n                    let cb = funs[i];\n                    if (cb === func) {\n                        funs.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n            return this\n        }\n    }\n    const count = document.querySelector('#el'),\n        total1 = document.querySelector('#el2');\n    const event1 = new Event1()\n    const eventAwesome = new CustomEvent('priceChange', {\n        bubbles: true,\n        detail: { getprice: () => count.value }\n    });\n    event1.on('priceChange', function (e) {\n        var price = count.value || 0\n        total1.innerHTML = 5 * price\n    })\n    el.addEventListener('change', function (e) {\n        var val = e.target.value\n        event1.trigger('priceChange')\n    });\n    /*************自定义浏览器事件系统分割线  *************/\n    // document.addEventListener('priceChange', function (e) {\n    //     var price = e.detail.getprice() || 0\n    //     total1.innerHTML=5 * price\n    //   })\n    // el.addEventListener('change', function (e) {\n    //   var val = e.target.value\n    //   e.target.dispatchEvent(eventAwesome)\n    // });\n</script>\n<script>\n    // 双向绑定\n    // let data = {\n    //     price: 5,\n    //     count: 2\n    // },\n    //     callb = null\n\n    // class Events {\n    //     constructor() {\n    //         this._events = []\n    //     }\n    //     on() {\n    //         if (callb && !this._events.includes(callb)) {\n    //             this._events.push(callb)\n    //         }\n    //     }\n    //     triger() {\n    //         this._events.forEach((callb) => {\n    //             callb && callb()\n    //         })\n    //     }\n    // }\n\n    // Object.keys(data).forEach((key) => {\n    //     let initVlue = data[key]\n    //     const e1 = new Events()\n    //     Object.defineProperty(data, key, {\n    //         get() {\n    //             //内部判断是否需要注册\n    //             e1.on()\n    //             // 执行过置否\n    //             callb = null\n    //             // get不变更值\n    //             return initVlue\n    //         },\n    //         set(newVal) {\n    //             initVlue = newVal\n    //             // set操作触发事件，同步数据变动\n    //             e1.triger()\n    //         }\n    //     })\n    // })\n    // function watcher(func) {\n    //     // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    //     callb = func\n    //     // 初次执行时，获取对应值自然经过get方法注册事件\n    //     callb()\n    //     // 置否避免重复注册\n    //     callb = null\n    // }\n    // // 此处指定事件触发回调，注册监听事件\n    // watcher(() => {\n    //     data.total = data.price * data.count\n    // })\n</script>\n\n</html>","source":"event/index.html","raw":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n<head>\n    <title>\n        自定义事件\n    </title>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta name=\"keywords\" content=\"react.js, react, component, components, ui, framework\">\n</head>\n\n<body>\n    <div>一本书的价格：<input type='text' id='el' value=10 /></div>\n    <div>5本书的价格：<span id='el2'>50</span>元</div>\n</body>\n<script>\n    // 事件系统\n    class Event1 {\n        constructor() {\n            // 事件队列\n            this._events = {}\n        }\n        // type对应事件名称，call回调\n        on(type, call) {\n            let funs = this._events[type]\n            // 首次直接赋值，同种类型事件可能多个回调所以数组\n            // 否则push进入队列即可\n            if (funs) {\n                funs.push(call)\n            } else {\n                this._events.type = []\n                this._events.type.push(call)\n            }\n        }\n        // 触发事件\n        trigger(type) {\n            let funs = this._events.type,\n                [first, ...other] = Array.from(arguments)\n            //对应事件类型存在，循环执行回调队列  \n            if (funs) {\n                let i = 0,\n                    j = funs.length;\n                for (i = 0; i < j; i++) {\n                    let cb = funs[i];\n                    cb.apply(this, other);\n                }\n            }\n        }\n        // 取消绑定，还是循环\n        off(type, func) {\n            let funs = this._events.type\n            if (funs) {\n                let i = 0,\n                    j = funs.length;\n                for (i = 0; i < j; i++) {\n                    let cb = funs[i];\n                    if (cb === func) {\n                        funs.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n            return this\n        }\n    }\n    const count = document.querySelector('#el'),\n        total1 = document.querySelector('#el2');\n    const event1 = new Event1()\n    const eventAwesome = new CustomEvent('priceChange', {\n        bubbles: true,\n        detail: { getprice: () => count.value }\n    });\n    event1.on('priceChange', function (e) {\n        var price = count.value || 0\n        total1.innerHTML = 5 * price\n    })\n    el.addEventListener('change', function (e) {\n        var val = e.target.value\n        event1.trigger('priceChange')\n    });\n    /*************自定义浏览器事件系统分割线  *************/\n    // document.addEventListener('priceChange', function (e) {\n    //     var price = e.detail.getprice() || 0\n    //     total1.innerHTML=5 * price\n    //   })\n    // el.addEventListener('change', function (e) {\n    //   var val = e.target.value\n    //   e.target.dispatchEvent(eventAwesome)\n    // });\n</script>\n<script>\n    // 双向绑定\n    // let data = {\n    //     price: 5,\n    //     count: 2\n    // },\n    //     callb = null\n\n    // class Events {\n    //     constructor() {\n    //         this._events = []\n    //     }\n    //     on() {\n    //         if (callb && !this._events.includes(callb)) {\n    //             this._events.push(callb)\n    //         }\n    //     }\n    //     triger() {\n    //         this._events.forEach((callb) => {\n    //             callb && callb()\n    //         })\n    //     }\n    // }\n\n    // Object.keys(data).forEach((key) => {\n    //     let initVlue = data[key]\n    //     const e1 = new Events()\n    //     Object.defineProperty(data, key, {\n    //         get() {\n    //             //内部判断是否需要注册\n    //             e1.on()\n    //             // 执行过置否\n    //             callb = null\n    //             // get不变更值\n    //             return initVlue\n    //         },\n    //         set(newVal) {\n    //             initVlue = newVal\n    //             // set操作触发事件，同步数据变动\n    //             e1.triger()\n    //         }\n    //     })\n    // })\n    // function watcher(func) {\n    //     // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    //     callb = func\n    //     // 初次执行时，获取对应值自然经过get方法注册事件\n    //     callb()\n    //     // 置否避免重复注册\n    //     callb = null\n    // }\n    // // 此处指定事件触发回调，注册监听事件\n    // watcher(() => {\n    //     data.total = data.price * data.count\n    // })\n</script>\n\n</html>","date":"2018-08-25T14:22:57.000Z","updated":"2018-08-25T14:22:57.000Z","path":"event/index.html","title":"","comments":1,"layout":"page","_id":"ck4tbvt1c000bgw92cxxzg8b1","content":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n<head>\n    <title>\n        自定义事件\n    </title>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta name=\"keywords\" content=\"react.js, react, component, components, ui, framework\">\n</head>\n\n<body>\n    <div>一本书的价格：<input type=\"text\" id=\"el\" value=\"10\"></div>\n    <div>5本书的价格：<span id=\"el2\">50</span>元</div>\n</body>\n<script>\n    // 事件系统\n    class Event1 {\n        constructor() {\n            // 事件队列\n            this._events = {}\n        }\n        // type对应事件名称，call回调\n        on(type, call) {\n            let funs = this._events[type]\n            // 首次直接赋值，同种类型事件可能多个回调所以数组\n            // 否则push进入队列即可\n            if (funs) {\n                funs.push(call)\n            } else {\n                this._events.type = []\n                this._events.type.push(call)\n            }\n        }\n        // 触发事件\n        trigger(type) {\n            let funs = this._events.type,\n                [first, ...other] = Array.from(arguments)\n            //对应事件类型存在，循环执行回调队列  \n            if (funs) {\n                let i = 0,\n                    j = funs.length;\n                for (i = 0; i < j; i++) {\n                    let cb = funs[i];\n                    cb.apply(this, other);\n                }\n            }\n        }\n        // 取消绑定，还是循环\n        off(type, func) {\n            let funs = this._events.type\n            if (funs) {\n                let i = 0,\n                    j = funs.length;\n                for (i = 0; i < j; i++) {\n                    let cb = funs[i];\n                    if (cb === func) {\n                        funs.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n            return this\n        }\n    }\n    const count = document.querySelector('#el'),\n        total1 = document.querySelector('#el2');\n    const event1 = new Event1()\n    const eventAwesome = new CustomEvent('priceChange', {\n        bubbles: true,\n        detail: { getprice: () => count.value }\n    });\n    event1.on('priceChange', function (e) {\n        var price = count.value || 0\n        total1.innerHTML = 5 * price\n    })\n    el.addEventListener('change', function (e) {\n        var val = e.target.value\n        event1.trigger('priceChange')\n    });\n    /*************自定义浏览器事件系统分割线  *************/\n    // document.addEventListener('priceChange', function (e) {\n    //     var price = e.detail.getprice() || 0\n    //     total1.innerHTML=5 * price\n    //   })\n    // el.addEventListener('change', function (e) {\n    //   var val = e.target.value\n    //   e.target.dispatchEvent(eventAwesome)\n    // });\n</script>\n<script>\n    // 双向绑定\n    // let data = {\n    //     price: 5,\n    //     count: 2\n    // },\n    //     callb = null\n\n    // class Events {\n    //     constructor() {\n    //         this._events = []\n    //     }\n    //     on() {\n    //         if (callb && !this._events.includes(callb)) {\n    //             this._events.push(callb)\n    //         }\n    //     }\n    //     triger() {\n    //         this._events.forEach((callb) => {\n    //             callb && callb()\n    //         })\n    //     }\n    // }\n\n    // Object.keys(data).forEach((key) => {\n    //     let initVlue = data[key]\n    //     const e1 = new Events()\n    //     Object.defineProperty(data, key, {\n    //         get() {\n    //             //内部判断是否需要注册\n    //             e1.on()\n    //             // 执行过置否\n    //             callb = null\n    //             // get不变更值\n    //             return initVlue\n    //         },\n    //         set(newVal) {\n    //             initVlue = newVal\n    //             // set操作触发事件，同步数据变动\n    //             e1.triger()\n    //         }\n    //     })\n    // })\n    // function watcher(func) {\n    //     // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    //     callb = func\n    //     // 初次执行时，获取对应值自然经过get方法注册事件\n    //     callb()\n    //     // 置否避免重复注册\n    //     callb = null\n    // }\n    // // 此处指定事件触发回调，注册监听事件\n    // watcher(() => {\n    //     data.total = data.price * data.count\n    // })\n</script>\n\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n<head>\n    <title>\n        自定义事件\n    </title>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta name=\"keywords\" content=\"react.js, react, component, components, ui, framework\">\n</head>\n\n<body>\n    <div>一本书的价格：<input type=\"text\" id=\"el\" value=\"10\"></div>\n    <div>5本书的价格：<span id=\"el2\">50</span>元</div>\n</body>\n<script>\n    // 事件系统\n    class Event1 {\n        constructor() {\n            // 事件队列\n            this._events = {}\n        }\n        // type对应事件名称，call回调\n        on(type, call) {\n            let funs = this._events[type]\n            // 首次直接赋值，同种类型事件可能多个回调所以数组\n            // 否则push进入队列即可\n            if (funs) {\n                funs.push(call)\n            } else {\n                this._events.type = []\n                this._events.type.push(call)\n            }\n        }\n        // 触发事件\n        trigger(type) {\n            let funs = this._events.type,\n                [first, ...other] = Array.from(arguments)\n            //对应事件类型存在，循环执行回调队列  \n            if (funs) {\n                let i = 0,\n                    j = funs.length;\n                for (i = 0; i < j; i++) {\n                    let cb = funs[i];\n                    cb.apply(this, other);\n                }\n            }\n        }\n        // 取消绑定，还是循环\n        off(type, func) {\n            let funs = this._events.type\n            if (funs) {\n                let i = 0,\n                    j = funs.length;\n                for (i = 0; i < j; i++) {\n                    let cb = funs[i];\n                    if (cb === func) {\n                        funs.splice(i, 1);\n                        return;\n                    }\n                }\n            }\n            return this\n        }\n    }\n    const count = document.querySelector('#el'),\n        total1 = document.querySelector('#el2');\n    const event1 = new Event1()\n    const eventAwesome = new CustomEvent('priceChange', {\n        bubbles: true,\n        detail: { getprice: () => count.value }\n    });\n    event1.on('priceChange', function (e) {\n        var price = count.value || 0\n        total1.innerHTML = 5 * price\n    })\n    el.addEventListener('change', function (e) {\n        var val = e.target.value\n        event1.trigger('priceChange')\n    });\n    /*************自定义浏览器事件系统分割线  *************/\n    // document.addEventListener('priceChange', function (e) {\n    //     var price = e.detail.getprice() || 0\n    //     total1.innerHTML=5 * price\n    //   })\n    // el.addEventListener('change', function (e) {\n    //   var val = e.target.value\n    //   e.target.dispatchEvent(eventAwesome)\n    // });\n</script>\n<script>\n    // 双向绑定\n    // let data = {\n    //     price: 5,\n    //     count: 2\n    // },\n    //     callb = null\n\n    // class Events {\n    //     constructor() {\n    //         this._events = []\n    //     }\n    //     on() {\n    //         if (callb && !this._events.includes(callb)) {\n    //             this._events.push(callb)\n    //         }\n    //     }\n    //     triger() {\n    //         this._events.forEach((callb) => {\n    //             callb && callb()\n    //         })\n    //     }\n    // }\n\n    // Object.keys(data).forEach((key) => {\n    //     let initVlue = data[key]\n    //     const e1 = new Events()\n    //     Object.defineProperty(data, key, {\n    //         get() {\n    //             //内部判断是否需要注册\n    //             e1.on()\n    //             // 执行过置否\n    //             callb = null\n    //             // get不变更值\n    //             return initVlue\n    //         },\n    //         set(newVal) {\n    //             initVlue = newVal\n    //             // set操作触发事件，同步数据变动\n    //             e1.triger()\n    //         }\n    //     })\n    // })\n    // function watcher(func) {\n    //     // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    //     callb = func\n    //     // 初次执行时，获取对应值自然经过get方法注册事件\n    //     callb()\n    //     // 置否避免重复注册\n    //     callb = null\n    // }\n    // // 此处指定事件触发回调，注册监听事件\n    // watcher(() => {\n    //     data.total = data.price * data.count\n    // })\n</script>\n\n</html>"},{"_content":"function registerServiceWorker(){\n    // 注册service worker\n    return navigator.serviceWorker.register('./sw1.js').then(registration => {\n        console.log('注册成功');\n        // 返回\n        return registration;\n    })\n    .catch(err => {\n        console.error('注册失败', err);\n    });\n}\nfunction execute() {\n    // 允许之后执行\n    registerServiceWorker().then(registration => {\n        // 初次演示注释掉\n        registration.showNotification('Hello World!');\n    });\n}\n// 获取通知权限之后再执行\nfunction getPermission(){\n    return new Promise((resolve, reject) => {\n        const permissionPromise = Notification.requestPermission(result => {\n            resolve(result);\n        });\n    }).then(result => {\n            if (result === 'granted') {\n                execute();\n            }\n            else {\n                console.log('no permission');\n            }\n        });\n}\nwindow.onload = function () {\n    var myImage = document.querySelector('#root img'),\n        src = './asset/sw.jpg';\n    myImage.src = src;\n    if (!('serviceWorker' in navigator)) {\n        return;\n    }\n    if (!('PushManager' in window)) {\n        return;\n    }\n    // 初次  \n    // registerServiceWorker()\n    // 通知权限\n    getPermission()\n}","source":"pwa/index.js","raw":"function registerServiceWorker(){\n    // 注册service worker\n    return navigator.serviceWorker.register('./sw1.js').then(registration => {\n        console.log('注册成功');\n        // 返回\n        return registration;\n    })\n    .catch(err => {\n        console.error('注册失败', err);\n    });\n}\nfunction execute() {\n    // 允许之后执行\n    registerServiceWorker().then(registration => {\n        // 初次演示注释掉\n        registration.showNotification('Hello World!');\n    });\n}\n// 获取通知权限之后再执行\nfunction getPermission(){\n    return new Promise((resolve, reject) => {\n        const permissionPromise = Notification.requestPermission(result => {\n            resolve(result);\n        });\n    }).then(result => {\n            if (result === 'granted') {\n                execute();\n            }\n            else {\n                console.log('no permission');\n            }\n        });\n}\nwindow.onload = function () {\n    var myImage = document.querySelector('#root img'),\n        src = './asset/sw.jpg';\n    myImage.src = src;\n    if (!('serviceWorker' in navigator)) {\n        return;\n    }\n    if (!('PushManager' in window)) {\n        return;\n    }\n    // 初次  \n    // registerServiceWorker()\n    // 通知权限\n    getPermission()\n}","date":"2018-08-24T07:48:19.000Z","updated":"2018-08-24T07:48:19.000Z","path":"pwa/index.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt1e000dgw92q1gqznev","content":"function registerServiceWorker(){\n    // 注册service worker\n    return navigator.serviceWorker.register('./sw1.js').then(registration => {\n        console.log('注册成功');\n        // 返回\n        return registration;\n    })\n    .catch(err => {\n        console.error('注册失败', err);\n    });\n}\nfunction execute() {\n    // 允许之后执行\n    registerServiceWorker().then(registration => {\n        // 初次演示注释掉\n        registration.showNotification('Hello World!');\n    });\n}\n// 获取通知权限之后再执行\nfunction getPermission(){\n    return new Promise((resolve, reject) => {\n        const permissionPromise = Notification.requestPermission(result => {\n            resolve(result);\n        });\n    }).then(result => {\n            if (result === 'granted') {\n                execute();\n            }\n            else {\n                console.log('no permission');\n            }\n        });\n}\nwindow.onload = function () {\n    var myImage = document.querySelector('#root img'),\n        src = './asset/sw.jpg';\n    myImage.src = src;\n    if (!('serviceWorker' in navigator)) {\n        return;\n    }\n    if (!('PushManager' in window)) {\n        return;\n    }\n    // 初次  \n    // registerServiceWorker()\n    // 通知权限\n    getPermission()\n}","site":{"data":{}},"excerpt":"","more":"function registerServiceWorker(){\n    // 注册service worker\n    return navigator.serviceWorker.register('./sw1.js').then(registration => {\n        console.log('注册成功');\n        // 返回\n        return registration;\n    })\n    .catch(err => {\n        console.error('注册失败', err);\n    });\n}\nfunction execute() {\n    // 允许之后执行\n    registerServiceWorker().then(registration => {\n        // 初次演示注释掉\n        registration.showNotification('Hello World!');\n    });\n}\n// 获取通知权限之后再执行\nfunction getPermission(){\n    return new Promise((resolve, reject) => {\n        const permissionPromise = Notification.requestPermission(result => {\n            resolve(result);\n        });\n    }).then(result => {\n            if (result === 'granted') {\n                execute();\n            }\n            else {\n                console.log('no permission');\n            }\n        });\n}\nwindow.onload = function () {\n    var myImage = document.querySelector('#root img'),\n        src = './asset/sw.jpg';\n    myImage.src = src;\n    if (!('serviceWorker' in navigator)) {\n        return;\n    }\n    if (!('PushManager' in window)) {\n        return;\n    }\n    // 初次  \n    // registerServiceWorker()\n    // 通知权限\n    getPermission()\n}"},{"_content":"{\n  \"name\": \"PWA\",\n  \"short_name\": \"PWA\",\n  \"description\": \"测试demo\",\n  \"icons\": [{\n      \"src\": \"https://h5.sinaimg.cn/upload/696/2017/08/23/weibologo.png\",\n      \"sizes\": \"606x606\",\n      \"type\": \"image/png\"\n    }],\n  \"start_url\": \"/pwa/demo.html\",\n  \"scope\": \"/\",\n  \"display\": \"standalone\",\n  \"orientation\": \"portrait\",\n  \"background_color\": \"#F3F3F3\",\n  \"theme_color\": \"#F3F3F3\",\n  \"related_applications\": [],\n  \"prefer_related_applications\": false\n}\n","source":"pwa/mainfest.json","raw":"{\n  \"name\": \"PWA\",\n  \"short_name\": \"PWA\",\n  \"description\": \"测试demo\",\n  \"icons\": [{\n      \"src\": \"https://h5.sinaimg.cn/upload/696/2017/08/23/weibologo.png\",\n      \"sizes\": \"606x606\",\n      \"type\": \"image/png\"\n    }],\n  \"start_url\": \"/pwa/demo.html\",\n  \"scope\": \"/\",\n  \"display\": \"standalone\",\n  \"orientation\": \"portrait\",\n  \"background_color\": \"#F3F3F3\",\n  \"theme_color\": \"#F3F3F3\",\n  \"related_applications\": [],\n  \"prefer_related_applications\": false\n}\n","date":"2018-08-24T07:48:19.000Z","updated":"2018-08-24T07:48:19.000Z","path":"pwa/mainfest.json","layout":"false","title":"","comments":1,"_id":"ck4tbvt1i000ggw92mm3fov47","content":"{\"name\":\"PWA\",\"short_name\":\"PWA\",\"description\":\"测试demo\",\"icons\":[{\"src\":\"https://h5.sinaimg.cn/upload/696/2017/08/23/weibologo.png\",\"sizes\":\"606x606\",\"type\":\"image/png\"}],\"start_url\":\"/pwa/demo.html\",\"scope\":\"/\",\"display\":\"standalone\",\"orientation\":\"portrait\",\"background_color\":\"#F3F3F3\",\"theme_color\":\"#F3F3F3\",\"related_applications\":[],\"prefer_related_applications\":false}","site":{"data":{}},"excerpt":"","more":"{\"name\":\"PWA\",\"short_name\":\"PWA\",\"description\":\"测试demo\",\"icons\":[{\"src\":\"https://h5.sinaimg.cn/upload/696/2017/08/23/weibologo.png\",\"sizes\":\"606x606\",\"type\":\"image/png\"}],\"start_url\":\"/pwa/demo.html\",\"scope\":\"/\",\"display\":\"standalone\",\"orientation\":\"portrait\",\"background_color\":\"#F3F3F3\",\"theme_color\":\"#F3F3F3\",\"related_applications\":[],\"prefer_related_applications\":false}"},{"_content":"const PRECACHE = 'precache_test_1'\nconst RUNTIME = 'runtime';\nconst PRECACHE_URLS = [\n    '/',\n    'pwa/asset/sw.jpg',\n    'pwa/index.js'\n]\nself.addEventListener('install',e=>{\n    e.waitUntil(\n        caches.open(PRECACHE).then(cache=>{\n            cache.addAll(PRECACHE_URLS)\n        }).then(\n            self.skipWaiting()\n        )\n    )\n})\nself.addEventListener('activate', e => {\n      \n    e.waitUntil(\n        caches.keys().then(cacheNames=>{\n          return Promise.all(\n            cacheNames.map(function(cacheName) {\n              if (cacheName !== PRECACHE) {\n                return caches.delete(cacheName);\n              }\n            })\n      )}).then(() => self.clients.claim())\n   )\n  })\n  \n  \n  self.addEventListener('fetch', e => {\n    e.respondWith(\n      caches.match(e.request).then(function(response) {\n        if (response != null) {\n          return response\n        }\n        return fetch(e.request.url)\n      })\n    )\n  });","source":"pwa/sw1.js","raw":"const PRECACHE = 'precache_test_1'\nconst RUNTIME = 'runtime';\nconst PRECACHE_URLS = [\n    '/',\n    'pwa/asset/sw.jpg',\n    'pwa/index.js'\n]\nself.addEventListener('install',e=>{\n    e.waitUntil(\n        caches.open(PRECACHE).then(cache=>{\n            cache.addAll(PRECACHE_URLS)\n        }).then(\n            self.skipWaiting()\n        )\n    )\n})\nself.addEventListener('activate', e => {\n      \n    e.waitUntil(\n        caches.keys().then(cacheNames=>{\n          return Promise.all(\n            cacheNames.map(function(cacheName) {\n              if (cacheName !== PRECACHE) {\n                return caches.delete(cacheName);\n              }\n            })\n      )}).then(() => self.clients.claim())\n   )\n  })\n  \n  \n  self.addEventListener('fetch', e => {\n    e.respondWith(\n      caches.match(e.request).then(function(response) {\n        if (response != null) {\n          return response\n        }\n        return fetch(e.request.url)\n      })\n    )\n  });","date":"2018-08-24T07:48:19.000Z","updated":"2018-08-24T07:48:19.000Z","path":"pwa/sw1.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt1j000igw92gb5zz0vk","content":"const PRECACHE = 'precache_test_1'\nconst RUNTIME = 'runtime';\nconst PRECACHE_URLS = [\n    '/',\n    'pwa/asset/sw.jpg',\n    'pwa/index.js'\n]\nself.addEventListener('install',e=>{\n    e.waitUntil(\n        caches.open(PRECACHE).then(cache=>{\n            cache.addAll(PRECACHE_URLS)\n        }).then(\n            self.skipWaiting()\n        )\n    )\n})\nself.addEventListener('activate', e => {\n      \n    e.waitUntil(\n        caches.keys().then(cacheNames=>{\n          return Promise.all(\n            cacheNames.map(function(cacheName) {\n              if (cacheName !== PRECACHE) {\n                return caches.delete(cacheName);\n              }\n            })\n      )}).then(() => self.clients.claim())\n   )\n  })\n  \n  \n  self.addEventListener('fetch', e => {\n    e.respondWith(\n      caches.match(e.request).then(function(response) {\n        if (response != null) {\n          return response\n        }\n        return fetch(e.request.url)\n      })\n    )\n  });","site":{"data":{}},"excerpt":"","more":"const PRECACHE = 'precache_test_1'\nconst RUNTIME = 'runtime';\nconst PRECACHE_URLS = [\n    '/',\n    'pwa/asset/sw.jpg',\n    'pwa/index.js'\n]\nself.addEventListener('install',e=>{\n    e.waitUntil(\n        caches.open(PRECACHE).then(cache=>{\n            cache.addAll(PRECACHE_URLS)\n        }).then(\n            self.skipWaiting()\n        )\n    )\n})\nself.addEventListener('activate', e => {\n      \n    e.waitUntil(\n        caches.keys().then(cacheNames=>{\n          return Promise.all(\n            cacheNames.map(function(cacheName) {\n              if (cacheName !== PRECACHE) {\n                return caches.delete(cacheName);\n              }\n            })\n      )}).then(() => self.clients.claim())\n   )\n  })\n  \n  \n  self.addEventListener('fetch', e => {\n    e.respondWith(\n      caches.match(e.request).then(function(response) {\n        if (response != null) {\n          return response\n        }\n        return fetch(e.request.url)\n      })\n    )\n  });"},{"_content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>service worker</title>\n    <link rel=\"manifest\" href=\"./mainfest.json\">\n</head>\n<body>\n<div id='root'>\n<div>simple PWA demo</div>    \n\n<img alt=\"暂无图片\" style=\"width:200px;height:200px\"/>\n</div>\n\n<script src=\"./index.js\"></script>\n</body>\n</html>","source":"pwa/demo.html","raw":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>service worker</title>\n    <link rel=\"manifest\" href=\"./mainfest.json\">\n</head>\n<body>\n<div id='root'>\n<div>simple PWA demo</div>    \n\n<img alt=\"暂无图片\" style=\"width:200px;height:200px\"/>\n</div>\n\n<script src=\"./index.js\"></script>\n</body>\n</html>","date":"2018-08-24T07:48:19.000Z","updated":"2018-08-24T07:48:19.000Z","path":"pwa/demo.html","title":"","comments":1,"layout":"page","_id":"ck4tbvt6u0013gw92k4p6whrn","content":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>service worker</title>\n    <link rel=\"manifest\" href=\"./mainfest.json\">\n</head>\n<body>\n<div id=\"root\">\n<div>simple PWA demo</div>    \n\n<img alt=\"暂无图片\" style=\"width:200px;height:200px\">\n</div>\n\n<script src=\"./index.js\"></script>\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>service worker</title>\n    <link rel=\"manifest\" href=\"./mainfest.json\">\n</head>\n<body>\n<div id=\"root\">\n<div>simple PWA demo</div>    \n\n<img alt=\"暂无图片\" style=\"width:200px;height:200px\">\n</div>\n\n<script src=\"./index.js\"></script>\n</body>\n</html>"},{"_content":"<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"description\" content=\"\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no, minimal-ui\" />\n    <meta name=\"format-detection\" content=\"telephone=no\">\n    <meta name=\"format-detection\" content=\"email=no\" />\n    <title></title>\n</head>\n\n<body>\n    sdsddsd\n    <div id=\"root\"></div>\n</body>\n<script type=\"text/javascript\" src=\"./index.js\"></script>\n</html>","source":"sourcemap/index.html","raw":"<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"description\" content=\"\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no, minimal-ui\" />\n    <meta name=\"format-detection\" content=\"telephone=no\">\n    <meta name=\"format-detection\" content=\"email=no\" />\n    <title></title>\n</head>\n\n<body>\n    sdsddsd\n    <div id=\"root\"></div>\n</body>\n<script type=\"text/javascript\" src=\"./index.js\"></script>\n</html>","date":"2019-09-16T06:24:20.349Z","updated":"2019-09-16T06:24:20.348Z","path":"sourcemap/index.html","title":"","comments":1,"layout":"page","_id":"ck4tbvt6u0014gw92tvokjlju","content":"<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"description\" content=\"\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no, minimal-ui\">\n    <meta name=\"format-detection\" content=\"telephone=no\">\n    <meta name=\"format-detection\" content=\"email=no\">\n    <title></title>\n</head>\n\n<body>\n    sdsddsd\n    <div id=\"root\"></div>\n</body>\n<script type=\"text/javascript\" src=\"./index.js\"></script>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"description\" content=\"\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no, minimal-ui\">\n    <meta name=\"format-detection\" content=\"telephone=no\">\n    <meta name=\"format-detection\" content=\"email=no\">\n    <title></title>\n</head>\n\n<body>\n    sdsddsd\n    <div id=\"root\"></div>\n</body>\n<script type=\"text/javascript\" src=\"./index.js\"></script>\n</html>"},{"_content":"import { isNumber } from \"util\";\n\n// 数据准备\n/** \n * 输入 ： [1,null,2,3]\n * 输出：1,2,3\n*/\n\n/** \n * 二叉树遍历\n * 中序遍历，即先左边再右边,需要root的\n*/\n// 递归版本确实易懂，不过性能不好\nfunction inorderTraversal(root,arr){\n    // 存在根节点\n    if(root){\n        inorderTraversal(root.left,arr)\n        array.push(root.val)\n        inorderTraversal(root.right,arr)\n\n    }\n    return array;   \n}\nvar \n// 迭代版本\n/**\n * 迭代需要判断结束条件和执行顺序\n * 使用栈来存放当前节点遍历，直到栈已空\n * 因为是深度优先遍历，后进先出，所以用栈\n * 思路1、将左子节点入栈，直到叶子节点\n * 2、取出栈内节点，加入访问标识，然后查询右子节点\n * 3、不存在右边节点，则向上访问父节点重复1、2\n*/\nfunction inorderTraversal(root) {\n    // 存放遍历顺序\n    var arr = [],\n        // 存放节点队列\n        stack = [],\n        item = root\n        \n    // 节点存在，或者栈内有节点 \n    while(item || stack.length){\n        // 左子节点入队列进行入栈操作,直到叶子节点\n        // 没有左子节点，则进行下一步,查询下个节点\n        if(item){\n            stack.push(item)\n            item = item.left\n        }\n        // 开始访问已入栈节点\n        item = stack.pop()\n        // 压入访问记录\n        arr.push(item.val)\n        // 查找又子节点\n        item = item.right\n    }    \n    return array;\n}\n// 先序遍历\n// 入栈的时候遍历就可以可，\nfunction firstTravel(){\n    // 遍历结果\n    var result = [],\n        // 遍历栈\n        stack = [],\n        node = root\n    // 根节点存在 或者栈内节点存在，继续遍历   \n    while(node || stack.length ){  \n        // 左子节点入栈\n        while(node.left){\n            stack.push(node)\n            // 加入遍历队列\n            result.push(node.value)\n            node = node.left \n        } \n        // 节点出栈，查找右子节点\n        node = stack.pop()\n        // 遍历右节点\n        node = node.right\n    }  \n\n}\n// 后序遍历\n// 还是左节点先入栈，出栈的时候查询是否存在右节点，且该节点是否被访问过。\n// 因为右节点存在子节点的话，该节点会被遍历两次\nfunction lastTravel() {\n    // 遍历结果\n    var result = [],\n        // 遍历栈\n        stack = [],\n        // 标记子节点是否被访问\n        last = null,\n        node = root\n    // 根节点存在 或者栈内节点存在，继续遍历   \n    while (node || stack.length) {\n        // 左子节点入栈\n        while (node.left) {\n            stack.push(node)\n            node = node.left\n        }\n        // 判断子节点 父节点是否有右节点，有的话继续遍历\n        var traget = stack[stack.length-1]\n        // 存在右子节点，且未遍历过\n        if (traget.right && last !== traget.right){\n            // 遍历右节点\n            node = node.right    \n        }else{\n            // 节点出栈，查找右子节点\n            node = stack.pop()\n            // 接入队列\n            result.push(node.value)\n            // 标记遍历对象，以免二次遍历\n            last = node\n            // 终止条件\n            node= null\n        }\n    }\n}\n\n\n/** \n * 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n * 不能使用迭代判断，只能是递归，而if else 则只能使用 && \n * 思路1、递归相加，知道n为0 \n * 思路2、位运算，通过 n(n+1)/2 = (n方+n)/2 先求 n方+n 按位与 实现除的效果。\n*/\nfunction Sum_Solution(n){\n    return n && (n+Sum_Solution(n-1))\n}\nfunction Sum_Solution(n){\n    //二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）\n    return (Math.pow(n,2)+n) >> 1\n}\n\n\n/**\n * 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。\n * 思路就是 进行位运算 替代常规加减，将+的结果可以分开看，每位相加，然后将进位和不进位内容相加\n * 那么对照着就能看到\n * 二进制异或操作和不进位相加得到的结果相同(1^1=0 0^1=1 0^0=0)\n *  二进制与操作后左移和进位结果相同（1&1=1 1&0=0 0&0=0）\n * \n*/\n\nfunction add(num1,num2){\n    if(num2 == 0){\n        return num1\n    }\n    // 递归加下去，直到最终结果得到\n    return add(num1 ^ num2, (num1 & num2) << 1)\n}\n// 非递归\nfunction add(num1,num2){\n    while(num2!=0){\n        // 非进位\n        var res = num1 ^ num2;\n        num2 = (num1 & num2)>>1;\n        num1 = res\n    }\n    return res\n}\n\n\n// 判断是否为整数\nfunction isOdd(num){\n    if (Number(num)){\n        return num % 2 == 0\n    } \n}\n// 位运算\nfunction isOdd(num) {\n    if (Number(num)) {\n        return num&1 != 0\n    }\n}\n\n// 给定一个整数，判断是不是2的整数次幂\n// 例如4、8等，分析特性，\n// 二进制 只有一个1开头 100、1000，自己减去1 之后 均为011、0111 这样 进行与操作之后，均为0 \nfunction check(num){\n    return num & (num-1) == 0\n}\n// 常规做法\n// 2/2 = 1 2%2 = 0  如果除结果不为0 ，深入下去，判断。\n// 迭代判断直到最后，看是否整除\nfunction check(num) {\n    if (num != 1) {\n        while (num != 1) {\n            if (num % 2 == 0) {\n                num = num / 2;\n            } else {\n                return false;\n            }\n\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// 常规做法，转为二进制，记录1的个数\nfunction get1(num){\n    if(Number(num)){\n        var res = [],\n            count = 0\n            res1 = num,\n            res2 = 0\n        while (res1 > 0){\n            // 取余数\n            res2 = res1 % 2\n            // 取除数结果\n            res1 = parseInt(res1/2) \n            \n            res.push(res2)\n            if(res2 == 1){\n                count++\n            }\n        }\n        console.log('二进制表示>>>',res.reverse().toString())\n        console.log('1个数>>', count)\n    }\n}\n\n// 与1 与 可以获取最后一位的值\n// 然后右移运算，每次右移之后，最后一位就忽略了，获取上一位的值，直到为0。\nfunction get1(num){\n    var count = 0\n    while (num != 0) {\n        count += num & 1\n        // 带符号右移，符号位也可能是一\n        num >>= 1\n    }\n    console.log(count)\n    return count\n}\n\n\n/**\n * 在其他数都出现两次的数组中找到只出现一次的那个数\n * 思路1，遍历数组，存储出现次数\n * 思路2，数字与本身异或结果为0，那么出现两次的都可以被过滤掉，只剩下单次的值\n */\n\n function get1Num(arr){\n    var counts = [] \n    arr.forEach(item => {\n        // 不存在则入栈\n        var index = counts.indexOf(item)\n        if (index<0){\n            counts.push(item)\n        }else{\n            // 存在则删除该元素\n            // 截取直接元素获取切片\n            // counts.slice(index,1)\n            // splice 裁剪原数组\n            counts.splice(index,1)\n        }\n    })\n    console.log(counts)\n    return counts[0]\n }\n\n//  异或做法\nfunction get1Num(arr) {\n    if(!arr instanceof Array){\n        return '输入数组'\n    }\n    var counts = 0\n    arr.forEach(item => {\n        counts = counts ^ item\n    })\n    console.log(counts)\n    return counts[0]\n}\n\n\n/**\n * 在其他数都出现两次的数组中找到只出现一次的那两个数\n * 有两个数 只出现一次\n * 思路1 依然可用\n * 思路2 思路是这样的，对于两个单次的数，要是能按规律分别分到两个数组里，就满足目的了\n * 所以整体进行一次异或，获取异或后的值，因为异或的原理，不同的数肯定存在1的位，按这一位是否为1将数组分类。\n * 出现两次的相同值肯定在一起，单次的值肯定分开，这样达到目的了，分别异或就可以了\n * 题目变形：给你1-1000个连续自然数,然后从中随机去掉两个,再打乱顺序,要求只遍历一次,求出被去掉数\n * 将连续自然数跟打乱之后的合并就是 单次多次的问题了。\n * 右移就是降低一个进制即 除以2，取整，例如3 右移一位为1 。\n * 左移即乘以2 例如 1=》2 \n * 这里回顾下js的取整方法： \n * Math.ceil() 向上取整，即进一位，ceil 有天花板的意思，很好理解了\n * Math.floor() 向下取整，floor有地板的意思\n * Math.round() 四舍五入，round有圆环的意思，专指四舍五入\n * parseInt() 这个同floor\n * parseInt(2.2) // 2\n * Math.floor(2.2) //2\n * Math.ceil(2.2) // 3\n * Math.round(2.2) // 2\n **/\n\nfunction getTwo(arr){\n    var val=0,\n    //  位置记录\n        position = 0,\n        // res1\n        result1 = 0,\n        result2 = 0\n   // 获取异或值     \n   arr.forEach(item => {\n            val = val ^ item\n        }) \n    // 获取第k位为1的值\n    while((val & 1 == 0 )&& val <64){\n        // 右移\n        val = val >> 1\n        position++\n    }\n    arr.forEach(item => {\n        // 第k位为0 \n        if((item >> position & 1) == 1){\n            result1 ^= item\n        }else{\n            result2 ^= item\n        }\n    })\n    console.log('x,y>>',result1,result2)\n}\n\n\n\n/**\n * 把只包含质因子2、3和5的数称作丑数（Ugly Number）。\n * 例如6、8都是丑数，但14不是，因为它包含质因子7。\n * 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。\n *  思路：\n * 首先查找丑数规律： 丑数只能被2、3、5整除，说明第n个丑数只能是0 - n-1中某个丑数✖️2、✖️3、✖️5的结果。\n * 而且，这个数即第0 - n-1个丑数✖️2、✖️3、✖️5的结果中比第n-1个丑数大的最小值。结果可能有很多，需要排序。\n * 按照上面的规律，我们可以依次求出第0 - n个丑数。\n * \n * 基本思路：\n * 0-n-1 的丑数队列，因为已知因为第一个丑数知道，所以可以一直推下去。\n * 然后分别*2 *3，* 5 ，比较大于n-1 丑数最小值\n * 可以优化：\n * 有些值，确实很小，没必要每次都乘，记录下本次，*2 * 3 * 5 刚好大于n-1 丑数的值即可，下次从其开始循环。\n * \n */\n  \n function getUglyNumber(n){\n    //  记录位置标识\n    var i = j = k = 0,\n        // 初始数组就是1\n        arr = [1]\n    // 0 直接返回    \n    if(n == 0){\n        return arr[0]\n    }\n    // 获取丑数队列\n    while(arr.length <= n){\n        // next 丑数\n        arr.push(Math.min(arr[i]*2,arr[j]*3,arr[k]*5))\n        var currentItem = arr[arr.length - 1]\n        // 获取下次下标 n-1\n        while (arr[i] * 2 <= currentItem){\n            i++\n        }\n        while (arr[j] * 3 <= currentItem) {\n            j++\n        }\n        while (arr[k] * 5 <= currentItem) {\n            k++\n        }\n    }\n    console.log(arr[n])\n    return arr[n]\n }\n\n\n\n /**\n  * 数值的整数次方\n  * 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n  * 这道题逻辑上很简单，但很容易出错。\n  * 关键是要考虑全面，考虑到所有情况。\n  * exponent 是正，负，0的情况\n  * base为0的情况\n  * Math.abs（） absolute value 就是绝对值的意思，防抱死也有点意味，绝对可用\n  * */  \nfunction getPow(base, exponent){\n    if (exponent !== +exponent){\n        throw Error('必须为数字')\n    }\n    if (exponent == 0){\n        return 1\n    }\n    if(exponent > 1){\n        var result = base\n        for(var i =1;i<exponent;i++){\n            result *= base\n        }\n        return result\n    }\n    var num = Math.abs(exponent)\n    for (var i = 1; i < exponent; i++) {\n        result *= base\n    }\n    return result?1/result:false\n} \n\n\n/**\n * 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？\n * 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。\n * ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1到n中1出现的次数）。\n */\n/**\n * 既然计算位数，11可以算为两次，就要逐位分析，先从两位来判断\n * 分别计算，个位为1和十位为1 的情况，两者相加即为结果。\n * 需要判断数字，0、1、2关系有所不同，主要体现在对其后位数的限制\n * 0的话，后面位数可以不考虑，因为当前位不会位一，后面多大都不存在组合可能\n * 1的话，后面位数的大小要考虑，因为有部分值不能取到，例如13，那么14、15的情况不能取到，只能是3+1 ，有0\n * 2的话，就所有情况都满足了，完全根据前面值的决定，例如22，那么可以有(2+1)+(0+1)*10 = 13\n * 即下面这个情况：abcde，分析百位数字c\n * c = 0 : 有 ab*100 种情况\n * c = 1 : 有 ab*100 + de + 1 种情况\n * c > 2 : 有 (ab+1) * 100 种情况\n * 举个例子：\n * 210 \n * 个位为1： 21\n * 十位为1： 2*10+1\n * 百位为1： (0+1)*100\n * */ \nfunction getTotalNum(n){\n    let count = 0;\n    let i = 1;\n    let high = low = current = level = 0;\n    let length = n.toString().length;\n    while (i <= length) {\n        level = Math.pow(10, i - 1); //第i位数位于什么量级 1 10 100 ...\n        high = parseInt(n / (level * 10));\n        low = n % level;\n        current = parseInt(n / level) % 10;\n        if (current === 0) {\n            count += (high * level);\n        } else if (current === 1) {\n            count += (high * level + low + 1);\n        } else {\n            count += ((high + 1) * level);\n        }\n        i++;\n    }\n    return count;\n} \n\n\n// 自己实现\nfunction getTotal(n) {\n    var current = heigh = low = level = 0\n    // 位数下标\n    var i = 0\n    // 数字位数\n    var len = n.toString().length\n    // 总数\n    var total = 0\n    for (i; i < len; i++) {\n        level = Math.pow(10, i)\n        // 注意这里获取当前位置的value\n        heigh = Math.floor(n / (10 * level)) % 10\n        current = n % (10 * level)\n        low = n % (level)\n        if (current == 0) {\n            total += heigh * level\n        } else if (current == 1) {\n            total += heigh * level + low + 1\n        } else {\n            total += (heigh + 1) * level\n        }\n    }\n    return total\n}","source":"structure/data.js","raw":"import { isNumber } from \"util\";\n\n// 数据准备\n/** \n * 输入 ： [1,null,2,3]\n * 输出：1,2,3\n*/\n\n/** \n * 二叉树遍历\n * 中序遍历，即先左边再右边,需要root的\n*/\n// 递归版本确实易懂，不过性能不好\nfunction inorderTraversal(root,arr){\n    // 存在根节点\n    if(root){\n        inorderTraversal(root.left,arr)\n        array.push(root.val)\n        inorderTraversal(root.right,arr)\n\n    }\n    return array;   \n}\nvar \n// 迭代版本\n/**\n * 迭代需要判断结束条件和执行顺序\n * 使用栈来存放当前节点遍历，直到栈已空\n * 因为是深度优先遍历，后进先出，所以用栈\n * 思路1、将左子节点入栈，直到叶子节点\n * 2、取出栈内节点，加入访问标识，然后查询右子节点\n * 3、不存在右边节点，则向上访问父节点重复1、2\n*/\nfunction inorderTraversal(root) {\n    // 存放遍历顺序\n    var arr = [],\n        // 存放节点队列\n        stack = [],\n        item = root\n        \n    // 节点存在，或者栈内有节点 \n    while(item || stack.length){\n        // 左子节点入队列进行入栈操作,直到叶子节点\n        // 没有左子节点，则进行下一步,查询下个节点\n        if(item){\n            stack.push(item)\n            item = item.left\n        }\n        // 开始访问已入栈节点\n        item = stack.pop()\n        // 压入访问记录\n        arr.push(item.val)\n        // 查找又子节点\n        item = item.right\n    }    \n    return array;\n}\n// 先序遍历\n// 入栈的时候遍历就可以可，\nfunction firstTravel(){\n    // 遍历结果\n    var result = [],\n        // 遍历栈\n        stack = [],\n        node = root\n    // 根节点存在 或者栈内节点存在，继续遍历   \n    while(node || stack.length ){  \n        // 左子节点入栈\n        while(node.left){\n            stack.push(node)\n            // 加入遍历队列\n            result.push(node.value)\n            node = node.left \n        } \n        // 节点出栈，查找右子节点\n        node = stack.pop()\n        // 遍历右节点\n        node = node.right\n    }  \n\n}\n// 后序遍历\n// 还是左节点先入栈，出栈的时候查询是否存在右节点，且该节点是否被访问过。\n// 因为右节点存在子节点的话，该节点会被遍历两次\nfunction lastTravel() {\n    // 遍历结果\n    var result = [],\n        // 遍历栈\n        stack = [],\n        // 标记子节点是否被访问\n        last = null,\n        node = root\n    // 根节点存在 或者栈内节点存在，继续遍历   \n    while (node || stack.length) {\n        // 左子节点入栈\n        while (node.left) {\n            stack.push(node)\n            node = node.left\n        }\n        // 判断子节点 父节点是否有右节点，有的话继续遍历\n        var traget = stack[stack.length-1]\n        // 存在右子节点，且未遍历过\n        if (traget.right && last !== traget.right){\n            // 遍历右节点\n            node = node.right    \n        }else{\n            // 节点出栈，查找右子节点\n            node = stack.pop()\n            // 接入队列\n            result.push(node.value)\n            // 标记遍历对象，以免二次遍历\n            last = node\n            // 终止条件\n            node= null\n        }\n    }\n}\n\n\n/** \n * 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n * 不能使用迭代判断，只能是递归，而if else 则只能使用 && \n * 思路1、递归相加，知道n为0 \n * 思路2、位运算，通过 n(n+1)/2 = (n方+n)/2 先求 n方+n 按位与 实现除的效果。\n*/\nfunction Sum_Solution(n){\n    return n && (n+Sum_Solution(n-1))\n}\nfunction Sum_Solution(n){\n    //二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）\n    return (Math.pow(n,2)+n) >> 1\n}\n\n\n/**\n * 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。\n * 思路就是 进行位运算 替代常规加减，将+的结果可以分开看，每位相加，然后将进位和不进位内容相加\n * 那么对照着就能看到\n * 二进制异或操作和不进位相加得到的结果相同(1^1=0 0^1=1 0^0=0)\n *  二进制与操作后左移和进位结果相同（1&1=1 1&0=0 0&0=0）\n * \n*/\n\nfunction add(num1,num2){\n    if(num2 == 0){\n        return num1\n    }\n    // 递归加下去，直到最终结果得到\n    return add(num1 ^ num2, (num1 & num2) << 1)\n}\n// 非递归\nfunction add(num1,num2){\n    while(num2!=0){\n        // 非进位\n        var res = num1 ^ num2;\n        num2 = (num1 & num2)>>1;\n        num1 = res\n    }\n    return res\n}\n\n\n// 判断是否为整数\nfunction isOdd(num){\n    if (Number(num)){\n        return num % 2 == 0\n    } \n}\n// 位运算\nfunction isOdd(num) {\n    if (Number(num)) {\n        return num&1 != 0\n    }\n}\n\n// 给定一个整数，判断是不是2的整数次幂\n// 例如4、8等，分析特性，\n// 二进制 只有一个1开头 100、1000，自己减去1 之后 均为011、0111 这样 进行与操作之后，均为0 \nfunction check(num){\n    return num & (num-1) == 0\n}\n// 常规做法\n// 2/2 = 1 2%2 = 0  如果除结果不为0 ，深入下去，判断。\n// 迭代判断直到最后，看是否整除\nfunction check(num) {\n    if (num != 1) {\n        while (num != 1) {\n            if (num % 2 == 0) {\n                num = num / 2;\n            } else {\n                return false;\n            }\n\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// 常规做法，转为二进制，记录1的个数\nfunction get1(num){\n    if(Number(num)){\n        var res = [],\n            count = 0\n            res1 = num,\n            res2 = 0\n        while (res1 > 0){\n            // 取余数\n            res2 = res1 % 2\n            // 取除数结果\n            res1 = parseInt(res1/2) \n            \n            res.push(res2)\n            if(res2 == 1){\n                count++\n            }\n        }\n        console.log('二进制表示>>>',res.reverse().toString())\n        console.log('1个数>>', count)\n    }\n}\n\n// 与1 与 可以获取最后一位的值\n// 然后右移运算，每次右移之后，最后一位就忽略了，获取上一位的值，直到为0。\nfunction get1(num){\n    var count = 0\n    while (num != 0) {\n        count += num & 1\n        // 带符号右移，符号位也可能是一\n        num >>= 1\n    }\n    console.log(count)\n    return count\n}\n\n\n/**\n * 在其他数都出现两次的数组中找到只出现一次的那个数\n * 思路1，遍历数组，存储出现次数\n * 思路2，数字与本身异或结果为0，那么出现两次的都可以被过滤掉，只剩下单次的值\n */\n\n function get1Num(arr){\n    var counts = [] \n    arr.forEach(item => {\n        // 不存在则入栈\n        var index = counts.indexOf(item)\n        if (index<0){\n            counts.push(item)\n        }else{\n            // 存在则删除该元素\n            // 截取直接元素获取切片\n            // counts.slice(index,1)\n            // splice 裁剪原数组\n            counts.splice(index,1)\n        }\n    })\n    console.log(counts)\n    return counts[0]\n }\n\n//  异或做法\nfunction get1Num(arr) {\n    if(!arr instanceof Array){\n        return '输入数组'\n    }\n    var counts = 0\n    arr.forEach(item => {\n        counts = counts ^ item\n    })\n    console.log(counts)\n    return counts[0]\n}\n\n\n/**\n * 在其他数都出现两次的数组中找到只出现一次的那两个数\n * 有两个数 只出现一次\n * 思路1 依然可用\n * 思路2 思路是这样的，对于两个单次的数，要是能按规律分别分到两个数组里，就满足目的了\n * 所以整体进行一次异或，获取异或后的值，因为异或的原理，不同的数肯定存在1的位，按这一位是否为1将数组分类。\n * 出现两次的相同值肯定在一起，单次的值肯定分开，这样达到目的了，分别异或就可以了\n * 题目变形：给你1-1000个连续自然数,然后从中随机去掉两个,再打乱顺序,要求只遍历一次,求出被去掉数\n * 将连续自然数跟打乱之后的合并就是 单次多次的问题了。\n * 右移就是降低一个进制即 除以2，取整，例如3 右移一位为1 。\n * 左移即乘以2 例如 1=》2 \n * 这里回顾下js的取整方法： \n * Math.ceil() 向上取整，即进一位，ceil 有天花板的意思，很好理解了\n * Math.floor() 向下取整，floor有地板的意思\n * Math.round() 四舍五入，round有圆环的意思，专指四舍五入\n * parseInt() 这个同floor\n * parseInt(2.2) // 2\n * Math.floor(2.2) //2\n * Math.ceil(2.2) // 3\n * Math.round(2.2) // 2\n **/\n\nfunction getTwo(arr){\n    var val=0,\n    //  位置记录\n        position = 0,\n        // res1\n        result1 = 0,\n        result2 = 0\n   // 获取异或值     \n   arr.forEach(item => {\n            val = val ^ item\n        }) \n    // 获取第k位为1的值\n    while((val & 1 == 0 )&& val <64){\n        // 右移\n        val = val >> 1\n        position++\n    }\n    arr.forEach(item => {\n        // 第k位为0 \n        if((item >> position & 1) == 1){\n            result1 ^= item\n        }else{\n            result2 ^= item\n        }\n    })\n    console.log('x,y>>',result1,result2)\n}\n\n\n\n/**\n * 把只包含质因子2、3和5的数称作丑数（Ugly Number）。\n * 例如6、8都是丑数，但14不是，因为它包含质因子7。\n * 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。\n *  思路：\n * 首先查找丑数规律： 丑数只能被2、3、5整除，说明第n个丑数只能是0 - n-1中某个丑数✖️2、✖️3、✖️5的结果。\n * 而且，这个数即第0 - n-1个丑数✖️2、✖️3、✖️5的结果中比第n-1个丑数大的最小值。结果可能有很多，需要排序。\n * 按照上面的规律，我们可以依次求出第0 - n个丑数。\n * \n * 基本思路：\n * 0-n-1 的丑数队列，因为已知因为第一个丑数知道，所以可以一直推下去。\n * 然后分别*2 *3，* 5 ，比较大于n-1 丑数最小值\n * 可以优化：\n * 有些值，确实很小，没必要每次都乘，记录下本次，*2 * 3 * 5 刚好大于n-1 丑数的值即可，下次从其开始循环。\n * \n */\n  \n function getUglyNumber(n){\n    //  记录位置标识\n    var i = j = k = 0,\n        // 初始数组就是1\n        arr = [1]\n    // 0 直接返回    \n    if(n == 0){\n        return arr[0]\n    }\n    // 获取丑数队列\n    while(arr.length <= n){\n        // next 丑数\n        arr.push(Math.min(arr[i]*2,arr[j]*3,arr[k]*5))\n        var currentItem = arr[arr.length - 1]\n        // 获取下次下标 n-1\n        while (arr[i] * 2 <= currentItem){\n            i++\n        }\n        while (arr[j] * 3 <= currentItem) {\n            j++\n        }\n        while (arr[k] * 5 <= currentItem) {\n            k++\n        }\n    }\n    console.log(arr[n])\n    return arr[n]\n }\n\n\n\n /**\n  * 数值的整数次方\n  * 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。\n  * 这道题逻辑上很简单，但很容易出错。\n  * 关键是要考虑全面，考虑到所有情况。\n  * exponent 是正，负，0的情况\n  * base为0的情况\n  * Math.abs（） absolute value 就是绝对值的意思，防抱死也有点意味，绝对可用\n  * */  \nfunction getPow(base, exponent){\n    if (exponent !== +exponent){\n        throw Error('必须为数字')\n    }\n    if (exponent == 0){\n        return 1\n    }\n    if(exponent > 1){\n        var result = base\n        for(var i =1;i<exponent;i++){\n            result *= base\n        }\n        return result\n    }\n    var num = Math.abs(exponent)\n    for (var i = 1; i < exponent; i++) {\n        result *= base\n    }\n    return result?1/result:false\n} \n\n\n/**\n * 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？\n * 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。\n * ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1到n中1出现的次数）。\n */\n/**\n * 既然计算位数，11可以算为两次，就要逐位分析，先从两位来判断\n * 分别计算，个位为1和十位为1 的情况，两者相加即为结果。\n * 需要判断数字，0、1、2关系有所不同，主要体现在对其后位数的限制\n * 0的话，后面位数可以不考虑，因为当前位不会位一，后面多大都不存在组合可能\n * 1的话，后面位数的大小要考虑，因为有部分值不能取到，例如13，那么14、15的情况不能取到，只能是3+1 ，有0\n * 2的话，就所有情况都满足了，完全根据前面值的决定，例如22，那么可以有(2+1)+(0+1)*10 = 13\n * 即下面这个情况：abcde，分析百位数字c\n * c = 0 : 有 ab*100 种情况\n * c = 1 : 有 ab*100 + de + 1 种情况\n * c > 2 : 有 (ab+1) * 100 种情况\n * 举个例子：\n * 210 \n * 个位为1： 21\n * 十位为1： 2*10+1\n * 百位为1： (0+1)*100\n * */ \nfunction getTotalNum(n){\n    let count = 0;\n    let i = 1;\n    let high = low = current = level = 0;\n    let length = n.toString().length;\n    while (i <= length) {\n        level = Math.pow(10, i - 1); //第i位数位于什么量级 1 10 100 ...\n        high = parseInt(n / (level * 10));\n        low = n % level;\n        current = parseInt(n / level) % 10;\n        if (current === 0) {\n            count += (high * level);\n        } else if (current === 1) {\n            count += (high * level + low + 1);\n        } else {\n            count += ((high + 1) * level);\n        }\n        i++;\n    }\n    return count;\n} \n\n\n// 自己实现\nfunction getTotal(n) {\n    var current = heigh = low = level = 0\n    // 位数下标\n    var i = 0\n    // 数字位数\n    var len = n.toString().length\n    // 总数\n    var total = 0\n    for (i; i < len; i++) {\n        level = Math.pow(10, i)\n        // 注意这里获取当前位置的value\n        heigh = Math.floor(n / (10 * level)) % 10\n        current = n % (10 * level)\n        low = n % (level)\n        if (current == 0) {\n            total += heigh * level\n        } else if (current == 1) {\n            total += heigh * level + low + 1\n        } else {\n            total += (heigh + 1) * level\n        }\n    }\n    return total\n}","date":"2019-12-16T09:09:34.647Z","updated":"2019-12-16T09:09:34.647Z","path":"structure/data.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt6x0015gw923xqe46ot","content":"import { isNumber } from \"util\";\n\n// 数据准备\n/** \n * 输入 ： [1,null,2,3]\n * 输出：1,2,3\n*/\n\n/** \n * 二叉树遍历\n * 中序遍历，即先左边再右边,需要root的\n*/\n// 递归版本确实易懂，不过性能不好\nfunction inorderTraversal(root,arr){\n    // 存在根节点\n    if(root){\n        inorderTraversal(root.left,arr)\n        array.push(root.val)\n        inorderTraversal(root.right,arr)\n\n    }\n    return array;   \n}\nvar \n// 迭代版本\n/**\n * 迭代需要判断结束条件和执行顺序\n * 使用栈来存放当前节点遍历，直到栈已空\n * 因为是深度优先遍历，后进先出，所以用栈\n * 思路1、将左子节点入栈，直到叶子节点\n * 2、取出栈内节点，加入访问标识，然后查询右子节点\n * 3、不存在右边节点，则向上访问父节点重复1、2\n*/\nfunction inorderTraversal(root) {\n    // 存放遍历顺序\n    var arr = [],\n        // 存放节点队列\n        stack = [],\n        item = root\n        \n    // 节点存在，或者栈内有节点 \n    while(item || stack.length){\n        // 左子节点入队列进行入栈操作,直到叶子节点\n        // 没有左子节点，则进行下一步,查询下个节点\n        if(item){\n            stack.push(item)\n            item = item.left\n        }\n        // 开始访问已入栈节点\n        item = stack.pop()\n        // 压入访问记录\n        arr.push(item.val)\n        // 查找又子节点\n        item = item.right\n    }    \n    return array;\n}\n// 先序遍历\n// 入栈的时候遍历就可以可，\nfunction firstTravel(){\n    // 遍历结果\n    var result = [],\n        // 遍历栈\n        stack = [],\n        node = root\n    // 根节点存在 或者栈内节点存在，继续遍历   \n    while(node || stack.length ){  \n        // 左子节点入栈\n        while(node.left){\n            stack.push(node)\n            // 加入遍历队列\n            result.push(node.value)\n            node = node.left \n        } \n        // 节点出栈，查找右子节点\n        node = stack.pop()\n        // 遍历右节点\n        node = node.right\n    }  \n\n}\n// 后序遍历\n// 还是左节点先入栈，出栈的时候查询是否存在右节点，且该节点是否被访问过。\n// 因为右节点存在子节点的话，该节点会被遍历两次\nfunction lastTravel() {\n    // 遍历结果\n    var result = [],\n        // 遍历栈\n        stack = [],\n        // 标记子节点是否被访问\n        last = null,\n        node = root\n    // 根节点存在 或者栈内节点存在，继续遍历   \n    while (node || stack.length) {\n        // 左子节点入栈\n        while (node.left) {\n            stack.push(node)\n            node = node.left\n        }\n        // 判断子节点 父节点是否有右节点，有的话继续遍历\n        var traget = stack[stack.length-1]\n        // 存在右子节点，且未遍历过\n        if (traget.right && last !== traget.right){\n            // 遍历右节点\n            node = node.right    \n        }else{\n            // 节点出栈，查找右子节点\n            node = stack.pop()\n            // 接入队列\n            result.push(node.value)\n            // 标记遍历对象，以免二次遍历\n            last = node\n            // 终止条件\n            node= null\n        }\n    }\n}\n\n\n/** \n * 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n * 不能使用迭代判断，只能是递归，而if else 则只能使用 && \n * 思路1、递归相加，知道n为0 \n * 思路2、位运算，通过 n(n+1)/2 = (n方+n)/2 先求 n方+n 按位与 实现除的效果。\n*/\nfunction Sum_Solution(n){\n    return n && (n+Sum_Solution(n-1))\n}\nfunction Sum_Solution(n){\n    //二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）\n    return (Math.pow(n,2)+n) >> 1\n}\n\n\n/**\n * 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。\n * 思路就是 进行位运算 替代常规加减，将+的结果可以分开看，每位相加，然后将进位和不进位内容相加\n * 那么对照着就能看到\n * 二进制异或操作和不进位相加得到的结果相同(1^1=0 0^1=1 0^0=0)\n *  二进制与操作后左移和进位结果相同（1&1=1 1&0=0 0&0=0）\n * \n*/\n\nfunction add(num1,num2){\n    if(num2 == 0){\n        return num1\n    }\n    // 递归加下去，直到最终结果得到\n    return add(num1 ^ num2, (num1 & num2) << 1)\n}\n// 非递归\nfunction add(num1,num2){\n    while(num2!=0){\n        // 非进位\n        var res = num1 ^ num2;\n        num2 = (num1 & num2)>>1;\n        num1 = res\n    }\n    return res\n}\n\n\n// 判断是否为整数\nfunction isOdd(num){\n    if (Number(num)){\n        return num % 2 == 0\n    } \n}\n// 位运算\nfunction isOdd(num) {\n    if (Number(num)) {\n        return num&1 != 0\n    }\n}\n\n// 给定一个整数，判断是不是2的整数次幂\n// 例如4、8等，分析特性，\n// 二进制 只有一个1开头 100、1000，自己减去1 之后 均为011、0111 这样 进行与操作之后，均为0 \nfunction check(num){\n    return num & (num-1) == 0\n}\n// 常规做法\n// 2/2 = 1 2%2 = 0  如果除结果不为0 ，深入下去，判断。\n// 迭代判断直到最后，看是否整除\nfunction check(num) {\n    if (num != 1) {\n        while (num != 1) {\n            if (num % 2 == 0) {\n                num = num / 2;\n            } else {\n                return false;\n            }\n\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// 常规做法，转为二进制，记录1的个数\nfunction get1(num){\n    if(Number(num)){\n        var res = [],\n            count = 0\n            res1 = num,\n            res2 = 0\n        while (res1 > 0){\n            // 取余数\n            res2 = res1 % 2\n            // 取除数结果\n            res1 = parseInt(res1/2) \n            \n            res.push(res2)\n            if(res2 == 1){\n                count++\n            }\n        }\n        console.log('二进制表示>>>',res.reverse().toString())\n        console.log('1个数>>', count)\n    }\n}\n\n// 与1 与 可以获取最后一位的值\n// 然后右移运算，每次右移之后，最后一位就忽略了，获取上一位的值，直到为0。\nfunction get1(num){\n    var count = 0\n    while (num != 0) {\n        count += num & 1\n        // 带符号右移，符号位也可能是一\n        num >>= 1\n    }\n    console.log(count)\n    return count\n}\n\n\n/**\n * 在其他数都出现两次的数组中找到只出现一次的那个数\n * 思路1，遍历数组，存储出现次数\n * 思路2，数字与本身异或结果为0，那么出现两次的都可以被过滤掉，只剩下单次的值\n */\n\n function get1Num(arr){\n    var counts = [] \n    arr.forEach(item => {\n        // 不存在则入栈\n        var index = counts.indexOf(item)\n        if (index<0){ counts.push(item)=\"\" }else{=\"\" 存在则删除该元素=\"\" 截取直接元素获取切片=\"\" counts.slice(index,1)=\"\" splice=\"\" 裁剪原数组=\"\" counts.splice(index,1)=\"\" }=\"\" })=\"\" console.log(counts)=\"\" return=\"\" counts[0]=\"\" 异或做法=\"\" function=\"\" get1num(arr)=\"\" {=\"\" if(!arr=\"\" instanceof=\"\" array){=\"\" '输入数组'=\"\" var=\"\" counts=\"0\" arr.foreach(item=\"\"> {\n        counts = counts ^ item\n    })\n    console.log(counts)\n    return counts[0]\n}\n\n\n/**\n * 在其他数都出现两次的数组中找到只出现一次的那两个数\n * 有两个数 只出现一次\n * 思路1 依然可用\n * 思路2 思路是这样的，对于两个单次的数，要是能按规律分别分到两个数组里，就满足目的了\n * 所以整体进行一次异或，获取异或后的值，因为异或的原理，不同的数肯定存在1的位，按这一位是否为1将数组分类。\n * 出现两次的相同值肯定在一起，单次的值肯定分开，这样达到目的了，分别异或就可以了\n * 题目变形：给你1-1000个连续自然数,然后从中随机去掉两个,再打乱顺序,要求只遍历一次,求出被去掉数\n * 将连续自然数跟打乱之后的合并就是 单次多次的问题了。\n * 右移就是降低一个进制即 除以2，取整，例如3 右移一位为1 。\n * 左移即乘以2 例如 1=》2 \n * 这里回顾下js的取整方法： \n * Math.ceil() 向上取整，即进一位，ceil 有天花板的意思，很好理解了\n * Math.floor() 向下取整，floor有地板的意思\n * Math.round() 四舍五入，round有圆环的意思，专指四舍五入\n * parseInt() 这个同floor\n * parseInt(2.2) // 2\n * Math.floor(2.2) //2\n * Math.ceil(2.2) // 3\n * Math.round(2.2) // 2\n **/\n\nfunction getTwo(arr){\n    var val=0,\n    //  位置记录\n        position = 0,\n        // res1\n        result1 = 0,\n        result2 = 0\n   // 获取异或值     \n   arr.forEach(item => {\n            val = val ^ item\n        }) \n    // 获取第k位为1的值\n    while((val & 1 == 0 )&& val <64){ 右移=\"\" val=\"val\">> 1\n        position++\n    }\n    arr.forEach(item => {\n        // 第k位为0 \n        if((item >> position & 1) == 1){\n            result1 ^= item\n        }else{\n            result2 ^= item\n        }\n    })\n    console.log('x,y>>',result1,result2)\n}\n\n\n\n/**\n * 把只包含质因子2、3和5的数称作丑数（Ugly Number）。\n * 例如6、8都是丑数，但14不是，因为它包含质因子7。\n * 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。\n *  思路：\n * 首先查找丑数规律： 丑数只能被2、3、5整除，说明第n个丑数只能是0 - n-1中某个丑数✖️2、✖️3、✖️5的结果。\n * 而且，这个数即第0 - n-1个丑数✖️2、✖️3、✖️5的结果中比第n-1个丑数大的最小值。结果可能有很多，需要排序。\n * 按照上面的规律，我们可以依次求出第0 - n个丑数。\n * \n * 基本思路：\n * 0-n-1 的丑数队列，因为已知因为第一个丑数知道，所以可以一直推下去。\n * 然后分别*2 *3，* 5 ，比较大于n-1 丑数最小值\n * 可以优化：\n * 有些值，确实很小，没必要每次都乘，记录下本次，*2 * 3 * 5 刚好大于n-1 丑数的值即可，下次从其开始循环。\n * \n */\n  \n function getUglyNumber(n){\n    //  记录位置标识\n    var i = j = k = 0,\n        // 初始数组就是1\n        arr = [1]\n    // 0 直接返回    \n    if(n == 0){\n        return arr[0]\n    }\n    // 获取丑数队列\n    while(arr.length <= 1=\"\" 2=\"\" 3=\"\" 5=\"\" n){=\"\" next=\"\" 丑数=\"\" arr.push(math.min(arr[i]*2,arr[j]*3,arr[k]*5))=\"\" var=\"\" currentitem=\"arr[arr.length\" -=\"\" 1]=\"\" 获取下次下标=\"\" n-1=\"\" while=\"\" (arr[i]=\"\" *=\"\" <=\"currentItem){\" i++=\"\" }=\"\" (arr[j]=\"\" {=\"\" j++=\"\" (arr[k]=\"\" k++=\"\" console.log(arr[n])=\"\" return=\"\" arr[n]=\"\" **=\"\" 数值的整数次方=\"\" 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。=\"\" 这道题逻辑上很简单，但很容易出错。=\"\" 关键是要考虑全面，考虑到所有情况。=\"\" exponent=\"\" 是正，负，0的情况=\"\" base为0的情况=\"\" math.abs（）=\"\" absolute=\"\" value=\"\" 就是绝对值的意思，防抱死也有点意味，绝对可用=\"\" function=\"\" getpow(base,=\"\" exponent){=\"\" if=\"\" (exponent=\"\" !=\"=\" +exponent){=\"\" throw=\"\" error('必须为数字')=\"\" 0){=\"\" if(exponent=\"\"> 1){\n        var result = base\n        for(var i =1;i<exponent;i++){ 1=\"\" result=\"\" *=\"base\" }=\"\" return=\"\" var=\"\" num=\"Math.abs(exponent)\" for=\"\" (var=\"\" i=\"1;\" <=\"\" exponent;=\"\" i++)=\"\" {=\"\" result?1=\"\" result:false=\"\" **=\"\" 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？=\"\" 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。=\"\" acmer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1到n中1出现的次数）。=\"\" 既然计算位数，11可以算为两次，就要逐位分析，先从两位来判断=\"\" 分别计算，个位为1和十位为1=\"\" 的情况，两者相加即为结果。=\"\" 需要判断数字，0、1、2关系有所不同，主要体现在对其后位数的限制=\"\" 0的话，后面位数可以不考虑，因为当前位不会位一，后面多大都不存在组合可能=\"\" 1的话，后面位数的大小要考虑，因为有部分值不能取到，例如13，那么14、15的情况不能取到，只能是3+1=\"\" ，有0=\"\" 2的话，就所有情况都满足了，完全根据前面值的决定，例如22，那么可以有(2+1)+(0+1)*10=\"13\" 即下面这个情况：abcde，分析百位数字c=\"\" c=\"0\" :=\"\" 有=\"\" ab*100=\"\" 种情况=\"\" +=\"\" de=\"\"> 2 : 有 (ab+1) * 100 种情况\n * 举个例子：\n * 210 \n * 个位为1： 21\n * 十位为1： 2*10+1\n * 百位为1： (0+1)*100\n * */ \nfunction getTotalNum(n){\n    let count = 0;\n    let i = 1;\n    let high = low = current = level = 0;\n    let length = n.toString().length;\n    while (i </exponent;i++){></=></64){></0){>","site":{"data":{}},"excerpt":"","more":"import { isNumber } from \"util\";\n\n// 数据准备\n/** \n * 输入 ： [1,null,2,3]\n * 输出：1,2,3\n*/\n\n/** \n * 二叉树遍历\n * 中序遍历，即先左边再右边,需要root的\n*/\n// 递归版本确实易懂，不过性能不好\nfunction inorderTraversal(root,arr){\n    // 存在根节点\n    if(root){\n        inorderTraversal(root.left,arr)\n        array.push(root.val)\n        inorderTraversal(root.right,arr)\n\n    }\n    return array;   \n}\nvar \n// 迭代版本\n/**\n * 迭代需要判断结束条件和执行顺序\n * 使用栈来存放当前节点遍历，直到栈已空\n * 因为是深度优先遍历，后进先出，所以用栈\n * 思路1、将左子节点入栈，直到叶子节点\n * 2、取出栈内节点，加入访问标识，然后查询右子节点\n * 3、不存在右边节点，则向上访问父节点重复1、2\n*/\nfunction inorderTraversal(root) {\n    // 存放遍历顺序\n    var arr = [],\n        // 存放节点队列\n        stack = [],\n        item = root\n        \n    // 节点存在，或者栈内有节点 \n    while(item || stack.length){\n        // 左子节点入队列进行入栈操作,直到叶子节点\n        // 没有左子节点，则进行下一步,查询下个节点\n        if(item){\n            stack.push(item)\n            item = item.left\n        }\n        // 开始访问已入栈节点\n        item = stack.pop()\n        // 压入访问记录\n        arr.push(item.val)\n        // 查找又子节点\n        item = item.right\n    }    \n    return array;\n}\n// 先序遍历\n// 入栈的时候遍历就可以可，\nfunction firstTravel(){\n    // 遍历结果\n    var result = [],\n        // 遍历栈\n        stack = [],\n        node = root\n    // 根节点存在 或者栈内节点存在，继续遍历   \n    while(node || stack.length ){  \n        // 左子节点入栈\n        while(node.left){\n            stack.push(node)\n            // 加入遍历队列\n            result.push(node.value)\n            node = node.left \n        } \n        // 节点出栈，查找右子节点\n        node = stack.pop()\n        // 遍历右节点\n        node = node.right\n    }  \n\n}\n// 后序遍历\n// 还是左节点先入栈，出栈的时候查询是否存在右节点，且该节点是否被访问过。\n// 因为右节点存在子节点的话，该节点会被遍历两次\nfunction lastTravel() {\n    // 遍历结果\n    var result = [],\n        // 遍历栈\n        stack = [],\n        // 标记子节点是否被访问\n        last = null,\n        node = root\n    // 根节点存在 或者栈内节点存在，继续遍历   \n    while (node || stack.length) {\n        // 左子节点入栈\n        while (node.left) {\n            stack.push(node)\n            node = node.left\n        }\n        // 判断子节点 父节点是否有右节点，有的话继续遍历\n        var traget = stack[stack.length-1]\n        // 存在右子节点，且未遍历过\n        if (traget.right && last !== traget.right){\n            // 遍历右节点\n            node = node.right    \n        }else{\n            // 节点出栈，查找右子节点\n            node = stack.pop()\n            // 接入队列\n            result.push(node.value)\n            // 标记遍历对象，以免二次遍历\n            last = node\n            // 终止条件\n            node= null\n        }\n    }\n}\n\n\n/** \n * 1+2+3+...+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n * 不能使用迭代判断，只能是递归，而if else 则只能使用 && \n * 思路1、递归相加，知道n为0 \n * 思路2、位运算，通过 n(n+1)/2 = (n方+n)/2 先求 n方+n 按位与 实现除的效果。\n*/\nfunction Sum_Solution(n){\n    return n && (n+Sum_Solution(n-1))\n}\nfunction Sum_Solution(n){\n    //二进制右移b位（去掉末b位），相当于a除以2的b次方（取整）\n    return (Math.pow(n,2)+n) >> 1\n}\n\n\n/**\n * 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。\n * 思路就是 进行位运算 替代常规加减，将+的结果可以分开看，每位相加，然后将进位和不进位内容相加\n * 那么对照着就能看到\n * 二进制异或操作和不进位相加得到的结果相同(1^1=0 0^1=1 0^0=0)\n *  二进制与操作后左移和进位结果相同（1&1=1 1&0=0 0&0=0）\n * \n*/\n\nfunction add(num1,num2){\n    if(num2 == 0){\n        return num1\n    }\n    // 递归加下去，直到最终结果得到\n    return add(num1 ^ num2, (num1 & num2) << 1)\n}\n// 非递归\nfunction add(num1,num2){\n    while(num2!=0){\n        // 非进位\n        var res = num1 ^ num2;\n        num2 = (num1 & num2)>>1;\n        num1 = res\n    }\n    return res\n}\n\n\n// 判断是否为整数\nfunction isOdd(num){\n    if (Number(num)){\n        return num % 2 == 0\n    } \n}\n// 位运算\nfunction isOdd(num) {\n    if (Number(num)) {\n        return num&1 != 0\n    }\n}\n\n// 给定一个整数，判断是不是2的整数次幂\n// 例如4、8等，分析特性，\n// 二进制 只有一个1开头 100、1000，自己减去1 之后 均为011、0111 这样 进行与操作之后，均为0 \nfunction check(num){\n    return num & (num-1) == 0\n}\n// 常规做法\n// 2/2 = 1 2%2 = 0  如果除结果不为0 ，深入下去，判断。\n// 迭代判断直到最后，看是否整除\nfunction check(num) {\n    if (num != 1) {\n        while (num != 1) {\n            if (num % 2 == 0) {\n                num = num / 2;\n            } else {\n                return false;\n            }\n\n        }\n        return true;\n    } else {\n        return false;\n    }\n}\n\n// 常规做法，转为二进制，记录1的个数\nfunction get1(num){\n    if(Number(num)){\n        var res = [],\n            count = 0\n            res1 = num,\n            res2 = 0\n        while (res1 > 0){\n            // 取余数\n            res2 = res1 % 2\n            // 取除数结果\n            res1 = parseInt(res1/2) \n            \n            res.push(res2)\n            if(res2 == 1){\n                count++\n            }\n        }\n        console.log('二进制表示>>>',res.reverse().toString())\n        console.log('1个数>>', count)\n    }\n}\n\n// 与1 与 可以获取最后一位的值\n// 然后右移运算，每次右移之后，最后一位就忽略了，获取上一位的值，直到为0。\nfunction get1(num){\n    var count = 0\n    while (num != 0) {\n        count += num & 1\n        // 带符号右移，符号位也可能是一\n        num >>= 1\n    }\n    console.log(count)\n    return count\n}\n\n\n/**\n * 在其他数都出现两次的数组中找到只出现一次的那个数\n * 思路1，遍历数组，存储出现次数\n * 思路2，数字与本身异或结果为0，那么出现两次的都可以被过滤掉，只剩下单次的值\n */\n\n function get1Num(arr){\n    var counts = [] \n    arr.forEach(item => {\n        // 不存在则入栈\n        var index = counts.indexOf(item)\n        if (index<0){ counts.push(item)=\"\" }else{=\"\" 存在则删除该元素=\"\" 截取直接元素获取切片=\"\" counts.slice(index,1)=\"\" splice=\"\" 裁剪原数组=\"\" counts.splice(index,1)=\"\" }=\"\" })=\"\" console.log(counts)=\"\" return=\"\" counts[0]=\"\" 异或做法=\"\" function=\"\" get1num(arr)=\"\" {=\"\" if(!arr=\"\" instanceof=\"\" array){=\"\" '输入数组'=\"\" var=\"\" counts=\"0\" arr.foreach(item=\"\"> {\n        counts = counts ^ item\n    })\n    console.log(counts)\n    return counts[0]\n}\n\n\n/**\n * 在其他数都出现两次的数组中找到只出现一次的那两个数\n * 有两个数 只出现一次\n * 思路1 依然可用\n * 思路2 思路是这样的，对于两个单次的数，要是能按规律分别分到两个数组里，就满足目的了\n * 所以整体进行一次异或，获取异或后的值，因为异或的原理，不同的数肯定存在1的位，按这一位是否为1将数组分类。\n * 出现两次的相同值肯定在一起，单次的值肯定分开，这样达到目的了，分别异或就可以了\n * 题目变形：给你1-1000个连续自然数,然后从中随机去掉两个,再打乱顺序,要求只遍历一次,求出被去掉数\n * 将连续自然数跟打乱之后的合并就是 单次多次的问题了。\n * 右移就是降低一个进制即 除以2，取整，例如3 右移一位为1 。\n * 左移即乘以2 例如 1=》2 \n * 这里回顾下js的取整方法： \n * Math.ceil() 向上取整，即进一位，ceil 有天花板的意思，很好理解了\n * Math.floor() 向下取整，floor有地板的意思\n * Math.round() 四舍五入，round有圆环的意思，专指四舍五入\n * parseInt() 这个同floor\n * parseInt(2.2) // 2\n * Math.floor(2.2) //2\n * Math.ceil(2.2) // 3\n * Math.round(2.2) // 2\n **/\n\nfunction getTwo(arr){\n    var val=0,\n    //  位置记录\n        position = 0,\n        // res1\n        result1 = 0,\n        result2 = 0\n   // 获取异或值     \n   arr.forEach(item => {\n            val = val ^ item\n        }) \n    // 获取第k位为1的值\n    while((val & 1 == 0 )&& val <64){ 右移=\"\" val=\"val\">> 1\n        position++\n    }\n    arr.forEach(item => {\n        // 第k位为0 \n        if((item >> position & 1) == 1){\n            result1 ^= item\n        }else{\n            result2 ^= item\n        }\n    })\n    console.log('x,y>>',result1,result2)\n}\n\n\n\n/**\n * 把只包含质因子2、3和5的数称作丑数（Ugly Number）。\n * 例如6、8都是丑数，但14不是，因为它包含质因子7。\n * 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。\n *  思路：\n * 首先查找丑数规律： 丑数只能被2、3、5整除，说明第n个丑数只能是0 - n-1中某个丑数✖️2、✖️3、✖️5的结果。\n * 而且，这个数即第0 - n-1个丑数✖️2、✖️3、✖️5的结果中比第n-1个丑数大的最小值。结果可能有很多，需要排序。\n * 按照上面的规律，我们可以依次求出第0 - n个丑数。\n * \n * 基本思路：\n * 0-n-1 的丑数队列，因为已知因为第一个丑数知道，所以可以一直推下去。\n * 然后分别*2 *3，* 5 ，比较大于n-1 丑数最小值\n * 可以优化：\n * 有些值，确实很小，没必要每次都乘，记录下本次，*2 * 3 * 5 刚好大于n-1 丑数的值即可，下次从其开始循环。\n * \n */\n  \n function getUglyNumber(n){\n    //  记录位置标识\n    var i = j = k = 0,\n        // 初始数组就是1\n        arr = [1]\n    // 0 直接返回    \n    if(n == 0){\n        return arr[0]\n    }\n    // 获取丑数队列\n    while(arr.length <= 1=\"\" 2=\"\" 3=\"\" 5=\"\" n){=\"\" next=\"\" 丑数=\"\" arr.push(math.min(arr[i]*2,arr[j]*3,arr[k]*5))=\"\" var=\"\" currentitem=\"arr[arr.length\" -=\"\" 1]=\"\" 获取下次下标=\"\" n-1=\"\" while=\"\" (arr[i]=\"\" *=\"\" <=\"currentItem){\" i++=\"\" }=\"\" (arr[j]=\"\" {=\"\" j++=\"\" (arr[k]=\"\" k++=\"\" console.log(arr[n])=\"\" return=\"\" arr[n]=\"\" **=\"\" 数值的整数次方=\"\" 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。=\"\" 这道题逻辑上很简单，但很容易出错。=\"\" 关键是要考虑全面，考虑到所有情况。=\"\" exponent=\"\" 是正，负，0的情况=\"\" base为0的情况=\"\" math.abs（）=\"\" absolute=\"\" value=\"\" 就是绝对值的意思，防抱死也有点意味，绝对可用=\"\" function=\"\" getpow(base,=\"\" exponent){=\"\" if=\"\" (exponent=\"\" !=\"=\" +exponent){=\"\" throw=\"\" error('必须为数字')=\"\" 0){=\"\" if(exponent=\"\"> 1){\n        var result = base\n        for(var i =1;i<exponent;i++){ 1=\"\" result=\"\" *=\"base\" }=\"\" return=\"\" var=\"\" num=\"Math.abs(exponent)\" for=\"\" (var=\"\" i=\"1;\" <=\"\" exponent;=\"\" i++)=\"\" {=\"\" result?1=\"\" result:false=\"\" **=\"\" 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？=\"\" 为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。=\"\" acmer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1到n中1出现的次数）。=\"\" 既然计算位数，11可以算为两次，就要逐位分析，先从两位来判断=\"\" 分别计算，个位为1和十位为1=\"\" 的情况，两者相加即为结果。=\"\" 需要判断数字，0、1、2关系有所不同，主要体现在对其后位数的限制=\"\" 0的话，后面位数可以不考虑，因为当前位不会位一，后面多大都不存在组合可能=\"\" 1的话，后面位数的大小要考虑，因为有部分值不能取到，例如13，那么14、15的情况不能取到，只能是3+1=\"\" ，有0=\"\" 2的话，就所有情况都满足了，完全根据前面值的决定，例如22，那么可以有(2+1)+(0+1)*10=\"13\" 即下面这个情况：abcde，分析百位数字c=\"\" c=\"0\" :=\"\" 有=\"\" ab*100=\"\" 种情况=\"\" +=\"\" de=\"\"> 2 : 有 (ab+1) * 100 种情况\n * 举个例子：\n * 210 \n * 个位为1： 21\n * 十位为1： 2*10+1\n * 百位为1： (0+1)*100\n * */ \nfunction getTotalNum(n){\n    let count = 0;\n    let i = 1;\n    let high = low = current = level = 0;\n    let length = n.toString().length;\n    while (i </exponent;i++){></=></64){></0){>"},{"_content":"// node节点\nfunction node(val){\n    this.val = val\n    this.next = null\n}\nfunction LinkList(){\n    this.head = new Node('head');     //头节点\n    this.find = find;                   //查找节点\n    this.insert = insert;               //插入节点\n    this.remove = remove;               //删除节点\n    this.findPrev = findPrev;           //查找前一个节点\n    this.display = display;             //显示链表\n}\n\n// 查找所有值并输出\n// 迭代调用知道找到最后一个节点，即next为null\nfunction printVlas(){   \n    const arr = []\n    // 找到当前第一个元素\n    let head = LinkList.find(0)\n    while(head){\n        let {val,next} = head\n        arr.push(val)\n        head = next\n    }\n}\n\n// 删除链表节点，删除分为几种情况 一般是给定头部节点\n/** \n * 首节点\n * 中间节点\n * 尾节点\n */\nfunction remove(head,node){\n    // 头节点\n    if (node.next) {\n        // 中间节点,将next节点覆盖当前节点\n        node.val = node.next.val;\n        node.next = node.next.next;\n    } else if (head.value = node.value) {\n        // 节点置为null，头部节点也为null,该节点被null覆盖\n        node = null;\n        head = null;\n    }else{\n        // 尾部节点，且非头，则需要遍历到最后一个，next指向null\n        // 从头遍历\n        node = head;\n        // 最后一个之前，当前节点都被next覆盖。\n        while (node.next.next) {\n            node = node.next;\n        }\n        // 没有next指向，即删除尾节点\n        node.next = null;\n        node = null;\n    }\n}","source":"structure/linklist.js","raw":"// node节点\nfunction node(val){\n    this.val = val\n    this.next = null\n}\nfunction LinkList(){\n    this.head = new Node('head');     //头节点\n    this.find = find;                   //查找节点\n    this.insert = insert;               //插入节点\n    this.remove = remove;               //删除节点\n    this.findPrev = findPrev;           //查找前一个节点\n    this.display = display;             //显示链表\n}\n\n// 查找所有值并输出\n// 迭代调用知道找到最后一个节点，即next为null\nfunction printVlas(){   \n    const arr = []\n    // 找到当前第一个元素\n    let head = LinkList.find(0)\n    while(head){\n        let {val,next} = head\n        arr.push(val)\n        head = next\n    }\n}\n\n// 删除链表节点，删除分为几种情况 一般是给定头部节点\n/** \n * 首节点\n * 中间节点\n * 尾节点\n */\nfunction remove(head,node){\n    // 头节点\n    if (node.next) {\n        // 中间节点,将next节点覆盖当前节点\n        node.val = node.next.val;\n        node.next = node.next.next;\n    } else if (head.value = node.value) {\n        // 节点置为null，头部节点也为null,该节点被null覆盖\n        node = null;\n        head = null;\n    }else{\n        // 尾部节点，且非头，则需要遍历到最后一个，next指向null\n        // 从头遍历\n        node = head;\n        // 最后一个之前，当前节点都被next覆盖。\n        while (node.next.next) {\n            node = node.next;\n        }\n        // 没有next指向，即删除尾节点\n        node.next = null;\n        node = null;\n    }\n}","date":"2019-12-16T08:32:55.377Z","updated":"2019-12-16T08:32:55.377Z","path":"structure/linklist.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt6x0016gw92xkp0igxm","content":"// node节点\nfunction node(val){\n    this.val = val\n    this.next = null\n}\nfunction LinkList(){\n    this.head = new Node('head');     //头节点\n    this.find = find;                   //查找节点\n    this.insert = insert;               //插入节点\n    this.remove = remove;               //删除节点\n    this.findPrev = findPrev;           //查找前一个节点\n    this.display = display;             //显示链表\n}\n\n// 查找所有值并输出\n// 迭代调用知道找到最后一个节点，即next为null\nfunction printVlas(){   \n    const arr = []\n    // 找到当前第一个元素\n    let head = LinkList.find(0)\n    while(head){\n        let {val,next} = head\n        arr.push(val)\n        head = next\n    }\n}\n\n// 删除链表节点，删除分为几种情况 一般是给定头部节点\n/** \n * 首节点\n * 中间节点\n * 尾节点\n */\nfunction remove(head,node){\n    // 头节点\n    if (node.next) {\n        // 中间节点,将next节点覆盖当前节点\n        node.val = node.next.val;\n        node.next = node.next.next;\n    } else if (head.value = node.value) {\n        // 节点置为null，头部节点也为null,该节点被null覆盖\n        node = null;\n        head = null;\n    }else{\n        // 尾部节点，且非头，则需要遍历到最后一个，next指向null\n        // 从头遍历\n        node = head;\n        // 最后一个之前，当前节点都被next覆盖。\n        while (node.next.next) {\n            node = node.next;\n        }\n        // 没有next指向，即删除尾节点\n        node.next = null;\n        node = null;\n    }\n}","site":{"data":{}},"excerpt":"","more":"// node节点\nfunction node(val){\n    this.val = val\n    this.next = null\n}\nfunction LinkList(){\n    this.head = new Node('head');     //头节点\n    this.find = find;                   //查找节点\n    this.insert = insert;               //插入节点\n    this.remove = remove;               //删除节点\n    this.findPrev = findPrev;           //查找前一个节点\n    this.display = display;             //显示链表\n}\n\n// 查找所有值并输出\n// 迭代调用知道找到最后一个节点，即next为null\nfunction printVlas(){   \n    const arr = []\n    // 找到当前第一个元素\n    let head = LinkList.find(0)\n    while(head){\n        let {val,next} = head\n        arr.push(val)\n        head = next\n    }\n}\n\n// 删除链表节点，删除分为几种情况 一般是给定头部节点\n/** \n * 首节点\n * 中间节点\n * 尾节点\n */\nfunction remove(head,node){\n    // 头节点\n    if (node.next) {\n        // 中间节点,将next节点覆盖当前节点\n        node.val = node.next.val;\n        node.next = node.next.next;\n    } else if (head.value = node.value) {\n        // 节点置为null，头部节点也为null,该节点被null覆盖\n        node = null;\n        head = null;\n    }else{\n        // 尾部节点，且非头，则需要遍历到最后一个，next指向null\n        // 从头遍历\n        node = head;\n        // 最后一个之前，当前节点都被next覆盖。\n        while (node.next.next) {\n            node = node.next;\n        }\n        // 没有next指向，即删除尾节点\n        node.next = null;\n        node = null;\n    }\n}"},{"_content":"function sayHello(name){if(name.length>2){name=name.substr(0,1)+\"...\"}console.log(\"hello,\",name)}sayHello(\"世界\");sayHello(\"第三世界的人们\");\n//# sourceMappingURL=/index.js.map","source":"sourcemap/index.js","raw":"function sayHello(name){if(name.length>2){name=name.substr(0,1)+\"...\"}console.log(\"hello,\",name)}sayHello(\"世界\");sayHello(\"第三世界的人们\");\n//# sourceMappingURL=/index.js.map","date":"2019-09-16T06:24:20.350Z","updated":"2019-09-16T06:24:20.349Z","path":"sourcemap/index.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt6y0017gw92tdzt1rnk","content":"function sayHello(name){if(name.length>2){name=name.substr(0,1)+\"...\"}console.log(\"hello,\",name)}sayHello(\"世界\");sayHello(\"第三世界的人们\");\n//# sourceMappingURL=/index.js.map","site":{"data":{}},"excerpt":"","more":"function sayHello(name){if(name.length>2){name=name.substr(0,1)+\"...\"}console.log(\"hello,\",name)}sayHello(\"世界\");sayHello(\"第三世界的人们\");\n//# sourceMappingURL=/index.js.map"},{"_content":"\n// 执行排序方法\nfunction execMethod(fn) {\n    // 获取测试测试数据\n    arr = [55, 11, 64, 73, 77, 201, 38, 51, 57, 97]\n    console.log('origin-arr>>>', arr)\n    return fn()\n}\n// 交换两项\nfunction swapItem(arr, i, j) {\n    let temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n} \n// \n/**\n *  冒泡排序,\n *  每次循环，以为是从前往后走，所以最大值肯定筛选出来。\n *  要想最小值，需要从最后开始遍历，其实没必要了。\n *  相邻前后交换位置，\n * */ \nfunction bubbleSort(){\n    let len = arr.length\n    // 这样写错误的原因呢？循环的时候只与i比，相互之间没有比较  \n    for(i=0;i<len;i++){\n        // 当前元素 n轮循环之后，后面几位是拍好序的，所以只关注前面即可。\n        for(let j = 0;j<len-i-1;j++){\n            if (arr[j+1] < arr[j]){\n                swapItem(arr,j,j+1)\n            }\n        }\n        console.log\n    } \n    return arr   \n} \n\n// 执行方案\nexecMethod(bubbleSort)\n\n\n\n/**\n * 选择排序，也是多次遍历，实现在于获取最小位置下标，\n * 遍历完成之后，再交换\n * 而非相邻交换，效率略高\n * */ \n\nfunction selectSort(){\n    let len = arr.length;\n    for(var i = 1;i<len;i++){\n        let minIndex = i\n        for(var j = 0;j<i;j++){\n            if (arr[minIndex]>arr[j] ) {\n                minIndex = j\n            }\n        }\n        // 只有不等才交换\n        i !== minIndex && swapItem(minIndex,i)\n    }\n    return arr\n}\n   \n// run\nexecMethod(selectSort)\n\n// 其实前面有点插入排序的感觉。。。。。不过是交换方式不同罢了。\n/** \n * 插入排序\n * 原理在于认为第一项是有序，从首至尾，顺序插入。\n * 即每一项都与前n项对比，直到完成。\n * */ \nfunction insertionSort(){\n    var len = arr.length;\n    // 第一项已经是有序\n    for(var i = 1;i<len;i++){\n        var item = arr[i];\n            target = i\n        // 左侧从最大值开始与item比较，直到小于item出现\n        for(var j = i-1;j>-1;j--){\n            // 满足插入顺序,当前元素往后移动，给待排位元素留空\n            if(arr[j]>item){\n                target = j\n                arr[j+1] = arr[j]\n                // 查找到符合元素则终止\n            }\n            \n        }\n        // 插入对应元素,不用交互，因为位置上已经是可用元素\n        arr[target] = item\n    }\n    return arr\n}\nexecMethod(insertionSort)\n\n/** \n * 归并排序 可以分治法的体现，将大的数组拆分至最小单元，\n * 小单元排序之后，再合并\n * 合并时，分别对比就可。\n * */ \nfunction mergeSort(arrs= arr){\n    // 判断终止条件\n    if(arrs.length < 2){\n        return arrs\n    }\n    let mid = Math.floor(arrs.length/2),\n        left = arrs.slice(0,mid),\n        right = arrs.slice(mid)\n    return merge(mergeSort(left),mergeSort(right))\n}\nfunction merge(left,right){\n    var temp = []\n    // 对于2的元素比较最为清晰，进行排序的步骤，此时left分别已经是有序\n    // 依次挨个对比，小的入栈，大的留下来，直到比完\n    while(left.length && right.length){\n        if(left[0] < right[0]){\n            temp.push(left.shift())\n        }else{\n            temp.push(right.shift())\n        }\n    }\n    // 剩下的，left肯定大于right\n    // 顺序已经固定，依次插入即可\n    while(left.length){\n        temp.push(left.shift())\n    }\n    while (right.length) {\n        temp.push(right.shift())\n    }\n    return temp\n}\nexecMethod(mergeSort)\n\n\n\n/** \n * 相比于归并排序来说，快排并没有将数组实际分割，而是选择标准元素即主元\n * 将数组按大小进行分割。然后依次排序，直到最小数组\n * 循环的过程，使用left，right两个指针，从右至做寻找中元插入位置。\n * \n *\n*/\nfunction quickSort(arr,start,end){\n    var left = start,\n        right = end\n    // 已经交叉，则不再进行。    \n    if (end - start < 1) {\n        return;\n    }\n    // 保留初始值，即中元值，以首位元素为默认值。\n    var target = arr[start]\n    while (left< right){\n        // 查找小于target的右侧位置,当前大于，则前一位肯定可以插入\n        // 至于是否符合，则要继续迭代判断\n        while(left < right && arr[right]>=target){\n            right--;\n        }\n        // 此时arr[right] 小于target或者已经到底，既然如此则把其放到左侧。\n        // 找到插入点,将target赋于当期那元素，因为中元已经保留，所以肯定先覆盖left\n        arr[left] = arr[right]\n        // 前方可能有大于target的元素，继续从左侧开始查找\n        while(left<right && arr[left]<target){\n            left++;   \n        }\n        // 此时left要么与right相等，相等了，则当前位置就是合适位置\n        // 要么是大于target赋给 right是ok的。\n        arr[right] = arr[left]\n    }    \n    // 此时left为中间位置\n    arr[left] = target\n    console.log('arr>>>', arr)\n    quickSort(arr, start, left - 1);\n    quickSort(arr, left + 1, end);\n    return arr;\n}\nquickSort(arr,0,9)\n\n\n\n/**\n * 二分搜索 \n * */ \n\nfunction binarySearch(item){\n    var arr = [1,2,3,4,11,34,55,77,88,99,100]\n    console.log('已排序数组>>',arr)\n    var len = arr.length,\n        left=0,\n        right = len-1,\n        midIndex \n    // 选中间，作为比较标准，判断是否到首尾 \n    while(left<=right){\n        // 中间位置选取\n        midIndex = Math.floor((left+right) / 2)\n        var midItem = arr[midIndex]\n        if (midItem == item){\n            console.log('最终位置》》', midItem)\n            return minIndex\n        }\n        // 左边\n        if(midItem > item){\n            // 取之前元素\n            right = midIndex -1    \n        }\n        if(midItem<item){\n            left = left+1\n        }\n        console.log('中间位置》》', midItem)\n    }\n    console.log('最终位置》》', -1)   \n    return -1  \n} \n\n\n\n\nfunction getTotal(n){\n    var current = heigh = low = level = 0\n    // 位数下标\n    var i = 0\n    // 数字位数\n    var len = n.toString().length\n    // 总数\n    var total = 0\n    for(i;i<len;i++){\n        level = Math.pow(10,i)\n        // 注意这里获取当前位置的value\n        heigh = Math.floor(n/(10*level))%10\n        current = n % (10 * level)\n        low = n % (level)\n        if(current == 0){\n            total += heigh*level\n        }else if(current == 1){\n            total += heigh*level + low+1\n        }else{\n            total += (heigh+1)*level\n        }\n    }\n    return total\n}","source":"structure/sort.js","raw":"\n// 执行排序方法\nfunction execMethod(fn) {\n    // 获取测试测试数据\n    arr = [55, 11, 64, 73, 77, 201, 38, 51, 57, 97]\n    console.log('origin-arr>>>', arr)\n    return fn()\n}\n// 交换两项\nfunction swapItem(arr, i, j) {\n    let temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n} \n// \n/**\n *  冒泡排序,\n *  每次循环，以为是从前往后走，所以最大值肯定筛选出来。\n *  要想最小值，需要从最后开始遍历，其实没必要了。\n *  相邻前后交换位置，\n * */ \nfunction bubbleSort(){\n    let len = arr.length\n    // 这样写错误的原因呢？循环的时候只与i比，相互之间没有比较  \n    for(i=0;i<len;i++){\n        // 当前元素 n轮循环之后，后面几位是拍好序的，所以只关注前面即可。\n        for(let j = 0;j<len-i-1;j++){\n            if (arr[j+1] < arr[j]){\n                swapItem(arr,j,j+1)\n            }\n        }\n        console.log\n    } \n    return arr   \n} \n\n// 执行方案\nexecMethod(bubbleSort)\n\n\n\n/**\n * 选择排序，也是多次遍历，实现在于获取最小位置下标，\n * 遍历完成之后，再交换\n * 而非相邻交换，效率略高\n * */ \n\nfunction selectSort(){\n    let len = arr.length;\n    for(var i = 1;i<len;i++){\n        let minIndex = i\n        for(var j = 0;j<i;j++){\n            if (arr[minIndex]>arr[j] ) {\n                minIndex = j\n            }\n        }\n        // 只有不等才交换\n        i !== minIndex && swapItem(minIndex,i)\n    }\n    return arr\n}\n   \n// run\nexecMethod(selectSort)\n\n// 其实前面有点插入排序的感觉。。。。。不过是交换方式不同罢了。\n/** \n * 插入排序\n * 原理在于认为第一项是有序，从首至尾，顺序插入。\n * 即每一项都与前n项对比，直到完成。\n * */ \nfunction insertionSort(){\n    var len = arr.length;\n    // 第一项已经是有序\n    for(var i = 1;i<len;i++){\n        var item = arr[i];\n            target = i\n        // 左侧从最大值开始与item比较，直到小于item出现\n        for(var j = i-1;j>-1;j--){\n            // 满足插入顺序,当前元素往后移动，给待排位元素留空\n            if(arr[j]>item){\n                target = j\n                arr[j+1] = arr[j]\n                // 查找到符合元素则终止\n            }\n            \n        }\n        // 插入对应元素,不用交互，因为位置上已经是可用元素\n        arr[target] = item\n    }\n    return arr\n}\nexecMethod(insertionSort)\n\n/** \n * 归并排序 可以分治法的体现，将大的数组拆分至最小单元，\n * 小单元排序之后，再合并\n * 合并时，分别对比就可。\n * */ \nfunction mergeSort(arrs= arr){\n    // 判断终止条件\n    if(arrs.length < 2){\n        return arrs\n    }\n    let mid = Math.floor(arrs.length/2),\n        left = arrs.slice(0,mid),\n        right = arrs.slice(mid)\n    return merge(mergeSort(left),mergeSort(right))\n}\nfunction merge(left,right){\n    var temp = []\n    // 对于2的元素比较最为清晰，进行排序的步骤，此时left分别已经是有序\n    // 依次挨个对比，小的入栈，大的留下来，直到比完\n    while(left.length && right.length){\n        if(left[0] < right[0]){\n            temp.push(left.shift())\n        }else{\n            temp.push(right.shift())\n        }\n    }\n    // 剩下的，left肯定大于right\n    // 顺序已经固定，依次插入即可\n    while(left.length){\n        temp.push(left.shift())\n    }\n    while (right.length) {\n        temp.push(right.shift())\n    }\n    return temp\n}\nexecMethod(mergeSort)\n\n\n\n/** \n * 相比于归并排序来说，快排并没有将数组实际分割，而是选择标准元素即主元\n * 将数组按大小进行分割。然后依次排序，直到最小数组\n * 循环的过程，使用left，right两个指针，从右至做寻找中元插入位置。\n * \n *\n*/\nfunction quickSort(arr,start,end){\n    var left = start,\n        right = end\n    // 已经交叉，则不再进行。    \n    if (end - start < 1) {\n        return;\n    }\n    // 保留初始值，即中元值，以首位元素为默认值。\n    var target = arr[start]\n    while (left< right){\n        // 查找小于target的右侧位置,当前大于，则前一位肯定可以插入\n        // 至于是否符合，则要继续迭代判断\n        while(left < right && arr[right]>=target){\n            right--;\n        }\n        // 此时arr[right] 小于target或者已经到底，既然如此则把其放到左侧。\n        // 找到插入点,将target赋于当期那元素，因为中元已经保留，所以肯定先覆盖left\n        arr[left] = arr[right]\n        // 前方可能有大于target的元素，继续从左侧开始查找\n        while(left<right && arr[left]<target){\n            left++;   \n        }\n        // 此时left要么与right相等，相等了，则当前位置就是合适位置\n        // 要么是大于target赋给 right是ok的。\n        arr[right] = arr[left]\n    }    \n    // 此时left为中间位置\n    arr[left] = target\n    console.log('arr>>>', arr)\n    quickSort(arr, start, left - 1);\n    quickSort(arr, left + 1, end);\n    return arr;\n}\nquickSort(arr,0,9)\n\n\n\n/**\n * 二分搜索 \n * */ \n\nfunction binarySearch(item){\n    var arr = [1,2,3,4,11,34,55,77,88,99,100]\n    console.log('已排序数组>>',arr)\n    var len = arr.length,\n        left=0,\n        right = len-1,\n        midIndex \n    // 选中间，作为比较标准，判断是否到首尾 \n    while(left<=right){\n        // 中间位置选取\n        midIndex = Math.floor((left+right) / 2)\n        var midItem = arr[midIndex]\n        if (midItem == item){\n            console.log('最终位置》》', midItem)\n            return minIndex\n        }\n        // 左边\n        if(midItem > item){\n            // 取之前元素\n            right = midIndex -1    \n        }\n        if(midItem<item){\n            left = left+1\n        }\n        console.log('中间位置》》', midItem)\n    }\n    console.log('最终位置》》', -1)   \n    return -1  \n} \n\n\n\n\nfunction getTotal(n){\n    var current = heigh = low = level = 0\n    // 位数下标\n    var i = 0\n    // 数字位数\n    var len = n.toString().length\n    // 总数\n    var total = 0\n    for(i;i<len;i++){\n        level = Math.pow(10,i)\n        // 注意这里获取当前位置的value\n        heigh = Math.floor(n/(10*level))%10\n        current = n % (10 * level)\n        low = n % (level)\n        if(current == 0){\n            total += heigh*level\n        }else if(current == 1){\n            total += heigh*level + low+1\n        }else{\n            total += (heigh+1)*level\n        }\n    }\n    return total\n}","date":"2019-12-16T09:08:40.407Z","updated":"2019-12-16T09:08:40.407Z","path":"structure/sort.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt6y0018gw92745avaoo","content":"\n// 执行排序方法\nfunction execMethod(fn) {\n    // 获取测试测试数据\n    arr = [55, 11, 64, 73, 77, 201, 38, 51, 57, 97]\n    console.log('origin-arr>>>', arr)\n    return fn()\n}\n// 交换两项\nfunction swapItem(arr, i, j) {\n    let temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n} \n// \n/**\n *  冒泡排序,\n *  每次循环，以为是从前往后走，所以最大值肯定筛选出来。\n *  要想最小值，需要从最后开始遍历，其实没必要了。\n *  相邻前后交换位置，\n * */ \nfunction bubbleSort(){\n    let len = arr.length\n    // 这样写错误的原因呢？循环的时候只与i比，相互之间没有比较  \n    for(i=0;i<len;i++){ 当前元素=\"\" n轮循环之后，后面几位是拍好序的，所以只关注前面即可。=\"\" for(let=\"\" j=\"0;j<len-i-1;j++){\" if=\"\" (arr[j+1]=\"\" <=\"\" arr[j]){=\"\" swapitem(arr,j,j+1)=\"\" }=\"\" console.log=\"\" return=\"\" arr=\"\" 执行方案=\"\" execmethod(bubblesort)=\"\" **=\"\" *=\"\" 选择排序，也是多次遍历，实现在于获取最小位置下标，=\"\" 遍历完成之后，再交换=\"\" 而非相邻交换，效率略高=\"\" function=\"\" selectsort(){=\"\" let=\"\" len=\"arr.length;\" for(var=\"\" i=\"1;i<len;i++){\" minindex=\"i\" (arr[minindex]=\"\">arr[j] ) {\n                minIndex = j\n            }\n        }\n        // 只有不等才交换\n        i !== minIndex && swapItem(minIndex,i)\n    }\n    return arr\n}\n   \n// run\nexecMethod(selectSort)\n\n// 其实前面有点插入排序的感觉。。。。。不过是交换方式不同罢了。\n/** \n * 插入排序\n * 原理在于认为第一项是有序，从首至尾，顺序插入。\n * 即每一项都与前n项对比，直到完成。\n * */ \nfunction insertionSort(){\n    var len = arr.length;\n    // 第一项已经是有序\n    for(var i = 1;i<len;i++){ var=\"\" item=\"arr[i];\" target=\"i\" 左侧从最大值开始与item比较，直到小于item出现=\"\" for(var=\"\" j=\"i-1;j\">-1;j--){\n            // 满足插入顺序,当前元素往后移动，给待排位元素留空\n            if(arr[j]>item){\n                target = j\n                arr[j+1] = arr[j]\n                // 查找到符合元素则终止\n            }\n            \n        }\n        // 插入对应元素,不用交互，因为位置上已经是可用元素\n        arr[target] = item\n    }\n    return arr\n}\nexecMethod(insertionSort)\n\n/** \n * 归并排序 可以分治法的体现，将大的数组拆分至最小单元，\n * 小单元排序之后，再合并\n * 合并时，分别对比就可。\n * */ \nfunction mergeSort(arrs= arr){\n    // 判断终止条件\n    if(arrs.length < 2){\n        return arrs\n    }\n    let mid = Math.floor(arrs.length/2),\n        left = arrs.slice(0,mid),\n        right = arrs.slice(mid)\n    return merge(mergeSort(left),mergeSort(right))\n}\nfunction merge(left,right){\n    var temp = []\n    // 对于2的元素比较最为清晰，进行排序的步骤，此时left分别已经是有序\n    // 依次挨个对比，小的入栈，大的留下来，直到比完\n    while(left.length && right.length){\n        if(left[0] < right[0]){\n            temp.push(left.shift())\n        }else{\n            temp.push(right.shift())\n        }\n    }\n    // 剩下的，left肯定大于right\n    // 顺序已经固定，依次插入即可\n    while(left.length){\n        temp.push(left.shift())\n    }\n    while (right.length) {\n        temp.push(right.shift())\n    }\n    return temp\n}\nexecMethod(mergeSort)\n\n\n\n/** \n * 相比于归并排序来说，快排并没有将数组实际分割，而是选择标准元素即主元\n * 将数组按大小进行分割。然后依次排序，直到最小数组\n * 循环的过程，使用left，right两个指针，从右至做寻找中元插入位置。\n * \n *\n*/\nfunction quickSort(arr,start,end){\n    var left = start,\n        right = end\n    // 已经交叉，则不再进行。    \n    if (end - start < 1) {\n        return;\n    }\n    // 保留初始值，即中元值，以首位元素为默认值。\n    var target = arr[start]\n    while (left< right){\n        // 查找小于target的右侧位置,当前大于，则前一位肯定可以插入\n        // 至于是否符合，则要继续迭代判断\n        while(left < right && arr[right]>=target){\n            right--;\n        }\n        // 此时arr[right] 小于target或者已经到底，既然如此则把其放到左侧。\n        // 找到插入点,将target赋于当期那元素，因为中元已经保留，所以肯定先覆盖left\n        arr[left] = arr[right]\n        // 前方可能有大于target的元素，继续从左侧开始查找\n        while(left<right &&=\"\" arr[left]<target){=\"\" left++;=\"\" }=\"\" 此时left要么与right相等，相等了，则当前位置就是合适位置=\"\" 要么是大于target赋给=\"\" right是ok的。=\"\" arr[right]=\"arr[left]\" 此时left为中间位置=\"\" arr[left]=\"target\" console.log('arr=\"\">>>', arr)\n    quickSort(arr, start, left - 1);\n    quickSort(arr, left + 1, end);\n    return arr;\n}\nquickSort(arr,0,9)\n\n\n\n/**\n * 二分搜索 \n * */ \n\nfunction binarySearch(item){\n    var arr = [1,2,3,4,11,34,55,77,88,99,100]\n    console.log('已排序数组>>',arr)\n    var len = arr.length,\n        left=0,\n        right = len-1,\n        midIndex \n    // 选中间，作为比较标准，判断是否到首尾 \n    while(left<=right){ 中间位置选取=\"\" midindex=\"Math.floor((left+right)\" 2)=\"\" var=\"\" miditem=\"arr[midIndex]\" if=\"\" (miditem=\"=\" item){=\"\" console.log('最终位置》》',=\"\" miditem)=\"\" return=\"\" minindex=\"\" }=\"\" 左边=\"\" if(miditem=\"\"> item){\n            // 取之前元素\n            right = midIndex -1    \n        }\n        if(midItem</=right){></right></len;i++){></len;i++){>","site":{"data":{}},"excerpt":"","more":"\n// 执行排序方法\nfunction execMethod(fn) {\n    // 获取测试测试数据\n    arr = [55, 11, 64, 73, 77, 201, 38, 51, 57, 97]\n    console.log('origin-arr>>>', arr)\n    return fn()\n}\n// 交换两项\nfunction swapItem(arr, i, j) {\n    let temp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = temp\n} \n// \n/**\n *  冒泡排序,\n *  每次循环，以为是从前往后走，所以最大值肯定筛选出来。\n *  要想最小值，需要从最后开始遍历，其实没必要了。\n *  相邻前后交换位置，\n * */ \nfunction bubbleSort(){\n    let len = arr.length\n    // 这样写错误的原因呢？循环的时候只与i比，相互之间没有比较  \n    for(i=0;i<len;i++){ 当前元素=\"\" n轮循环之后，后面几位是拍好序的，所以只关注前面即可。=\"\" for(let=\"\" j=\"0;j<len-i-1;j++){\" if=\"\" (arr[j+1]=\"\" <=\"\" arr[j]){=\"\" swapitem(arr,j,j+1)=\"\" }=\"\" console.log=\"\" return=\"\" arr=\"\" 执行方案=\"\" execmethod(bubblesort)=\"\" **=\"\" *=\"\" 选择排序，也是多次遍历，实现在于获取最小位置下标，=\"\" 遍历完成之后，再交换=\"\" 而非相邻交换，效率略高=\"\" function=\"\" selectsort(){=\"\" let=\"\" len=\"arr.length;\" for(var=\"\" i=\"1;i<len;i++){\" minindex=\"i\" (arr[minindex]=\"\">arr[j] ) {\n                minIndex = j\n            }\n        }\n        // 只有不等才交换\n        i !== minIndex && swapItem(minIndex,i)\n    }\n    return arr\n}\n   \n// run\nexecMethod(selectSort)\n\n// 其实前面有点插入排序的感觉。。。。。不过是交换方式不同罢了。\n/** \n * 插入排序\n * 原理在于认为第一项是有序，从首至尾，顺序插入。\n * 即每一项都与前n项对比，直到完成。\n * */ \nfunction insertionSort(){\n    var len = arr.length;\n    // 第一项已经是有序\n    for(var i = 1;i<len;i++){ var=\"\" item=\"arr[i];\" target=\"i\" 左侧从最大值开始与item比较，直到小于item出现=\"\" for(var=\"\" j=\"i-1;j\">-1;j--){\n            // 满足插入顺序,当前元素往后移动，给待排位元素留空\n            if(arr[j]>item){\n                target = j\n                arr[j+1] = arr[j]\n                // 查找到符合元素则终止\n            }\n            \n        }\n        // 插入对应元素,不用交互，因为位置上已经是可用元素\n        arr[target] = item\n    }\n    return arr\n}\nexecMethod(insertionSort)\n\n/** \n * 归并排序 可以分治法的体现，将大的数组拆分至最小单元，\n * 小单元排序之后，再合并\n * 合并时，分别对比就可。\n * */ \nfunction mergeSort(arrs= arr){\n    // 判断终止条件\n    if(arrs.length < 2){\n        return arrs\n    }\n    let mid = Math.floor(arrs.length/2),\n        left = arrs.slice(0,mid),\n        right = arrs.slice(mid)\n    return merge(mergeSort(left),mergeSort(right))\n}\nfunction merge(left,right){\n    var temp = []\n    // 对于2的元素比较最为清晰，进行排序的步骤，此时left分别已经是有序\n    // 依次挨个对比，小的入栈，大的留下来，直到比完\n    while(left.length && right.length){\n        if(left[0] < right[0]){\n            temp.push(left.shift())\n        }else{\n            temp.push(right.shift())\n        }\n    }\n    // 剩下的，left肯定大于right\n    // 顺序已经固定，依次插入即可\n    while(left.length){\n        temp.push(left.shift())\n    }\n    while (right.length) {\n        temp.push(right.shift())\n    }\n    return temp\n}\nexecMethod(mergeSort)\n\n\n\n/** \n * 相比于归并排序来说，快排并没有将数组实际分割，而是选择标准元素即主元\n * 将数组按大小进行分割。然后依次排序，直到最小数组\n * 循环的过程，使用left，right两个指针，从右至做寻找中元插入位置。\n * \n *\n*/\nfunction quickSort(arr,start,end){\n    var left = start,\n        right = end\n    // 已经交叉，则不再进行。    \n    if (end - start < 1) {\n        return;\n    }\n    // 保留初始值，即中元值，以首位元素为默认值。\n    var target = arr[start]\n    while (left< right){\n        // 查找小于target的右侧位置,当前大于，则前一位肯定可以插入\n        // 至于是否符合，则要继续迭代判断\n        while(left < right && arr[right]>=target){\n            right--;\n        }\n        // 此时arr[right] 小于target或者已经到底，既然如此则把其放到左侧。\n        // 找到插入点,将target赋于当期那元素，因为中元已经保留，所以肯定先覆盖left\n        arr[left] = arr[right]\n        // 前方可能有大于target的元素，继续从左侧开始查找\n        while(left<right &&=\"\" arr[left]<target){=\"\" left++;=\"\" }=\"\" 此时left要么与right相等，相等了，则当前位置就是合适位置=\"\" 要么是大于target赋给=\"\" right是ok的。=\"\" arr[right]=\"arr[left]\" 此时left为中间位置=\"\" arr[left]=\"target\" console.log('arr=\"\">>>', arr)\n    quickSort(arr, start, left - 1);\n    quickSort(arr, left + 1, end);\n    return arr;\n}\nquickSort(arr,0,9)\n\n\n\n/**\n * 二分搜索 \n * */ \n\nfunction binarySearch(item){\n    var arr = [1,2,3,4,11,34,55,77,88,99,100]\n    console.log('已排序数组>>',arr)\n    var len = arr.length,\n        left=0,\n        right = len-1,\n        midIndex \n    // 选中间，作为比较标准，判断是否到首尾 \n    while(left<=right){ 中间位置选取=\"\" midindex=\"Math.floor((left+right)\" 2)=\"\" var=\"\" miditem=\"arr[midIndex]\" if=\"\" (miditem=\"=\" item){=\"\" console.log('最终位置》》',=\"\" miditem)=\"\" return=\"\" minindex=\"\" }=\"\" 左边=\"\" if(miditem=\"\"> item){\n            // 取之前元素\n            right = midIndex -1    \n        }\n        if(midItem</=right){></right></len;i++){></len;i++){>"},{"_content":"export default class Team {\n    constructor(){\n        this.name ='火箭'\n    }\n}","source":"ioc/v1/team.js","raw":"export default class Team {\n    constructor(){\n        this.name ='火箭'\n    }\n}","date":"2018-10-24T12:01:12.000Z","updated":"2018-10-24T12:01:12.000Z","path":"ioc/v1/team.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt7u001agw9204udcv06","content":"export default class Team {\n    constructor(){\n        this.name ='火箭'\n    }\n}","site":{"data":{}},"excerpt":"","more":"export default class Team {\n    constructor(){\n        this.name ='火箭'\n    }\n}"},{"_content":"import team from './team'\nexport default class Player{\n    constructor(){\n        this.team = team\n    }\n    info(){\n        console.log(this.team.name)\n    }\n}","source":"ioc/v1/player.js","raw":"import team from './team'\nexport default class Player{\n    constructor(){\n        this.team = team\n    }\n    info(){\n        console.log(this.team.name)\n    }\n}","date":"2018-10-24T12:01:52.000Z","updated":"2018-10-24T12:01:52.000Z","path":"ioc/v1/player.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt7v001cgw92efp8tupw","content":"import team from './team'\nexport default class Player{\n    constructor(){\n        this.team = team\n    }\n    info(){\n        console.log(this.team.name)\n    }\n}","site":{"data":{}},"excerpt":"","more":"import team from './team'\nexport default class Player{\n    constructor(){\n        this.team = team\n    }\n    info(){\n        console.log(this.team.name)\n    }\n}"},{"_content":"sayHello('世界')\nsayHello('第三世界的人们')","source":"sourcemap/src/main.js","raw":"sayHello('世界')\nsayHello('第三世界的人们')","date":"2019-09-16T06:24:20.353Z","updated":"2019-09-16T06:24:20.353Z","path":"sourcemap/src/main.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt9r001lgw92khah6a79","content":"sayHello('世界')\nsayHello('第三世界的人们')","site":{"data":{}},"excerpt":"","more":"sayHello('世界')\nsayHello('第三世界的人们')"},{"_content":"function sayHello(name) {\n    if (name.length > 2) {\n        name = name.substr(0, 1) + '...'\n    }\n    console.log('hello,', name)\n}","source":"sourcemap/src/log.js","raw":"function sayHello(name) {\n    if (name.length > 2) {\n        name = name.substr(0, 1) + '...'\n    }\n    console.log('hello,', name)\n}","date":"2019-09-16T06:24:20.352Z","updated":"2019-09-16T06:24:20.352Z","path":"sourcemap/src/log.js","layout":"false","title":"","comments":1,"_id":"ck4tbvt9r001mgw928z5ai8wu","content":"function sayHello(name) {\n    if (name.length > 2) {\n        name = name.substr(0, 1) + '...'\n    }\n    console.log('hello,', name)\n}","site":{"data":{}},"excerpt":"","more":"function sayHello(name) {\n    if (name.length > 2) {\n        name = name.substr(0, 1) + '...'\n    }\n    console.log('hello,', name)\n}"},{"_content":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n<head>\n    <title>\n        自定义属性换肤\n    </title>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta name=\"keywords\" content=\"react.js, react, component, components, ui, framework\">\n</head>\n\n<body>\n    <button id='j_click'>点击切换主题色</button>\n    <div>字体颜色改变</div>\n</body>\n<script>\n    var btn = document.querySelecter('#js_click'),\n        dataMap = ['green','blue'],\n        index=0,\n        root = document.querySelector('body')\n    function count(){\n        if(index>2){\n            index++\n        }else{\n            index = 0\n        }\n    }    \n    function handleTheme(){\n        count()\n        var clolr_Theme = dataMap[index]\n        \n    }\n    btn.addEventListener('click',()=>{\n        handleTheme()\n    })\n    \n</script>\n<script>\n    // 双向绑定\n    // let data = {\n    //     price: 5,\n    //     count: 2\n    // },\n    //     callb = null\n\n    // class Events {\n    //     constructor() {\n    //         this._events = []\n    //     }\n    //     on() {\n    //         if (callb && !this._events.includes(callb)) {\n    //             this._events.push(callb)\n    //         }\n    //     }\n    //     triger() {\n    //         this._events.forEach((callb) => {\n    //             callb && callb()\n    //         })\n    //     }\n    // }\n\n    // Object.keys(data).forEach((key) => {\n    //     let initVlue = data[key]\n    //     const e1 = new Events()\n    //     Object.defineProperty(data, key, {\n    //         get() {\n    //             //内部判断是否需要注册\n    //             e1.on()\n    //             // 执行过置否\n    //             callb = null\n    //             // get不变更值\n    //             return initVlue\n    //         },\n    //         set(newVal) {\n    //             initVlue = newVal\n    //             // set操作触发事件，同步数据变动\n    //             e1.triger()\n    //         }\n    //     })\n    // })\n    // function watcher(func) {\n    //     // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    //     callb = func\n    //     // 初次执行时，获取对应值自然经过get方法注册事件\n    //     callb()\n    //     // 置否避免重复注册\n    //     callb = null\n    // }\n    // // 此处指定事件触发回调，注册监听事件\n    // watcher(() => {\n    //     data.total = data.price * data.count\n    // })\n</script>\n\n</html>","source":"theme/part1/index.html","raw":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n<head>\n    <title>\n        自定义属性换肤\n    </title>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta name=\"keywords\" content=\"react.js, react, component, components, ui, framework\">\n</head>\n\n<body>\n    <button id='j_click'>点击切换主题色</button>\n    <div>字体颜色改变</div>\n</body>\n<script>\n    var btn = document.querySelecter('#js_click'),\n        dataMap = ['green','blue'],\n        index=0,\n        root = document.querySelector('body')\n    function count(){\n        if(index>2){\n            index++\n        }else{\n            index = 0\n        }\n    }    \n    function handleTheme(){\n        count()\n        var clolr_Theme = dataMap[index]\n        \n    }\n    btn.addEventListener('click',()=>{\n        handleTheme()\n    })\n    \n</script>\n<script>\n    // 双向绑定\n    // let data = {\n    //     price: 5,\n    //     count: 2\n    // },\n    //     callb = null\n\n    // class Events {\n    //     constructor() {\n    //         this._events = []\n    //     }\n    //     on() {\n    //         if (callb && !this._events.includes(callb)) {\n    //             this._events.push(callb)\n    //         }\n    //     }\n    //     triger() {\n    //         this._events.forEach((callb) => {\n    //             callb && callb()\n    //         })\n    //     }\n    // }\n\n    // Object.keys(data).forEach((key) => {\n    //     let initVlue = data[key]\n    //     const e1 = new Events()\n    //     Object.defineProperty(data, key, {\n    //         get() {\n    //             //内部判断是否需要注册\n    //             e1.on()\n    //             // 执行过置否\n    //             callb = null\n    //             // get不变更值\n    //             return initVlue\n    //         },\n    //         set(newVal) {\n    //             initVlue = newVal\n    //             // set操作触发事件，同步数据变动\n    //             e1.triger()\n    //         }\n    //     })\n    // })\n    // function watcher(func) {\n    //     // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    //     callb = func\n    //     // 初次执行时，获取对应值自然经过get方法注册事件\n    //     callb()\n    //     // 置否避免重复注册\n    //     callb = null\n    // }\n    // // 此处指定事件触发回调，注册监听事件\n    // watcher(() => {\n    //     data.total = data.price * data.count\n    // })\n</script>\n\n</html>","date":"2019-09-20T03:51:22.789Z","updated":"2019-09-20T03:51:22.789Z","path":"theme/part1/index.html","title":"","comments":1,"layout":"page","_id":"ck4tbvt9s001ngw92qcv20jf8","content":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n<head>\n    <title>\n        自定义属性换肤\n    </title>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta name=\"keywords\" content=\"react.js, react, component, components, ui, framework\">\n</head>\n\n<body>\n    <button id=\"j_click\">点击切换主题色</button>\n    <div>字体颜色改变</div>\n</body>\n<script>\n    var btn = document.querySelecter('#js_click'),\n        dataMap = ['green','blue'],\n        index=0,\n        root = document.querySelector('body')\n    function count(){\n        if(index>2){\n            index++\n        }else{\n            index = 0\n        }\n    }    \n    function handleTheme(){\n        count()\n        var clolr_Theme = dataMap[index]\n        \n    }\n    btn.addEventListener('click',()=>{\n        handleTheme()\n    })\n    \n</script>\n<script>\n    // 双向绑定\n    // let data = {\n    //     price: 5,\n    //     count: 2\n    // },\n    //     callb = null\n\n    // class Events {\n    //     constructor() {\n    //         this._events = []\n    //     }\n    //     on() {\n    //         if (callb && !this._events.includes(callb)) {\n    //             this._events.push(callb)\n    //         }\n    //     }\n    //     triger() {\n    //         this._events.forEach((callb) => {\n    //             callb && callb()\n    //         })\n    //     }\n    // }\n\n    // Object.keys(data).forEach((key) => {\n    //     let initVlue = data[key]\n    //     const e1 = new Events()\n    //     Object.defineProperty(data, key, {\n    //         get() {\n    //             //内部判断是否需要注册\n    //             e1.on()\n    //             // 执行过置否\n    //             callb = null\n    //             // get不变更值\n    //             return initVlue\n    //         },\n    //         set(newVal) {\n    //             initVlue = newVal\n    //             // set操作触发事件，同步数据变动\n    //             e1.triger()\n    //         }\n    //     })\n    // })\n    // function watcher(func) {\n    //     // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    //     callb = func\n    //     // 初次执行时，获取对应值自然经过get方法注册事件\n    //     callb()\n    //     // 置否避免重复注册\n    //     callb = null\n    // }\n    // // 此处指定事件触发回调，注册监听事件\n    // watcher(() => {\n    //     data.total = data.price * data.count\n    // })\n</script>\n\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n<head>\n    <title>\n        自定义属性换肤\n    </title>\n    <meta charset=\"utf-8\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta name=\"keywords\" content=\"react.js, react, component, components, ui, framework\">\n</head>\n\n<body>\n    <button id=\"j_click\">点击切换主题色</button>\n    <div>字体颜色改变</div>\n</body>\n<script>\n    var btn = document.querySelecter('#js_click'),\n        dataMap = ['green','blue'],\n        index=0,\n        root = document.querySelector('body')\n    function count(){\n        if(index>2){\n            index++\n        }else{\n            index = 0\n        }\n    }    \n    function handleTheme(){\n        count()\n        var clolr_Theme = dataMap[index]\n        \n    }\n    btn.addEventListener('click',()=>{\n        handleTheme()\n    })\n    \n</script>\n<script>\n    // 双向绑定\n    // let data = {\n    //     price: 5,\n    //     count: 2\n    // },\n    //     callb = null\n\n    // class Events {\n    //     constructor() {\n    //         this._events = []\n    //     }\n    //     on() {\n    //         if (callb && !this._events.includes(callb)) {\n    //             this._events.push(callb)\n    //         }\n    //     }\n    //     triger() {\n    //         this._events.forEach((callb) => {\n    //             callb && callb()\n    //         })\n    //     }\n    // }\n\n    // Object.keys(data).forEach((key) => {\n    //     let initVlue = data[key]\n    //     const e1 = new Events()\n    //     Object.defineProperty(data, key, {\n    //         get() {\n    //             //内部判断是否需要注册\n    //             e1.on()\n    //             // 执行过置否\n    //             callb = null\n    //             // get不变更值\n    //             return initVlue\n    //         },\n    //         set(newVal) {\n    //             initVlue = newVal\n    //             // set操作触发事件，同步数据变动\n    //             e1.triger()\n    //         }\n    //     })\n    // })\n    // function watcher(func) {\n    //     // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    //     callb = func\n    //     // 初次执行时，获取对应值自然经过get方法注册事件\n    //     callb()\n    //     // 置否避免重复注册\n    //     callb = null\n    // }\n    // // 此处指定事件触发回调，注册监听事件\n    // watcher(() => {\n    //     data.total = data.price * data.count\n    // })\n</script>\n\n</html>"}],"Post":[{"title":"前端解读面向切面编程(AOP)","date":"2018-10-25T16:00:00.000Z","_content":"  \n## 前言  \n面向对象(OOP)作为经典的设计范式，对于我们来说可谓无人不知，还记得我们入行起始时那句经典的总结吗-**万事万物皆对象**。  \n是的，基于OOP思想封装、继承、多态的特点，我们会自然而然的遵循模块化、组件化的思维来设计开发应用，以到达易维护、可扩展、高复用的目的。  \n既然OOP这么多优点，那么经常被大家提起的面向切面编程（AOP）是什么回事呢，下面我们就一起来看一下。   \n<!-- more -->\n## AOP定义  \n第一步还是要知道aop是什么，先个来自维基百科的解释：   \n \n**面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。  \n侧面的概念源于对面向对象的程序设计的改进，但并不只限于此，它还可以用来改进传统的函数。**  \n\n其从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来.  \n业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过侧面来封装、维护.\n这样原本分散在在整个应用程序中的变动就可以很好的管理起来。  \n\n#### tip\n确实有点那么不太清晰，有点乱。不过在乱之前，我们可以选能理解的部分先看一下:  \n  \n* **侧面(也就是切面) 用来描述分散在对象、类或函数中的横切关注点**。  \n    重点在这，分散在对象中的横切关注点，可以猜一下是什么，应该就是不同对象之间公用的部分   \n* **侧面的概念源于对面向对象的程序设计的改进，它还可以用来改进传统的函数**.\n    AOP 显然不是OOP的替代品，是OOP的一种补充。   \n* **从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。**  \n    具体到业务项目中来说，主关注点就是业务逻辑了。针对特定领域问题代码的调用，就是AOP要关注的部分   \n\n**简而言之，AOP是针对业务处理过程中的切面(即非业务逻辑部分，例如错误处理，埋点，日志等)进行提取.**  \n它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果(目的是降低耦合)。  \n具体到实现来说就是通过动态的方式将非主关注点部分插入到主关注点(一般是业务逻辑中)   \n\n说了这么多，可能不太明白，还是一起看代码吧。\n\n## 埋点场景\n  \n很普遍的这么个场景，需要点击按钮之后进行信息上报。\n假设我们有这么个logger的工具，可以进行上报：  \n\n```js\nconst logger = console.log\n//引入即可使用\nlogger('按钮被点击了')\n```\n那么，我们直接撸起来吧：   \n```js\nconst doSomething = ()=>{\n    console.log('doSomething')\n} \nlet clickHandler = ()=>{\n   logger('doSomething之前')\n   // n行代码 \n   doSomething() \n   logger('doSomething之后')\n   //n 行代码\n}\n```\n看起来也没什么的，简单粗暴。  \n如果有30个按钮，每个业务逻辑不同，都需要埋这个点(假设打点信息一致)。  \n我们30个函数里面，都要手动写这个方法的话，这也太坑爹了吧。  \n主要是与业务代码严重耦合，哪天不小心动了点其他内容，手抖误删了，就gg了。  \n后续维护的时候，简直噩梦。    \n仔细看一下，这不就是符合AOP的使用前提吗，那么试试AOP吧。   \n  \n### 关注点划分\n \n根据前面提的，可以划分下关注点。  \n\n| 主关注点 | 侧关注点 |\n| --- | --- |\n| 业务逻辑(doSomething) | 埋点信息 logger |\n\n前面提到AOP关注的是步骤具体到例子来说其实就是插入logger的步骤。   \n插入时机无非时业务逻辑执行之前或者之后的阶段。    \n具体实现起来也不那么困难   \n   \n### 实现思路\n具体到js来说，由于语言本身的特性，天生就具有运行时动态插入逻辑的能力。  \n重点在于在原函数上增加其他功能并不改变函数本身。  \n  \n毕竟函数可以接受一切形式的参数，当然函数也不例外了。  \n当传入一个函数的时候，我们要对其操作的余地就很大了，  \n保存原函数，然后利用后续参数加上call或apply，就可以达到我们的目的。  \n此外为了给函数都增加一个属性，我们在原型上操作就行了。 \n\n#### 经典before或者after的实现   \n\n网上太多类似实现了，直接看代码好了：  \n\n```js\n// action 即为我们的侧关注点，即logger\nFunction.prototype.after = function (action) {\n    //保留当前函数，这里this指向运行函数即clickHandler\n    var func = this;\n    // return 被包装过的函数，这里就可以执行其他功能了。\n    // 并且该方法挂在Function.prototype上，\n    // 被返回的函数依然具有after属性,可以链式调用\n    return function () {\n        // 原函数执行，这里不考虑异步\n        var result = func.apply(this, arguments);\n        // 执行之后的操作\n        action.apply(this,arguments);\n        // 将执行结果返回\n        return result;\n    };\n};\n// before 实现类似，只不过执行顺序差别而已\nFunction.prototype.before = function (action) {\n    var func = this;\n    return function () {\n        action.apply(this,arguments);\n        return func.apply(this, arguments);\n    };\n};\n```\n那么我们使用AOP改造之后的代码就如下了:\n```js\nconst doSomething = ()=>{\n    console.log('doSomething')\n} \nlet clickHandler = ()=>{\n   // n行代码 \n   doSomething() \n   //n 行代码\n}\nclickHandler = clickHandler.before(()=>{\n     logger('doSomething之前')\n}).after(()=>{\n     logger('doSomething之后')\n})\nclickHandler() // 执行结果和预期一致\n```\n到这里就实现了面向切面编程，我们的业务逻辑里面只管业务本身，侧关注点通过这种方式来动态引入，与主逻辑解耦，更加纯净、易于维护。\n\n## 结束语\n到这里，简单的AOP就介绍完成了。利用这种模式结合我们js本身的特性，可以尝试更多的可能。\n例如我们react中常见的HOC、es7的装饰者模式、HOF等，很多时候不得不感叹大牛们思想的精髓，会让我们有种顿悟的感觉。本文抛砖引玉，共同学习啦，对自己是总结和提高，更希望能帮助到需要的小伙伴。[更多文章请移步我的博客](https://github.com/xiaoxiangdaiyu/blog)\n#### 参考文章  \n[AllyTeam - 用AOP改善javascript代码](http://www.alloyteam.com/2013/08/yong-aop-gai-shan-javascript-dai-ma/)   \n[深入浅出 Javascript Decorators 和 AOP 编程](https://juejin.im/entry/5a12443951882512a860e93c) \n\n\n","source":"_posts/AOP.md","raw":"---\ntitle: 前端解读面向切面编程(AOP)\ndate: 2018-10-26\n---\n  \n## 前言  \n面向对象(OOP)作为经典的设计范式，对于我们来说可谓无人不知，还记得我们入行起始时那句经典的总结吗-**万事万物皆对象**。  \n是的，基于OOP思想封装、继承、多态的特点，我们会自然而然的遵循模块化、组件化的思维来设计开发应用，以到达易维护、可扩展、高复用的目的。  \n既然OOP这么多优点，那么经常被大家提起的面向切面编程（AOP）是什么回事呢，下面我们就一起来看一下。   \n<!-- more -->\n## AOP定义  \n第一步还是要知道aop是什么，先个来自维基百科的解释：   \n \n**面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。  \n侧面的概念源于对面向对象的程序设计的改进，但并不只限于此，它还可以用来改进传统的函数。**  \n\n其从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来.  \n业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过侧面来封装、维护.\n这样原本分散在在整个应用程序中的变动就可以很好的管理起来。  \n\n#### tip\n确实有点那么不太清晰，有点乱。不过在乱之前，我们可以选能理解的部分先看一下:  \n  \n* **侧面(也就是切面) 用来描述分散在对象、类或函数中的横切关注点**。  \n    重点在这，分散在对象中的横切关注点，可以猜一下是什么，应该就是不同对象之间公用的部分   \n* **侧面的概念源于对面向对象的程序设计的改进，它还可以用来改进传统的函数**.\n    AOP 显然不是OOP的替代品，是OOP的一种补充。   \n* **从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。**  \n    具体到业务项目中来说，主关注点就是业务逻辑了。针对特定领域问题代码的调用，就是AOP要关注的部分   \n\n**简而言之，AOP是针对业务处理过程中的切面(即非业务逻辑部分，例如错误处理，埋点，日志等)进行提取.**  \n它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果(目的是降低耦合)。  \n具体到实现来说就是通过动态的方式将非主关注点部分插入到主关注点(一般是业务逻辑中)   \n\n说了这么多，可能不太明白，还是一起看代码吧。\n\n## 埋点场景\n  \n很普遍的这么个场景，需要点击按钮之后进行信息上报。\n假设我们有这么个logger的工具，可以进行上报：  \n\n```js\nconst logger = console.log\n//引入即可使用\nlogger('按钮被点击了')\n```\n那么，我们直接撸起来吧：   \n```js\nconst doSomething = ()=>{\n    console.log('doSomething')\n} \nlet clickHandler = ()=>{\n   logger('doSomething之前')\n   // n行代码 \n   doSomething() \n   logger('doSomething之后')\n   //n 行代码\n}\n```\n看起来也没什么的，简单粗暴。  \n如果有30个按钮，每个业务逻辑不同，都需要埋这个点(假设打点信息一致)。  \n我们30个函数里面，都要手动写这个方法的话，这也太坑爹了吧。  \n主要是与业务代码严重耦合，哪天不小心动了点其他内容，手抖误删了，就gg了。  \n后续维护的时候，简直噩梦。    \n仔细看一下，这不就是符合AOP的使用前提吗，那么试试AOP吧。   \n  \n### 关注点划分\n \n根据前面提的，可以划分下关注点。  \n\n| 主关注点 | 侧关注点 |\n| --- | --- |\n| 业务逻辑(doSomething) | 埋点信息 logger |\n\n前面提到AOP关注的是步骤具体到例子来说其实就是插入logger的步骤。   \n插入时机无非时业务逻辑执行之前或者之后的阶段。    \n具体实现起来也不那么困难   \n   \n### 实现思路\n具体到js来说，由于语言本身的特性，天生就具有运行时动态插入逻辑的能力。  \n重点在于在原函数上增加其他功能并不改变函数本身。  \n  \n毕竟函数可以接受一切形式的参数，当然函数也不例外了。  \n当传入一个函数的时候，我们要对其操作的余地就很大了，  \n保存原函数，然后利用后续参数加上call或apply，就可以达到我们的目的。  \n此外为了给函数都增加一个属性，我们在原型上操作就行了。 \n\n#### 经典before或者after的实现   \n\n网上太多类似实现了，直接看代码好了：  \n\n```js\n// action 即为我们的侧关注点，即logger\nFunction.prototype.after = function (action) {\n    //保留当前函数，这里this指向运行函数即clickHandler\n    var func = this;\n    // return 被包装过的函数，这里就可以执行其他功能了。\n    // 并且该方法挂在Function.prototype上，\n    // 被返回的函数依然具有after属性,可以链式调用\n    return function () {\n        // 原函数执行，这里不考虑异步\n        var result = func.apply(this, arguments);\n        // 执行之后的操作\n        action.apply(this,arguments);\n        // 将执行结果返回\n        return result;\n    };\n};\n// before 实现类似，只不过执行顺序差别而已\nFunction.prototype.before = function (action) {\n    var func = this;\n    return function () {\n        action.apply(this,arguments);\n        return func.apply(this, arguments);\n    };\n};\n```\n那么我们使用AOP改造之后的代码就如下了:\n```js\nconst doSomething = ()=>{\n    console.log('doSomething')\n} \nlet clickHandler = ()=>{\n   // n行代码 \n   doSomething() \n   //n 行代码\n}\nclickHandler = clickHandler.before(()=>{\n     logger('doSomething之前')\n}).after(()=>{\n     logger('doSomething之后')\n})\nclickHandler() // 执行结果和预期一致\n```\n到这里就实现了面向切面编程，我们的业务逻辑里面只管业务本身，侧关注点通过这种方式来动态引入，与主逻辑解耦，更加纯净、易于维护。\n\n## 结束语\n到这里，简单的AOP就介绍完成了。利用这种模式结合我们js本身的特性，可以尝试更多的可能。\n例如我们react中常见的HOC、es7的装饰者模式、HOF等，很多时候不得不感叹大牛们思想的精髓，会让我们有种顿悟的感觉。本文抛砖引玉，共同学习啦，对自己是总结和提高，更希望能帮助到需要的小伙伴。[更多文章请移步我的博客](https://github.com/xiaoxiangdaiyu/blog)\n#### 参考文章  \n[AllyTeam - 用AOP改善javascript代码](http://www.alloyteam.com/2013/08/yong-aop-gai-shan-javascript-dai-ma/)   \n[深入浅出 Javascript Decorators 和 AOP 编程](https://juejin.im/entry/5a12443951882512a860e93c) \n\n\n","slug":"AOP","published":1,"updated":"2018-10-26T11:49:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt0y0000gw92x9nefv59","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>面向对象(OOP)作为经典的设计范式，对于我们来说可谓无人不知，还记得我们入行起始时那句经典的总结吗-<strong>万事万物皆对象</strong>。<br>是的，基于OOP思想封装、继承、多态的特点，我们会自然而然的遵循模块化、组件化的思维来设计开发应用，以到达易维护、可扩展、高复用的目的。<br>既然OOP这么多优点，那么经常被大家提起的面向切面编程（AOP）是什么回事呢，下面我们就一起来看一下。<br><a id=\"more\"></a></p>\n<h2 id=\"AOP定义\"><a href=\"#AOP定义\" class=\"headerlink\" title=\"AOP定义\"></a>AOP定义</h2><p>第一步还是要知道aop是什么，先个来自维基百科的解释：   </p>\n<p><strong>面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。<br>侧面的概念源于对面向对象的程序设计的改进，但并不只限于此，它还可以用来改进传统的函数。</strong>  </p>\n<p>其从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来.<br>业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过侧面来封装、维护.<br>这样原本分散在在整个应用程序中的变动就可以很好的管理起来。  </p>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><p>确实有点那么不太清晰，有点乱。不过在乱之前，我们可以选能理解的部分先看一下:  </p>\n<ul>\n<li><strong>侧面(也就是切面) 用来描述分散在对象、类或函数中的横切关注点</strong>。<br>  重点在这，分散在对象中的横切关注点，可以猜一下是什么，应该就是不同对象之间公用的部分   </li>\n<li><strong>侧面的概念源于对面向对象的程序设计的改进，它还可以用来改进传统的函数</strong>.<br>  AOP 显然不是OOP的替代品，是OOP的一种补充。   </li>\n<li><strong>从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。</strong><br>  具体到业务项目中来说，主关注点就是业务逻辑了。针对特定领域问题代码的调用，就是AOP要关注的部分   </li>\n</ul>\n<p><strong>简而言之，AOP是针对业务处理过程中的切面(即非业务逻辑部分，例如错误处理，埋点，日志等)进行提取.</strong><br>它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果(目的是降低耦合)。<br>具体到实现来说就是通过动态的方式将非主关注点部分插入到主关注点(一般是业务逻辑中)   </p>\n<p>说了这么多，可能不太明白，还是一起看代码吧。</p>\n<h2 id=\"埋点场景\"><a href=\"#埋点场景\" class=\"headerlink\" title=\"埋点场景\"></a>埋点场景</h2><p>很普遍的这么个场景，需要点击按钮之后进行信息上报。<br>假设我们有这么个logger的工具，可以进行上报：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"built_in\">console</span>.log</span><br><span class=\"line\"><span class=\"comment\">//引入即可使用</span></span><br><span class=\"line\">logger(<span class=\"string\">'按钮被点击了'</span>)</span><br></pre></td></tr></table></figure>\n<p>那么，我们直接撸起来吧：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'doSomething'</span>)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">let</span> clickHandler = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">   logger(<span class=\"string\">'doSomething之前'</span>)</span><br><span class=\"line\">   <span class=\"comment\">// n行代码 </span></span><br><span class=\"line\">   doSomething() </span><br><span class=\"line\">   logger(<span class=\"string\">'doSomething之后'</span>)</span><br><span class=\"line\">   <span class=\"comment\">//n 行代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>看起来也没什么的，简单粗暴。<br>如果有30个按钮，每个业务逻辑不同，都需要埋这个点(假设打点信息一致)。<br>我们30个函数里面，都要手动写这个方法的话，这也太坑爹了吧。<br>主要是与业务代码严重耦合，哪天不小心动了点其他内容，手抖误删了，就gg了。<br>后续维护的时候，简直噩梦。<br>仔细看一下，这不就是符合AOP的使用前提吗，那么试试AOP吧。   </p>\n<h3 id=\"关注点划分\"><a href=\"#关注点划分\" class=\"headerlink\" title=\"关注点划分\"></a>关注点划分</h3><p>根据前面提的，可以划分下关注点。  </p>\n<table>\n<thead>\n<tr>\n<th>主关注点</th>\n<th>侧关注点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>业务逻辑(doSomething)</td>\n<td>埋点信息 logger</td>\n</tr>\n</tbody>\n</table>\n<p>前面提到AOP关注的是步骤具体到例子来说其实就是插入logger的步骤。<br>插入时机无非时业务逻辑执行之前或者之后的阶段。<br>具体实现起来也不那么困难   </p>\n<h3 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h3><p>具体到js来说，由于语言本身的特性，天生就具有运行时动态插入逻辑的能力。<br>重点在于在原函数上增加其他功能并不改变函数本身。  </p>\n<p>毕竟函数可以接受一切形式的参数，当然函数也不例外了。<br>当传入一个函数的时候，我们要对其操作的余地就很大了，<br>保存原函数，然后利用后续参数加上call或apply，就可以达到我们的目的。<br>此外为了给函数都增加一个属性，我们在原型上操作就行了。 </p>\n<h4 id=\"经典before或者after的实现\"><a href=\"#经典before或者after的实现\" class=\"headerlink\" title=\"经典before或者after的实现\"></a>经典before或者after的实现</h4><p>网上太多类似实现了，直接看代码好了：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action 即为我们的侧关注点，即logger</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.after = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//保留当前函数，这里this指向运行函数即clickHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> func = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// return 被包装过的函数，这里就可以执行其他功能了。</span></span><br><span class=\"line\">    <span class=\"comment\">// 并且该方法挂在Function.prototype上，</span></span><br><span class=\"line\">    <span class=\"comment\">// 被返回的函数依然具有after属性,可以链式调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 原函数执行，这里不考虑异步</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = func.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 执行之后的操作</span></span><br><span class=\"line\">        action.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 将执行结果返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// before 实现类似，只不过执行顺序差别而已</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.before = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> func = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        action.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>那么我们使用AOP改造之后的代码就如下了:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'doSomething'</span>)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">let</span> clickHandler = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// n行代码 </span></span><br><span class=\"line\">   doSomething() </span><br><span class=\"line\">   <span class=\"comment\">//n 行代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">clickHandler = clickHandler.before(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">     logger(<span class=\"string\">'doSomething之前'</span>)</span><br><span class=\"line\">&#125;).after(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">     logger(<span class=\"string\">'doSomething之后'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">clickHandler() <span class=\"comment\">// 执行结果和预期一致</span></span><br></pre></td></tr></table></figure></p>\n<p>到这里就实现了面向切面编程，我们的业务逻辑里面只管业务本身，侧关注点通过这种方式来动态引入，与主逻辑解耦，更加纯净、易于维护。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>到这里，简单的AOP就介绍完成了。利用这种模式结合我们js本身的特性，可以尝试更多的可能。<br>例如我们react中常见的HOC、es7的装饰者模式、HOF等，很多时候不得不感叹大牛们思想的精髓，会让我们有种顿悟的感觉。本文抛砖引玉，共同学习啦，对自己是总结和提高，更希望能帮助到需要的小伙伴。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">更多文章请移步我的博客</a></p>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://www.alloyteam.com/2013/08/yong-aop-gai-shan-javascript-dai-ma/\" target=\"_blank\" rel=\"noopener\">AllyTeam - 用AOP改善javascript代码</a><br><a href=\"https://juejin.im/entry/5a12443951882512a860e93c\" target=\"_blank\" rel=\"noopener\">深入浅出 Javascript Decorators 和 AOP 编程</a> </p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>面向对象(OOP)作为经典的设计范式，对于我们来说可谓无人不知，还记得我们入行起始时那句经典的总结吗-<strong>万事万物皆对象</strong>。<br>是的，基于OOP思想封装、继承、多态的特点，我们会自然而然的遵循模块化、组件化的思维来设计开发应用，以到达易维护、可扩展、高复用的目的。<br>既然OOP这么多优点，那么经常被大家提起的面向切面编程（AOP）是什么回事呢，下面我们就一起来看一下。<br>","more":"</p>\n<h2 id=\"AOP定义\"><a href=\"#AOP定义\" class=\"headerlink\" title=\"AOP定义\"></a>AOP定义</h2><p>第一步还是要知道aop是什么，先个来自维基百科的解释：   </p>\n<p><strong>面向侧面的程序设计（aspect-oriented programming，AOP，又译作面向方面的程序设计、观点导向编程、剖面导向程序设计）是计算机科学中的一个术语，指一种程序设计范型。<br>侧面的概念源于对面向对象的程序设计的改进，但并不只限于此，它还可以用来改进传统的函数。</strong>  </p>\n<p>其从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。分离关注点使得解决特定领域问题的代码从业务逻辑中独立出来.<br>业务逻辑的代码中不再含有针对特定领域问题代码的调用，业务逻辑同特定领域问题的关系通过侧面来封装、维护.<br>这样原本分散在在整个应用程序中的变动就可以很好的管理起来。  </p>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><p>确实有点那么不太清晰，有点乱。不过在乱之前，我们可以选能理解的部分先看一下:  </p>\n<ul>\n<li><strong>侧面(也就是切面) 用来描述分散在对象、类或函数中的横切关注点</strong>。<br>  重点在这，分散在对象中的横切关注点，可以猜一下是什么，应该就是不同对象之间公用的部分   </li>\n<li><strong>侧面的概念源于对面向对象的程序设计的改进，它还可以用来改进传统的函数</strong>.<br>  AOP 显然不是OOP的替代品，是OOP的一种补充。   </li>\n<li><strong>从主关注点中分离出横切关注点是面向侧面的程序设计的核心概念。</strong><br>  具体到业务项目中来说，主关注点就是业务逻辑了。针对特定领域问题代码的调用，就是AOP要关注的部分   </li>\n</ul>\n<p><strong>简而言之，AOP是针对业务处理过程中的切面(即非业务逻辑部分，例如错误处理，埋点，日志等)进行提取.</strong><br>它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果(目的是降低耦合)。<br>具体到实现来说就是通过动态的方式将非主关注点部分插入到主关注点(一般是业务逻辑中)   </p>\n<p>说了这么多，可能不太明白，还是一起看代码吧。</p>\n<h2 id=\"埋点场景\"><a href=\"#埋点场景\" class=\"headerlink\" title=\"埋点场景\"></a>埋点场景</h2><p>很普遍的这么个场景，需要点击按钮之后进行信息上报。<br>假设我们有这么个logger的工具，可以进行上报：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> logger = <span class=\"built_in\">console</span>.log</span><br><span class=\"line\"><span class=\"comment\">//引入即可使用</span></span><br><span class=\"line\">logger(<span class=\"string\">'按钮被点击了'</span>)</span><br></pre></td></tr></table></figure>\n<p>那么，我们直接撸起来吧：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'doSomething'</span>)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">let</span> clickHandler = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">   logger(<span class=\"string\">'doSomething之前'</span>)</span><br><span class=\"line\">   <span class=\"comment\">// n行代码 </span></span><br><span class=\"line\">   doSomething() </span><br><span class=\"line\">   logger(<span class=\"string\">'doSomething之后'</span>)</span><br><span class=\"line\">   <span class=\"comment\">//n 行代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>看起来也没什么的，简单粗暴。<br>如果有30个按钮，每个业务逻辑不同，都需要埋这个点(假设打点信息一致)。<br>我们30个函数里面，都要手动写这个方法的话，这也太坑爹了吧。<br>主要是与业务代码严重耦合，哪天不小心动了点其他内容，手抖误删了，就gg了。<br>后续维护的时候，简直噩梦。<br>仔细看一下，这不就是符合AOP的使用前提吗，那么试试AOP吧。   </p>\n<h3 id=\"关注点划分\"><a href=\"#关注点划分\" class=\"headerlink\" title=\"关注点划分\"></a>关注点划分</h3><p>根据前面提的，可以划分下关注点。  </p>\n<table>\n<thead>\n<tr>\n<th>主关注点</th>\n<th>侧关注点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>业务逻辑(doSomething)</td>\n<td>埋点信息 logger</td>\n</tr>\n</tbody>\n</table>\n<p>前面提到AOP关注的是步骤具体到例子来说其实就是插入logger的步骤。<br>插入时机无非时业务逻辑执行之前或者之后的阶段。<br>具体实现起来也不那么困难   </p>\n<h3 id=\"实现思路\"><a href=\"#实现思路\" class=\"headerlink\" title=\"实现思路\"></a>实现思路</h3><p>具体到js来说，由于语言本身的特性，天生就具有运行时动态插入逻辑的能力。<br>重点在于在原函数上增加其他功能并不改变函数本身。  </p>\n<p>毕竟函数可以接受一切形式的参数，当然函数也不例外了。<br>当传入一个函数的时候，我们要对其操作的余地就很大了，<br>保存原函数，然后利用后续参数加上call或apply，就可以达到我们的目的。<br>此外为了给函数都增加一个属性，我们在原型上操作就行了。 </p>\n<h4 id=\"经典before或者after的实现\"><a href=\"#经典before或者after的实现\" class=\"headerlink\" title=\"经典before或者after的实现\"></a>经典before或者after的实现</h4><p>网上太多类似实现了，直接看代码好了：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// action 即为我们的侧关注点，即logger</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.after = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//保留当前函数，这里this指向运行函数即clickHandler</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> func = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// return 被包装过的函数，这里就可以执行其他功能了。</span></span><br><span class=\"line\">    <span class=\"comment\">// 并且该方法挂在Function.prototype上，</span></span><br><span class=\"line\">    <span class=\"comment\">// 被返回的函数依然具有after属性,可以链式调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 原函数执行，这里不考虑异步</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> result = func.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 执行之后的操作</span></span><br><span class=\"line\">        action.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"comment\">// 将执行结果返回</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// before 实现类似，只不过执行顺序差别而已</span></span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.before = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> func = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        action.apply(<span class=\"keyword\">this</span>,<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> func.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>那么我们使用AOP改造之后的代码就如下了:<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> doSomething = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'doSomething'</span>)</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"keyword\">let</span> clickHandler = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// n行代码 </span></span><br><span class=\"line\">   doSomething() </span><br><span class=\"line\">   <span class=\"comment\">//n 行代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">clickHandler = clickHandler.before(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">     logger(<span class=\"string\">'doSomething之前'</span>)</span><br><span class=\"line\">&#125;).after(<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">     logger(<span class=\"string\">'doSomething之后'</span>)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">clickHandler() <span class=\"comment\">// 执行结果和预期一致</span></span><br></pre></td></tr></table></figure></p>\n<p>到这里就实现了面向切面编程，我们的业务逻辑里面只管业务本身，侧关注点通过这种方式来动态引入，与主逻辑解耦，更加纯净、易于维护。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>到这里，简单的AOP就介绍完成了。利用这种模式结合我们js本身的特性，可以尝试更多的可能。<br>例如我们react中常见的HOC、es7的装饰者模式、HOF等，很多时候不得不感叹大牛们思想的精髓，会让我们有种顿悟的感觉。本文抛砖引玉，共同学习啦，对自己是总结和提高，更希望能帮助到需要的小伙伴。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">更多文章请移步我的博客</a></p>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://www.alloyteam.com/2013/08/yong-aop-gai-shan-javascript-dai-ma/\" target=\"_blank\" rel=\"noopener\">AllyTeam - 用AOP改善javascript代码</a><br><a href=\"https://juejin.im/entry/5a12443951882512a860e93c\" target=\"_blank\" rel=\"noopener\">深入浅出 Javascript Decorators 和 AOP 编程</a> </p>"},{"title":"关于CORS 应该注意的几点","date":"2019-07-01T16:00:00.000Z","_content":"  \n## 前言\n对于跨域，随着w3c的CORS的出现，相比较于有些年头的jsonp，CORS以其简单安全，支持post的优势越来越收到大家的欢迎。具体如何CORS的原理和实现，[直接推荐阮老师的文章](http://www.ruanyifeng.com/blog/2016/04/cors.html),十分详细。本文主要关注CORS实现过程中的几个疑惑点。\n<!-- more -->\n## 预检请求\n### 背景\n浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request)。\n#### 简单请求\n同时满足一下条件的即是简单请求：\n\n1. 请求方法是以下三种方法之一：\nHEAD、GET、POST\n2. HTTP的头信息不超出以下几种字段\nAccept\nAccept-Language\nContent-Language\nLast-Event-ID\nContent-Type：只限于三个值application/x-www-form、multipart/form-data、text/plain\n#### 非简单请求\n显然，不同时满足则为非简单请求(可以认为是复杂请求)。两者的差别在于复杂请求在与服务端交互时多了一次options的预检请求，毕竟复杂请求一般就是HTTP请求头信息超出限制或者method为put、delete等操作行为，处于安全考虑，需要服务端先行验证来决定是否给予相关权限。  \n\n如下所示（示例来自阮老师文章）:\n\n```js\nvar url = 'http://api.alice.com/cors';\nvar xhr = new XMLHttpRequest();\n// PUT method为复杂请求，要预检\nxhr.open('PUT', url, true);\nxhr.setRequestHeader('X-Custom-Header', 'value');\nxhr.send();\n```  \n非简单请求，浏览器自动发送otpios的预检请求，请求头如下：\n\n```js\nOPTIONS /cors HTTP/1.1\n// 请求源\nOrigin: http://api.bob.com\n// 必须字段，指明正式cors请求将会使用那些method\nAccess-Control-Request-Method: PUT\n// 除简单头之外，额外的请求头\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n```\n\n对于预检信息，服务端一般做了如下操作：\n\n1、检查origin、Access-Control-Request-Method和Access-Control-Request-Headers等字段，确认是否允许跨域，如果允许跨域作出回应： \n\n```js\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\n// 允许的源 \nAccess-Control-Allow-Origin: http://api.bob.com\n// 允许的请求方式\nAccess-Control-Allow-Methods: GET, POST, PUT\n// 允许额外header\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n```\n\n如果不允许跨域，依然响应该请求，不过不携带CORS相关的信息。浏览器则会认为服务器不允许跨域，触发错误。\n\n```js\n// 常见的跨域错误\nXMLHttpRequest cannot load http://api.alice.com.\nOrigin http://api.bob.com is not allowed by Access-Control-Allow-Origin.\n```\n\n到这里一个流程结束，不过我们要关注的是options 预检请求之后 code 返回的问题\n### options 成功之后，返回code 200 还是 204\n\n常规预检的就是对于options的请求直接返回code 200的响应，表示校验通过。\n但是前两天发现有的返回为code204。两者之间的差别具体在哪呢。\n\n#### 常见用法\n\n1、针对特定接口支持CORS时，在代码里加判断对于options返回200\n\n```java\n// 随便找了段java代码 \nif (req.getMethod().equals(\"OPTIONS\")) {\n     res.setStatus(200);\n }\n```\n\n2、如果整个域名都支持CORS，可以再nginx侧直接配置，此时常见的是返回204.\n\n```shell\nif ($request_method = 'OPTIONS') { \n    add_header Access-Control-Allow-Origin *; \n    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;\n    #****省略...\n    return 204; \n}\n```\n#### 总结\n两者之间的差别，首先可以参考下204和200 对应的含义（下面内容摘自MDN）。\n**200**\n请求成功，成功的具体含义依据http method 的不同而有所差别。：\n* GET: 资源已经被提取并在消息中文中传递\n* POST: 描述动作结果的资源在消息体中传输\n\n**204**\n服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。\n客户端是浏览器的haul，用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。\n\n简单总结，204返回表示请求成功，并且无消息体，优势在于节省网络请求。\n\n#### 具体到options请求，选用哪一个。\n贴切的来说，应该像其他options请求一样为预检optiosn请求返回相同的code状态码，相关规范不要求或者推荐其他内容。  \n**fecth请求**\n例如对于[Fetch 规范](https://fetch.spec.whatwg.org/) 要求CORS协议的status可以为200-209里面的任意值。  \n\n```json\nIf a CORS check for request and response returns success \nand response’s status is an ok status, \nrun these substeps.\n```\n如果response为一个okstatus就可以继续执行\n\n```json\nAn ok status is any status in the range 200 to 299, inclusive.\n```\n并不要求具体哪一个值。\n所以从fetch来看，两者均可选择。  \n  \n**HTTP 1.1**\n对于http/1.1 规范来说，有一章节专门定义了各种响应code。对于[2开头的2-XXcode](https://tools.ietf.org/html/rfc7231#section-6.3),分别描述如下：\n\n* **200**\n请求成功，成功的具体含义依据http method 的不同而有所差别。\n* GET: 资源已经被提取并在消息中文中传递\n* POST: 描述动作结果的资源在消息体中传输\n* OPTIONS:  communications options成功的表示\n由上可知，对于options预检请求的响应，需要包含下面两种情况：\n1、表明请求成功\n2、描述通信选项（这里包括， Access-Control-Allow-Methods 和 Access-Control-Allow-Headers这些响应头）\n看起来，上面就是200在http定义中的含义，显然满足，但是如果继续看204的含义，好像也可以满足需求。\n\n**204**\n服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。\n客户端是浏览器的话，用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。\n\n#### 结论\n首先两者都可以使用，对于200，从定义而言更符合场景和定义。但是204无消息体，优势在于节省网络请求。  \n至于用哪个，大家自行做下判断。\n  \n\n### 跨域 读取cookie\n作为常见的场景，cookie一般会存放一些，鉴权会话等信息。对于CORS跨域，默认的是不包含cookie的。\n\n```js\nA cross-origin request by default does not bring any credentials (cookies or HTTP authentication)\n```\n如果要操作cookie需要分别从服务端和客户端两个场景来看。  \n\n#### 客户端 request 携带cookie\n\nrequest如果要携带cookie，需要特定参数指明。可能看到过这个参数为credentials或者withCredentials，什么时候用两者呢。主要跟请求的实现有关：\n\n1. **Fetch 使用credentials**\n    直接使用原生Fetch的话，需要设置credentials。  \n    \n    credentials 是Request接口的只读属性，用于表示用户代理是否应该在跨域请求的情况下从其他域发送cookies。这与XHR的withCredentials 标志相似，不同的是有三个可选值（后者是两个）：  \n    \n* omit: 从不发送cookies.\n* same-origin: 只有当URL与响应脚本同源才发送 cookies、 HTTP Basic authentication 等验证信息.(浏览器默认值,在旧版本浏览器，例如safari 11依旧是omit，safari 12已更改)\n* include: 不论是不是跨域的请求,总是发送请求资源域在本地的 cookies、 HTTP Basic authentication 等验证信息.\n\nCORS跨域的时候，只需要如下设置：  \n\n```js\nfetch('http://another.com', {\n  credentials: \"include\"\n});\n```\n2.   **XHR 使用withCredentials**\n\n基于XMLHttpRequest实现的请求使用withCredentials来允许携带cookie。  \n该属性为boolean类型，所以只有true/false两个取值，默认为false。  \n这样也很好理解，默认不携带是处于安全考虑。  \n使用如下\n\n```js\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'http://example.com/', true);\nxhr.withCredentials = true;\nxhr.send(null);\n```\n\n适用框架：jquery的ajax，axios等。\n\n#### 服务端 Access-Control-Allow-Credentials  \n\n当客户端设置了允许携带cookie之后，并不能完成该操作，毕竟是跨域，服务端也需要做响应设置，否则浏览器拿不到正确响应。\n\n```js\nAccess-Control-Allow-Credentials:true\n```\n看MDN 的解释：  \n \n```js\n\nThe Access-Control-Allow-Credentials response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (Request.credentials) is \"include\".  \n```\n\n当 credentials为include的时候，通知浏览器是否将响应暴露给前端jscode，如果为false，js不能读取响应自然请求报错。\n只有Access-Control-Allow-Credentials为true时，才会将响应暴露给客户端。\n当作为预检请求响应头时，表明该实际请求(即后面的真正请求)是否可以使用credentials。  \n   \n不过对于简单请求，因为没有预检，如果服务端没有正确响应，浏览器会忽略该属性，并不会直接报错。  \n需要与XMLHttpRequest.withCredentials属性或者Fetch 的credentials 配合使用。   \n\n\n#### 注意\n如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。  \n同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传。  \n且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。   \n\n毕竟cookie是有path来保证封闭性的，如果可以随便读取不管从安全还是性能上都是一种隐患。  \n\n### 多域名跨域\n\n对于多域名跨域，方法比较多。  \n\n#### 1、Access-Control-Allow-Origin：*  \n允许任意域名跨域，显然支持多域名。不过从安全性和cookie的使用的角度来看并不推荐。  \n#### 2、动态匹配域名\n这种实现方式比较多，原理就是声明允许的多域名配置，可以是数组或者是正则，根据当前请求的域名，来判断是否在适用返回内，在的话则设置Access-Control-Allow-Origin为当前域名。\n\n具体实现这里就不写了。  \n\n### 结束语\n#### 参考文章\n[http://www.ruanyifeng.com/blog/2016/04/cors.html](http://www.ruanyifeng.com/blog/2016/04/cors.html)   \n[https://fetch.spec.whatwg.org/#cors-protocol-and-credentials](https://fetch.spec.whatwg.org/#cors-protocol-and-credentials)   \n[http://www.yunweipai.com/archives/9381.html](http://www.yunweipai.com/archives/9381.html)   \n以上是在工作中偶然发现的几点疑惑，解决之后深究了下具体原理。希望能对其他同学有所帮助，抛砖引玉，一起努力。\n\n\n","source":"_posts/CORS.md","raw":"---\ntitle: 关于CORS 应该注意的几点\ndate: 2019-07-02\n---\n  \n## 前言\n对于跨域，随着w3c的CORS的出现，相比较于有些年头的jsonp，CORS以其简单安全，支持post的优势越来越收到大家的欢迎。具体如何CORS的原理和实现，[直接推荐阮老师的文章](http://www.ruanyifeng.com/blog/2016/04/cors.html),十分详细。本文主要关注CORS实现过程中的几个疑惑点。\n<!-- more -->\n## 预检请求\n### 背景\n浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request)。\n#### 简单请求\n同时满足一下条件的即是简单请求：\n\n1. 请求方法是以下三种方法之一：\nHEAD、GET、POST\n2. HTTP的头信息不超出以下几种字段\nAccept\nAccept-Language\nContent-Language\nLast-Event-ID\nContent-Type：只限于三个值application/x-www-form、multipart/form-data、text/plain\n#### 非简单请求\n显然，不同时满足则为非简单请求(可以认为是复杂请求)。两者的差别在于复杂请求在与服务端交互时多了一次options的预检请求，毕竟复杂请求一般就是HTTP请求头信息超出限制或者method为put、delete等操作行为，处于安全考虑，需要服务端先行验证来决定是否给予相关权限。  \n\n如下所示（示例来自阮老师文章）:\n\n```js\nvar url = 'http://api.alice.com/cors';\nvar xhr = new XMLHttpRequest();\n// PUT method为复杂请求，要预检\nxhr.open('PUT', url, true);\nxhr.setRequestHeader('X-Custom-Header', 'value');\nxhr.send();\n```  \n非简单请求，浏览器自动发送otpios的预检请求，请求头如下：\n\n```js\nOPTIONS /cors HTTP/1.1\n// 请求源\nOrigin: http://api.bob.com\n// 必须字段，指明正式cors请求将会使用那些method\nAccess-Control-Request-Method: PUT\n// 除简单头之外，额外的请求头\nAccess-Control-Request-Headers: X-Custom-Header\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n```\n\n对于预检信息，服务端一般做了如下操作：\n\n1、检查origin、Access-Control-Request-Method和Access-Control-Request-Headers等字段，确认是否允许跨域，如果允许跨域作出回应： \n\n```js\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\n// 允许的源 \nAccess-Control-Allow-Origin: http://api.bob.com\n// 允许的请求方式\nAccess-Control-Allow-Methods: GET, POST, PUT\n// 允许额外header\nAccess-Control-Allow-Headers: X-Custom-Header\nContent-Type: text/html; charset=utf-8\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n```\n\n如果不允许跨域，依然响应该请求，不过不携带CORS相关的信息。浏览器则会认为服务器不允许跨域，触发错误。\n\n```js\n// 常见的跨域错误\nXMLHttpRequest cannot load http://api.alice.com.\nOrigin http://api.bob.com is not allowed by Access-Control-Allow-Origin.\n```\n\n到这里一个流程结束，不过我们要关注的是options 预检请求之后 code 返回的问题\n### options 成功之后，返回code 200 还是 204\n\n常规预检的就是对于options的请求直接返回code 200的响应，表示校验通过。\n但是前两天发现有的返回为code204。两者之间的差别具体在哪呢。\n\n#### 常见用法\n\n1、针对特定接口支持CORS时，在代码里加判断对于options返回200\n\n```java\n// 随便找了段java代码 \nif (req.getMethod().equals(\"OPTIONS\")) {\n     res.setStatus(200);\n }\n```\n\n2、如果整个域名都支持CORS，可以再nginx侧直接配置，此时常见的是返回204.\n\n```shell\nif ($request_method = 'OPTIONS') { \n    add_header Access-Control-Allow-Origin *; \n    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;\n    #****省略...\n    return 204; \n}\n```\n#### 总结\n两者之间的差别，首先可以参考下204和200 对应的含义（下面内容摘自MDN）。\n**200**\n请求成功，成功的具体含义依据http method 的不同而有所差别。：\n* GET: 资源已经被提取并在消息中文中传递\n* POST: 描述动作结果的资源在消息体中传输\n\n**204**\n服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。\n客户端是浏览器的haul，用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。\n\n简单总结，204返回表示请求成功，并且无消息体，优势在于节省网络请求。\n\n#### 具体到options请求，选用哪一个。\n贴切的来说，应该像其他options请求一样为预检optiosn请求返回相同的code状态码，相关规范不要求或者推荐其他内容。  \n**fecth请求**\n例如对于[Fetch 规范](https://fetch.spec.whatwg.org/) 要求CORS协议的status可以为200-209里面的任意值。  \n\n```json\nIf a CORS check for request and response returns success \nand response’s status is an ok status, \nrun these substeps.\n```\n如果response为一个okstatus就可以继续执行\n\n```json\nAn ok status is any status in the range 200 to 299, inclusive.\n```\n并不要求具体哪一个值。\n所以从fetch来看，两者均可选择。  \n  \n**HTTP 1.1**\n对于http/1.1 规范来说，有一章节专门定义了各种响应code。对于[2开头的2-XXcode](https://tools.ietf.org/html/rfc7231#section-6.3),分别描述如下：\n\n* **200**\n请求成功，成功的具体含义依据http method 的不同而有所差别。\n* GET: 资源已经被提取并在消息中文中传递\n* POST: 描述动作结果的资源在消息体中传输\n* OPTIONS:  communications options成功的表示\n由上可知，对于options预检请求的响应，需要包含下面两种情况：\n1、表明请求成功\n2、描述通信选项（这里包括， Access-Control-Allow-Methods 和 Access-Control-Allow-Headers这些响应头）\n看起来，上面就是200在http定义中的含义，显然满足，但是如果继续看204的含义，好像也可以满足需求。\n\n**204**\n服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。\n客户端是浏览器的话，用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。\n\n#### 结论\n首先两者都可以使用，对于200，从定义而言更符合场景和定义。但是204无消息体，优势在于节省网络请求。  \n至于用哪个，大家自行做下判断。\n  \n\n### 跨域 读取cookie\n作为常见的场景，cookie一般会存放一些，鉴权会话等信息。对于CORS跨域，默认的是不包含cookie的。\n\n```js\nA cross-origin request by default does not bring any credentials (cookies or HTTP authentication)\n```\n如果要操作cookie需要分别从服务端和客户端两个场景来看。  \n\n#### 客户端 request 携带cookie\n\nrequest如果要携带cookie，需要特定参数指明。可能看到过这个参数为credentials或者withCredentials，什么时候用两者呢。主要跟请求的实现有关：\n\n1. **Fetch 使用credentials**\n    直接使用原生Fetch的话，需要设置credentials。  \n    \n    credentials 是Request接口的只读属性，用于表示用户代理是否应该在跨域请求的情况下从其他域发送cookies。这与XHR的withCredentials 标志相似，不同的是有三个可选值（后者是两个）：  \n    \n* omit: 从不发送cookies.\n* same-origin: 只有当URL与响应脚本同源才发送 cookies、 HTTP Basic authentication 等验证信息.(浏览器默认值,在旧版本浏览器，例如safari 11依旧是omit，safari 12已更改)\n* include: 不论是不是跨域的请求,总是发送请求资源域在本地的 cookies、 HTTP Basic authentication 等验证信息.\n\nCORS跨域的时候，只需要如下设置：  \n\n```js\nfetch('http://another.com', {\n  credentials: \"include\"\n});\n```\n2.   **XHR 使用withCredentials**\n\n基于XMLHttpRequest实现的请求使用withCredentials来允许携带cookie。  \n该属性为boolean类型，所以只有true/false两个取值，默认为false。  \n这样也很好理解，默认不携带是处于安全考虑。  \n使用如下\n\n```js\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'http://example.com/', true);\nxhr.withCredentials = true;\nxhr.send(null);\n```\n\n适用框架：jquery的ajax，axios等。\n\n#### 服务端 Access-Control-Allow-Credentials  \n\n当客户端设置了允许携带cookie之后，并不能完成该操作，毕竟是跨域，服务端也需要做响应设置，否则浏览器拿不到正确响应。\n\n```js\nAccess-Control-Allow-Credentials:true\n```\n看MDN 的解释：  \n \n```js\n\nThe Access-Control-Allow-Credentials response header tells browsers whether to expose the response to frontend JavaScript code when the request's credentials mode (Request.credentials) is \"include\".  \n```\n\n当 credentials为include的时候，通知浏览器是否将响应暴露给前端jscode，如果为false，js不能读取响应自然请求报错。\n只有Access-Control-Allow-Credentials为true时，才会将响应暴露给客户端。\n当作为预检请求响应头时，表明该实际请求(即后面的真正请求)是否可以使用credentials。  \n   \n不过对于简单请求，因为没有预检，如果服务端没有正确响应，浏览器会忽略该属性，并不会直接报错。  \n需要与XMLHttpRequest.withCredentials属性或者Fetch 的credentials 配合使用。   \n\n\n#### 注意\n如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。  \n同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传。  \n且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。   \n\n毕竟cookie是有path来保证封闭性的，如果可以随便读取不管从安全还是性能上都是一种隐患。  \n\n### 多域名跨域\n\n对于多域名跨域，方法比较多。  \n\n#### 1、Access-Control-Allow-Origin：*  \n允许任意域名跨域，显然支持多域名。不过从安全性和cookie的使用的角度来看并不推荐。  \n#### 2、动态匹配域名\n这种实现方式比较多，原理就是声明允许的多域名配置，可以是数组或者是正则，根据当前请求的域名，来判断是否在适用返回内，在的话则设置Access-Control-Allow-Origin为当前域名。\n\n具体实现这里就不写了。  \n\n### 结束语\n#### 参考文章\n[http://www.ruanyifeng.com/blog/2016/04/cors.html](http://www.ruanyifeng.com/blog/2016/04/cors.html)   \n[https://fetch.spec.whatwg.org/#cors-protocol-and-credentials](https://fetch.spec.whatwg.org/#cors-protocol-and-credentials)   \n[http://www.yunweipai.com/archives/9381.html](http://www.yunweipai.com/archives/9381.html)   \n以上是在工作中偶然发现的几点疑惑，解决之后深究了下具体原理。希望能对其他同学有所帮助，抛砖引玉，一起努力。\n\n\n","slug":"CORS","published":1,"updated":"2019-07-02T01:45:22.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt130002gw928nuvrdy7","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于跨域，随着w3c的CORS的出现，相比较于有些年头的jsonp，CORS以其简单安全，支持post的优势越来越收到大家的欢迎。具体如何CORS的原理和实现，<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">直接推荐阮老师的文章</a>,十分详细。本文主要关注CORS实现过程中的几个疑惑点。<br><a id=\"more\"></a></p>\n<h2 id=\"预检请求\"><a href=\"#预检请求\" class=\"headerlink\" title=\"预检请求\"></a>预检请求</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request)。</p>\n<h4 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h4><p>同时满足一下条件的即是简单请求：</p>\n<ol>\n<li>请求方法是以下三种方法之一：<br>HEAD、GET、POST</li>\n<li>HTTP的头信息不超出以下几种字段<br>Accept<br>Accept-Language<br>Content-Language<br>Last-Event-ID<br>Content-Type：只限于三个值application/x-www-form、multipart/form-data、text/plain<h4 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h4>显然，不同时满足则为非简单请求(可以认为是复杂请求)。两者的差别在于复杂请求在与服务端交互时多了一次options的预检请求，毕竟复杂请求一般就是HTTP请求头信息超出限制或者method为put、delete等操作行为，处于安全考虑，需要服务端先行验证来决定是否给予相关权限。  </li>\n</ol>\n<p>如下所示（示例来自阮老师文章）:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://api.alice.com/cors'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\"><span class=\"comment\">// PUT method为复杂请求，要预检</span></span><br><span class=\"line\">xhr.open(<span class=\"string\">'PUT'</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">'X-Custom-Header'</span>, <span class=\"string\">'value'</span>);</span><br><span class=\"line\">xhr.send();</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">非简单请求，浏览器自动发送otpios的预检请求，请求头如下：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">OPTIONS /cors HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"comment\">// 请求源</span></span><br><span class=\"line\">Origin: http:<span class=\"comment\">//api.bob.com</span></span><br><span class=\"line\"><span class=\"comment\">// 必须字段，指明正式cors请求将会使用那些method</span></span><br><span class=\"line\">Access-Control-Request-Method: PUT</span><br><span class=\"line\"><span class=\"comment\">// 除简单头之外，额外的请求头</span></span><br><span class=\"line\">Access-Control-Request-Headers: X-Custom-Header</span><br><span class=\"line\">Host: api.alice.com</span><br><span class=\"line\">Accept-Language: en-US</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">User-Agent: Mozilla/<span class=\"number\">5.0</span>...</span><br></pre></td></tr></table></figure>\n<p>对于预检信息，服务端一般做了如下操作：</p>\n<p>1、检查origin、Access-Control-Request-Method和Access-Control-Request-Headers等字段，确认是否允许跨域，如果允许跨域作出回应： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"built_in\">Date</span>: Mon, <span class=\"number\">01</span> Dec <span class=\"number\">2008</span> <span class=\"number\">01</span>:<span class=\"number\">15</span>:<span class=\"number\">39</span> GMT</span><br><span class=\"line\">Server: Apache/<span class=\"number\">2.0</span><span class=\"number\">.61</span> (Unix)</span><br><span class=\"line\"><span class=\"comment\">// 允许的源 </span></span><br><span class=\"line\">Access-Control-Allow-Origin: http:<span class=\"comment\">//api.bob.com</span></span><br><span class=\"line\"><span class=\"comment\">// 允许的请求方式</span></span><br><span class=\"line\">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class=\"line\"><span class=\"comment\">// 允许额外header</span></span><br><span class=\"line\">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class=\"line\">Content-Type: text/html; charset=utf<span class=\"number\">-8</span></span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: <span class=\"number\">0</span></span><br><span class=\"line\">Keep-Alive: timeout=<span class=\"number\">2</span>, max=<span class=\"number\">100</span></span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Type: text/plain</span><br></pre></td></tr></table></figure>\n<p>如果不允许跨域，依然响应该请求，不过不携带CORS相关的信息。浏览器则会认为服务器不允许跨域，触发错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 常见的跨域错误</span></span><br><span class=\"line\">XMLHttpRequest cannot load http:<span class=\"comment\">//api.alice.com.</span></span><br><span class=\"line\">Origin http:<span class=\"comment\">//api.bob.com is not allowed by Access-Control-Allow-Origin.</span></span><br></pre></td></tr></table></figure>\n<p>到这里一个流程结束，不过我们要关注的是options 预检请求之后 code 返回的问题</p>\n<h3 id=\"options-成功之后，返回code-200-还是-204\"><a href=\"#options-成功之后，返回code-200-还是-204\" class=\"headerlink\" title=\"options 成功之后，返回code 200 还是 204\"></a>options 成功之后，返回code 200 还是 204</h3><p>常规预检的就是对于options的请求直接返回code 200的响应，表示校验通过。<br>但是前两天发现有的返回为code204。两者之间的差别具体在哪呢。</p>\n<h4 id=\"常见用法\"><a href=\"#常见用法\" class=\"headerlink\" title=\"常见用法\"></a>常见用法</h4><p>1、针对特定接口支持CORS时，在代码里加判断对于options返回200</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 随便找了段java代码 </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (req.getMethod().equals(<span class=\"string\">\"OPTIONS\"</span>)) &#123;</span><br><span class=\"line\">     res.setStatus(<span class=\"number\">200</span>);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>2、如果整个域名都支持CORS，可以再nginx侧直接配置，此时常见的是返回204.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ($request_method = 'OPTIONS') &#123; </span><br><span class=\"line\">    add_header Access-Control-Allow-Origin *; </span><br><span class=\"line\">    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;</span><br><span class=\"line\">    #****省略...</span><br><span class=\"line\">    return 204; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>两者之间的差别，首先可以参考下204和200 对应的含义（下面内容摘自MDN）。<br><strong>200</strong><br>请求成功，成功的具体含义依据http method 的不同而有所差别。：</p>\n<ul>\n<li>GET: 资源已经被提取并在消息中文中传递</li>\n<li>POST: 描述动作结果的资源在消息体中传输</li>\n</ul>\n<p><strong>204</strong><br>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。<br>客户端是浏览器的haul，用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p>\n<p>简单总结，204返回表示请求成功，并且无消息体，优势在于节省网络请求。</p>\n<h4 id=\"具体到options请求，选用哪一个。\"><a href=\"#具体到options请求，选用哪一个。\" class=\"headerlink\" title=\"具体到options请求，选用哪一个。\"></a>具体到options请求，选用哪一个。</h4><p>贴切的来说，应该像其他options请求一样为预检optiosn请求返回相同的code状态码，相关规范不要求或者推荐其他内容。<br><strong>fecth请求</strong><br>例如对于<a href=\"https://fetch.spec.whatwg.org/\" target=\"_blank\" rel=\"noopener\">Fetch 规范</a> 要求CORS协议的status可以为200-209里面的任意值。  </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If a CORS check for request and response returns success </span><br><span class=\"line\">and response’s status is an ok status, </span><br><span class=\"line\">run these substeps.</span><br></pre></td></tr></table></figure>\n<p>如果response为一个okstatus就可以继续执行</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">An ok status is any status in the range 200 to 299, inclusive.</span><br></pre></td></tr></table></figure>\n<p>并不要求具体哪一个值。<br>所以从fetch来看，两者均可选择。  </p>\n<p><strong>HTTP 1.1</strong><br>对于http/1.1 规范来说，有一章节专门定义了各种响应code。对于<a href=\"https://tools.ietf.org/html/rfc7231#section-6.3\" target=\"_blank\" rel=\"noopener\">2开头的2-XXcode</a>,分别描述如下：</p>\n<ul>\n<li><strong>200</strong><br>请求成功，成功的具体含义依据http method 的不同而有所差别。</li>\n<li>GET: 资源已经被提取并在消息中文中传递</li>\n<li>POST: 描述动作结果的资源在消息体中传输</li>\n<li>OPTIONS:  communications options成功的表示<br>由上可知，对于options预检请求的响应，需要包含下面两种情况：<br>1、表明请求成功<br>2、描述通信选项（这里包括， Access-Control-Allow-Methods 和 Access-Control-Allow-Headers这些响应头）<br>看起来，上面就是200在http定义中的含义，显然满足，但是如果继续看204的含义，好像也可以满足需求。</li>\n</ul>\n<p><strong>204</strong><br>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。<br>客户端是浏览器的话，用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>首先两者都可以使用，对于200，从定义而言更符合场景和定义。但是204无消息体，优势在于节省网络请求。<br>至于用哪个，大家自行做下判断。</p>\n<h3 id=\"跨域-读取cookie\"><a href=\"#跨域-读取cookie\" class=\"headerlink\" title=\"跨域 读取cookie\"></a>跨域 读取cookie</h3><p>作为常见的场景，cookie一般会存放一些，鉴权会话等信息。对于CORS跨域，默认的是不包含cookie的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A cross-origin request by <span class=\"keyword\">default</span> does not bring any credentials (cookies or HTTP authentication)</span><br></pre></td></tr></table></figure>\n<p>如果要操作cookie需要分别从服务端和客户端两个场景来看。  </p>\n<h4 id=\"客户端-request-携带cookie\"><a href=\"#客户端-request-携带cookie\" class=\"headerlink\" title=\"客户端 request 携带cookie\"></a>客户端 request 携带cookie</h4><p>request如果要携带cookie，需要特定参数指明。可能看到过这个参数为credentials或者withCredentials，什么时候用两者呢。主要跟请求的实现有关：</p>\n<ol>\n<li><p><strong>Fetch 使用credentials</strong><br> 直接使用原生Fetch的话，需要设置credentials。  </p>\n<p> credentials 是Request接口的只读属性，用于表示用户代理是否应该在跨域请求的情况下从其他域发送cookies。这与XHR的withCredentials 标志相似，不同的是有三个可选值（后者是两个）：  </p>\n</li>\n</ol>\n<ul>\n<li>omit: 从不发送cookies.</li>\n<li>same-origin: 只有当URL与响应脚本同源才发送 cookies、 HTTP Basic authentication 等验证信息.(浏览器默认值,在旧版本浏览器，例如safari 11依旧是omit，safari 12已更改)</li>\n<li>include: 不论是不是跨域的请求,总是发送请求资源域在本地的 cookies、 HTTP Basic authentication 等验证信息.</li>\n</ul>\n<p>CORS跨域的时候，只需要如下设置：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'http://another.com'</span>, &#123;</span><br><span class=\"line\">  credentials: <span class=\"string\">\"include\"</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><strong>XHR 使用withCredentials</strong></li>\n</ol>\n<p>基于XMLHttpRequest实现的请求使用withCredentials来允许携带cookie。<br>该属性为boolean类型，所以只有true/false两个取值，默认为false。<br>这样也很好理解，默认不携带是处于安全考虑。<br>使用如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">'GET'</span>, <span class=\"string\">'http://example.com/'</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">xhr.withCredentials = <span class=\"literal\">true</span>;</span><br><span class=\"line\">xhr.send(<span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>适用框架：jquery的ajax，axios等。</p>\n<h4 id=\"服务端-Access-Control-Allow-Credentials\"><a href=\"#服务端-Access-Control-Allow-Credentials\" class=\"headerlink\" title=\"服务端 Access-Control-Allow-Credentials\"></a>服务端 Access-Control-Allow-Credentials</h4><p>当客户端设置了允许携带cookie之后，并不能完成该操作，毕竟是跨域，服务端也需要做响应设置，否则浏览器拿不到正确响应。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Credentials:<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>看MDN 的解释：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">The Access-Control-Allow-Credentials response header tells browsers whether to expose the response to frontend JavaScript code when the request<span class=\"string\">'s credentials mode (Request.credentials) is \"include\".</span></span><br></pre></td></tr></table></figure>\n<p>当 credentials为include的时候，通知浏览器是否将响应暴露给前端jscode，如果为false，js不能读取响应自然请求报错。<br>只有Access-Control-Allow-Credentials为true时，才会将响应暴露给客户端。<br>当作为预检请求响应头时，表明该实际请求(即后面的真正请求)是否可以使用credentials。  </p>\n<p>不过对于简单请求，因为没有预检，如果服务端没有正确响应，浏览器会忽略该属性，并不会直接报错。<br>需要与XMLHttpRequest.withCredentials属性或者Fetch 的credentials 配合使用。   </p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。<br>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传。<br>且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。   </p>\n<p>毕竟cookie是有path来保证封闭性的，如果可以随便读取不管从安全还是性能上都是一种隐患。  </p>\n<h3 id=\"多域名跨域\"><a href=\"#多域名跨域\" class=\"headerlink\" title=\"多域名跨域\"></a>多域名跨域</h3><p>对于多域名跨域，方法比较多。  </p>\n<h4 id=\"1、Access-Control-Allow-Origin：\"><a href=\"#1、Access-Control-Allow-Origin：\" class=\"headerlink\" title=\"1、Access-Control-Allow-Origin：*\"></a>1、Access-Control-Allow-Origin：*</h4><p>允许任意域名跨域，显然支持多域名。不过从安全性和cookie的使用的角度来看并不推荐。  </p>\n<h4 id=\"2、动态匹配域名\"><a href=\"#2、动态匹配域名\" class=\"headerlink\" title=\"2、动态匹配域名\"></a>2、动态匹配域名</h4><p>这种实现方式比较多，原理就是声明允许的多域名配置，可以是数组或者是正则，根据当前请求的域名，来判断是否在适用返回内，在的话则设置Access-Control-Allow-Origin为当前域名。</p>\n<p>具体实现这里就不写了。  </p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/04/cors.html</a><br><a href=\"https://fetch.spec.whatwg.org/#cors-protocol-and-credentials\" target=\"_blank\" rel=\"noopener\">https://fetch.spec.whatwg.org/#cors-protocol-and-credentials</a><br><a href=\"http://www.yunweipai.com/archives/9381.html\" target=\"_blank\" rel=\"noopener\">http://www.yunweipai.com/archives/9381.html</a><br>以上是在工作中偶然发现的几点疑惑，解决之后深究了下具体原理。希望能对其他同学有所帮助，抛砖引玉，一起努力。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于跨域，随着w3c的CORS的出现，相比较于有些年头的jsonp，CORS以其简单安全，支持post的优势越来越收到大家的欢迎。具体如何CORS的原理和实现，<a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">直接推荐阮老师的文章</a>,十分详细。本文主要关注CORS实现过程中的几个疑惑点。<br>","more":"</p>\n<h2 id=\"预检请求\"><a href=\"#预检请求\" class=\"headerlink\" title=\"预检请求\"></a>预检请求</h2><h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request)。</p>\n<h4 id=\"简单请求\"><a href=\"#简单请求\" class=\"headerlink\" title=\"简单请求\"></a>简单请求</h4><p>同时满足一下条件的即是简单请求：</p>\n<ol>\n<li>请求方法是以下三种方法之一：<br>HEAD、GET、POST</li>\n<li>HTTP的头信息不超出以下几种字段<br>Accept<br>Accept-Language<br>Content-Language<br>Last-Event-ID<br>Content-Type：只限于三个值application/x-www-form、multipart/form-data、text/plain<h4 id=\"非简单请求\"><a href=\"#非简单请求\" class=\"headerlink\" title=\"非简单请求\"></a>非简单请求</h4>显然，不同时满足则为非简单请求(可以认为是复杂请求)。两者的差别在于复杂请求在与服务端交互时多了一次options的预检请求，毕竟复杂请求一般就是HTTP请求头信息超出限制或者method为put、delete等操作行为，处于安全考虑，需要服务端先行验证来决定是否给予相关权限。  </li>\n</ol>\n<p>如下所示（示例来自阮老师文章）:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://api.alice.com/cors'</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\"><span class=\"comment\">// PUT method为复杂请求，要预检</span></span><br><span class=\"line\">xhr.open(<span class=\"string\">'PUT'</span>, url, <span class=\"literal\">true</span>);</span><br><span class=\"line\">xhr.setRequestHeader(<span class=\"string\">'X-Custom-Header'</span>, <span class=\"string\">'value'</span>);</span><br><span class=\"line\">xhr.send();</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">非简单请求，浏览器自动发送otpios的预检请求，请求头如下：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">OPTIONS /cors HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\"><span class=\"comment\">// 请求源</span></span><br><span class=\"line\">Origin: http:<span class=\"comment\">//api.bob.com</span></span><br><span class=\"line\"><span class=\"comment\">// 必须字段，指明正式cors请求将会使用那些method</span></span><br><span class=\"line\">Access-Control-Request-Method: PUT</span><br><span class=\"line\"><span class=\"comment\">// 除简单头之外，额外的请求头</span></span><br><span class=\"line\">Access-Control-Request-Headers: X-Custom-Header</span><br><span class=\"line\">Host: api.alice.com</span><br><span class=\"line\">Accept-Language: en-US</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">User-Agent: Mozilla/<span class=\"number\">5.0</span>...</span><br></pre></td></tr></table></figure>\n<p>对于预检信息，服务端一般做了如下操作：</p>\n<p>1、检查origin、Access-Control-Request-Method和Access-Control-Request-Headers等字段，确认是否允许跨域，如果允许跨域作出回应： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/<span class=\"number\">1.1</span> <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"built_in\">Date</span>: Mon, <span class=\"number\">01</span> Dec <span class=\"number\">2008</span> <span class=\"number\">01</span>:<span class=\"number\">15</span>:<span class=\"number\">39</span> GMT</span><br><span class=\"line\">Server: Apache/<span class=\"number\">2.0</span><span class=\"number\">.61</span> (Unix)</span><br><span class=\"line\"><span class=\"comment\">// 允许的源 </span></span><br><span class=\"line\">Access-Control-Allow-Origin: http:<span class=\"comment\">//api.bob.com</span></span><br><span class=\"line\"><span class=\"comment\">// 允许的请求方式</span></span><br><span class=\"line\">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class=\"line\"><span class=\"comment\">// 允许额外header</span></span><br><span class=\"line\">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class=\"line\">Content-Type: text/html; charset=utf<span class=\"number\">-8</span></span><br><span class=\"line\">Content-Encoding: gzip</span><br><span class=\"line\">Content-Length: <span class=\"number\">0</span></span><br><span class=\"line\">Keep-Alive: timeout=<span class=\"number\">2</span>, max=<span class=\"number\">100</span></span><br><span class=\"line\">Connection: Keep-Alive</span><br><span class=\"line\">Content-Type: text/plain</span><br></pre></td></tr></table></figure>\n<p>如果不允许跨域，依然响应该请求，不过不携带CORS相关的信息。浏览器则会认为服务器不允许跨域，触发错误。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 常见的跨域错误</span></span><br><span class=\"line\">XMLHttpRequest cannot load http:<span class=\"comment\">//api.alice.com.</span></span><br><span class=\"line\">Origin http:<span class=\"comment\">//api.bob.com is not allowed by Access-Control-Allow-Origin.</span></span><br></pre></td></tr></table></figure>\n<p>到这里一个流程结束，不过我们要关注的是options 预检请求之后 code 返回的问题</p>\n<h3 id=\"options-成功之后，返回code-200-还是-204\"><a href=\"#options-成功之后，返回code-200-还是-204\" class=\"headerlink\" title=\"options 成功之后，返回code 200 还是 204\"></a>options 成功之后，返回code 200 还是 204</h3><p>常规预检的就是对于options的请求直接返回code 200的响应，表示校验通过。<br>但是前两天发现有的返回为code204。两者之间的差别具体在哪呢。</p>\n<h4 id=\"常见用法\"><a href=\"#常见用法\" class=\"headerlink\" title=\"常见用法\"></a>常见用法</h4><p>1、针对特定接口支持CORS时，在代码里加判断对于options返回200</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 随便找了段java代码 </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (req.getMethod().equals(<span class=\"string\">\"OPTIONS\"</span>)) &#123;</span><br><span class=\"line\">     res.setStatus(<span class=\"number\">200</span>);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>2、如果整个域名都支持CORS，可以再nginx侧直接配置，此时常见的是返回204.</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if ($request_method = 'OPTIONS') &#123; </span><br><span class=\"line\">    add_header Access-Control-Allow-Origin *; </span><br><span class=\"line\">    add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;</span><br><span class=\"line\">    #****省略...</span><br><span class=\"line\">    return 204; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>两者之间的差别，首先可以参考下204和200 对应的含义（下面内容摘自MDN）。<br><strong>200</strong><br>请求成功，成功的具体含义依据http method 的不同而有所差别。：</p>\n<ul>\n<li>GET: 资源已经被提取并在消息中文中传递</li>\n<li>POST: 描述动作结果的资源在消息体中传输</li>\n</ul>\n<p><strong>204</strong><br>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。<br>客户端是浏览器的haul，用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p>\n<p>简单总结，204返回表示请求成功，并且无消息体，优势在于节省网络请求。</p>\n<h4 id=\"具体到options请求，选用哪一个。\"><a href=\"#具体到options请求，选用哪一个。\" class=\"headerlink\" title=\"具体到options请求，选用哪一个。\"></a>具体到options请求，选用哪一个。</h4><p>贴切的来说，应该像其他options请求一样为预检optiosn请求返回相同的code状态码，相关规范不要求或者推荐其他内容。<br><strong>fecth请求</strong><br>例如对于<a href=\"https://fetch.spec.whatwg.org/\" target=\"_blank\" rel=\"noopener\">Fetch 规范</a> 要求CORS协议的status可以为200-209里面的任意值。  </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">If a CORS check for request and response returns success </span><br><span class=\"line\">and response’s status is an ok status, </span><br><span class=\"line\">run these substeps.</span><br></pre></td></tr></table></figure>\n<p>如果response为一个okstatus就可以继续执行</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">An ok status is any status in the range 200 to 299, inclusive.</span><br></pre></td></tr></table></figure>\n<p>并不要求具体哪一个值。<br>所以从fetch来看，两者均可选择。  </p>\n<p><strong>HTTP 1.1</strong><br>对于http/1.1 规范来说，有一章节专门定义了各种响应code。对于<a href=\"https://tools.ietf.org/html/rfc7231#section-6.3\" target=\"_blank\" rel=\"noopener\">2开头的2-XXcode</a>,分别描述如下：</p>\n<ul>\n<li><strong>200</strong><br>请求成功，成功的具体含义依据http method 的不同而有所差别。</li>\n<li>GET: 资源已经被提取并在消息中文中传递</li>\n<li>POST: 描述动作结果的资源在消息体中传输</li>\n<li>OPTIONS:  communications options成功的表示<br>由上可知，对于options预检请求的响应，需要包含下面两种情况：<br>1、表明请求成功<br>2、描述通信选项（这里包括， Access-Control-Allow-Methods 和 Access-Control-Allow-Headers这些响应头）<br>看起来，上面就是200在http定义中的含义，显然满足，但是如果继续看204的含义，好像也可以满足需求。</li>\n</ul>\n<p><strong>204</strong><br>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。<br>客户端是浏览器的话，用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><p>首先两者都可以使用，对于200，从定义而言更符合场景和定义。但是204无消息体，优势在于节省网络请求。<br>至于用哪个，大家自行做下判断。</p>\n<h3 id=\"跨域-读取cookie\"><a href=\"#跨域-读取cookie\" class=\"headerlink\" title=\"跨域 读取cookie\"></a>跨域 读取cookie</h3><p>作为常见的场景，cookie一般会存放一些，鉴权会话等信息。对于CORS跨域，默认的是不包含cookie的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A cross-origin request by <span class=\"keyword\">default</span> does not bring any credentials (cookies or HTTP authentication)</span><br></pre></td></tr></table></figure>\n<p>如果要操作cookie需要分别从服务端和客户端两个场景来看。  </p>\n<h4 id=\"客户端-request-携带cookie\"><a href=\"#客户端-request-携带cookie\" class=\"headerlink\" title=\"客户端 request 携带cookie\"></a>客户端 request 携带cookie</h4><p>request如果要携带cookie，需要特定参数指明。可能看到过这个参数为credentials或者withCredentials，什么时候用两者呢。主要跟请求的实现有关：</p>\n<ol>\n<li><p><strong>Fetch 使用credentials</strong><br> 直接使用原生Fetch的话，需要设置credentials。  </p>\n<p> credentials 是Request接口的只读属性，用于表示用户代理是否应该在跨域请求的情况下从其他域发送cookies。这与XHR的withCredentials 标志相似，不同的是有三个可选值（后者是两个）：  </p>\n</li>\n</ol>\n<ul>\n<li>omit: 从不发送cookies.</li>\n<li>same-origin: 只有当URL与响应脚本同源才发送 cookies、 HTTP Basic authentication 等验证信息.(浏览器默认值,在旧版本浏览器，例如safari 11依旧是omit，safari 12已更改)</li>\n<li>include: 不论是不是跨域的请求,总是发送请求资源域在本地的 cookies、 HTTP Basic authentication 等验证信息.</li>\n</ul>\n<p>CORS跨域的时候，只需要如下设置：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetch(<span class=\"string\">'http://another.com'</span>, &#123;</span><br><span class=\"line\">  credentials: <span class=\"string\">\"include\"</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li><strong>XHR 使用withCredentials</strong></li>\n</ol>\n<p>基于XMLHttpRequest实现的请求使用withCredentials来允许携带cookie。<br>该属性为boolean类型，所以只有true/false两个取值，默认为false。<br>这样也很好理解，默认不携带是处于安全考虑。<br>使用如下</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest();</span><br><span class=\"line\">xhr.open(<span class=\"string\">'GET'</span>, <span class=\"string\">'http://example.com/'</span>, <span class=\"literal\">true</span>);</span><br><span class=\"line\">xhr.withCredentials = <span class=\"literal\">true</span>;</span><br><span class=\"line\">xhr.send(<span class=\"literal\">null</span>);</span><br></pre></td></tr></table></figure>\n<p>适用框架：jquery的ajax，axios等。</p>\n<h4 id=\"服务端-Access-Control-Allow-Credentials\"><a href=\"#服务端-Access-Control-Allow-Credentials\" class=\"headerlink\" title=\"服务端 Access-Control-Allow-Credentials\"></a>服务端 Access-Control-Allow-Credentials</h4><p>当客户端设置了允许携带cookie之后，并不能完成该操作，毕竟是跨域，服务端也需要做响应设置，否则浏览器拿不到正确响应。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access-Control-Allow-Credentials:<span class=\"literal\">true</span></span><br></pre></td></tr></table></figure>\n<p>看MDN 的解释：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">The Access-Control-Allow-Credentials response header tells browsers whether to expose the response to frontend JavaScript code when the request<span class=\"string\">'s credentials mode (Request.credentials) is \"include\".</span></span><br></pre></td></tr></table></figure>\n<p>当 credentials为include的时候，通知浏览器是否将响应暴露给前端jscode，如果为false，js不能读取响应自然请求报错。<br>只有Access-Control-Allow-Credentials为true时，才会将响应暴露给客户端。<br>当作为预检请求响应头时，表明该实际请求(即后面的真正请求)是否可以使用credentials。  </p>\n<p>不过对于简单请求，因为没有预检，如果服务端没有正确响应，浏览器会忽略该属性，并不会直接报错。<br>需要与XMLHttpRequest.withCredentials属性或者Fetch 的credentials 配合使用。   </p>\n<h4 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h4><p>如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。<br>同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传。<br>且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。   </p>\n<p>毕竟cookie是有path来保证封闭性的，如果可以随便读取不管从安全还是性能上都是一种隐患。  </p>\n<h3 id=\"多域名跨域\"><a href=\"#多域名跨域\" class=\"headerlink\" title=\"多域名跨域\"></a>多域名跨域</h3><p>对于多域名跨域，方法比较多。  </p>\n<h4 id=\"1、Access-Control-Allow-Origin：\"><a href=\"#1、Access-Control-Allow-Origin：\" class=\"headerlink\" title=\"1、Access-Control-Allow-Origin：*\"></a>1、Access-Control-Allow-Origin：*</h4><p>允许任意域名跨域，显然支持多域名。不过从安全性和cookie的使用的角度来看并不推荐。  </p>\n<h4 id=\"2、动态匹配域名\"><a href=\"#2、动态匹配域名\" class=\"headerlink\" title=\"2、动态匹配域名\"></a>2、动态匹配域名</h4><p>这种实现方式比较多，原理就是声明允许的多域名配置，可以是数组或者是正则，根据当前请求的域名，来判断是否在适用返回内，在的话则设置Access-Control-Allow-Origin为当前域名。</p>\n<p>具体实现这里就不写了。  </p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2016/04/cors.html</a><br><a href=\"https://fetch.spec.whatwg.org/#cors-protocol-and-credentials\" target=\"_blank\" rel=\"noopener\">https://fetch.spec.whatwg.org/#cors-protocol-and-credentials</a><br><a href=\"http://www.yunweipai.com/archives/9381.html\" target=\"_blank\" rel=\"noopener\">http://www.yunweipai.com/archives/9381.html</a><br>以上是在工作中偶然发现的几点疑惑，解决之后深究了下具体原理。希望能对其他同学有所帮助，抛砖引玉，一起努力。</p>"},{"title":"编写一个babel插件","date":"2018-06-01T00:00:29.000Z","_content":"## 前言 \n对于前端开发而言，babel肯定是再熟悉不过了，工作中肯定会用到。除了用作转换es6和jsx的工具之外，个人感觉babel基于抽象语法树的插件机制，给我们提供了更多的可能。关于babel相关概念和插件文档，网上是有很多的，讲的挺不错的。详细的解析推荐官方的[babel插件手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-asts)。在开发插件之前，有些内容还是要了解一下的，已经熟悉的大佬们可以直接跳过。\n<!-- more -->\n## 抽象语法树（AST）\n\nBabel 使用一个基于 ESTree 并修改过的 AST，它的内核说明文档可以在[这里](https://github. com/babel/babel/blob/master/doc/ast/spec. md)找到。\n直接看实例应该更清晰：  \n\n```js \nfunction square(n) {\n  return n * n;\n}\n```\n对应的AST对象(babel提供的对象格式)\n```js\n{\n  //代码块类别，函数声明\n  type: \"FunctionDeclaration\",\n  //变量标识\n  id: {\n    type: \"Identifier\",\n    //变量名称\n    name: \"square\"\n  },\n  //参数\n  params: [{\n    type: \"Identifier\",\n    name: \"n\"\n  }],\n  //函数体\n  body: {\n     //块语句\n    type: \"BlockStatement\",\n    body: [{\n       //return 语句\n      type: \"ReturnStatement\",\n      argument: {\n        //二元表达式\n        type: \"BinaryExpression\",\n        //操作符\n        operator: \"*\",\n        left: {\n          type: \"Identifier\",\n          name: \"n\"\n        },\n        right: {\n          type: \"Identifier\",\n          name: \"n\"\n        }\n      }\n    }]\n  }\n}\n```\n大概就是上面这个层级关系，每一层都被称为节点（Node),一个完整AST对应的js对象可能会有很多节点，视具体情况而定。babel将每个节点都作为一个接口返回。其中包括的属性就如上面代码所示，例如type，start，end，loc等通用属性和具体type对应的私有属性。我们后面插件的处理也是根据不同的type来处理的。  \n  \n看到这个庞大的js对象，不要感到头疼，如果说让我们每次都自己去分析AST和按照babel的定义去记住不同类型，显然不现实。这种事情应该交给电脑来执行，我们可以利用[AST Explorer ](http://astexplorer.net/#/Z1exs6BWMq)来将目标代码转成语法树对象，结合[ AST node types](https://github.com/babel/babylon/blob/master/ast/spec.md#variabledeclarator)来查看具体属性。   \n\n## Babel 的处理步骤\nBabel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）,具体过程就不想详细描述了，直接看官方手册就好。  \n需要注意的是，babel插件就是在转换过程中起作用的，即将解析完成的语法树对象按照自己的目的进行处理，然后再进行代码生成步骤。所以要深入了解转换相关的内容。  \n\n代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps），以便于调试。\n\n代码生成的原理：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。转换的时候是是进行递归的树形遍历。\n\n## 转换 \n### Visitor\n转换的时候，是插件开始起作用的时候，但是如何进入到这个过程呢，babel给我们提供了一个Visitor的规范。我们可以通过Visitor来定义我们的访问逻辑。大概就是下面这个样子\n```js\nconst MyVisitor = {\n  //这里对应上面node的type，所有type为Identifier的节点都会进入该方法中\n  Identifier() {\n    console.log(\"Called!\");\n  }\n};\n//以该方法为例 \nfunction square(n) {\n  return n * n;\n} \n//会调用四次，因为\n//函数名square\n//形参 n\n//函数体中的两个n，都是Identifier\npath.traverse(MyVisitor); \n//  所以输出四个\nCalled!\nCalled!\nCalled!\nCalled!\n```\n因为深度优先的遍历算法，到一个叶子节点之后，发现没有子孙节点，需要向上溯源才能回到上一级继续遍历下个子节点，所以每个节点都会被访问两次。  \n如果不指定的话，调用都发生在进入节点时，当然也可以在退出时调用访问者方法。\n```js   \nconst MyVisitor = {\n  Identifier: {\n    enter() {\n      console.log(\"Entered!\");\n    },\n    exit() {\n      console.log(\"Exited!\");\n    }\n  }\n}; \n```\n此外还有一些小技巧：  \n\n可以在方法名用|来匹配多种不同的type，使用相同的处理函数。\n```js\nconst MyVisitor = {\n  \"ExportNamedDeclaration|Flow\"(path) {}\n};\n```\n此外可以在访问者中使用别名(如babel-types定义)\n例如Function是FunctionDeclaration，FunctionExpression，ArrowFunctionExpression，ObjectMethod和ObjectMethod的别名,可以用它来匹配上述所有类型的type  \n\n```js  \nconst MyVisitor = {\n  Function(path) {}\n};\n```\n### Paths\nAST 通常会有许多节点，那么节点直接如何相互关联呢？ 我们可以使用一个可操作和访问的巨大可变对象表示节点之间的关联关系，或者也可以用Paths（路径）来简化这件事情。Path 是表示两个节点之间连接的对象。直接看例子比较清晰一点。  \n\n```js  \n\n{\n  type: \"FunctionDeclaration\",\n  id: {\n    type: \"Identifier\",\n    name: \"square\"\n  },\n  ...\n}\n\n\n```\n\n将子节点 Identifier 表示为一个路径（Path）的话，看起来是这样的：  \n\n```js\n{\n  \"parent\": {\n    \"type\": \"FunctionDeclaration\",\n    \"id\": {...},\n    ....\n  },\n  \"node\": {\n    \"type\": \"Identifier\",\n    \"name\": \"square\"\n  }\n}\n```\n当你通过一个 Identifier() 成员方法的访问者时，你实际上是在访问路径而非节点。 通过这种方式，你操作的就是节点的响应式表示（译注：即路径）而非节点本身。  \n\n## 编写插件\n\n前面都是些必备知识点，本文只是将一些相对重要一点的知识点提了一下。详细的还是要去看开发手册的。\n个人而言开发插件的话应该有下面三个步骤：   \n \n1. 分析源文件抽象语法树AST\n2. 分析目标文件抽象语法树\n3. 构建Visitor   \n   3.1 确定访问条件  \n   3.2 确定转换逻辑    \n   \n插件主要的就是3步骤，但是前两步是十分重要的。3.1和3.2分别依赖于1和2的结果。只有清晰了解AST结构之后，才能有的放矢，事半功倍。\n举个例子，如下代码：    \n\n```js \nvar func = ()=>{\n    console.log(this.b)\n}; \n```\n目的是将箭头函数转换成普通函数声明(这里仅仅是具体这种格式的转化，其他部分就先不涉及)。如下:  \n\n```js  \nvar _this = this;\nvar func = function () {\n    console.log(_this.b);\n};\n```\n\n### 源文件语法树   \n \n这里分析下这个简单的函数声明，按照上面定义分析，不过这里还是推荐[AST Explorer ](http://astexplorer.net/#/Z1exs6BWMq)可以清晰的看到我们的语法树。这里只截取有用信息：  \n\n```js\n        \"init\": {\n              \"type\": \"ArrowFunctionExpression\",\n              /*...其他信息....*/\n              \"id\": null,\n              //形参\n              \"params\": [],\n              \"body\": {\n                //函数体,this部分\n                \"arguments\": [\n                        {\n                          \"type\": \"MemberExpression\",\n                          \"object\": {\n                             //this 表达式\n                            \"type\": \"ThisExpression\",\n                          },\n                          \"property\": {\n                             //b属性\n                            \"type\": \"Identifier\",\n                            \"name\": \"b\"\n                          }\n                        }\n                      ]\n             }\n        }\n```\n我们要转换的只是ArrowFunctionExpression即箭头函数和this表达式ThisExpression部分，其他暂时不动。  \n那么我们的visitor里的函数名称就包括ArrowFunctionExpression和ThisExpression了。  \n  \n```js  \n//visitor里面方法的key就对应我们要处理的node  type\nconst visitor = {\n    //处理this表达式  \n    ThisExpression(path){\n        //将this转换成_this的形式\n    },\n    //处理箭头函数。\n    ArrowFunctionExpression(path){\n       //转换成普通的FunctionExpression\n    }\n}   \n```\n### 目标文件语法树   \n  \n同样的方法，语法树对象如下：  \n语法树太长，我们就看一下变化的地方好了  \n \n```js\n    //转换之后的body由两个元素的数组，两个变量声明是统计关系\n    \"body\": [\n      //var _this = this;结构\n      {\n        \"type\": \"VariableDeclaration\",\n        \"kind\": \"var\",\n        \"declarations\": [\n          {\n            \"type\": \"VariableDeclarator\",\n            //left为_this的标识\n            \"id\": {\n              \"type\": \"Identifier\",\n              \"name\": \"_this\"\n            },\n            //right为this表达式\n            \"init\": {\n              \"type\": \"ThisExpression\"\n              /***其他**/\n            }\n      },   \n      // var func = function (b) {\n      //      console.log(_this.b);\n      //  };结构 只看关键的\n      {\n        \"type\": \"VariableDeclaration\",\n        \"kind\": \"var\",\n        \"declarations\": [\n          {\n            /*****省略*******/\n            \"arguments\": [\n                        {\n                          \"type\": \"MemberExpression\",\n                          //转换之后的_this.b\n                          \"object\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"_this\"\n                          },\n                          \"property\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"b\"\n                          }\n                          ]\n          }\n      }\n    ]\n```\n经过对比，确定我们的操作应该是将ArrowFunctionExpression替换为FunctionExpression，遇到有this表达式的，绑定一下this，并将其转换。 \n进行替换增加等操作时就要用到path提供的api了：  \n   \n* replaceWith(targetObj) 替换  \n* findParent() 查找满足条件的父节点  \n* insertBefore 插入兄弟节点   \n更多请查询文档，这里只列出我们用到的方法。\n  \n### 构造节点   \n \n这里将这个操作单独拿出来，toFunctionExpression这个api的说明我始终没找到。。。。可能是我没找对地方[FunctionExpression](https://github.com/babel/babylon/blob/master/ast/spec.md#functiondeclaration)，没办法我去babel源码里找了一遍：    \n\n```js\n//@src  /babel/packages/babel-types/src/definitions/core.js\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  //....\n}\n//又找到 FunctionDeclaration\ndefineType(\"FunctionDeclaration\", {\n  //这里才看到参数: id,params,body..\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"]\n  //....  \n}\n\n```\n这样的话才知道入参，如果有清晰的文档，请大家不吝赐教。下面就简单了。\n### 后来又专门找了一下，终于找到对应文档了[传送门](https://babeljs.io/docs/core-packages/babel-types/)  \n   \n### 完善Visitor\n \n```js  \nconst Visitor = {\n    //this表达式\n    ThisExpression(path){\n        //构建var _this = this\n        let node = t.VariableDeclaration(\n            'var',\n            [\n                t.VariableDeclarator(\n                    t.Identifier('_this'),\n                    t.Identifier('this')\n                )\n            ]\n        ),\n        //构建 _this标识符\n        str = t.Identifier('_this'),\n        //查找变量声明的父节点\n        //这里只是针对例子的，真正转换需要考虑的情况很多\n        parentPath = path.findParent((path) => path.isVariableDeclaration())\n        //满足条件\n        if(parentPath){\n            //插入\n            parentPath.insertBefore(node)\n            path.replaceWith(\n                str\n            )\n        }else{\n            return\n        }\n    },\n    //处理箭头函数。\n    ArrowFunctionExpression(path){\n        var node = path.node\n        //构造一个t.FunctionExpression节点，将原有path替换掉即可\n        path.replaceWith(t.FunctionExpression(\n            node.id,\n            node.params,\n            node.body\n          ))\n    }\n}     \n```    \n\n主体visitor至此算结束了，当然如果是插件的话   \n \n```js   \n//babel调用插件时会将babel-types作为参数传入 \nexport default function({ types: t }) {\n  return {\n    visitor:Visitor\n  }\n```  \n在本地调试的话，可以分别引入babel-core和babel-types  \n\n```js\nvar babel = require('babel-core');\nvar t = require('babel-types');\nvar code = `var func = ()=>{\n    console.log(this.b)\n  };`\nconst result = babel.transform(code, {\n\tplugins: [{\n\t  //前面的Visitor\n\t\tvisitor: Visitor\n\t}]\n});  \n//输出转换之后的code\n/**\n * var _this = this;\n * var func = function () {\n * console.log(_this.b);\n * }; \n */\nconsole.log(result.code);  \n```     \n\n### 更新说明\n对于构造新的语法内容时，除了上面使用t.VariableDeclaration这种费劲的表达式之外可以借助babel-template实现。\n用法参考\n```js\nconst buildRequire = template(`\n  var IMPORT_NAME = require(SOURCE);\n`);\n\nconst ast = buildRequire({\n  IMPORT_NAME: t.identifier(\"myModule\"),\n  SOURCE: t.stringLiteral(\"my-module\"),\n});\n```\n新版本可 使用replaceWithSourceString\n\n```js\nFunctionDeclaration(path) {\n  path.replaceWithSourceString(`function add(a, b) {\n    return a + b;\n  }`);\n}\n```\n\n## 结束语  \n### 参考文章   \n[Babel 插件手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-replacing-a-node)   \n[Babel for ES6? And Beyond!](https://www.h5jun.com/post/babel-for-es6-and-beyond.html)   \n\n纸上得来终觉浅，原本也认为已经理解了babel的原理和插件机制，没想到连写个小demo都这么费劲。主要还是对相关api不熟悉，不知道如何去构建节点，熟练之后应该会好很多。此文是插件手册的一个简单总结，把自己实现的思路汇总了一下。抛砖引玉，共同进步，另外希望对有需要的同学略有帮助。[原文详见](https://github.com/xiaoxiangdaiyu/blog)\n\n\n\n\n","source":"_posts/babelplugin.md","raw":"---\ntitle: 编写一个babel插件\ndate: 2018-06-1 08:00:29\ntags:\n---\n## 前言 \n对于前端开发而言，babel肯定是再熟悉不过了，工作中肯定会用到。除了用作转换es6和jsx的工具之外，个人感觉babel基于抽象语法树的插件机制，给我们提供了更多的可能。关于babel相关概念和插件文档，网上是有很多的，讲的挺不错的。详细的解析推荐官方的[babel插件手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-asts)。在开发插件之前，有些内容还是要了解一下的，已经熟悉的大佬们可以直接跳过。\n<!-- more -->\n## 抽象语法树（AST）\n\nBabel 使用一个基于 ESTree 并修改过的 AST，它的内核说明文档可以在[这里](https://github. com/babel/babel/blob/master/doc/ast/spec. md)找到。\n直接看实例应该更清晰：  \n\n```js \nfunction square(n) {\n  return n * n;\n}\n```\n对应的AST对象(babel提供的对象格式)\n```js\n{\n  //代码块类别，函数声明\n  type: \"FunctionDeclaration\",\n  //变量标识\n  id: {\n    type: \"Identifier\",\n    //变量名称\n    name: \"square\"\n  },\n  //参数\n  params: [{\n    type: \"Identifier\",\n    name: \"n\"\n  }],\n  //函数体\n  body: {\n     //块语句\n    type: \"BlockStatement\",\n    body: [{\n       //return 语句\n      type: \"ReturnStatement\",\n      argument: {\n        //二元表达式\n        type: \"BinaryExpression\",\n        //操作符\n        operator: \"*\",\n        left: {\n          type: \"Identifier\",\n          name: \"n\"\n        },\n        right: {\n          type: \"Identifier\",\n          name: \"n\"\n        }\n      }\n    }]\n  }\n}\n```\n大概就是上面这个层级关系，每一层都被称为节点（Node),一个完整AST对应的js对象可能会有很多节点，视具体情况而定。babel将每个节点都作为一个接口返回。其中包括的属性就如上面代码所示，例如type，start，end，loc等通用属性和具体type对应的私有属性。我们后面插件的处理也是根据不同的type来处理的。  \n  \n看到这个庞大的js对象，不要感到头疼，如果说让我们每次都自己去分析AST和按照babel的定义去记住不同类型，显然不现实。这种事情应该交给电脑来执行，我们可以利用[AST Explorer ](http://astexplorer.net/#/Z1exs6BWMq)来将目标代码转成语法树对象，结合[ AST node types](https://github.com/babel/babylon/blob/master/ast/spec.md#variabledeclarator)来查看具体属性。   \n\n## Babel 的处理步骤\nBabel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）,具体过程就不想详细描述了，直接看官方手册就好。  \n需要注意的是，babel插件就是在转换过程中起作用的，即将解析完成的语法树对象按照自己的目的进行处理，然后再进行代码生成步骤。所以要深入了解转换相关的内容。  \n\n代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps），以便于调试。\n\n代码生成的原理：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。转换的时候是是进行递归的树形遍历。\n\n## 转换 \n### Visitor\n转换的时候，是插件开始起作用的时候，但是如何进入到这个过程呢，babel给我们提供了一个Visitor的规范。我们可以通过Visitor来定义我们的访问逻辑。大概就是下面这个样子\n```js\nconst MyVisitor = {\n  //这里对应上面node的type，所有type为Identifier的节点都会进入该方法中\n  Identifier() {\n    console.log(\"Called!\");\n  }\n};\n//以该方法为例 \nfunction square(n) {\n  return n * n;\n} \n//会调用四次，因为\n//函数名square\n//形参 n\n//函数体中的两个n，都是Identifier\npath.traverse(MyVisitor); \n//  所以输出四个\nCalled!\nCalled!\nCalled!\nCalled!\n```\n因为深度优先的遍历算法，到一个叶子节点之后，发现没有子孙节点，需要向上溯源才能回到上一级继续遍历下个子节点，所以每个节点都会被访问两次。  \n如果不指定的话，调用都发生在进入节点时，当然也可以在退出时调用访问者方法。\n```js   \nconst MyVisitor = {\n  Identifier: {\n    enter() {\n      console.log(\"Entered!\");\n    },\n    exit() {\n      console.log(\"Exited!\");\n    }\n  }\n}; \n```\n此外还有一些小技巧：  \n\n可以在方法名用|来匹配多种不同的type，使用相同的处理函数。\n```js\nconst MyVisitor = {\n  \"ExportNamedDeclaration|Flow\"(path) {}\n};\n```\n此外可以在访问者中使用别名(如babel-types定义)\n例如Function是FunctionDeclaration，FunctionExpression，ArrowFunctionExpression，ObjectMethod和ObjectMethod的别名,可以用它来匹配上述所有类型的type  \n\n```js  \nconst MyVisitor = {\n  Function(path) {}\n};\n```\n### Paths\nAST 通常会有许多节点，那么节点直接如何相互关联呢？ 我们可以使用一个可操作和访问的巨大可变对象表示节点之间的关联关系，或者也可以用Paths（路径）来简化这件事情。Path 是表示两个节点之间连接的对象。直接看例子比较清晰一点。  \n\n```js  \n\n{\n  type: \"FunctionDeclaration\",\n  id: {\n    type: \"Identifier\",\n    name: \"square\"\n  },\n  ...\n}\n\n\n```\n\n将子节点 Identifier 表示为一个路径（Path）的话，看起来是这样的：  \n\n```js\n{\n  \"parent\": {\n    \"type\": \"FunctionDeclaration\",\n    \"id\": {...},\n    ....\n  },\n  \"node\": {\n    \"type\": \"Identifier\",\n    \"name\": \"square\"\n  }\n}\n```\n当你通过一个 Identifier() 成员方法的访问者时，你实际上是在访问路径而非节点。 通过这种方式，你操作的就是节点的响应式表示（译注：即路径）而非节点本身。  \n\n## 编写插件\n\n前面都是些必备知识点，本文只是将一些相对重要一点的知识点提了一下。详细的还是要去看开发手册的。\n个人而言开发插件的话应该有下面三个步骤：   \n \n1. 分析源文件抽象语法树AST\n2. 分析目标文件抽象语法树\n3. 构建Visitor   \n   3.1 确定访问条件  \n   3.2 确定转换逻辑    \n   \n插件主要的就是3步骤，但是前两步是十分重要的。3.1和3.2分别依赖于1和2的结果。只有清晰了解AST结构之后，才能有的放矢，事半功倍。\n举个例子，如下代码：    \n\n```js \nvar func = ()=>{\n    console.log(this.b)\n}; \n```\n目的是将箭头函数转换成普通函数声明(这里仅仅是具体这种格式的转化，其他部分就先不涉及)。如下:  \n\n```js  \nvar _this = this;\nvar func = function () {\n    console.log(_this.b);\n};\n```\n\n### 源文件语法树   \n \n这里分析下这个简单的函数声明，按照上面定义分析，不过这里还是推荐[AST Explorer ](http://astexplorer.net/#/Z1exs6BWMq)可以清晰的看到我们的语法树。这里只截取有用信息：  \n\n```js\n        \"init\": {\n              \"type\": \"ArrowFunctionExpression\",\n              /*...其他信息....*/\n              \"id\": null,\n              //形参\n              \"params\": [],\n              \"body\": {\n                //函数体,this部分\n                \"arguments\": [\n                        {\n                          \"type\": \"MemberExpression\",\n                          \"object\": {\n                             //this 表达式\n                            \"type\": \"ThisExpression\",\n                          },\n                          \"property\": {\n                             //b属性\n                            \"type\": \"Identifier\",\n                            \"name\": \"b\"\n                          }\n                        }\n                      ]\n             }\n        }\n```\n我们要转换的只是ArrowFunctionExpression即箭头函数和this表达式ThisExpression部分，其他暂时不动。  \n那么我们的visitor里的函数名称就包括ArrowFunctionExpression和ThisExpression了。  \n  \n```js  \n//visitor里面方法的key就对应我们要处理的node  type\nconst visitor = {\n    //处理this表达式  \n    ThisExpression(path){\n        //将this转换成_this的形式\n    },\n    //处理箭头函数。\n    ArrowFunctionExpression(path){\n       //转换成普通的FunctionExpression\n    }\n}   \n```\n### 目标文件语法树   \n  \n同样的方法，语法树对象如下：  \n语法树太长，我们就看一下变化的地方好了  \n \n```js\n    //转换之后的body由两个元素的数组，两个变量声明是统计关系\n    \"body\": [\n      //var _this = this;结构\n      {\n        \"type\": \"VariableDeclaration\",\n        \"kind\": \"var\",\n        \"declarations\": [\n          {\n            \"type\": \"VariableDeclarator\",\n            //left为_this的标识\n            \"id\": {\n              \"type\": \"Identifier\",\n              \"name\": \"_this\"\n            },\n            //right为this表达式\n            \"init\": {\n              \"type\": \"ThisExpression\"\n              /***其他**/\n            }\n      },   \n      // var func = function (b) {\n      //      console.log(_this.b);\n      //  };结构 只看关键的\n      {\n        \"type\": \"VariableDeclaration\",\n        \"kind\": \"var\",\n        \"declarations\": [\n          {\n            /*****省略*******/\n            \"arguments\": [\n                        {\n                          \"type\": \"MemberExpression\",\n                          //转换之后的_this.b\n                          \"object\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"_this\"\n                          },\n                          \"property\": {\n                            \"type\": \"Identifier\",\n                            \"name\": \"b\"\n                          }\n                          ]\n          }\n      }\n    ]\n```\n经过对比，确定我们的操作应该是将ArrowFunctionExpression替换为FunctionExpression，遇到有this表达式的，绑定一下this，并将其转换。 \n进行替换增加等操作时就要用到path提供的api了：  \n   \n* replaceWith(targetObj) 替换  \n* findParent() 查找满足条件的父节点  \n* insertBefore 插入兄弟节点   \n更多请查询文档，这里只列出我们用到的方法。\n  \n### 构造节点   \n \n这里将这个操作单独拿出来，toFunctionExpression这个api的说明我始终没找到。。。。可能是我没找对地方[FunctionExpression](https://github.com/babel/babylon/blob/master/ast/spec.md#functiondeclaration)，没办法我去babel源码里找了一遍：    \n\n```js\n//@src  /babel/packages/babel-types/src/definitions/core.js\ndefineType(\"FunctionExpression\", {\n  inherits: \"FunctionDeclaration\",\n  //....\n}\n//又找到 FunctionDeclaration\ndefineType(\"FunctionDeclaration\", {\n  //这里才看到参数: id,params,body..\n  builder: [\"id\", \"params\", \"body\", \"generator\", \"async\"],\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"]\n  //....  \n}\n\n```\n这样的话才知道入参，如果有清晰的文档，请大家不吝赐教。下面就简单了。\n### 后来又专门找了一下，终于找到对应文档了[传送门](https://babeljs.io/docs/core-packages/babel-types/)  \n   \n### 完善Visitor\n \n```js  \nconst Visitor = {\n    //this表达式\n    ThisExpression(path){\n        //构建var _this = this\n        let node = t.VariableDeclaration(\n            'var',\n            [\n                t.VariableDeclarator(\n                    t.Identifier('_this'),\n                    t.Identifier('this')\n                )\n            ]\n        ),\n        //构建 _this标识符\n        str = t.Identifier('_this'),\n        //查找变量声明的父节点\n        //这里只是针对例子的，真正转换需要考虑的情况很多\n        parentPath = path.findParent((path) => path.isVariableDeclaration())\n        //满足条件\n        if(parentPath){\n            //插入\n            parentPath.insertBefore(node)\n            path.replaceWith(\n                str\n            )\n        }else{\n            return\n        }\n    },\n    //处理箭头函数。\n    ArrowFunctionExpression(path){\n        var node = path.node\n        //构造一个t.FunctionExpression节点，将原有path替换掉即可\n        path.replaceWith(t.FunctionExpression(\n            node.id,\n            node.params,\n            node.body\n          ))\n    }\n}     \n```    \n\n主体visitor至此算结束了，当然如果是插件的话   \n \n```js   \n//babel调用插件时会将babel-types作为参数传入 \nexport default function({ types: t }) {\n  return {\n    visitor:Visitor\n  }\n```  \n在本地调试的话，可以分别引入babel-core和babel-types  \n\n```js\nvar babel = require('babel-core');\nvar t = require('babel-types');\nvar code = `var func = ()=>{\n    console.log(this.b)\n  };`\nconst result = babel.transform(code, {\n\tplugins: [{\n\t  //前面的Visitor\n\t\tvisitor: Visitor\n\t}]\n});  \n//输出转换之后的code\n/**\n * var _this = this;\n * var func = function () {\n * console.log(_this.b);\n * }; \n */\nconsole.log(result.code);  \n```     \n\n### 更新说明\n对于构造新的语法内容时，除了上面使用t.VariableDeclaration这种费劲的表达式之外可以借助babel-template实现。\n用法参考\n```js\nconst buildRequire = template(`\n  var IMPORT_NAME = require(SOURCE);\n`);\n\nconst ast = buildRequire({\n  IMPORT_NAME: t.identifier(\"myModule\"),\n  SOURCE: t.stringLiteral(\"my-module\"),\n});\n```\n新版本可 使用replaceWithSourceString\n\n```js\nFunctionDeclaration(path) {\n  path.replaceWithSourceString(`function add(a, b) {\n    return a + b;\n  }`);\n}\n```\n\n## 结束语  \n### 参考文章   \n[Babel 插件手册](https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-replacing-a-node)   \n[Babel for ES6? And Beyond!](https://www.h5jun.com/post/babel-for-es6-and-beyond.html)   \n\n纸上得来终觉浅，原本也认为已经理解了babel的原理和插件机制，没想到连写个小demo都这么费劲。主要还是对相关api不熟悉，不知道如何去构建节点，熟练之后应该会好很多。此文是插件手册的一个简单总结，把自己实现的思路汇总了一下。抛砖引玉，共同进步，另外希望对有需要的同学略有帮助。[原文详见](https://github.com/xiaoxiangdaiyu/blog)\n\n\n\n\n","slug":"babelplugin","published":1,"updated":"2019-09-23T09:08:25.446Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt160004gw929794145r","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于前端开发而言，babel肯定是再熟悉不过了，工作中肯定会用到。除了用作转换es6和jsx的工具之外，个人感觉babel基于抽象语法树的插件机制，给我们提供了更多的可能。关于babel相关概念和插件文档，网上是有很多的，讲的挺不错的。详细的解析推荐官方的<a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-asts\" target=\"_blank\" rel=\"noopener\">babel插件手册</a>。在开发插件之前，有些内容还是要了解一下的，已经熟悉的大佬们可以直接跳过。<br><a id=\"more\"></a></p>\n<h2 id=\"抽象语法树（AST）\"><a href=\"#抽象语法树（AST）\" class=\"headerlink\" title=\"抽象语法树（AST）\"></a>抽象语法树（AST）</h2><p>Babel 使用一个基于 ESTree 并修改过的 AST，它的内核说明文档可以在<a href=\"https://github. com/babel/babel/blob/master/doc/ast/spec. md\" target=\"_blank\" rel=\"noopener\">这里</a>找到。<br>直接看实例应该更清晰：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n * n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对应的AST对象(babel提供的对象格式)<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">//代码块类别，函数声明</span></span><br><span class=\"line\">  type: <span class=\"string\">\"FunctionDeclaration\"</span>,</span><br><span class=\"line\">  <span class=\"comment\">//变量标识</span></span><br><span class=\"line\">  id: &#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">//变量名称</span></span><br><span class=\"line\">    name: <span class=\"string\">\"square\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//参数</span></span><br><span class=\"line\">  params: [&#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">    name: <span class=\"string\">\"n\"</span></span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">  <span class=\"comment\">//函数体</span></span><br><span class=\"line\">  body: &#123;</span><br><span class=\"line\">     <span class=\"comment\">//块语句</span></span><br><span class=\"line\">    type: <span class=\"string\">\"BlockStatement\"</span>,</span><br><span class=\"line\">    body: [&#123;</span><br><span class=\"line\">       <span class=\"comment\">//return 语句</span></span><br><span class=\"line\">      type: <span class=\"string\">\"ReturnStatement\"</span>,</span><br><span class=\"line\">      argument: &#123;</span><br><span class=\"line\">        <span class=\"comment\">//二元表达式</span></span><br><span class=\"line\">        type: <span class=\"string\">\"BinaryExpression\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">//操作符</span></span><br><span class=\"line\">        operator: <span class=\"string\">\"*\"</span>,</span><br><span class=\"line\">        left: &#123;</span><br><span class=\"line\">          type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">          name: <span class=\"string\">\"n\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        right: &#123;</span><br><span class=\"line\">          type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">          name: <span class=\"string\">\"n\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大概就是上面这个层级关系，每一层都被称为节点（Node),一个完整AST对应的js对象可能会有很多节点，视具体情况而定。babel将每个节点都作为一个接口返回。其中包括的属性就如上面代码所示，例如type，start，end，loc等通用属性和具体type对应的私有属性。我们后面插件的处理也是根据不同的type来处理的。  </p>\n<p>看到这个庞大的js对象，不要感到头疼，如果说让我们每次都自己去分析AST和按照babel的定义去记住不同类型，显然不现实。这种事情应该交给电脑来执行，我们可以利用<a href=\"http://astexplorer.net/#/Z1exs6BWMq\" target=\"_blank\" rel=\"noopener\">AST Explorer </a>来将目标代码转成语法树对象，结合<a href=\"https://github.com/babel/babylon/blob/master/ast/spec.md#variabledeclarator\" target=\"_blank\" rel=\"noopener\"> AST node types</a>来查看具体属性。   </p>\n<h2 id=\"Babel-的处理步骤\"><a href=\"#Babel-的处理步骤\" class=\"headerlink\" title=\"Babel 的处理步骤\"></a>Babel 的处理步骤</h2><p>Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）,具体过程就不想详细描述了，直接看官方手册就好。<br>需要注意的是，babel插件就是在转换过程中起作用的，即将解析完成的语法树对象按照自己的目的进行处理，然后再进行代码生成步骤。所以要深入了解转换相关的内容。  </p>\n<p>代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps），以便于调试。</p>\n<p>代码生成的原理：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。转换的时候是是进行递归的树形遍历。</p>\n<h2 id=\"转换\"><a href=\"#转换\" class=\"headerlink\" title=\"转换\"></a>转换</h2><h3 id=\"Visitor\"><a href=\"#Visitor\" class=\"headerlink\" title=\"Visitor\"></a>Visitor</h3><p>转换的时候，是插件开始起作用的时候，但是如何进入到这个过程呢，babel给我们提供了一个Visitor的规范。我们可以通过Visitor来定义我们的访问逻辑。大概就是下面这个样子<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyVisitor = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里对应上面node的type，所有type为Identifier的节点都会进入该方法中</span></span><br><span class=\"line\">  Identifier() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Called!\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//以该方法为例 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n * n;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">//会调用四次，因为</span></span><br><span class=\"line\"><span class=\"comment\">//函数名square</span></span><br><span class=\"line\"><span class=\"comment\">//形参 n</span></span><br><span class=\"line\"><span class=\"comment\">//函数体中的两个n，都是Identifier</span></span><br><span class=\"line\">path.traverse(MyVisitor); </span><br><span class=\"line\"><span class=\"comment\">//  所以输出四个</span></span><br><span class=\"line\">Called!</span><br><span class=\"line\">Called!</span><br><span class=\"line\">Called!</span><br><span class=\"line\">Called!</span><br></pre></td></tr></table></figure></p>\n<p>因为深度优先的遍历算法，到一个叶子节点之后，发现没有子孙节点，需要向上溯源才能回到上一级继续遍历下个子节点，所以每个节点都会被访问两次。<br>如果不指定的话，调用都发生在进入节点时，当然也可以在退出时调用访问者方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyVisitor = &#123;</span><br><span class=\"line\">  Identifier: &#123;</span><br><span class=\"line\">    enter() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Entered!\"</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    exit() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Exited!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>此外还有一些小技巧：  </p>\n<p>可以在方法名用|来匹配多种不同的type，使用相同的处理函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyVisitor = &#123;</span><br><span class=\"line\">  <span class=\"string\">\"ExportNamedDeclaration|Flow\"</span>(path) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>此外可以在访问者中使用别名(如babel-types定义)<br>例如Function是FunctionDeclaration，FunctionExpression，ArrowFunctionExpression，ObjectMethod和ObjectMethod的别名,可以用它来匹配上述所有类型的type  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyVisitor = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span>(path) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Paths\"><a href=\"#Paths\" class=\"headerlink\" title=\"Paths\"></a>Paths</h3><p>AST 通常会有许多节点，那么节点直接如何相互关联呢？ 我们可以使用一个可操作和访问的巨大可变对象表示节点之间的关联关系，或者也可以用Paths（路径）来简化这件事情。Path 是表示两个节点之间连接的对象。直接看例子比较清晰一点。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">\"FunctionDeclaration\"</span>,</span><br><span class=\"line\">  id: &#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">    name: <span class=\"string\">\"square\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将子节点 Identifier 表示为一个路径（Path）的话，看起来是这样的：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"parent\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"FunctionDeclaration\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"id\"</span>: &#123;...&#125;,</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"node\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"square\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你通过一个 Identifier() 成员方法的访问者时，你实际上是在访问路径而非节点。 通过这种方式，你操作的就是节点的响应式表示（译注：即路径）而非节点本身。  </p>\n<h2 id=\"编写插件\"><a href=\"#编写插件\" class=\"headerlink\" title=\"编写插件\"></a>编写插件</h2><p>前面都是些必备知识点，本文只是将一些相对重要一点的知识点提了一下。详细的还是要去看开发手册的。<br>个人而言开发插件的话应该有下面三个步骤：   </p>\n<ol>\n<li>分析源文件抽象语法树AST</li>\n<li>分析目标文件抽象语法树</li>\n<li>构建Visitor<br>3.1 确定访问条件<br>3.2 确定转换逻辑    </li>\n</ol>\n<p>插件主要的就是3步骤，但是前两步是十分重要的。3.1和3.2分别依赖于1和2的结果。只有清晰了解AST结构之后，才能有的放矢，事半功倍。<br>举个例子，如下代码：    </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.b)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>目的是将箭头函数转换成普通函数声明(这里仅仅是具体这种格式的转化，其他部分就先不涉及)。如下:  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(_this.b);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"源文件语法树\"><a href=\"#源文件语法树\" class=\"headerlink\" title=\"源文件语法树\"></a>源文件语法树</h3><p>这里分析下这个简单的函数声明，按照上面定义分析，不过这里还是推荐<a href=\"http://astexplorer.net/#/Z1exs6BWMq\" target=\"_blank\" rel=\"noopener\">AST Explorer </a>可以清晰的看到我们的语法树。这里只截取有用信息：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"init\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"type\"</span>: <span class=\"string\">\"ArrowFunctionExpression\"</span>,</span><br><span class=\"line\">      <span class=\"comment\">/*...其他信息....*/</span></span><br><span class=\"line\">      <span class=\"string\">\"id\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      <span class=\"comment\">//形参</span></span><br><span class=\"line\">      <span class=\"string\">\"params\"</span>: [],</span><br><span class=\"line\">      <span class=\"string\">\"body\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">//函数体,this部分</span></span><br><span class=\"line\">        <span class=\"string\">\"arguments\"</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                  <span class=\"string\">\"type\"</span>: <span class=\"string\">\"MemberExpression\"</span>,</span><br><span class=\"line\">                  <span class=\"string\">\"object\"</span>: &#123;</span><br><span class=\"line\">                     <span class=\"comment\">//this 表达式</span></span><br><span class=\"line\">                    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"ThisExpression\"</span>,</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">\"property\"</span>: &#123;</span><br><span class=\"line\">                     <span class=\"comment\">//b属性</span></span><br><span class=\"line\">                    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              ]</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们要转换的只是ArrowFunctionExpression即箭头函数和this表达式ThisExpression部分，其他暂时不动。<br>那么我们的visitor里的函数名称就包括ArrowFunctionExpression和ThisExpression了。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//visitor里面方法的key就对应我们要处理的node  type</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> visitor = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//处理this表达式  </span></span><br><span class=\"line\">    ThisExpression(path)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将this转换成_this的形式</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//处理箭头函数。</span></span><br><span class=\"line\">    ArrowFunctionExpression(path)&#123;</span><br><span class=\"line\">       <span class=\"comment\">//转换成普通的FunctionExpression</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"目标文件语法树\"><a href=\"#目标文件语法树\" class=\"headerlink\" title=\"目标文件语法树\"></a>目标文件语法树</h3><p>同样的方法，语法树对象如下：<br>语法树太长，我们就看一下变化的地方好了  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//转换之后的body由两个元素的数组，两个变量声明是统计关系</span></span><br><span class=\"line\"><span class=\"string\">\"body\"</span>: [</span><br><span class=\"line\">  <span class=\"comment\">//var _this = this;结构</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"VariableDeclaration\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kind\"</span>: <span class=\"string\">\"var\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"declarations\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"VariableDeclarator\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">//left为_this的标识</span></span><br><span class=\"line\">        <span class=\"string\">\"id\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">\"type\"</span>: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"name\"</span>: <span class=\"string\">\"_this\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">//right为this表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"init\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">\"type\"</span>: <span class=\"string\">\"ThisExpression\"</span></span><br><span class=\"line\">          <span class=\"comment\">/***其他**/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;,   </span><br><span class=\"line\">  <span class=\"comment\">// var func = function (b) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//      console.log(_this.b);</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;;结构 只看关键的</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"VariableDeclaration\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kind\"</span>: <span class=\"string\">\"var\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"declarations\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*****省略*******/</span></span><br><span class=\"line\">        <span class=\"string\">\"arguments\"</span>: [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                      <span class=\"string\">\"type\"</span>: <span class=\"string\">\"MemberExpression\"</span>,</span><br><span class=\"line\">                      <span class=\"comment\">//转换之后的_this.b</span></span><br><span class=\"line\">                      <span class=\"string\">\"object\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"_this\"</span></span><br><span class=\"line\">                      &#125;,</span><br><span class=\"line\">                      <span class=\"string\">\"property\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                      ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>经过对比，确定我们的操作应该是将ArrowFunctionExpression替换为FunctionExpression，遇到有this表达式的，绑定一下this，并将其转换。<br>进行替换增加等操作时就要用到path提供的api了：  </p>\n<ul>\n<li>replaceWith(targetObj) 替换  </li>\n<li>findParent() 查找满足条件的父节点  </li>\n<li>insertBefore 插入兄弟节点<br>更多请查询文档，这里只列出我们用到的方法。</li>\n</ul>\n<h3 id=\"构造节点\"><a href=\"#构造节点\" class=\"headerlink\" title=\"构造节点\"></a>构造节点</h3><p>这里将这个操作单独拿出来，toFunctionExpression这个api的说明我始终没找到。。。。可能是我没找对地方<a href=\"https://github.com/babel/babylon/blob/master/ast/spec.md#functiondeclaration\" target=\"_blank\" rel=\"noopener\">FunctionExpression</a>，没办法我去babel源码里找了一遍：    </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@src  /babel/packages/babel-types/src/definitions/core.js</span></span><br><span class=\"line\">defineType(<span class=\"string\">\"FunctionExpression\"</span>, &#123;</span><br><span class=\"line\">  inherits: <span class=\"string\">\"FunctionDeclaration\"</span>,</span><br><span class=\"line\">  <span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//又找到 FunctionDeclaration</span></span><br><span class=\"line\">defineType(<span class=\"string\">\"FunctionDeclaration\"</span>, &#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里才看到参数: id,params,body..</span></span><br><span class=\"line\">  builder: [<span class=\"string\">\"id\"</span>, <span class=\"string\">\"params\"</span>, <span class=\"string\">\"body\"</span>, <span class=\"string\">\"generator\"</span>, <span class=\"string\">\"async\"</span>],</span><br><span class=\"line\">  visitor: [<span class=\"string\">\"id\"</span>, <span class=\"string\">\"params\"</span>, <span class=\"string\">\"body\"</span>, <span class=\"string\">\"returnType\"</span>, <span class=\"string\">\"typeParameters\"</span>]</span><br><span class=\"line\">  <span class=\"comment\">//....  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的话才知道入参，如果有清晰的文档，请大家不吝赐教。下面就简单了。</p>\n<h3 id=\"后来又专门找了一下，终于找到对应文档了传送门\"><a href=\"#后来又专门找了一下，终于找到对应文档了传送门\" class=\"headerlink\" title=\"后来又专门找了一下，终于找到对应文档了传送门\"></a>后来又专门找了一下，终于找到对应文档了<a href=\"https://babeljs.io/docs/core-packages/babel-types/\" target=\"_blank\" rel=\"noopener\">传送门</a></h3><h3 id=\"完善Visitor\"><a href=\"#完善Visitor\" class=\"headerlink\" title=\"完善Visitor\"></a>完善Visitor</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Visitor = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//this表达式</span></span><br><span class=\"line\">    ThisExpression(path)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//构建var _this = this</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> node = t.VariableDeclaration(</span><br><span class=\"line\">            <span class=\"string\">'var'</span>,</span><br><span class=\"line\">            [</span><br><span class=\"line\">                t.VariableDeclarator(</span><br><span class=\"line\">                    t.Identifier(<span class=\"string\">'_this'</span>),</span><br><span class=\"line\">                    t.Identifier(<span class=\"string\">'this'</span>)</span><br><span class=\"line\">                )</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        <span class=\"comment\">//构建 _this标识符</span></span><br><span class=\"line\">        str = t.Identifier(<span class=\"string\">'_this'</span>),</span><br><span class=\"line\">        <span class=\"comment\">//查找变量声明的父节点</span></span><br><span class=\"line\">        <span class=\"comment\">//这里只是针对例子的，真正转换需要考虑的情况很多</span></span><br><span class=\"line\">        parentPath = path.findParent(<span class=\"function\">(<span class=\"params\">path</span>) =&gt;</span> path.isVariableDeclaration())</span><br><span class=\"line\">        <span class=\"comment\">//满足条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(parentPath)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//插入</span></span><br><span class=\"line\">            parentPath.insertBefore(node)</span><br><span class=\"line\">            path.replaceWith(</span><br><span class=\"line\">                str</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//处理箭头函数。</span></span><br><span class=\"line\">    ArrowFunctionExpression(path)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> node = path.node</span><br><span class=\"line\">        <span class=\"comment\">//构造一个t.FunctionExpression节点，将原有path替换掉即可</span></span><br><span class=\"line\">        path.replaceWith(t.FunctionExpression(</span><br><span class=\"line\">            node.id,</span><br><span class=\"line\">            node.params,</span><br><span class=\"line\">            node.body</span><br><span class=\"line\">          ))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;     </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">主体visitor至此算结束了，当然如果是插件的话   </span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js   </span><br><span class=\"line\"><span class=\"comment\">//babel调用插件时会将babel-types作为参数传入 </span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">&#123; types: t &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    visitor:Visitor</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">在本地调试的话，可以分别引入babel-core和babel-types  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-core'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> t = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-types'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> code = <span class=\"string\">`var func = ()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    console.log(this.b)</span></span><br><span class=\"line\"><span class=\"string\">  &#125;;`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = babel.transform(code, &#123;</span><br><span class=\"line\">\tplugins: [&#123;</span><br><span class=\"line\">\t  <span class=\"comment\">//前面的Visitor</span></span><br><span class=\"line\">\t\tvisitor: Visitor</span><br><span class=\"line\">\t&#125;]</span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"comment\">//输出转换之后的code</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * var _this = this;</span></span><br><span class=\"line\"><span class=\"comment\"> * var func = function () &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> * console.log(_this.b);</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.code);  </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`     </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 更新说明</span></span><br><span class=\"line\"><span class=\"string\">对于构造新的语法内容时，除了上面使用t.VariableDeclaration这种费劲的表达式之外可以借助babel-template实现。</span></span><br><span class=\"line\"><span class=\"string\">用法参考</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">const</span> buildRequire = template(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  var IMPORT_NAME = require(SOURCE);</span></span><br><span class=\"line\"><span class=\"string\">`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ast = buildRequire(&#123;</span><br><span class=\"line\">  IMPORT_NAME: t.identifier(<span class=\"string\">\"myModule\"</span>),</span><br><span class=\"line\">  SOURCE: t.stringLiteral(<span class=\"string\">\"my-module\"</span>),</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>新版本可 使用replaceWithSourceString</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FunctionDeclaration(path) &#123;</span><br><span class=\"line\">  path.replaceWithSourceString(<span class=\"string\">`function add(a, b) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    return a + b;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-replacing-a-node\" target=\"_blank\" rel=\"noopener\">Babel 插件手册</a><br><a href=\"https://www.h5jun.com/post/babel-for-es6-and-beyond.html\" target=\"_blank\" rel=\"noopener\">Babel for ES6? And Beyond!</a>   </p>\n<p>纸上得来终觉浅，原本也认为已经理解了babel的原理和插件机制，没想到连写个小demo都这么费劲。主要还是对相关api不熟悉，不知道如何去构建节点，熟练之后应该会好很多。此文是插件手册的一个简单总结，把自己实现的思路汇总了一下。抛砖引玉，共同进步，另外希望对有需要的同学略有帮助。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">原文详见</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于前端开发而言，babel肯定是再熟悉不过了，工作中肯定会用到。除了用作转换es6和jsx的工具之外，个人感觉babel基于抽象语法树的插件机制，给我们提供了更多的可能。关于babel相关概念和插件文档，网上是有很多的，讲的挺不错的。详细的解析推荐官方的<a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-asts\" target=\"_blank\" rel=\"noopener\">babel插件手册</a>。在开发插件之前，有些内容还是要了解一下的，已经熟悉的大佬们可以直接跳过。<br>","more":"</p>\n<h2 id=\"抽象语法树（AST）\"><a href=\"#抽象语法树（AST）\" class=\"headerlink\" title=\"抽象语法树（AST）\"></a>抽象语法树（AST）</h2><p>Babel 使用一个基于 ESTree 并修改过的 AST，它的内核说明文档可以在<a href=\"https://github. com/babel/babel/blob/master/doc/ast/spec. md\" target=\"_blank\" rel=\"noopener\">这里</a>找到。<br>直接看实例应该更清晰：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n * n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对应的AST对象(babel提供的对象格式)<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">//代码块类别，函数声明</span></span><br><span class=\"line\">  type: <span class=\"string\">\"FunctionDeclaration\"</span>,</span><br><span class=\"line\">  <span class=\"comment\">//变量标识</span></span><br><span class=\"line\">  id: &#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">    <span class=\"comment\">//变量名称</span></span><br><span class=\"line\">    name: <span class=\"string\">\"square\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">//参数</span></span><br><span class=\"line\">  params: [&#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">    name: <span class=\"string\">\"n\"</span></span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">  <span class=\"comment\">//函数体</span></span><br><span class=\"line\">  body: &#123;</span><br><span class=\"line\">     <span class=\"comment\">//块语句</span></span><br><span class=\"line\">    type: <span class=\"string\">\"BlockStatement\"</span>,</span><br><span class=\"line\">    body: [&#123;</span><br><span class=\"line\">       <span class=\"comment\">//return 语句</span></span><br><span class=\"line\">      type: <span class=\"string\">\"ReturnStatement\"</span>,</span><br><span class=\"line\">      argument: &#123;</span><br><span class=\"line\">        <span class=\"comment\">//二元表达式</span></span><br><span class=\"line\">        type: <span class=\"string\">\"BinaryExpression\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">//操作符</span></span><br><span class=\"line\">        operator: <span class=\"string\">\"*\"</span>,</span><br><span class=\"line\">        left: &#123;</span><br><span class=\"line\">          type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">          name: <span class=\"string\">\"n\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        right: &#123;</span><br><span class=\"line\">          type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">          name: <span class=\"string\">\"n\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>大概就是上面这个层级关系，每一层都被称为节点（Node),一个完整AST对应的js对象可能会有很多节点，视具体情况而定。babel将每个节点都作为一个接口返回。其中包括的属性就如上面代码所示，例如type，start，end，loc等通用属性和具体type对应的私有属性。我们后面插件的处理也是根据不同的type来处理的。  </p>\n<p>看到这个庞大的js对象，不要感到头疼，如果说让我们每次都自己去分析AST和按照babel的定义去记住不同类型，显然不现实。这种事情应该交给电脑来执行，我们可以利用<a href=\"http://astexplorer.net/#/Z1exs6BWMq\" target=\"_blank\" rel=\"noopener\">AST Explorer </a>来将目标代码转成语法树对象，结合<a href=\"https://github.com/babel/babylon/blob/master/ast/spec.md#variabledeclarator\" target=\"_blank\" rel=\"noopener\"> AST node types</a>来查看具体属性。   </p>\n<h2 id=\"Babel-的处理步骤\"><a href=\"#Babel-的处理步骤\" class=\"headerlink\" title=\"Babel 的处理步骤\"></a>Babel 的处理步骤</h2><p>Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）,具体过程就不想详细描述了，直接看官方手册就好。<br>需要注意的是，babel插件就是在转换过程中起作用的，即将解析完成的语法树对象按照自己的目的进行处理，然后再进行代码生成步骤。所以要深入了解转换相关的内容。  </p>\n<p>代码生成步骤把最终（经过一系列转换之后）的 AST 转换成字符串形式的代码，同时还会创建源码映射（source maps），以便于调试。</p>\n<p>代码生成的原理：深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。转换的时候是是进行递归的树形遍历。</p>\n<h2 id=\"转换\"><a href=\"#转换\" class=\"headerlink\" title=\"转换\"></a>转换</h2><h3 id=\"Visitor\"><a href=\"#Visitor\" class=\"headerlink\" title=\"Visitor\"></a>Visitor</h3><p>转换的时候，是插件开始起作用的时候，但是如何进入到这个过程呢，babel给我们提供了一个Visitor的规范。我们可以通过Visitor来定义我们的访问逻辑。大概就是下面这个样子<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyVisitor = &#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里对应上面node的type，所有type为Identifier的节点都会进入该方法中</span></span><br><span class=\"line\">  Identifier() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Called!\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">//以该方法为例 </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">square</span>(<span class=\"params\">n</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n * n;</span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"comment\">//会调用四次，因为</span></span><br><span class=\"line\"><span class=\"comment\">//函数名square</span></span><br><span class=\"line\"><span class=\"comment\">//形参 n</span></span><br><span class=\"line\"><span class=\"comment\">//函数体中的两个n，都是Identifier</span></span><br><span class=\"line\">path.traverse(MyVisitor); </span><br><span class=\"line\"><span class=\"comment\">//  所以输出四个</span></span><br><span class=\"line\">Called!</span><br><span class=\"line\">Called!</span><br><span class=\"line\">Called!</span><br><span class=\"line\">Called!</span><br></pre></td></tr></table></figure></p>\n<p>因为深度优先的遍历算法，到一个叶子节点之后，发现没有子孙节点，需要向上溯源才能回到上一级继续遍历下个子节点，所以每个节点都会被访问两次。<br>如果不指定的话，调用都发生在进入节点时，当然也可以在退出时调用访问者方法。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyVisitor = &#123;</span><br><span class=\"line\">  Identifier: &#123;</span><br><span class=\"line\">    enter() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Entered!\"</span>);</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    exit() &#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Exited!\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>此外还有一些小技巧：  </p>\n<p>可以在方法名用|来匹配多种不同的type，使用相同的处理函数。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyVisitor = &#123;</span><br><span class=\"line\">  <span class=\"string\">\"ExportNamedDeclaration|Flow\"</span>(path) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>此外可以在访问者中使用别名(如babel-types定义)<br>例如Function是FunctionDeclaration，FunctionExpression，ArrowFunctionExpression，ObjectMethod和ObjectMethod的别名,可以用它来匹配上述所有类型的type  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> MyVisitor = &#123;</span><br><span class=\"line\">  <span class=\"built_in\">Function</span>(path) &#123;&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Paths\"><a href=\"#Paths\" class=\"headerlink\" title=\"Paths\"></a>Paths</h3><p>AST 通常会有许多节点，那么节点直接如何相互关联呢？ 我们可以使用一个可操作和访问的巨大可变对象表示节点之间的关联关系，或者也可以用Paths（路径）来简化这件事情。Path 是表示两个节点之间连接的对象。直接看例子比较清晰一点。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  type: <span class=\"string\">\"FunctionDeclaration\"</span>,</span><br><span class=\"line\">  id: &#123;</span><br><span class=\"line\">    type: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">    name: <span class=\"string\">\"square\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>将子节点 Identifier 表示为一个路径（Path）的话，看起来是这样的：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"parent\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"FunctionDeclaration\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"id\"</span>: &#123;...&#125;,</span><br><span class=\"line\">    ....</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"node\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"square\"</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当你通过一个 Identifier() 成员方法的访问者时，你实际上是在访问路径而非节点。 通过这种方式，你操作的就是节点的响应式表示（译注：即路径）而非节点本身。  </p>\n<h2 id=\"编写插件\"><a href=\"#编写插件\" class=\"headerlink\" title=\"编写插件\"></a>编写插件</h2><p>前面都是些必备知识点，本文只是将一些相对重要一点的知识点提了一下。详细的还是要去看开发手册的。<br>个人而言开发插件的话应该有下面三个步骤：   </p>\n<ol>\n<li>分析源文件抽象语法树AST</li>\n<li>分析目标文件抽象语法树</li>\n<li>构建Visitor<br>3.1 确定访问条件<br>3.2 确定转换逻辑    </li>\n</ol>\n<p>插件主要的就是3步骤，但是前两步是十分重要的。3.1和3.2分别依赖于1和2的结果。只有清晰了解AST结构之后，才能有的放矢，事半功倍。<br>举个例子，如下代码：    </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.b)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>目的是将箭头函数转换成普通函数声明(这里仅仅是具体这种格式的转化，其他部分就先不涉及)。如下:  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> func = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(_this.b);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h3 id=\"源文件语法树\"><a href=\"#源文件语法树\" class=\"headerlink\" title=\"源文件语法树\"></a>源文件语法树</h3><p>这里分析下这个简单的函数声明，按照上面定义分析，不过这里还是推荐<a href=\"http://astexplorer.net/#/Z1exs6BWMq\" target=\"_blank\" rel=\"noopener\">AST Explorer </a>可以清晰的看到我们的语法树。这里只截取有用信息：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"init\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"type\"</span>: <span class=\"string\">\"ArrowFunctionExpression\"</span>,</span><br><span class=\"line\">      <span class=\"comment\">/*...其他信息....*/</span></span><br><span class=\"line\">      <span class=\"string\">\"id\"</span>: <span class=\"literal\">null</span>,</span><br><span class=\"line\">      <span class=\"comment\">//形参</span></span><br><span class=\"line\">      <span class=\"string\">\"params\"</span>: [],</span><br><span class=\"line\">      <span class=\"string\">\"body\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"comment\">//函数体,this部分</span></span><br><span class=\"line\">        <span class=\"string\">\"arguments\"</span>: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                  <span class=\"string\">\"type\"</span>: <span class=\"string\">\"MemberExpression\"</span>,</span><br><span class=\"line\">                  <span class=\"string\">\"object\"</span>: &#123;</span><br><span class=\"line\">                     <span class=\"comment\">//this 表达式</span></span><br><span class=\"line\">                    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"ThisExpression\"</span>,</span><br><span class=\"line\">                  &#125;,</span><br><span class=\"line\">                  <span class=\"string\">\"property\"</span>: &#123;</span><br><span class=\"line\">                     <span class=\"comment\">//b属性</span></span><br><span class=\"line\">                    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">                    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">                  &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">              ]</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们要转换的只是ArrowFunctionExpression即箭头函数和this表达式ThisExpression部分，其他暂时不动。<br>那么我们的visitor里的函数名称就包括ArrowFunctionExpression和ThisExpression了。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//visitor里面方法的key就对应我们要处理的node  type</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> visitor = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//处理this表达式  </span></span><br><span class=\"line\">    ThisExpression(path)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//将this转换成_this的形式</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//处理箭头函数。</span></span><br><span class=\"line\">    ArrowFunctionExpression(path)&#123;</span><br><span class=\"line\">       <span class=\"comment\">//转换成普通的FunctionExpression</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"目标文件语法树\"><a href=\"#目标文件语法树\" class=\"headerlink\" title=\"目标文件语法树\"></a>目标文件语法树</h3><p>同样的方法，语法树对象如下：<br>语法树太长，我们就看一下变化的地方好了  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//转换之后的body由两个元素的数组，两个变量声明是统计关系</span></span><br><span class=\"line\"><span class=\"string\">\"body\"</span>: [</span><br><span class=\"line\">  <span class=\"comment\">//var _this = this;结构</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"VariableDeclaration\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kind\"</span>: <span class=\"string\">\"var\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"declarations\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"VariableDeclarator\"</span>,</span><br><span class=\"line\">        <span class=\"comment\">//left为_this的标识</span></span><br><span class=\"line\">        <span class=\"string\">\"id\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">\"type\"</span>: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">          <span class=\"string\">\"name\"</span>: <span class=\"string\">\"_this\"</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        <span class=\"comment\">//right为this表达式</span></span><br><span class=\"line\">        <span class=\"string\">\"init\"</span>: &#123;</span><br><span class=\"line\">          <span class=\"string\">\"type\"</span>: <span class=\"string\">\"ThisExpression\"</span></span><br><span class=\"line\">          <span class=\"comment\">/***其他**/</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;,   </span><br><span class=\"line\">  <span class=\"comment\">// var func = function (b) &#123;</span></span><br><span class=\"line\">  <span class=\"comment\">//      console.log(_this.b);</span></span><br><span class=\"line\">  <span class=\"comment\">//  &#125;;结构 只看关键的</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"string\">\"type\"</span>: <span class=\"string\">\"VariableDeclaration\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"kind\"</span>: <span class=\"string\">\"var\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"declarations\"</span>: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*****省略*******/</span></span><br><span class=\"line\">        <span class=\"string\">\"arguments\"</span>: [</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                      <span class=\"string\">\"type\"</span>: <span class=\"string\">\"MemberExpression\"</span>,</span><br><span class=\"line\">                      <span class=\"comment\">//转换之后的_this.b</span></span><br><span class=\"line\">                      <span class=\"string\">\"object\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"_this\"</span></span><br><span class=\"line\">                      &#125;,</span><br><span class=\"line\">                      <span class=\"string\">\"property\"</span>: &#123;</span><br><span class=\"line\">                        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"Identifier\"</span>,</span><br><span class=\"line\">                        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"b\"</span></span><br><span class=\"line\">                      &#125;</span><br><span class=\"line\">                      ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>经过对比，确定我们的操作应该是将ArrowFunctionExpression替换为FunctionExpression，遇到有this表达式的，绑定一下this，并将其转换。<br>进行替换增加等操作时就要用到path提供的api了：  </p>\n<ul>\n<li>replaceWith(targetObj) 替换  </li>\n<li>findParent() 查找满足条件的父节点  </li>\n<li>insertBefore 插入兄弟节点<br>更多请查询文档，这里只列出我们用到的方法。</li>\n</ul>\n<h3 id=\"构造节点\"><a href=\"#构造节点\" class=\"headerlink\" title=\"构造节点\"></a>构造节点</h3><p>这里将这个操作单独拿出来，toFunctionExpression这个api的说明我始终没找到。。。。可能是我没找对地方<a href=\"https://github.com/babel/babylon/blob/master/ast/spec.md#functiondeclaration\" target=\"_blank\" rel=\"noopener\">FunctionExpression</a>，没办法我去babel源码里找了一遍：    </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//@src  /babel/packages/babel-types/src/definitions/core.js</span></span><br><span class=\"line\">defineType(<span class=\"string\">\"FunctionExpression\"</span>, &#123;</span><br><span class=\"line\">  inherits: <span class=\"string\">\"FunctionDeclaration\"</span>,</span><br><span class=\"line\">  <span class=\"comment\">//....</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//又找到 FunctionDeclaration</span></span><br><span class=\"line\">defineType(<span class=\"string\">\"FunctionDeclaration\"</span>, &#123;</span><br><span class=\"line\">  <span class=\"comment\">//这里才看到参数: id,params,body..</span></span><br><span class=\"line\">  builder: [<span class=\"string\">\"id\"</span>, <span class=\"string\">\"params\"</span>, <span class=\"string\">\"body\"</span>, <span class=\"string\">\"generator\"</span>, <span class=\"string\">\"async\"</span>],</span><br><span class=\"line\">  visitor: [<span class=\"string\">\"id\"</span>, <span class=\"string\">\"params\"</span>, <span class=\"string\">\"body\"</span>, <span class=\"string\">\"returnType\"</span>, <span class=\"string\">\"typeParameters\"</span>]</span><br><span class=\"line\">  <span class=\"comment\">//....  </span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的话才知道入参，如果有清晰的文档，请大家不吝赐教。下面就简单了。</p>\n<h3 id=\"后来又专门找了一下，终于找到对应文档了传送门\"><a href=\"#后来又专门找了一下，终于找到对应文档了传送门\" class=\"headerlink\" title=\"后来又专门找了一下，终于找到对应文档了传送门\"></a>后来又专门找了一下，终于找到对应文档了<a href=\"https://babeljs.io/docs/core-packages/babel-types/\" target=\"_blank\" rel=\"noopener\">传送门</a></h3><h3 id=\"完善Visitor\"><a href=\"#完善Visitor\" class=\"headerlink\" title=\"完善Visitor\"></a>完善Visitor</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Visitor = &#123;</span><br><span class=\"line\">    <span class=\"comment\">//this表达式</span></span><br><span class=\"line\">    ThisExpression(path)&#123;</span><br><span class=\"line\">        <span class=\"comment\">//构建var _this = this</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> node = t.VariableDeclaration(</span><br><span class=\"line\">            <span class=\"string\">'var'</span>,</span><br><span class=\"line\">            [</span><br><span class=\"line\">                t.VariableDeclarator(</span><br><span class=\"line\">                    t.Identifier(<span class=\"string\">'_this'</span>),</span><br><span class=\"line\">                    t.Identifier(<span class=\"string\">'this'</span>)</span><br><span class=\"line\">                )</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        ),</span><br><span class=\"line\">        <span class=\"comment\">//构建 _this标识符</span></span><br><span class=\"line\">        str = t.Identifier(<span class=\"string\">'_this'</span>),</span><br><span class=\"line\">        <span class=\"comment\">//查找变量声明的父节点</span></span><br><span class=\"line\">        <span class=\"comment\">//这里只是针对例子的，真正转换需要考虑的情况很多</span></span><br><span class=\"line\">        parentPath = path.findParent(<span class=\"function\">(<span class=\"params\">path</span>) =&gt;</span> path.isVariableDeclaration())</span><br><span class=\"line\">        <span class=\"comment\">//满足条件</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(parentPath)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//插入</span></span><br><span class=\"line\">            parentPath.insertBefore(node)</span><br><span class=\"line\">            path.replaceWith(</span><br><span class=\"line\">                str</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//处理箭头函数。</span></span><br><span class=\"line\">    ArrowFunctionExpression(path)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> node = path.node</span><br><span class=\"line\">        <span class=\"comment\">//构造一个t.FunctionExpression节点，将原有path替换掉即可</span></span><br><span class=\"line\">        path.replaceWith(t.FunctionExpression(</span><br><span class=\"line\">            node.id,</span><br><span class=\"line\">            node.params,</span><br><span class=\"line\">            node.body</span><br><span class=\"line\">          ))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;     </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">主体visitor至此算结束了，当然如果是插件的话   </span></span><br><span class=\"line\"><span class=\"string\"> </span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js   </span><br><span class=\"line\"><span class=\"comment\">//babel调用插件时会将babel-types作为参数传入 </span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">&#123; types: t &#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    visitor:Visitor</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">在本地调试的话，可以分别引入babel-core和babel-types  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-core'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> t = <span class=\"built_in\">require</span>(<span class=\"string\">'babel-types'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> code = <span class=\"string\">`var func = ()=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"string\">    console.log(this.b)</span></span><br><span class=\"line\"><span class=\"string\">  &#125;;`</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> result = babel.transform(code, &#123;</span><br><span class=\"line\">\tplugins: [&#123;</span><br><span class=\"line\">\t  <span class=\"comment\">//前面的Visitor</span></span><br><span class=\"line\">\t\tvisitor: Visitor</span><br><span class=\"line\">\t&#125;]</span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"comment\">//输出转换之后的code</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * var _this = this;</span></span><br><span class=\"line\"><span class=\"comment\"> * var func = function () &#123;</span></span><br><span class=\"line\"><span class=\"comment\"> * console.log(_this.b);</span></span><br><span class=\"line\"><span class=\"comment\"> * &#125;; </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(result.code);  </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`     </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 更新说明</span></span><br><span class=\"line\"><span class=\"string\">对于构造新的语法内容时，除了上面使用t.VariableDeclaration这种费劲的表达式之外可以借助babel-template实现。</span></span><br><span class=\"line\"><span class=\"string\">用法参考</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">const</span> buildRequire = template(<span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">  var IMPORT_NAME = require(SOURCE);</span></span><br><span class=\"line\"><span class=\"string\">`</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> ast = buildRequire(&#123;</span><br><span class=\"line\">  IMPORT_NAME: t.identifier(<span class=\"string\">\"myModule\"</span>),</span><br><span class=\"line\">  SOURCE: t.stringLiteral(<span class=\"string\">\"my-module\"</span>),</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>新版本可 使用replaceWithSourceString</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FunctionDeclaration(path) &#123;</span><br><span class=\"line\">  path.replaceWithSourceString(<span class=\"string\">`function add(a, b) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    return a + b;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-replacing-a-node\" target=\"_blank\" rel=\"noopener\">Babel 插件手册</a><br><a href=\"https://www.h5jun.com/post/babel-for-es6-and-beyond.html\" target=\"_blank\" rel=\"noopener\">Babel for ES6? And Beyond!</a>   </p>\n<p>纸上得来终觉浅，原本也认为已经理解了babel的原理和插件机制，没想到连写个小demo都这么费劲。主要还是对相关api不熟悉，不知道如何去构建节点，熟练之后应该会好很多。此文是插件手册的一个简单总结，把自己实现的思路汇总了一下。抛砖引玉，共同进步，另外希望对有需要的同学略有帮助。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">原文详见</a></p>"},{"title":"译-javascript中的依赖注入","date":"2018-10-24T16:00:00.000Z","_content":"  \n## 前言\n在[上文](https://juejin.im/post/5bd07377e51d457a58075974)介绍过控制反转之后，本来打算写篇文章介绍下控制反转的常见模式-依赖注入。在翻看资料的时候，发现了一篇好文[Dependency injection in JavaScript](http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript)，就不自己折腾了，结合自己理解翻译一下，好文共赏。\n<!-- more -->\n我喜欢引用这样一句话‘编程是对复杂性的管理’。可能你也听过计算机世界是一个巨大的抽象结构。我们简单的包装东西并重复的生产新的工具。思考那么一下下，我们使用的编程语言都包括内置的功能，这些功能可能是基于其他低级操作的抽象方法，包括我们是用的javascript。  \n迟早，我们都会需要使用别的开发者开发的抽象功能，也就是我们要依赖其他人的代码。我希望使用没有依赖的模块，显然这是很难实现的。即使你创建了很好的像黑盒一样的组件，但总有个将所有部分合并起来的地方。这就是依赖注入起作用的地方，当前来看，高效管理依赖的能力是迫切需要的，本文总结了原作者对这个问题的看法。\n## 目标\n假设我们有两个模块，一个是发出ajax请求的服务，一个是路由：\n\n```js\nvar service = function() {\n    return { name: 'Service' };\n}\nvar router = function() {\n    return { name: 'Router' };\n}\n```\n\n下面是另一个依赖了上述模块的函数：\n\n```js\nvar doSomething = function(other) {\n    var s = service();\n    var r = router();\n};\n```\n\n为了更有趣一点，该函数需要接受一个参数。当然我们可以使用上面的代码，但是这不太灵活。\n如果我们想使用ServiceXML、ServiceJSON，或者我们想要mock一些测试模块，这样我们不能每次都是编辑函数体。为了解决这个现状，首先我们提出将依赖当做参数传给函数，如下：  \n\n```js\nvar doSomething = function(service, router, other) {\n    var s = service();\n    var r = router();\n};\n```\n\n这样，我们把需要的模块的具体实例传递过来。然而这样有个新的问题：想一下如果dosomething函数在很多地方被调用，如果有第三个依赖条件，我们不能改变所有的调用doSomething的地方。\n举个小栗子：  \n假如我们有很多地方用到了doSomething：\n\n```js\n//a.js\nvar a = doSomething(service,router,1)\n//b.js \nvar b = doSomething(service,router,2)\n// 假如依赖条件更改了，即doSomething需要第三个依赖，才能正常工作\n// 这时候就需要在上面不同文件中修改了，如果文件数量够多，就不合适了。\nvar doSomething = function(service, router, third,thother) {\n    var s = service();\n    var r = router();\n    //***\n};\n\n```\n\n因此，我们需要一个帮助我们来管理依赖的工具。这就是依赖注入器想要解决的问题，先看一下我们想要达到的目标：\n\n* 可以注册依赖 \n* 注入器应该接受一个函数并且返回一个已经获得需要资源的函数\n* 我们不应该写复杂的代码，需要简短优雅的语法\n* 注入器应该保持传入函数的作用域\n* 被传入的函数应该可以接受自定义参数，不仅仅是被描述的依赖。\n\n看起来比较完美的列表就如上了，让我们来尝试实现它。\n\n### requirejs/AMD的方式\n\n大家都可能听说过requirejs，它是很不错的依赖管理方案。\n\n```js\ndefine(['service', 'router'], function(service, router) {       \n    // ...\n});\n```\n\n这种思路是首先声明需要的依赖，然后开始编写函数。这里参数的顺序是很重要的。我们来试试写一个名为injector的模块，可以接受相同语法。  \n\n```js\nvar doSomething = injector.resolve(['service', 'router'], function(service, router, other) {\n    expect(service().name).to.be('Service');\n    expect(router().name).to.be('Router');\n    expect(other).to.be('Other');\n});\ndoSomething(\"Other\");\n```\n\n这里稍微停顿一下，解释一下doSomething的函数体，使用expect.js来作为断言库来确保我的代码能像期望那样正常工作。体现了一点点[TDD（测试驱动开发）](https://zh.wikipedia.org/wiki/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91)的开发模式。\n\n下面是我们injector模块的开始，一个单例模式是很好的选择，因此可以在我们应用的不同部分运行的很不错。\n  \n```js\nvar injector = {\n    dependencies: {},\n    register: function(key, value) {\n        this.dependencies[key] = value;\n    },\n    resolve: function(deps, func, scope) {\n\n    }\n}\n```\n\n从代码来看，确实是一个很简单的对象。有两个函数和一个作为存储队列的变量。我们需要做的是检查deps依赖数组，并且从dependencies队列中查找答案。剩下的就是调用.apply方法来拼接被传递过来函数的参数。\n\n```js\n //处理之后将依赖项当做参数传入给func\nresolve: function(deps, func, scope) {\n    var args = [];\n    //处理依赖，如果依赖队列中不存在对应的依赖模块，显然该依赖不能被调用那么报错，\n    for(var i=0; i<deps.length, d=deps[i]; i++) {\n        if(this.dependencies[d]) {\n            args.push(this.dependencies[d]);\n        } else {\n            throw new Error('Can\\'t resolve ' + d);\n        }\n    }\n    //处理参数，将参数拼接在依赖后面，以便和函数中参数位置对应\n    return function() {\n        func.apply(scope || {}, args.concat(Array.prototype.slice.call(arguments, 0)));\n    }        \n}\n```\n\n如果scope存在，是可以被有效传递的。Array.prototype.slice.call(arguments, 0)将arguments(类数组)转换成真正的数组。  \n目前来看很不错的，可以通过测试。当前的问题时，我们必须写两次需要的依赖，并且顺序不可变动，额外的参数只能在最后面。   \n  \n### 反射实现\n\n从维基百科来说，反射是程序在运行时可以检查和修改对象结构和行为的一种能力。简而言之，在js的上下文中，是指读取并且分析对象或者函数的源码。看下开头的doSomething，如果使用doSomething.toString() 可以得到下面的结果。\n\n```js\n\"function (service, router, other) {\n    var s = service();\n    var r = router();\n}\"\n```\n\n这种将函数转成字符串的方式赋予我们获取预期参数的能力。并且更重要的是，他们的name。下面是Angular依赖注入的实现方式，我从Angular那拿了点可以获取arguments的正则表达式：\n\n```js\n/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m\n```\n\n这样我们可以修改resolve方法了：\n#### tip\n这里，我将测试例子拿上来应该更好理解一点。  \n\n```js\nvar doSomething = injector.resolve(function(service, other, router) {\n    expect(service().name).to.be('Service');\n    expect(router().name).to.be('Router');\n    expect(other).to.be('Other');\n});\ndoSomething(\"Other\");\n```\n\n继续来看我们的实现。\n\n```js\nresolve: function() {\n    // agrs 传给func的参数数组，包括依赖模块及自定义参数\n    var func, deps, scope, args = [], self = this;\n    // 获取传入的func，主要是为了下面来拆分字符串\n    func = arguments[0];\n    // 正则拆分，获取依赖模块的数组\n    deps = func.toString().match(/^functions*[^(]*(s*([^)]*))/m)[1].replace(/ /g, '').split(',');\n    //待绑定作用域，不存在则不指定\n    scope = arguments[1] || {};\n    return function() {\n        // 将arguments转为数组\n        // 即后面再次调用的时候，doSomething(\"Other\");   \n        // 这里的Other就是a，用来补充缺失的模块。\n        var a = Array.prototype.slice.call(arguments, 0);\n        //循环依赖模块数组\n        for(var i=0; i<deps.length; i++) {\n            var d = deps[i];\n            // 依赖队列中模块存在且不为空的话，push进参数数组中。\n            // 依赖队列中不存在对应模块的话从a中取第一个元素push进去(shift之后，数组在改变)\n            args.push(self.dependencies[d] && d != '' ? self.dependencies[d] : a.shift());\n        }\n        //依赖当做参数传入\n        func.apply(scope || {}, args);\n    }        \n}\n```\n\n使用这个正则来处理函数时，可以得到下面结果：\n\n```js\n[\"function (service, router, other)\", \"service, router, other\"]\n```\n\n我们需要的只是第二项，一旦我们清除数组并拆分字符串，我们将会得到依赖数组。主要变化在下面：\n\n```js\nvar a = Array.prototype.slice.call(arguments, 0);\n...\nargs.push(self.dependencies[d] && d != '' ? self.dependencies[d] : a.shift());\n```\n \n这样我们就循环遍历依赖项，如果缺少某些东西，我们可以尝试从arguments对象中获取。幸好，当数组为空的时候shift方法也只是返回undefined而非抛错。所以新版的用法如下：\n\n```js\n//不用在前面声明依赖模块了\nvar doSomething = injector.resolve(function(service, other, router) {\n    expect(service().name).to.be('Service');\n    expect(router().name).to.be('Router');\n    expect(other).to.be('Other');\n});\ndoSomething(\"Other\");\n```\n\n这样就不用重复声明了，顺序也可变。我们复制了Angular的魔力。  \n然而，这并不完美，压缩会破坏我们的逻辑，这是反射注入的一大问题。因为压缩改变了参数的名称所以我们没有能力去解决这些依赖。例如：\n\n```js\n// 显然根据key来匹配就是有问题的了\nvar doSomething=function(e,t,n){var r=e();var i=t()}\n```\n\nAngular团队的解决方案如下：\n\n```js\nvar doSomething = injector.resolve(['service', 'router', function(service, router) {\n\n}]);\n```\n\n看起来就和开始的require.js的方式一样了。作者个人不能找到更优的解决方案，为了适应这两种方式。最终方案看起来如下：\n\n```js\nvar injector = {\n    dependencies: {},\n    register: function(key, value) {\n        this.dependencies[key] = value;\n    },\n    resolve: function() {\n        var func, deps, scope, args = [], self = this;\n        // 该种情况是兼容形式，先声明\n        if(typeof arguments[0] === 'string') {\n            func = arguments[1];\n            deps = arguments[0].replace(/ /g, '').split(',');\n            scope = arguments[2] || {};\n        } else {\n            // 反射的第一种方式\n            func = arguments[0];\n            deps = func.toString().match(/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m)[1].replace(/ /g, '').split(',');\n            scope = arguments[1] || {};\n        }\n        return function() {\n            var a = Array.prototype.slice.call(arguments, 0);\n            for(var i=0; i<deps.length; i++) {\n                var d = deps[i];\n                args.push(self.dependencies[d] && d != '' ? self.dependencies[d] : a.shift());\n            }\n            func.apply(scope || {}, args);\n        }        \n    }\n}\n```\n\n现在resolve接受两或者三个参数，如果是两个就是我们写的第一种了，如果是三个，会将第一个参数解析并填充到deps。下面就是测试例子(我一直认为将这段例子放在前面可能大家更好阅读一些。)：  \n\n```js\n// 缺失了一项模块other\nvar doSomething = injector.resolve('router,,service', function(a, b, c) {\n    expect(a().name).to.be('Router');\n    expect(b).to.be('Other');\n    expect(c().name).to.be('Service');\n});\n// 这里传的Other将会用来拼凑\ndoSomething(\"Other\");\n```\n\n可能会注意到argumets[0]中确实了一项，就是为了测试填充功能的。\n  \n### 直接注入作用域   \n\n有时候，我们使用第三种的注入方式，它涉及到函数作用域的操作(或者其他名字，this对象)，并不经常使用  \n\n```js\nvar injector = {\n    dependencies: {},\n    register: function(key, value) {\n        this.dependencies[key] = value;\n    },\n    resolve: function(deps, func, scope) {\n        var args = [];\n        scope = scope || {};\n        for(var i=0; i<deps.length, d=deps[i]; i++) {\n            if(this.dependencies[d]) {\n                //区别就在这里了，直接将依赖加到scope上\n                //这样就可以直接在函数作用域中调用了\n                scope[d] = this.dependencies[d];\n            } else {\n                throw new Error('Can\\'t resolve ' + d);\n            }\n        }\n        return function() {\n            func.apply(scope || {}, Array.prototype.slice.call(arguments, 0));\n        }        \n    }\n}\n```\n\n我们做的就是将依赖加到作用域上，这样的好处是不用再参数里加依赖了，已经是函数作用域的一部分了。  \n\n```js\nvar doSomething = injector.resolve(['service', 'router'], function(other) {\n    expect(this.service().name).to.be('Service');\n    expect(this.router().name).to.be('Router');\n    expect(other).to.be('Other');\n});\ndoSomething(\"Other\");\n```\n\n### 结束语   \n\n依赖注入是我们所有人都做过的事情中的一种，可能没有意识到罢了。即使没有听过，你也可能用过很多次了。   \n通过这篇文章对于这个熟悉而又陌生的概念的了解加深了不少，希望能帮助到有需要的同学。最后个人能力有限，翻译有误的地方欢迎大家指出，共同进步。  \n再次感谢原文作者[原文地址](http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript)","source":"_posts/Di.md","raw":"---\ntitle: 译-javascript中的依赖注入\ndate: 2018-10-25\n---\n  \n## 前言\n在[上文](https://juejin.im/post/5bd07377e51d457a58075974)介绍过控制反转之后，本来打算写篇文章介绍下控制反转的常见模式-依赖注入。在翻看资料的时候，发现了一篇好文[Dependency injection in JavaScript](http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript)，就不自己折腾了，结合自己理解翻译一下，好文共赏。\n<!-- more -->\n我喜欢引用这样一句话‘编程是对复杂性的管理’。可能你也听过计算机世界是一个巨大的抽象结构。我们简单的包装东西并重复的生产新的工具。思考那么一下下，我们使用的编程语言都包括内置的功能，这些功能可能是基于其他低级操作的抽象方法，包括我们是用的javascript。  \n迟早，我们都会需要使用别的开发者开发的抽象功能，也就是我们要依赖其他人的代码。我希望使用没有依赖的模块，显然这是很难实现的。即使你创建了很好的像黑盒一样的组件，但总有个将所有部分合并起来的地方。这就是依赖注入起作用的地方，当前来看，高效管理依赖的能力是迫切需要的，本文总结了原作者对这个问题的看法。\n## 目标\n假设我们有两个模块，一个是发出ajax请求的服务，一个是路由：\n\n```js\nvar service = function() {\n    return { name: 'Service' };\n}\nvar router = function() {\n    return { name: 'Router' };\n}\n```\n\n下面是另一个依赖了上述模块的函数：\n\n```js\nvar doSomething = function(other) {\n    var s = service();\n    var r = router();\n};\n```\n\n为了更有趣一点，该函数需要接受一个参数。当然我们可以使用上面的代码，但是这不太灵活。\n如果我们想使用ServiceXML、ServiceJSON，或者我们想要mock一些测试模块，这样我们不能每次都是编辑函数体。为了解决这个现状，首先我们提出将依赖当做参数传给函数，如下：  \n\n```js\nvar doSomething = function(service, router, other) {\n    var s = service();\n    var r = router();\n};\n```\n\n这样，我们把需要的模块的具体实例传递过来。然而这样有个新的问题：想一下如果dosomething函数在很多地方被调用，如果有第三个依赖条件，我们不能改变所有的调用doSomething的地方。\n举个小栗子：  \n假如我们有很多地方用到了doSomething：\n\n```js\n//a.js\nvar a = doSomething(service,router,1)\n//b.js \nvar b = doSomething(service,router,2)\n// 假如依赖条件更改了，即doSomething需要第三个依赖，才能正常工作\n// 这时候就需要在上面不同文件中修改了，如果文件数量够多，就不合适了。\nvar doSomething = function(service, router, third,thother) {\n    var s = service();\n    var r = router();\n    //***\n};\n\n```\n\n因此，我们需要一个帮助我们来管理依赖的工具。这就是依赖注入器想要解决的问题，先看一下我们想要达到的目标：\n\n* 可以注册依赖 \n* 注入器应该接受一个函数并且返回一个已经获得需要资源的函数\n* 我们不应该写复杂的代码，需要简短优雅的语法\n* 注入器应该保持传入函数的作用域\n* 被传入的函数应该可以接受自定义参数，不仅仅是被描述的依赖。\n\n看起来比较完美的列表就如上了，让我们来尝试实现它。\n\n### requirejs/AMD的方式\n\n大家都可能听说过requirejs，它是很不错的依赖管理方案。\n\n```js\ndefine(['service', 'router'], function(service, router) {       \n    // ...\n});\n```\n\n这种思路是首先声明需要的依赖，然后开始编写函数。这里参数的顺序是很重要的。我们来试试写一个名为injector的模块，可以接受相同语法。  \n\n```js\nvar doSomething = injector.resolve(['service', 'router'], function(service, router, other) {\n    expect(service().name).to.be('Service');\n    expect(router().name).to.be('Router');\n    expect(other).to.be('Other');\n});\ndoSomething(\"Other\");\n```\n\n这里稍微停顿一下，解释一下doSomething的函数体，使用expect.js来作为断言库来确保我的代码能像期望那样正常工作。体现了一点点[TDD（测试驱动开发）](https://zh.wikipedia.org/wiki/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91)的开发模式。\n\n下面是我们injector模块的开始，一个单例模式是很好的选择，因此可以在我们应用的不同部分运行的很不错。\n  \n```js\nvar injector = {\n    dependencies: {},\n    register: function(key, value) {\n        this.dependencies[key] = value;\n    },\n    resolve: function(deps, func, scope) {\n\n    }\n}\n```\n\n从代码来看，确实是一个很简单的对象。有两个函数和一个作为存储队列的变量。我们需要做的是检查deps依赖数组，并且从dependencies队列中查找答案。剩下的就是调用.apply方法来拼接被传递过来函数的参数。\n\n```js\n //处理之后将依赖项当做参数传入给func\nresolve: function(deps, func, scope) {\n    var args = [];\n    //处理依赖，如果依赖队列中不存在对应的依赖模块，显然该依赖不能被调用那么报错，\n    for(var i=0; i<deps.length, d=deps[i]; i++) {\n        if(this.dependencies[d]) {\n            args.push(this.dependencies[d]);\n        } else {\n            throw new Error('Can\\'t resolve ' + d);\n        }\n    }\n    //处理参数，将参数拼接在依赖后面，以便和函数中参数位置对应\n    return function() {\n        func.apply(scope || {}, args.concat(Array.prototype.slice.call(arguments, 0)));\n    }        \n}\n```\n\n如果scope存在，是可以被有效传递的。Array.prototype.slice.call(arguments, 0)将arguments(类数组)转换成真正的数组。  \n目前来看很不错的，可以通过测试。当前的问题时，我们必须写两次需要的依赖，并且顺序不可变动，额外的参数只能在最后面。   \n  \n### 反射实现\n\n从维基百科来说，反射是程序在运行时可以检查和修改对象结构和行为的一种能力。简而言之，在js的上下文中，是指读取并且分析对象或者函数的源码。看下开头的doSomething，如果使用doSomething.toString() 可以得到下面的结果。\n\n```js\n\"function (service, router, other) {\n    var s = service();\n    var r = router();\n}\"\n```\n\n这种将函数转成字符串的方式赋予我们获取预期参数的能力。并且更重要的是，他们的name。下面是Angular依赖注入的实现方式，我从Angular那拿了点可以获取arguments的正则表达式：\n\n```js\n/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m\n```\n\n这样我们可以修改resolve方法了：\n#### tip\n这里，我将测试例子拿上来应该更好理解一点。  \n\n```js\nvar doSomething = injector.resolve(function(service, other, router) {\n    expect(service().name).to.be('Service');\n    expect(router().name).to.be('Router');\n    expect(other).to.be('Other');\n});\ndoSomething(\"Other\");\n```\n\n继续来看我们的实现。\n\n```js\nresolve: function() {\n    // agrs 传给func的参数数组，包括依赖模块及自定义参数\n    var func, deps, scope, args = [], self = this;\n    // 获取传入的func，主要是为了下面来拆分字符串\n    func = arguments[0];\n    // 正则拆分，获取依赖模块的数组\n    deps = func.toString().match(/^functions*[^(]*(s*([^)]*))/m)[1].replace(/ /g, '').split(',');\n    //待绑定作用域，不存在则不指定\n    scope = arguments[1] || {};\n    return function() {\n        // 将arguments转为数组\n        // 即后面再次调用的时候，doSomething(\"Other\");   \n        // 这里的Other就是a，用来补充缺失的模块。\n        var a = Array.prototype.slice.call(arguments, 0);\n        //循环依赖模块数组\n        for(var i=0; i<deps.length; i++) {\n            var d = deps[i];\n            // 依赖队列中模块存在且不为空的话，push进参数数组中。\n            // 依赖队列中不存在对应模块的话从a中取第一个元素push进去(shift之后，数组在改变)\n            args.push(self.dependencies[d] && d != '' ? self.dependencies[d] : a.shift());\n        }\n        //依赖当做参数传入\n        func.apply(scope || {}, args);\n    }        \n}\n```\n\n使用这个正则来处理函数时，可以得到下面结果：\n\n```js\n[\"function (service, router, other)\", \"service, router, other\"]\n```\n\n我们需要的只是第二项，一旦我们清除数组并拆分字符串，我们将会得到依赖数组。主要变化在下面：\n\n```js\nvar a = Array.prototype.slice.call(arguments, 0);\n...\nargs.push(self.dependencies[d] && d != '' ? self.dependencies[d] : a.shift());\n```\n \n这样我们就循环遍历依赖项，如果缺少某些东西，我们可以尝试从arguments对象中获取。幸好，当数组为空的时候shift方法也只是返回undefined而非抛错。所以新版的用法如下：\n\n```js\n//不用在前面声明依赖模块了\nvar doSomething = injector.resolve(function(service, other, router) {\n    expect(service().name).to.be('Service');\n    expect(router().name).to.be('Router');\n    expect(other).to.be('Other');\n});\ndoSomething(\"Other\");\n```\n\n这样就不用重复声明了，顺序也可变。我们复制了Angular的魔力。  \n然而，这并不完美，压缩会破坏我们的逻辑，这是反射注入的一大问题。因为压缩改变了参数的名称所以我们没有能力去解决这些依赖。例如：\n\n```js\n// 显然根据key来匹配就是有问题的了\nvar doSomething=function(e,t,n){var r=e();var i=t()}\n```\n\nAngular团队的解决方案如下：\n\n```js\nvar doSomething = injector.resolve(['service', 'router', function(service, router) {\n\n}]);\n```\n\n看起来就和开始的require.js的方式一样了。作者个人不能找到更优的解决方案，为了适应这两种方式。最终方案看起来如下：\n\n```js\nvar injector = {\n    dependencies: {},\n    register: function(key, value) {\n        this.dependencies[key] = value;\n    },\n    resolve: function() {\n        var func, deps, scope, args = [], self = this;\n        // 该种情况是兼容形式，先声明\n        if(typeof arguments[0] === 'string') {\n            func = arguments[1];\n            deps = arguments[0].replace(/ /g, '').split(',');\n            scope = arguments[2] || {};\n        } else {\n            // 反射的第一种方式\n            func = arguments[0];\n            deps = func.toString().match(/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m)[1].replace(/ /g, '').split(',');\n            scope = arguments[1] || {};\n        }\n        return function() {\n            var a = Array.prototype.slice.call(arguments, 0);\n            for(var i=0; i<deps.length; i++) {\n                var d = deps[i];\n                args.push(self.dependencies[d] && d != '' ? self.dependencies[d] : a.shift());\n            }\n            func.apply(scope || {}, args);\n        }        \n    }\n}\n```\n\n现在resolve接受两或者三个参数，如果是两个就是我们写的第一种了，如果是三个，会将第一个参数解析并填充到deps。下面就是测试例子(我一直认为将这段例子放在前面可能大家更好阅读一些。)：  \n\n```js\n// 缺失了一项模块other\nvar doSomething = injector.resolve('router,,service', function(a, b, c) {\n    expect(a().name).to.be('Router');\n    expect(b).to.be('Other');\n    expect(c().name).to.be('Service');\n});\n// 这里传的Other将会用来拼凑\ndoSomething(\"Other\");\n```\n\n可能会注意到argumets[0]中确实了一项，就是为了测试填充功能的。\n  \n### 直接注入作用域   \n\n有时候，我们使用第三种的注入方式，它涉及到函数作用域的操作(或者其他名字，this对象)，并不经常使用  \n\n```js\nvar injector = {\n    dependencies: {},\n    register: function(key, value) {\n        this.dependencies[key] = value;\n    },\n    resolve: function(deps, func, scope) {\n        var args = [];\n        scope = scope || {};\n        for(var i=0; i<deps.length, d=deps[i]; i++) {\n            if(this.dependencies[d]) {\n                //区别就在这里了，直接将依赖加到scope上\n                //这样就可以直接在函数作用域中调用了\n                scope[d] = this.dependencies[d];\n            } else {\n                throw new Error('Can\\'t resolve ' + d);\n            }\n        }\n        return function() {\n            func.apply(scope || {}, Array.prototype.slice.call(arguments, 0));\n        }        \n    }\n}\n```\n\n我们做的就是将依赖加到作用域上，这样的好处是不用再参数里加依赖了，已经是函数作用域的一部分了。  \n\n```js\nvar doSomething = injector.resolve(['service', 'router'], function(other) {\n    expect(this.service().name).to.be('Service');\n    expect(this.router().name).to.be('Router');\n    expect(other).to.be('Other');\n});\ndoSomething(\"Other\");\n```\n\n### 结束语   \n\n依赖注入是我们所有人都做过的事情中的一种，可能没有意识到罢了。即使没有听过，你也可能用过很多次了。   \n通过这篇文章对于这个熟悉而又陌生的概念的了解加深了不少，希望能帮助到有需要的同学。最后个人能力有限，翻译有误的地方欢迎大家指出，共同进步。  \n再次感谢原文作者[原文地址](http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript)","slug":"Di","published":1,"updated":"2018-10-25T08:22:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt170006gw92tkl4utjm","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在<a href=\"https://juejin.im/post/5bd07377e51d457a58075974\" target=\"_blank\" rel=\"noopener\">上文</a>介绍过控制反转之后，本来打算写篇文章介绍下控制反转的常见模式-依赖注入。在翻看资料的时候，发现了一篇好文<a href=\"http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript\" target=\"_blank\" rel=\"noopener\">Dependency injection in JavaScript</a>，就不自己折腾了，结合自己理解翻译一下，好文共赏。<br><a id=\"more\"></a><br>我喜欢引用这样一句话‘编程是对复杂性的管理’。可能你也听过计算机世界是一个巨大的抽象结构。我们简单的包装东西并重复的生产新的工具。思考那么一下下，我们使用的编程语言都包括内置的功能，这些功能可能是基于其他低级操作的抽象方法，包括我们是用的javascript。<br>迟早，我们都会需要使用别的开发者开发的抽象功能，也就是我们要依赖其他人的代码。我希望使用没有依赖的模块，显然这是很难实现的。即使你创建了很好的像黑盒一样的组件，但总有个将所有部分合并起来的地方。这就是依赖注入起作用的地方，当前来看，高效管理依赖的能力是迫切需要的，本文总结了原作者对这个问题的看法。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>假设我们有两个模块，一个是发出ajax请求的服务，一个是路由：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> service = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Service'</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Router'</span> &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是另一个依赖了上述模块的函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">other</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = service();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = router();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了更有趣一点，该函数需要接受一个参数。当然我们可以使用上面的代码，但是这不太灵活。<br>如果我们想使用ServiceXML、ServiceJSON，或者我们想要mock一些测试模块，这样我们不能每次都是编辑函数体。为了解决这个现状，首先我们提出将依赖当做参数传给函数，如下：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, router, other</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = service();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = router();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样，我们把需要的模块的具体实例传递过来。然而这样有个新的问题：想一下如果dosomething函数在很多地方被调用，如果有第三个依赖条件，我们不能改变所有的调用doSomething的地方。<br>举个小栗子：<br>假如我们有很多地方用到了doSomething：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//a.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = doSomething(service,router,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">//b.js </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = doSomething(service,router,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// 假如依赖条件更改了，即doSomething需要第三个依赖，才能正常工作</span></span><br><span class=\"line\"><span class=\"comment\">// 这时候就需要在上面不同文件中修改了，如果文件数量够多，就不合适了。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, router, third,thother</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = service();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = router();</span><br><span class=\"line\">    <span class=\"comment\">//***</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>因此，我们需要一个帮助我们来管理依赖的工具。这就是依赖注入器想要解决的问题，先看一下我们想要达到的目标：</p>\n<ul>\n<li>可以注册依赖 </li>\n<li>注入器应该接受一个函数并且返回一个已经获得需要资源的函数</li>\n<li>我们不应该写复杂的代码，需要简短优雅的语法</li>\n<li>注入器应该保持传入函数的作用域</li>\n<li>被传入的函数应该可以接受自定义参数，不仅仅是被描述的依赖。</li>\n</ul>\n<p>看起来比较完美的列表就如上了，让我们来尝试实现它。</p>\n<h3 id=\"requirejs-AMD的方式\"><a href=\"#requirejs-AMD的方式\" class=\"headerlink\" title=\"requirejs/AMD的方式\"></a>requirejs/AMD的方式</h3><p>大家都可能听说过requirejs，它是很不错的依赖管理方案。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'service'</span>, <span class=\"string\">'router'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, router</span>) </span>&#123;       </span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这种思路是首先声明需要的依赖，然后开始编写函数。这里参数的顺序是很重要的。我们来试试写一个名为injector的模块，可以接受相同语法。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve([<span class=\"string\">'service'</span>, <span class=\"string\">'router'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, router, other</span>) </span>&#123;</span><br><span class=\"line\">    expect(service().name).to.be(<span class=\"string\">'Service'</span>);</span><br><span class=\"line\">    expect(router().name).to.be(<span class=\"string\">'Router'</span>);</span><br><span class=\"line\">    expect(other).to.be(<span class=\"string\">'Other'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">doSomething(<span class=\"string\">\"Other\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这里稍微停顿一下，解释一下doSomething的函数体，使用expect.js来作为断言库来确保我的代码能像期望那样正常工作。体现了一点点<a href=\"https://zh.wikipedia.org/wiki/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91\" target=\"_blank\" rel=\"noopener\">TDD（测试驱动开发）</a>的开发模式。</p>\n<p>下面是我们injector模块的开始，一个单例模式是很好的选择，因此可以在我们应用的不同部分运行的很不错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> injector = &#123;</span><br><span class=\"line\">    dependencies: &#123;&#125;,</span><br><span class=\"line\">    register: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dependencies[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, func, scope</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码来看，确实是一个很简单的对象。有两个函数和一个作为存储队列的变量。我们需要做的是检查deps依赖数组，并且从dependencies队列中查找答案。剩下的就是调用.apply方法来拼接被传递过来函数的参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//处理之后将依赖项当做参数传入给func</span></span><br><span class=\"line\">resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, func, scope</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = [];</span><br><span class=\"line\">    <span class=\"comment\">//处理依赖，如果依赖队列中不存在对应的依赖模块，显然该依赖不能被调用那么报错，</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;deps.length, d=deps[i]; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.dependencies[d]) &#123;</span><br><span class=\"line\">            args.push(<span class=\"keyword\">this</span>.dependencies[d]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Can\\'t resolve '</span> + d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//处理参数，将参数拼接在依赖后面，以便和函数中参数位置对应</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        func.apply(scope || &#123;&#125;, args.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>)));</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果scope存在，是可以被有效传递的。Array.prototype.slice.call(arguments, 0)将arguments(类数组)转换成真正的数组。<br>目前来看很不错的，可以通过测试。当前的问题时，我们必须写两次需要的依赖，并且顺序不可变动，额外的参数只能在最后面。   </p>\n<h3 id=\"反射实现\"><a href=\"#反射实现\" class=\"headerlink\" title=\"反射实现\"></a>反射实现</h3><p>从维基百科来说，反射是程序在运行时可以检查和修改对象结构和行为的一种能力。简而言之，在js的上下文中，是指读取并且分析对象或者函数的源码。看下开头的doSomething，如果使用doSomething.toString() 可以得到下面的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"function (service, router, other) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    var s = service();</span></span><br><span class=\"line\"><span class=\"string\">    var r = router();</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span></span><br></pre></td></tr></table></figure>\n<p>这种将函数转成字符串的方式赋予我们获取预期参数的能力。并且更重要的是，他们的name。下面是Angular依赖注入的实现方式，我从Angular那拿了点可以获取arguments的正则表达式：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span><br></pre></td></tr></table></figure>\n<p>这样我们可以修改resolve方法了：</p>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><p>这里，我将测试例子拿上来应该更好理解一点。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, other, router</span>) </span>&#123;</span><br><span class=\"line\">    expect(service().name).to.be(<span class=\"string\">'Service'</span>);</span><br><span class=\"line\">    expect(router().name).to.be(<span class=\"string\">'Router'</span>);</span><br><span class=\"line\">    expect(other).to.be(<span class=\"string\">'Other'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">doSomething(<span class=\"string\">\"Other\"</span>);</span><br></pre></td></tr></table></figure>\n<p>继续来看我们的实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// agrs 传给func的参数数组，包括依赖模块及自定义参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> func, deps, scope, args = [], self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取传入的func，主要是为了下面来拆分字符串</span></span><br><span class=\"line\">    func = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 正则拆分，获取依赖模块的数组</span></span><br><span class=\"line\">    deps = func.toString().match(<span class=\"regexp\">/^functions*[^(]*(s*([^)]*))/m</span>)[<span class=\"number\">1</span>].replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">''</span>).split(<span class=\"string\">','</span>);</span><br><span class=\"line\">    <span class=\"comment\">//待绑定作用域，不存在则不指定</span></span><br><span class=\"line\">    scope = <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>] || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将arguments转为数组</span></span><br><span class=\"line\">        <span class=\"comment\">// 即后面再次调用的时候，doSomething(\"Other\");   </span></span><br><span class=\"line\">        <span class=\"comment\">// 这里的Other就是a，用来补充缺失的模块。</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">//循环依赖模块数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> d = deps[i];</span><br><span class=\"line\">            <span class=\"comment\">// 依赖队列中模块存在且不为空的话，push进参数数组中。</span></span><br><span class=\"line\">            <span class=\"comment\">// 依赖队列中不存在对应模块的话从a中取第一个元素push进去(shift之后，数组在改变)</span></span><br><span class=\"line\">            args.push(self.dependencies[d] &amp;&amp; d != <span class=\"string\">''</span> ? self.dependencies[d] : a.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//依赖当做参数传入</span></span><br><span class=\"line\">        func.apply(scope || &#123;&#125;, args);</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用这个正则来处理函数时，可以得到下面结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">\"function (service, router, other)\"</span>, <span class=\"string\">\"service, router, other\"</span>]</span><br></pre></td></tr></table></figure>\n<p>我们需要的只是第二项，一旦我们清除数组并拆分字符串，我们将会得到依赖数组。主要变化在下面：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\">args.push(self.dependencies[d] &amp;&amp; d != <span class=\"string\">''</span> ? self.dependencies[d] : a.shift());</span><br></pre></td></tr></table></figure>\n<p>这样我们就循环遍历依赖项，如果缺少某些东西，我们可以尝试从arguments对象中获取。幸好，当数组为空的时候shift方法也只是返回undefined而非抛错。所以新版的用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不用在前面声明依赖模块了</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, other, router</span>) </span>&#123;</span><br><span class=\"line\">    expect(service().name).to.be(<span class=\"string\">'Service'</span>);</span><br><span class=\"line\">    expect(router().name).to.be(<span class=\"string\">'Router'</span>);</span><br><span class=\"line\">    expect(other).to.be(<span class=\"string\">'Other'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">doSomething(<span class=\"string\">\"Other\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这样就不用重复声明了，顺序也可变。我们复制了Angular的魔力。<br>然而，这并不完美，压缩会破坏我们的逻辑，这是反射注入的一大问题。因为压缩改变了参数的名称所以我们没有能力去解决这些依赖。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显然根据key来匹配就是有问题的了</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> doSomething=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e,t,n</span>)</span>&#123;<span class=\"keyword\">var</span> r=e();<span class=\"keyword\">var</span> i=t()&#125;</span><br></pre></td></tr></table></figure>\n<p>Angular团队的解决方案如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve([<span class=\"string\">'service'</span>, <span class=\"string\">'router'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, router</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;]);</span><br></pre></td></tr></table></figure>\n<p>看起来就和开始的require.js的方式一样了。作者个人不能找到更优的解决方案，为了适应这两种方式。最终方案看起来如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> injector = &#123;</span><br><span class=\"line\">    dependencies: &#123;&#125;,</span><br><span class=\"line\">    register: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dependencies[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> func, deps, scope, args = [], self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 该种情况是兼容形式，先声明</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">            func = <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">            deps = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>].replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">''</span>).split(<span class=\"string\">','</span>);</span><br><span class=\"line\">            scope = <span class=\"built_in\">arguments</span>[<span class=\"number\">2</span>] || &#123;&#125;;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 反射的第一种方式</span></span><br><span class=\"line\">            func = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">            deps = func.toString().match(<span class=\"regexp\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span>)[<span class=\"number\">1</span>].replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">''</span>).split(<span class=\"string\">','</span>);</span><br><span class=\"line\">            scope = <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>] || &#123;&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> a = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> d = deps[i];</span><br><span class=\"line\">                args.push(self.dependencies[d] &amp;&amp; d != <span class=\"string\">''</span> ? self.dependencies[d] : a.shift());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            func.apply(scope || &#123;&#125;, args);</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在resolve接受两或者三个参数，如果是两个就是我们写的第一种了，如果是三个，会将第一个参数解析并填充到deps。下面就是测试例子(我一直认为将这段例子放在前面可能大家更好阅读一些。)：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 缺失了一项模块other</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve(<span class=\"string\">'router,,service'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">    expect(a().name).to.be(<span class=\"string\">'Router'</span>);</span><br><span class=\"line\">    expect(b).to.be(<span class=\"string\">'Other'</span>);</span><br><span class=\"line\">    expect(c().name).to.be(<span class=\"string\">'Service'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 这里传的Other将会用来拼凑</span></span><br><span class=\"line\">doSomething(<span class=\"string\">\"Other\"</span>);</span><br></pre></td></tr></table></figure>\n<p>可能会注意到argumets[0]中确实了一项，就是为了测试填充功能的。</p>\n<h3 id=\"直接注入作用域\"><a href=\"#直接注入作用域\" class=\"headerlink\" title=\"直接注入作用域\"></a>直接注入作用域</h3><p>有时候，我们使用第三种的注入方式，它涉及到函数作用域的操作(或者其他名字，this对象)，并不经常使用  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> injector = &#123;</span><br><span class=\"line\">    dependencies: &#123;&#125;,</span><br><span class=\"line\">    register: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dependencies[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, func, scope</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = [];</span><br><span class=\"line\">        scope = scope || &#123;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;deps.length, d=deps[i]; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.dependencies[d]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//区别就在这里了，直接将依赖加到scope上</span></span><br><span class=\"line\">                <span class=\"comment\">//这样就可以直接在函数作用域中调用了</span></span><br><span class=\"line\">                scope[d] = <span class=\"keyword\">this</span>.dependencies[d];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Can\\'t resolve '</span> + d);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            func.apply(scope || &#123;&#125;, <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们做的就是将依赖加到作用域上，这样的好处是不用再参数里加依赖了，已经是函数作用域的一部分了。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve([<span class=\"string\">'service'</span>, <span class=\"string\">'router'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">other</span>) </span>&#123;</span><br><span class=\"line\">    expect(<span class=\"keyword\">this</span>.service().name).to.be(<span class=\"string\">'Service'</span>);</span><br><span class=\"line\">    expect(<span class=\"keyword\">this</span>.router().name).to.be(<span class=\"string\">'Router'</span>);</span><br><span class=\"line\">    expect(other).to.be(<span class=\"string\">'Other'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">doSomething(<span class=\"string\">\"Other\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>依赖注入是我们所有人都做过的事情中的一种，可能没有意识到罢了。即使没有听过，你也可能用过很多次了。<br>通过这篇文章对于这个熟悉而又陌生的概念的了解加深了不少，希望能帮助到有需要的同学。最后个人能力有限，翻译有误的地方欢迎大家指出，共同进步。<br>再次感谢原文作者<a href=\"http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在<a href=\"https://juejin.im/post/5bd07377e51d457a58075974\" target=\"_blank\" rel=\"noopener\">上文</a>介绍过控制反转之后，本来打算写篇文章介绍下控制反转的常见模式-依赖注入。在翻看资料的时候，发现了一篇好文<a href=\"http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript\" target=\"_blank\" rel=\"noopener\">Dependency injection in JavaScript</a>，就不自己折腾了，结合自己理解翻译一下，好文共赏。<br>","more":"<br>我喜欢引用这样一句话‘编程是对复杂性的管理’。可能你也听过计算机世界是一个巨大的抽象结构。我们简单的包装东西并重复的生产新的工具。思考那么一下下，我们使用的编程语言都包括内置的功能，这些功能可能是基于其他低级操作的抽象方法，包括我们是用的javascript。<br>迟早，我们都会需要使用别的开发者开发的抽象功能，也就是我们要依赖其他人的代码。我希望使用没有依赖的模块，显然这是很难实现的。即使你创建了很好的像黑盒一样的组件，但总有个将所有部分合并起来的地方。这就是依赖注入起作用的地方，当前来看，高效管理依赖的能力是迫切需要的，本文总结了原作者对这个问题的看法。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>假设我们有两个模块，一个是发出ajax请求的服务，一个是路由：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> service = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Service'</span> &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> router = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">name</span>: <span class=\"string\">'Router'</span> &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是另一个依赖了上述模块的函数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">other</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = service();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = router();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>为了更有趣一点，该函数需要接受一个参数。当然我们可以使用上面的代码，但是这不太灵活。<br>如果我们想使用ServiceXML、ServiceJSON，或者我们想要mock一些测试模块，这样我们不能每次都是编辑函数体。为了解决这个现状，首先我们提出将依赖当做参数传给函数，如下：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, router, other</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = service();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = router();</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样，我们把需要的模块的具体实例传递过来。然而这样有个新的问题：想一下如果dosomething函数在很多地方被调用，如果有第三个依赖条件，我们不能改变所有的调用doSomething的地方。<br>举个小栗子：<br>假如我们有很多地方用到了doSomething：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//a.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = doSomething(service,router,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">//b.js </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = doSomething(service,router,<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\">// 假如依赖条件更改了，即doSomething需要第三个依赖，才能正常工作</span></span><br><span class=\"line\"><span class=\"comment\">// 这时候就需要在上面不同文件中修改了，如果文件数量够多，就不合适了。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> doSomething = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, router, third,thother</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = service();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = router();</span><br><span class=\"line\">    <span class=\"comment\">//***</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>因此，我们需要一个帮助我们来管理依赖的工具。这就是依赖注入器想要解决的问题，先看一下我们想要达到的目标：</p>\n<ul>\n<li>可以注册依赖 </li>\n<li>注入器应该接受一个函数并且返回一个已经获得需要资源的函数</li>\n<li>我们不应该写复杂的代码，需要简短优雅的语法</li>\n<li>注入器应该保持传入函数的作用域</li>\n<li>被传入的函数应该可以接受自定义参数，不仅仅是被描述的依赖。</li>\n</ul>\n<p>看起来比较完美的列表就如上了，让我们来尝试实现它。</p>\n<h3 id=\"requirejs-AMD的方式\"><a href=\"#requirejs-AMD的方式\" class=\"headerlink\" title=\"requirejs/AMD的方式\"></a>requirejs/AMD的方式</h3><p>大家都可能听说过requirejs，它是很不错的依赖管理方案。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([<span class=\"string\">'service'</span>, <span class=\"string\">'router'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, router</span>) </span>&#123;       </span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>这种思路是首先声明需要的依赖，然后开始编写函数。这里参数的顺序是很重要的。我们来试试写一个名为injector的模块，可以接受相同语法。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve([<span class=\"string\">'service'</span>, <span class=\"string\">'router'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, router, other</span>) </span>&#123;</span><br><span class=\"line\">    expect(service().name).to.be(<span class=\"string\">'Service'</span>);</span><br><span class=\"line\">    expect(router().name).to.be(<span class=\"string\">'Router'</span>);</span><br><span class=\"line\">    expect(other).to.be(<span class=\"string\">'Other'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">doSomething(<span class=\"string\">\"Other\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这里稍微停顿一下，解释一下doSomething的函数体，使用expect.js来作为断言库来确保我的代码能像期望那样正常工作。体现了一点点<a href=\"https://zh.wikipedia.org/wiki/%E6%B5%8B%E8%AF%95%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91\" target=\"_blank\" rel=\"noopener\">TDD（测试驱动开发）</a>的开发模式。</p>\n<p>下面是我们injector模块的开始，一个单例模式是很好的选择，因此可以在我们应用的不同部分运行的很不错。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> injector = &#123;</span><br><span class=\"line\">    dependencies: &#123;&#125;,</span><br><span class=\"line\">    register: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dependencies[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, func, scope</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从代码来看，确实是一个很简单的对象。有两个函数和一个作为存储队列的变量。我们需要做的是检查deps依赖数组，并且从dependencies队列中查找答案。剩下的就是调用.apply方法来拼接被传递过来函数的参数。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"comment\">//处理之后将依赖项当做参数传入给func</span></span><br><span class=\"line\">resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, func, scope</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> args = [];</span><br><span class=\"line\">    <span class=\"comment\">//处理依赖，如果依赖队列中不存在对应的依赖模块，显然该依赖不能被调用那么报错，</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;deps.length, d=deps[i]; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.dependencies[d]) &#123;</span><br><span class=\"line\">            args.push(<span class=\"keyword\">this</span>.dependencies[d]);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Can\\'t resolve '</span> + d);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//处理参数，将参数拼接在依赖后面，以便和函数中参数位置对应</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        func.apply(scope || &#123;&#125;, args.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>)));</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果scope存在，是可以被有效传递的。Array.prototype.slice.call(arguments, 0)将arguments(类数组)转换成真正的数组。<br>目前来看很不错的，可以通过测试。当前的问题时，我们必须写两次需要的依赖，并且顺序不可变动，额外的参数只能在最后面。   </p>\n<h3 id=\"反射实现\"><a href=\"#反射实现\" class=\"headerlink\" title=\"反射实现\"></a>反射实现</h3><p>从维基百科来说，反射是程序在运行时可以检查和修改对象结构和行为的一种能力。简而言之，在js的上下文中，是指读取并且分析对象或者函数的源码。看下开头的doSomething，如果使用doSomething.toString() 可以得到下面的结果。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"function (service, router, other) &#123;</span></span><br><span class=\"line\"><span class=\"string\">    var s = service();</span></span><br><span class=\"line\"><span class=\"string\">    var r = router();</span></span><br><span class=\"line\"><span class=\"string\">&#125;\"</span></span><br></pre></td></tr></table></figure>\n<p>这种将函数转成字符串的方式赋予我们获取预期参数的能力。并且更重要的是，他们的name。下面是Angular依赖注入的实现方式，我从Angular那拿了点可以获取arguments的正则表达式：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span><br></pre></td></tr></table></figure>\n<p>这样我们可以修改resolve方法了：</p>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><p>这里，我将测试例子拿上来应该更好理解一点。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, other, router</span>) </span>&#123;</span><br><span class=\"line\">    expect(service().name).to.be(<span class=\"string\">'Service'</span>);</span><br><span class=\"line\">    expect(router().name).to.be(<span class=\"string\">'Router'</span>);</span><br><span class=\"line\">    expect(other).to.be(<span class=\"string\">'Other'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">doSomething(<span class=\"string\">\"Other\"</span>);</span><br></pre></td></tr></table></figure>\n<p>继续来看我们的实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// agrs 传给func的参数数组，包括依赖模块及自定义参数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> func, deps, scope, args = [], self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 获取传入的func，主要是为了下面来拆分字符串</span></span><br><span class=\"line\">    func = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"comment\">// 正则拆分，获取依赖模块的数组</span></span><br><span class=\"line\">    deps = func.toString().match(<span class=\"regexp\">/^functions*[^(]*(s*([^)]*))/m</span>)[<span class=\"number\">1</span>].replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">''</span>).split(<span class=\"string\">','</span>);</span><br><span class=\"line\">    <span class=\"comment\">//待绑定作用域，不存在则不指定</span></span><br><span class=\"line\">    scope = <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>] || &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将arguments转为数组</span></span><br><span class=\"line\">        <span class=\"comment\">// 即后面再次调用的时候，doSomething(\"Other\");   </span></span><br><span class=\"line\">        <span class=\"comment\">// 这里的Other就是a，用来补充缺失的模块。</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"comment\">//循环依赖模块数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> d = deps[i];</span><br><span class=\"line\">            <span class=\"comment\">// 依赖队列中模块存在且不为空的话，push进参数数组中。</span></span><br><span class=\"line\">            <span class=\"comment\">// 依赖队列中不存在对应模块的话从a中取第一个元素push进去(shift之后，数组在改变)</span></span><br><span class=\"line\">            args.push(self.dependencies[d] &amp;&amp; d != <span class=\"string\">''</span> ? self.dependencies[d] : a.shift());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//依赖当做参数传入</span></span><br><span class=\"line\">        func.apply(scope || &#123;&#125;, args);</span><br><span class=\"line\">    &#125;        </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用这个正则来处理函数时，可以得到下面结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">\"function (service, router, other)\"</span>, <span class=\"string\">\"service, router, other\"</span>]</span><br></pre></td></tr></table></figure>\n<p>我们需要的只是第二项，一旦我们清除数组并拆分字符串，我们将会得到依赖数组。主要变化在下面：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\">args.push(self.dependencies[d] &amp;&amp; d != <span class=\"string\">''</span> ? self.dependencies[d] : a.shift());</span><br></pre></td></tr></table></figure>\n<p>这样我们就循环遍历依赖项，如果缺少某些东西，我们可以尝试从arguments对象中获取。幸好，当数组为空的时候shift方法也只是返回undefined而非抛错。所以新版的用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//不用在前面声明依赖模块了</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, other, router</span>) </span>&#123;</span><br><span class=\"line\">    expect(service().name).to.be(<span class=\"string\">'Service'</span>);</span><br><span class=\"line\">    expect(router().name).to.be(<span class=\"string\">'Router'</span>);</span><br><span class=\"line\">    expect(other).to.be(<span class=\"string\">'Other'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">doSomething(<span class=\"string\">\"Other\"</span>);</span><br></pre></td></tr></table></figure>\n<p>这样就不用重复声明了，顺序也可变。我们复制了Angular的魔力。<br>然而，这并不完美，压缩会破坏我们的逻辑，这是反射注入的一大问题。因为压缩改变了参数的名称所以我们没有能力去解决这些依赖。例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 显然根据key来匹配就是有问题的了</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> doSomething=<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e,t,n</span>)</span>&#123;<span class=\"keyword\">var</span> r=e();<span class=\"keyword\">var</span> i=t()&#125;</span><br></pre></td></tr></table></figure>\n<p>Angular团队的解决方案如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve([<span class=\"string\">'service'</span>, <span class=\"string\">'router'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">service, router</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;]);</span><br></pre></td></tr></table></figure>\n<p>看起来就和开始的require.js的方式一样了。作者个人不能找到更优的解决方案，为了适应这两种方式。最终方案看起来如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> injector = &#123;</span><br><span class=\"line\">    dependencies: &#123;&#125;,</span><br><span class=\"line\">    register: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dependencies[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> func, deps, scope, args = [], self = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 该种情况是兼容形式，先声明</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] === <span class=\"string\">'string'</span>) &#123;</span><br><span class=\"line\">            func = <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>];</span><br><span class=\"line\">            deps = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>].replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">''</span>).split(<span class=\"string\">','</span>);</span><br><span class=\"line\">            scope = <span class=\"built_in\">arguments</span>[<span class=\"number\">2</span>] || &#123;&#125;;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 反射的第一种方式</span></span><br><span class=\"line\">            func = <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">            deps = func.toString().match(<span class=\"regexp\">/^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m</span>)[<span class=\"number\">1</span>].replace(<span class=\"regexp\">/ /g</span>, <span class=\"string\">''</span>).split(<span class=\"string\">','</span>);</span><br><span class=\"line\">            scope = <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>] || &#123;&#125;;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> a = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;deps.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> d = deps[i];</span><br><span class=\"line\">                args.push(self.dependencies[d] &amp;&amp; d != <span class=\"string\">''</span> ? self.dependencies[d] : a.shift());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            func.apply(scope || &#123;&#125;, args);</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在resolve接受两或者三个参数，如果是两个就是我们写的第一种了，如果是三个，会将第一个参数解析并填充到deps。下面就是测试例子(我一直认为将这段例子放在前面可能大家更好阅读一些。)：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 缺失了一项模块other</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve(<span class=\"string\">'router,,service'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">    expect(a().name).to.be(<span class=\"string\">'Router'</span>);</span><br><span class=\"line\">    expect(b).to.be(<span class=\"string\">'Other'</span>);</span><br><span class=\"line\">    expect(c().name).to.be(<span class=\"string\">'Service'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 这里传的Other将会用来拼凑</span></span><br><span class=\"line\">doSomething(<span class=\"string\">\"Other\"</span>);</span><br></pre></td></tr></table></figure>\n<p>可能会注意到argumets[0]中确实了一项，就是为了测试填充功能的。</p>\n<h3 id=\"直接注入作用域\"><a href=\"#直接注入作用域\" class=\"headerlink\" title=\"直接注入作用域\"></a>直接注入作用域</h3><p>有时候，我们使用第三种的注入方式，它涉及到函数作用域的操作(或者其他名字，this对象)，并不经常使用  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> injector = &#123;</span><br><span class=\"line\">    dependencies: &#123;&#125;,</span><br><span class=\"line\">    register: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key, value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.dependencies[key] = value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">deps, func, scope</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = [];</span><br><span class=\"line\">        scope = scope || &#123;&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i=<span class=\"number\">0</span>; i&lt;deps.length, d=deps[i]; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.dependencies[d]) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//区别就在这里了，直接将依赖加到scope上</span></span><br><span class=\"line\">                <span class=\"comment\">//这样就可以直接在函数作用域中调用了</span></span><br><span class=\"line\">                scope[d] = <span class=\"keyword\">this</span>.dependencies[d];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Can\\'t resolve '</span> + d);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            func.apply(scope || &#123;&#125;, <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>, <span class=\"number\">0</span>));</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们做的就是将依赖加到作用域上，这样的好处是不用再参数里加依赖了，已经是函数作用域的一部分了。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> doSomething = injector.resolve([<span class=\"string\">'service'</span>, <span class=\"string\">'router'</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">other</span>) </span>&#123;</span><br><span class=\"line\">    expect(<span class=\"keyword\">this</span>.service().name).to.be(<span class=\"string\">'Service'</span>);</span><br><span class=\"line\">    expect(<span class=\"keyword\">this</span>.router().name).to.be(<span class=\"string\">'Router'</span>);</span><br><span class=\"line\">    expect(other).to.be(<span class=\"string\">'Other'</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">doSomething(<span class=\"string\">\"Other\"</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>依赖注入是我们所有人都做过的事情中的一种，可能没有意识到罢了。即使没有听过，你也可能用过很多次了。<br>通过这篇文章对于这个熟悉而又陌生的概念的了解加深了不少，希望能帮助到有需要的同学。最后个人能力有限，翻译有误的地方欢迎大家指出，共同进步。<br>再次感谢原文作者<a href=\"http://krasimirtsonev.com/blog/article/Dependency-injection-in-JavaScript\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>"},{"title":"由清除float原理到BFC","date":"2018-05-14T16:00:00.000Z","_content":"  \n## 关于浮动\n设置为浮动的元素会脱离当前文档流，向左或向右移动直到边缘遇到另一个浮动元素或者到达边界。普通元素不会对齐造成影响。  \n浮动是把双刃剑，在给我们的布局带来便利的同时有一些缺点需要我们去解决。例如最常见的父元素塌陷。如下图所示：  \n<!-- more -->\n\n```css  \n.warper{\n    width: 200px;\n    border:1px solid  #ff6633;\n}\n.float-1{\n    float: left;\n    background: blue;\n    height: 100px;\n    width: 100px;\n}\n.float-2{\n    float: left;\n    background: #ff0;\n    height: 50px;\n    width: 100px;\n}\n//html  \n<div class='warper'>\n    <div class=\"float-1\"></div>\n    <div class=\"float-2\"></div>\n</div>\n```  \n<img src='/img/bfc/1.png'/>\n可以看到父元素的高度为0,为了解决这种状况就要清除浮动了。  \n\n### 清楚浮动的方式   \n\n总结了一下，大致有如下几类:  \n\n    1. 结尾空元素或者after等伪元素或者br 来clear\n    2. 父元素同样浮动\n    3. 父元素设置overflow为hidden或者auto \n    4. 父元素display：table       \n\n大致归类，可以分为两大类，1使用clear的属性，后面的可以归为一类，都是通过触发BFC来实现的。\n下面详细看一下这两大类清除浮动的方式及原理。   \n\n#### clear属性    \n\nclear 属性规定元素盒子的边不能和浮动元素相邻。该属性只能影响使用清除的元素本身，不能影响其他元素。    \n换而言之，如果已经存在浮动元素的话，那么该元素就不会像原本元素一样受其影响了。\n第一种方式里我们的填补元素(我自己的称呼)，就是起这种作用。  \n\n```css  \n//这里当然可以换成一个空的div，<br/>等，原理和效果都是一致的  \n.warper:after {\n    content: '';\n    height: 0;\n    display: block;\n    clear: both;\n} \n```     \n\n此时after伪元素设置clear：both之后表明，我两边都不能接受浮动元素，原本受浮动元素影响，伪元素的位置在浮动元素下方如图：\n<img src='/img/bfc/2.png'/>  \n\n这样显然也不能撑起父元素的高度。设置之后，需要重新安排安排了。既然两边都不接受浮动元素，但浮动元素位置也确定了，那只能把伪元素放在下边，如图：  \n<img src='/img/bfc/3.png'/>  \n\n可以看到，伪元素的位置在最下方了，距顶部的高度为float元素的高度，顺带撑起了父元素的高度。同样适用其他填充元素（display为block），都能达到相同的目的。   \n在看后面几种原理之前我们需要先看一下BFC的定义。  \n\n### BFC    \n\n#### 块级格式化上下文：BFC(block formatting contexts)    \n\n照本宣科的定义看起来可能不大好理解，BFC是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。借用张鑫旭大大的一句话，BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。  \n\n正如下面的解释：  \n\nIn a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats)   \n在BFC中，每个盒子的左外边框紧挨着包含块的左边框（从右到左的格式，则为紧挨右边框）。即使存在浮动也是这样的（尽管一个盒子的边框会由于浮动而收缩），除非这个盒子的内部创建了一个新的BFC浮动，盒子本身将会变得更窄）。     \n \n#### BFC的特性     \n\n1. 块级格式化上下文会阻止外边距叠加\n2. 块级格式化上下文不会重叠浮动元素\n3. 块级格式化上下文通常可以包含浮动     \n\n换句话说创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC任然属于文档中的普通流。所以呢浮动也就解决了，关于BFC以后要专门搞个文章仔细研究一下。  \n\n看到这里就可以知道了，为什么可以拿来清除浮动了，表现为BFC的元素都是一个十分个性的存在，无论里面怎么折腾，对外表现始终如一。大家肯定可以猜到，上面几种利用了BFC的清除方式肯定是触发了BFC的条件，让父元素变为BFC。我们来看一下触发BFC的条件，看是不是如我们所想。 \n\n#### BFC触发条件  \n    \nCSS3里面对这个规范做了改动，称之为：flow root，并且对触发条件进行了进一步说明。  \n\n```js\nfloat 除了none以外的值 \n \noverflow 除了visible 以外的值（hidden，auto，scroll ） \n \ndisplay (table-cell，table-caption，inline-block) \n \nposition（absolute，fixed） \n \nfieldset元素\n```   \n\n由上面可以对比一下，我们提到那几种方法，就是触发了BFC而已。  \n看个例子    \n\n```CSS  \n.warper{\n    width: 200px;\n    border:1px solid  #ff6633;\n    // 下面属性任选其一\n    overflow: hidden;\n    overflow: auto;\n    float: left;\n    display:inline-block;\n    position: fixed;\n}\n```      \n \n<img src='/img/bfc/4.png'/>  \n\n### 结束语   \n#### 参考文章  \n[CSS深入理解流体特性和BFC特性下多栏自适应布局](http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/)   \n[理解CSS中BFC](https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html)\n到这里清除float相关的内容就说完了，知其然更要知其所以然，清除float的方式繁多无比，掌握其中原理才能不人云亦云。当然抛砖引玉，更多的是共同学习共同进步,[更多请移步博客]()。\n\n\n\n\n\n","source":"_posts/bfc.md","raw":"---\ntitle: 由清除float原理到BFC\ndate: 2018-05-15\n---\n  \n## 关于浮动\n设置为浮动的元素会脱离当前文档流，向左或向右移动直到边缘遇到另一个浮动元素或者到达边界。普通元素不会对齐造成影响。  \n浮动是把双刃剑，在给我们的布局带来便利的同时有一些缺点需要我们去解决。例如最常见的父元素塌陷。如下图所示：  \n<!-- more -->\n\n```css  \n.warper{\n    width: 200px;\n    border:1px solid  #ff6633;\n}\n.float-1{\n    float: left;\n    background: blue;\n    height: 100px;\n    width: 100px;\n}\n.float-2{\n    float: left;\n    background: #ff0;\n    height: 50px;\n    width: 100px;\n}\n//html  \n<div class='warper'>\n    <div class=\"float-1\"></div>\n    <div class=\"float-2\"></div>\n</div>\n```  \n<img src='/img/bfc/1.png'/>\n可以看到父元素的高度为0,为了解决这种状况就要清除浮动了。  \n\n### 清楚浮动的方式   \n\n总结了一下，大致有如下几类:  \n\n    1. 结尾空元素或者after等伪元素或者br 来clear\n    2. 父元素同样浮动\n    3. 父元素设置overflow为hidden或者auto \n    4. 父元素display：table       \n\n大致归类，可以分为两大类，1使用clear的属性，后面的可以归为一类，都是通过触发BFC来实现的。\n下面详细看一下这两大类清除浮动的方式及原理。   \n\n#### clear属性    \n\nclear 属性规定元素盒子的边不能和浮动元素相邻。该属性只能影响使用清除的元素本身，不能影响其他元素。    \n换而言之，如果已经存在浮动元素的话，那么该元素就不会像原本元素一样受其影响了。\n第一种方式里我们的填补元素(我自己的称呼)，就是起这种作用。  \n\n```css  \n//这里当然可以换成一个空的div，<br/>等，原理和效果都是一致的  \n.warper:after {\n    content: '';\n    height: 0;\n    display: block;\n    clear: both;\n} \n```     \n\n此时after伪元素设置clear：both之后表明，我两边都不能接受浮动元素，原本受浮动元素影响，伪元素的位置在浮动元素下方如图：\n<img src='/img/bfc/2.png'/>  \n\n这样显然也不能撑起父元素的高度。设置之后，需要重新安排安排了。既然两边都不接受浮动元素，但浮动元素位置也确定了，那只能把伪元素放在下边，如图：  \n<img src='/img/bfc/3.png'/>  \n\n可以看到，伪元素的位置在最下方了，距顶部的高度为float元素的高度，顺带撑起了父元素的高度。同样适用其他填充元素（display为block），都能达到相同的目的。   \n在看后面几种原理之前我们需要先看一下BFC的定义。  \n\n### BFC    \n\n#### 块级格式化上下文：BFC(block formatting contexts)    \n\n照本宣科的定义看起来可能不大好理解，BFC是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。借用张鑫旭大大的一句话，BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。  \n\n正如下面的解释：  \n\nIn a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats)   \n在BFC中，每个盒子的左外边框紧挨着包含块的左边框（从右到左的格式，则为紧挨右边框）。即使存在浮动也是这样的（尽管一个盒子的边框会由于浮动而收缩），除非这个盒子的内部创建了一个新的BFC浮动，盒子本身将会变得更窄）。     \n \n#### BFC的特性     \n\n1. 块级格式化上下文会阻止外边距叠加\n2. 块级格式化上下文不会重叠浮动元素\n3. 块级格式化上下文通常可以包含浮动     \n\n换句话说创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC任然属于文档中的普通流。所以呢浮动也就解决了，关于BFC以后要专门搞个文章仔细研究一下。  \n\n看到这里就可以知道了，为什么可以拿来清除浮动了，表现为BFC的元素都是一个十分个性的存在，无论里面怎么折腾，对外表现始终如一。大家肯定可以猜到，上面几种利用了BFC的清除方式肯定是触发了BFC的条件，让父元素变为BFC。我们来看一下触发BFC的条件，看是不是如我们所想。 \n\n#### BFC触发条件  \n    \nCSS3里面对这个规范做了改动，称之为：flow root，并且对触发条件进行了进一步说明。  \n\n```js\nfloat 除了none以外的值 \n \noverflow 除了visible 以外的值（hidden，auto，scroll ） \n \ndisplay (table-cell，table-caption，inline-block) \n \nposition（absolute，fixed） \n \nfieldset元素\n```   \n\n由上面可以对比一下，我们提到那几种方法，就是触发了BFC而已。  \n看个例子    \n\n```CSS  \n.warper{\n    width: 200px;\n    border:1px solid  #ff6633;\n    // 下面属性任选其一\n    overflow: hidden;\n    overflow: auto;\n    float: left;\n    display:inline-block;\n    position: fixed;\n}\n```      \n \n<img src='/img/bfc/4.png'/>  \n\n### 结束语   \n#### 参考文章  \n[CSS深入理解流体特性和BFC特性下多栏自适应布局](http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/)   \n[理解CSS中BFC](https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html)\n到这里清除float相关的内容就说完了，知其然更要知其所以然，清除float的方式繁多无比，掌握其中原理才能不人云亦云。当然抛砖引玉，更多的是共同学习共同进步,[更多请移步博客]()。\n\n\n\n\n\n","slug":"bfc","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt190008gw92lqlusj7u","content":"<h2 id=\"关于浮动\"><a href=\"#关于浮动\" class=\"headerlink\" title=\"关于浮动\"></a>关于浮动</h2><p>设置为浮动的元素会脱离当前文档流，向左或向右移动直到边缘遇到另一个浮动元素或者到达边界。普通元素不会对齐造成影响。<br>浮动是把双刃剑，在给我们的布局带来便利的同时有一些缺点需要我们去解决。例如最常见的父元素塌陷。如下图所示：<br><a id=\"more\"></a></p>\n<pre><code class=\"css\"><span class=\"selector-class\">.warper</span>{\n    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;\n    <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid  <span class=\"number\">#ff6633</span>;\n}\n<span class=\"selector-class\">.float-1</span>{\n    <span class=\"attribute\">float</span>: left;\n    <span class=\"attribute\">background</span>: blue;\n    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;\n    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;\n}\n<span class=\"selector-class\">.float-2</span>{\n    <span class=\"attribute\">float</span>: left;\n    <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>;\n    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;\n    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;\n}\n//html  \n&lt;div class='warper'&gt;\n    &lt;div class=\"float-1\"&gt;&lt;/div&gt;\n    &lt;div class=\"float-2\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p><img src=\"/img/bfc/1.png\"><br>可以看到父元素的高度为0,为了解决这种状况就要清除浮动了。  </p>\n<h3 id=\"清楚浮动的方式\"><a href=\"#清楚浮动的方式\" class=\"headerlink\" title=\"清楚浮动的方式\"></a>清楚浮动的方式</h3><p>总结了一下，大致有如下几类:  </p>\n<pre><code>1. 结尾空元素或者after等伪元素或者br 来clear\n2. 父元素同样浮动\n3. 父元素设置overflow为hidden或者auto \n4. 父元素display：table       \n</code></pre><p>大致归类，可以分为两大类，1使用clear的属性，后面的可以归为一类，都是通过触发BFC来实现的。<br>下面详细看一下这两大类清除浮动的方式及原理。   </p>\n<h4 id=\"clear属性\"><a href=\"#clear属性\" class=\"headerlink\" title=\"clear属性\"></a>clear属性</h4><p>clear 属性规定元素盒子的边不能和浮动元素相邻。该属性只能影响使用清除的元素本身，不能影响其他元素。<br>换而言之，如果已经存在浮动元素的话，那么该元素就不会像原本元素一样受其影响了。<br>第一种方式里我们的填补元素(我自己的称呼)，就是起这种作用。  </p>\n<pre><code class=\"css\">//这里当然可以换成一个空的div，&lt;br/&gt;等，原理和效果都是一致的  \n<span class=\"selector-class\">.warper</span><span class=\"selector-pseudo\">:after</span> {\n    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;\n    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;\n    <span class=\"attribute\">display</span>: block;\n    <span class=\"attribute\">clear</span>: both;\n} \n</code></pre>\n<p>此时after伪元素设置clear：both之后表明，我两边都不能接受浮动元素，原本受浮动元素影响，伪元素的位置在浮动元素下方如图：<br><img src=\"/img/bfc/2.png\">  </p>\n<p>这样显然也不能撑起父元素的高度。设置之后，需要重新安排安排了。既然两边都不接受浮动元素，但浮动元素位置也确定了，那只能把伪元素放在下边，如图：<br><img src=\"/img/bfc/3.png\">  </p>\n<p>可以看到，伪元素的位置在最下方了，距顶部的高度为float元素的高度，顺带撑起了父元素的高度。同样适用其他填充元素（display为block），都能达到相同的目的。<br>在看后面几种原理之前我们需要先看一下BFC的定义。  </p>\n<h3 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h3><h4 id=\"块级格式化上下文：BFC-block-formatting-contexts\"><a href=\"#块级格式化上下文：BFC-block-formatting-contexts\" class=\"headerlink\" title=\"块级格式化上下文：BFC(block formatting contexts)\"></a>块级格式化上下文：BFC(block formatting contexts)</h4><p>照本宣科的定义看起来可能不大好理解，BFC是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。借用张鑫旭大大的一句话，BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。  </p>\n<p>正如下面的解释：  </p>\n<p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats)<br>在BFC中，每个盒子的左外边框紧挨着包含块的左边框（从右到左的格式，则为紧挨右边框）。即使存在浮动也是这样的（尽管一个盒子的边框会由于浮动而收缩），除非这个盒子的内部创建了一个新的BFC浮动，盒子本身将会变得更窄）。     </p>\n<h4 id=\"BFC的特性\"><a href=\"#BFC的特性\" class=\"headerlink\" title=\"BFC的特性\"></a>BFC的特性</h4><ol>\n<li>块级格式化上下文会阻止外边距叠加</li>\n<li>块级格式化上下文不会重叠浮动元素</li>\n<li>块级格式化上下文通常可以包含浮动     </li>\n</ol>\n<p>换句话说创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC任然属于文档中的普通流。所以呢浮动也就解决了，关于BFC以后要专门搞个文章仔细研究一下。  </p>\n<p>看到这里就可以知道了，为什么可以拿来清除浮动了，表现为BFC的元素都是一个十分个性的存在，无论里面怎么折腾，对外表现始终如一。大家肯定可以猜到，上面几种利用了BFC的清除方式肯定是触发了BFC的条件，让父元素变为BFC。我们来看一下触发BFC的条件，看是不是如我们所想。 </p>\n<h4 id=\"BFC触发条件\"><a href=\"#BFC触发条件\" class=\"headerlink\" title=\"BFC触发条件\"></a>BFC触发条件</h4><p>CSS3里面对这个规范做了改动，称之为：flow root，并且对触发条件进行了进一步说明。  </p>\n<pre><code class=\"js\">float 除了none以外的值 \n\noverflow 除了visible 以外的值（hidden，auto，scroll ） \n\ndisplay (table-cell，table-caption，inline-block) \n\nposition（absolute，fixed） \n\nfieldset元素\n</code></pre>\n<p>由上面可以对比一下，我们提到那几种方法，就是触发了BFC而已。<br>看个例子    </p>\n<pre><code class=\"CSS\"><span class=\"selector-class\">.warper</span>{\n    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;\n    <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid  <span class=\"number\">#ff6633</span>;\n    // 下面属性任选其一\n    <span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;\n    <span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">auto</span>;\n    <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">left</span>;\n    <span class=\"selector-tag\">display</span><span class=\"selector-pseudo\">:inline-block</span>;\n    <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">fixed</span>;\n}\n</code></pre>\n<p><img src=\"/img/bfc/4.png\">  </p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/\" target=\"_blank\" rel=\"noopener\">CSS深入理解流体特性和BFC特性下多栏自适应布局</a><br><a href=\"https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html\" target=\"_blank\" rel=\"noopener\">理解CSS中BFC</a><br>到这里清除float相关的内容就说完了，知其然更要知其所以然，清除float的方式繁多无比，掌握其中原理才能不人云亦云。当然抛砖引玉，更多的是共同学习共同进步,<a href=\"\">更多请移步博客</a>。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"关于浮动\"><a href=\"#关于浮动\" class=\"headerlink\" title=\"关于浮动\"></a>关于浮动</h2><p>设置为浮动的元素会脱离当前文档流，向左或向右移动直到边缘遇到另一个浮动元素或者到达边界。普通元素不会对齐造成影响。<br>浮动是把双刃剑，在给我们的布局带来便利的同时有一些缺点需要我们去解决。例如最常见的父元素塌陷。如下图所示：<br>","more":"</p>\n<pre><code class=\"css\"><span class=\"selector-class\">.warper</span>{\n    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;\n    <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid  <span class=\"number\">#ff6633</span>;\n}\n<span class=\"selector-class\">.float-1</span>{\n    <span class=\"attribute\">float</span>: left;\n    <span class=\"attribute\">background</span>: blue;\n    <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;\n    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;\n}\n<span class=\"selector-class\">.float-2</span>{\n    <span class=\"attribute\">float</span>: left;\n    <span class=\"attribute\">background</span>: <span class=\"number\">#ff0</span>;\n    <span class=\"attribute\">height</span>: <span class=\"number\">50px</span>;\n    <span class=\"attribute\">width</span>: <span class=\"number\">100px</span>;\n}\n//html  \n&lt;div class='warper'&gt;\n    &lt;div class=\"float-1\"&gt;&lt;/div&gt;\n    &lt;div class=\"float-2\"&gt;&lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n<p><img src=\"/img/bfc/1.png\"><br>可以看到父元素的高度为0,为了解决这种状况就要清除浮动了。  </p>\n<h3 id=\"清楚浮动的方式\"><a href=\"#清楚浮动的方式\" class=\"headerlink\" title=\"清楚浮动的方式\"></a>清楚浮动的方式</h3><p>总结了一下，大致有如下几类:  </p>\n<pre><code>1. 结尾空元素或者after等伪元素或者br 来clear\n2. 父元素同样浮动\n3. 父元素设置overflow为hidden或者auto \n4. 父元素display：table       \n</code></pre><p>大致归类，可以分为两大类，1使用clear的属性，后面的可以归为一类，都是通过触发BFC来实现的。<br>下面详细看一下这两大类清除浮动的方式及原理。   </p>\n<h4 id=\"clear属性\"><a href=\"#clear属性\" class=\"headerlink\" title=\"clear属性\"></a>clear属性</h4><p>clear 属性规定元素盒子的边不能和浮动元素相邻。该属性只能影响使用清除的元素本身，不能影响其他元素。<br>换而言之，如果已经存在浮动元素的话，那么该元素就不会像原本元素一样受其影响了。<br>第一种方式里我们的填补元素(我自己的称呼)，就是起这种作用。  </p>\n<pre><code class=\"css\">//这里当然可以换成一个空的div，&lt;br/&gt;等，原理和效果都是一致的  \n<span class=\"selector-class\">.warper</span><span class=\"selector-pseudo\">:after</span> {\n    <span class=\"attribute\">content</span>: <span class=\"string\">''</span>;\n    <span class=\"attribute\">height</span>: <span class=\"number\">0</span>;\n    <span class=\"attribute\">display</span>: block;\n    <span class=\"attribute\">clear</span>: both;\n} \n</code></pre>\n<p>此时after伪元素设置clear：both之后表明，我两边都不能接受浮动元素，原本受浮动元素影响，伪元素的位置在浮动元素下方如图：<br><img src=\"/img/bfc/2.png\">  </p>\n<p>这样显然也不能撑起父元素的高度。设置之后，需要重新安排安排了。既然两边都不接受浮动元素，但浮动元素位置也确定了，那只能把伪元素放在下边，如图：<br><img src=\"/img/bfc/3.png\">  </p>\n<p>可以看到，伪元素的位置在最下方了，距顶部的高度为float元素的高度，顺带撑起了父元素的高度。同样适用其他填充元素（display为block），都能达到相同的目的。<br>在看后面几种原理之前我们需要先看一下BFC的定义。  </p>\n<h3 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h3><h4 id=\"块级格式化上下文：BFC-block-formatting-contexts\"><a href=\"#块级格式化上下文：BFC-block-formatting-contexts\" class=\"headerlink\" title=\"块级格式化上下文：BFC(block formatting contexts)\"></a>块级格式化上下文：BFC(block formatting contexts)</h4><p>照本宣科的定义看起来可能不大好理解，BFC是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。借用张鑫旭大大的一句话，BFC元素特性表现原则就是，内部子元素再怎么翻江倒海，翻云覆雨都不会影响外部的元素。所以，避免margin穿透啊，清除浮动什么的也好理解了。  </p>\n<p>正如下面的解释：  </p>\n<p>In a block formatting context, each box’s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box’s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats)<br>在BFC中，每个盒子的左外边框紧挨着包含块的左边框（从右到左的格式，则为紧挨右边框）。即使存在浮动也是这样的（尽管一个盒子的边框会由于浮动而收缩），除非这个盒子的内部创建了一个新的BFC浮动，盒子本身将会变得更窄）。     </p>\n<h4 id=\"BFC的特性\"><a href=\"#BFC的特性\" class=\"headerlink\" title=\"BFC的特性\"></a>BFC的特性</h4><ol>\n<li>块级格式化上下文会阻止外边距叠加</li>\n<li>块级格式化上下文不会重叠浮动元素</li>\n<li>块级格式化上下文通常可以包含浮动     </li>\n</ol>\n<p>换句话说创建了 BFC的元素就是一个独立的盒子，里面的子元素不会在布局上影响外面的元素，反之亦然，同时BFC任然属于文档中的普通流。所以呢浮动也就解决了，关于BFC以后要专门搞个文章仔细研究一下。  </p>\n<p>看到这里就可以知道了，为什么可以拿来清除浮动了，表现为BFC的元素都是一个十分个性的存在，无论里面怎么折腾，对外表现始终如一。大家肯定可以猜到，上面几种利用了BFC的清除方式肯定是触发了BFC的条件，让父元素变为BFC。我们来看一下触发BFC的条件，看是不是如我们所想。 </p>\n<h4 id=\"BFC触发条件\"><a href=\"#BFC触发条件\" class=\"headerlink\" title=\"BFC触发条件\"></a>BFC触发条件</h4><p>CSS3里面对这个规范做了改动，称之为：flow root，并且对触发条件进行了进一步说明。  </p>\n<pre><code class=\"js\">float 除了none以外的值 \n\noverflow 除了visible 以外的值（hidden，auto，scroll ） \n\ndisplay (table-cell，table-caption，inline-block) \n\nposition（absolute，fixed） \n\nfieldset元素\n</code></pre>\n<p>由上面可以对比一下，我们提到那几种方法，就是触发了BFC而已。<br>看个例子    </p>\n<pre><code class=\"CSS\"><span class=\"selector-class\">.warper</span>{\n    <span class=\"attribute\">width</span>: <span class=\"number\">200px</span>;\n    <span class=\"attribute\">border</span>:<span class=\"number\">1px</span> solid  <span class=\"number\">#ff6633</span>;\n    // 下面属性任选其一\n    <span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">hidden</span>;\n    <span class=\"selector-tag\">overflow</span>: <span class=\"selector-tag\">auto</span>;\n    <span class=\"selector-tag\">float</span>: <span class=\"selector-tag\">left</span>;\n    <span class=\"selector-tag\">display</span><span class=\"selector-pseudo\">:inline-block</span>;\n    <span class=\"selector-tag\">position</span>: <span class=\"selector-tag\">fixed</span>;\n}\n</code></pre>\n<p><img src=\"/img/bfc/4.png\">  </p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://www.zhangxinxu.com/wordpress/2015/02/css-deep-understand-flow-bfc-column-two-auto-layout/\" target=\"_blank\" rel=\"noopener\">CSS深入理解流体特性和BFC特性下多栏自适应布局</a><br><a href=\"https://www.w3cplus.com/css/understanding-block-formatting-contexts-in-css.html\" target=\"_blank\" rel=\"noopener\">理解CSS中BFC</a><br>到这里清除float相关的内容就说完了，知其然更要知其所以然，清除float的方式繁多无比，掌握其中原理才能不人云亦云。当然抛砖引玉，更多的是共同学习共同进步,<a href=\"\">更多请移步博客</a>。</p>"},{"title":"由前端调试说来去","date":"2019-12-23T00:00:29.000Z","_content":"## 前言 \n对于软件开发者，主要工作除了coding之外的大部分时间在于调试，本地开发时的文件调试，测试交付后的远程调试。一切可以本地直接开干的调试过程都是享受的，因为你能洞察到每一段的执行结果。但远程调试，就繁琐很多，让人望文叹息。下面也去研究一下调试思路。","source":"_posts/debug.md","raw":"---\ntitle: 由前端调试说来去\ndate: 2019-12-23 08:00:29\ntags: 前端 调试\n---\n## 前言 \n对于软件开发者，主要工作除了coding之外的大部分时间在于调试，本地开发时的文件调试，测试交付后的远程调试。一切可以本地直接开干的调试过程都是享受的，因为你能洞察到每一段的执行结果。但远程调试，就繁琐很多，让人望文叹息。下面也去研究一下调试思路。","slug":"debug","published":1,"updated":"2019-12-30T07:06:06.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1b000agw92t3h9kmjg","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于软件开发者，主要工作除了coding之外的大部分时间在于调试，本地开发时的文件调试，测试交付后的远程调试。一切可以本地直接开干的调试过程都是享受的，因为你能洞察到每一段的执行结果。但远程调试，就繁琐很多，让人望文叹息。下面也去研究一下调试思路。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于软件开发者，主要工作除了coding之外的大部分时间在于调试，本地开发时的文件调试，测试交付后的远程调试。一切可以本地直接开干的调试过程都是享受的，因为你能洞察到每一段的执行结果。但远程调试，就繁琐很多，让人望文叹息。下面也去研究一下调试思路。</p>\n"},{"title":"http Content-Type 知多少","date":"2019-04-14T16:00:00.000Z","_content":"  \n## 前言\n作为前端开发，工作中少不了与接口请求打交道。对于常见的content-type，也能说上来几个，感觉还算了解。直到有一天，我要在查看google的批量接口合并时发现Content-Type: multipart/mixed以及Content-Type: application/http时，有点措手不及。赶紧深入研究下Content-Type相关内容来弥补下自己的不足，从前端的角度来看看Content-Type。\n<!-- more -->\n## Content-Type\nContent-Type:实体头部用于指示资源的MIME类型。如果未指定 ContentType，默认为text/html\n有两种场景：\n在请求中 (如POST 或 PUT)，客户端告诉服务器实际发送的数据类型。\n\n在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。\n\n简而言之就是标识资源或者所需资源的MIME类型。  \n\n句法如下：\n\n```bash\nContent-Type: text/html; charset=utf-8\nContent-Type: multipart/form-data; boundary=something\n```\n参数一般media-type、charset、boundary三种。\n我们的关注点在于media-type的取值以及其适用场景。\n\n### media-type\n更多的是作为MIME type( Multipurpose Internet Mail Extensions)出现，即多用途Internet邮件扩展。  \n其目的是用一种标准化的方式来标识文档的性质和格式。   \n浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；  \n因此服务器设置正确以将正确的MIME类型附加到响应对象的头部是非常重要的。  \n\n#### 结构\n\nMIME 组成结构如下：\n由类型与子类型两个字符串中间用'/'分隔而组成。不允许空格存在。对大小写不敏感，但传统都是小写。\n允许额外参数，如后面所示：\n\n```js\ntype/subtype;parameter=value\n```\n其中：\n\n* type对应通用类目，例如：text/video等。\n* subtype对应准确的子类，例如text下面细分为plain(纯文本)、html(html源码)、calendar（.ics）文件等。\n* parameter可选一般是charset或者bundaary等。\n\n### Types\n类目包括两种类型：独立类型和Multipart类型。\n#### 独立类型\n独立类型指只代表一个单独的文件或者媒体的类型，表明了对文件的分类。\n常见类型和实例如下：\n\n* text\n  文本数据包括一些人类可读的内容或者源码。例如：text/plain, text/csv, text/html.\n* application\n  数据为二进制的一种，例如application/octet-stream,application/pdf,application/pkcs8,application/zip.  \n* audio\n  音频或者音乐数据，例如audio/mpeg, audio/vorbis\n* video\n  视频数据或者文件，例如video/mp4\n* image\n  图像或图形数据，包括位图和矢量静止图像以及静止图像格式的动画版本。例如image/gif, image/png, image/jpeg, image/bmp, image/webp, image/x-icon\n  \n#### Multipart类型\nMultipart类型指明被分为几部分的一种文档的类目，且经常有不同的MIME类型。也可以用来表示属于相同事物的多个且独立的文件，这些独立的文件构成一个复杂的文档。在电子邮件场景中常见。  \n有两种Multipart类型：message和multipart。\n\n* message\n  一个包括其他信息的消息，常用于下面的场景，例如指明一个邮件包含转发信息或者在多种信息的情况下，允许以chunk的形式发送数据量很大的信息。包括message/rfc822和message/partial\n* multipart  \n  由多个不同MIME类型组件构成的数据，例如 multipart/form-data(使用FormData API生成的数据) \n  \n看完了基本定义，下面看看常见的类型及使用场景。\n  \n### 常见类型及使用场景\n#### 静态资源、图片、媒体类\n对于静态资源、图片和媒体类，也就是text、image、video等比较清晰明了，不再详细描述。\n#### application类\n* **application/json**  \n\n  随着json这种轻量级的数据交互格式的流行，特别是和脚本交互的便利，使得在前后接口中，越来越多采用json格式。对于http协议来说，最终传输的还是字符。这里不再多进行描述。  \n  \n* **application/x-www-form-urlencoded**\n  作为表单提交中默认的类型，其表明数据以标准的编码格式被编码为键值对。\n  数据被编码成以 '&' 分隔的键-值对, 同时以 '=' 分隔键和值. 非字母或数字的字符会被 percent-encoding: 这也就是为什么这种类型不支持二进制数据的原因 (应使用 multipart/form-data 代替).   \n   我们以新浪为例，可以看到其请求报文(formdata那里选择，view source可以看得比较清楚)：   \n<img src='https://user-gold-cdn.xitu.io/2019/4/14/16a1c6f743d8b587?w=1600&h=468&f=jpeg&s=128274'/>  \n\n* **multipart/form-data**\n  这里为了对比，就也放到这里来说了。  \n  一般用于涉及文件的表单提交，用于post请求，其格式如下：  \n  \n  ```json\n  Content-Type: multipart/form-data; boundary=aBoundaryString\n  ```  \n  其中boundary指明了请求体中每部分的分割符(对于multipart的类目，都会存在该字段，以区分请求体中数据的分割)，其请求体中则是对应表单每部分的内容。每部分都会有自己的请求体和相关内容。  \n例如如下的文档结构：  \n  \n```html\n  <form action=\"http://localhost:8000/\" method=\"post\" enctype=\"multipart/form-data\">\n  <input type=\"text\" name=\"myTextField\">\n  <input type=\"checkbox\" name=\"myCheckBox\">Check</input>\n  <input type=\"file\" name=\"myFile\">\n  <button>Send the file</button>\n</form>\n```   \n\n其请求信息如下：  \n\n```js\nPOST / HTTP/1.1\nHost: localhost:8000\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\n// 以 ---------------------------8721656041911415653955004498 作为分割符\nContent-Type: multipart/form-data; boundary=---------------------------8721656041911415653955004498\nContent-Length: 465\n\n-----------------------------8721656041911415653955004498\n// 分段一 文本相关信息\nContent-Disposition: form-data; name=\"myTextField\"\n// 对应value\nTest\n-----------------------------8721656041911415653955004498\n// checkbox\nContent-Disposition: form-data; name=\"myCheckBox\"\n\non\n-----------------------------8721656041911415653955004498\n// 文件\nContent-Disposition: form-data; name=\"myFile\"; filename=\"test.txt\"\nContent-Type: text/plain\n\nSimple file.\n-----------------------------8721656041911415653955004498--\n```\n\n* **application/javascript application/x-javascript text/javascript**   \n  对于js文件，常见MIME类型为text/javascript，但是前两种应该会有见到过。三者之间多少还是有点区别的。  \n  传统的js程序对应的MIME类型为text/javascript，其他的还有\"application/x-javascript\"（x前缀表示这是实验性类型）， 因为text/javascript是最常见的类型，所以RFC4329定义了“text/javascript”。不过，js文件实际上并不是真正的文本类型，因此推出了application/javascript类型，不过现行的支持性并不好，所以常常会用application/x-javascript来代替。   \n  \n* **application/zip application/gzip**   \n   zip 对应zip压缩文件，gzip是若干种文件压缩程序的简称，通常指GNU计划的实现，此处的gzip代表GNU zip。\n\n* **application/http**  \n   这一种大家可能就不常见了，从类型可以知道，是http请求，但具体用途还是要翻下[规范](https://www.iana.org/assignments/media-types/application/http)才能找到的。  \n   此类型包含的http请求包含在binary消息体中，在邮件协议传输中需要指明Content-Transfer-Encoding。   \n   在批量处理请求时会遇到，其表现如下：  \n\n```js\n--batch_0123456789\nContent-Type: application/http\nContent-ID: \n// 必须的字段，表明传送内容的编码格式 即二进制流\nContent-Transfer-Encoding: binary\n\nPOST https://www.googleapis.com/analytics/v3/management/accounts/XXXXXX/webproperties/UA-XXXXXX-1/customDimensions\nContent-Type: application/json\nContent-Length: 68\n\n{\n \"name\": \"Campaign Group\",\n \"scope\": \"SESSION\",\n \"active\": true\n} \n```    \n    \n#### multipart类型\n正如上文所述，multipart一般对应单个消息头对应多个消息体。\n常见语法如下:\n\n```js\nContent-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08jU534c0p\n```  \n\n其中boundary字段是必须的，用于区分消息体中的数据边界，一般是两个'-'的格式作为该端的开头，例如：\n\n```js\n--gc0p4Jq0M2Yt08jU534c0p\n```\n\n\n我们主要关注的也就是下面几种：  \n\n* **multipart/form-data**\n  见上面application部分。下面这几部分可能不是那么常见，不过还是可以了解一下，以免遇到的时候懵逼。  \n  \n* **multipart/mixed**    \n  该类型用于，消息体由多个独立的部分组成且想连续的展示。并且子数据类型有任一种无法被识别(此处指被浏览器直接识别的类型，例如text等)的类型时，都应该为mixed。  \n概括而言就是该邮件有二进制内容，非可以直接识别的内容  \n  \n例如：\n\n```js\nPOST /batch/farm/v1 HTTP/1.1\nAuthorization: Bearer your_auth_token\nHost: www.googleapis.com\nContent-Type: multipart/mixed; boundary=batch_foobarbaz\nContent-Length: total_content_length\n\n--batch_foobarbaz\n// 子内容为http请求 不过是boundary编码过的\nContent-Type: application/http\nContent-ID: <item1:12930812@barnyard.example.com>\n\nGET /farm/v1/animals/pony\n\n--batch_foobarbaz\nContent-Type: application/http\nContent-ID: <item2:12930812@barnyard.example.com>\n\nPUT /farm/v1/animals/sheep\nContent-Type: application/json\nContent-Length: part_content_length\nIf-Match: \"etag/sheep\"\n\n{\n  \"animalName\": \"sheep\",\n  \"animalAge\": \"5\"\n  \"peltColor\": \"green\",\n}\n\n--batch_foobarbaz\nContent-Type: application/http\nContent-ID: <item3:12930812@barnyard.example.com>\n\nGET /farm/v1/animals\nIf-None-Match: \"etag/animals\"\n\n--batch_foobarbaz--\n```\n这里消息体中的内容就是http请求，在google批量接口协议中用使用。\n   \n* **multipart/alternative**   \n  该类型与mixed的语法相同，但语义不同。其表明，消息体中的不同部分应该是相同信息的不同版本。即内容相同传输类型不同，以适应不同的接受者。  \n还是举例：  \n\n```js \nFrom:  Nathaniel Borenstein <nsb@bellcore.com> \nTo: Ned Freed <ned@innosoft.com> \nSubject: Formatted text mail \nMIME-Version: 1.0 \nContent-Type: multipart/alternative; boundary=boundary42 \n\n\n--boundary42 \nContent-Type: text/plain; charset=us-ascii \n\n...plain text version of message goes here.... \n\n--boundary42 \nContent-Type: text/richtext \n\n.... richtext version of same message goes here ... \n--boundary42 \nContent-Type: text/x-whatever \n\n.... fanciest formatted version of same  message  goes  here \n... \n--boundary42-- \n```   \n假如用户的系统可以识别 text/x-whatever 类型，那么其将会只看到这一部分。不同的用户看到什么内容取决于其系统支持何种类型。   \n  \n## 结束语\n### 参考\n[https://developers.google.com/drive/api/v3/batch?hl=zh-cn](https://developers.google.com/drive/api/v3/batch?hl=zh-cn)   \n[https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)  \n[https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html](https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html)  \n  \n到这里常见的content-type就介绍完了，感谢以上参考文章，此外水平有限可能有错误之处欢迎指出。对于前端同学来说，网络请求也是我们需要关注的部分，提升深度的同时也要注意落款广度，希望对有需要的同学有所裨益。","source":"_posts/content-type.md","raw":"---\ntitle: http Content-Type 知多少\ndate: 2019-04-15\n---\n  \n## 前言\n作为前端开发，工作中少不了与接口请求打交道。对于常见的content-type，也能说上来几个，感觉还算了解。直到有一天，我要在查看google的批量接口合并时发现Content-Type: multipart/mixed以及Content-Type: application/http时，有点措手不及。赶紧深入研究下Content-Type相关内容来弥补下自己的不足，从前端的角度来看看Content-Type。\n<!-- more -->\n## Content-Type\nContent-Type:实体头部用于指示资源的MIME类型。如果未指定 ContentType，默认为text/html\n有两种场景：\n在请求中 (如POST 或 PUT)，客户端告诉服务器实际发送的数据类型。\n\n在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。\n\n简而言之就是标识资源或者所需资源的MIME类型。  \n\n句法如下：\n\n```bash\nContent-Type: text/html; charset=utf-8\nContent-Type: multipart/form-data; boundary=something\n```\n参数一般media-type、charset、boundary三种。\n我们的关注点在于media-type的取值以及其适用场景。\n\n### media-type\n更多的是作为MIME type( Multipurpose Internet Mail Extensions)出现，即多用途Internet邮件扩展。  \n其目的是用一种标准化的方式来标识文档的性质和格式。   \n浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；  \n因此服务器设置正确以将正确的MIME类型附加到响应对象的头部是非常重要的。  \n\n#### 结构\n\nMIME 组成结构如下：\n由类型与子类型两个字符串中间用'/'分隔而组成。不允许空格存在。对大小写不敏感，但传统都是小写。\n允许额外参数，如后面所示：\n\n```js\ntype/subtype;parameter=value\n```\n其中：\n\n* type对应通用类目，例如：text/video等。\n* subtype对应准确的子类，例如text下面细分为plain(纯文本)、html(html源码)、calendar（.ics）文件等。\n* parameter可选一般是charset或者bundaary等。\n\n### Types\n类目包括两种类型：独立类型和Multipart类型。\n#### 独立类型\n独立类型指只代表一个单独的文件或者媒体的类型，表明了对文件的分类。\n常见类型和实例如下：\n\n* text\n  文本数据包括一些人类可读的内容或者源码。例如：text/plain, text/csv, text/html.\n* application\n  数据为二进制的一种，例如application/octet-stream,application/pdf,application/pkcs8,application/zip.  \n* audio\n  音频或者音乐数据，例如audio/mpeg, audio/vorbis\n* video\n  视频数据或者文件，例如video/mp4\n* image\n  图像或图形数据，包括位图和矢量静止图像以及静止图像格式的动画版本。例如image/gif, image/png, image/jpeg, image/bmp, image/webp, image/x-icon\n  \n#### Multipart类型\nMultipart类型指明被分为几部分的一种文档的类目，且经常有不同的MIME类型。也可以用来表示属于相同事物的多个且独立的文件，这些独立的文件构成一个复杂的文档。在电子邮件场景中常见。  \n有两种Multipart类型：message和multipart。\n\n* message\n  一个包括其他信息的消息，常用于下面的场景，例如指明一个邮件包含转发信息或者在多种信息的情况下，允许以chunk的形式发送数据量很大的信息。包括message/rfc822和message/partial\n* multipart  \n  由多个不同MIME类型组件构成的数据，例如 multipart/form-data(使用FormData API生成的数据) \n  \n看完了基本定义，下面看看常见的类型及使用场景。\n  \n### 常见类型及使用场景\n#### 静态资源、图片、媒体类\n对于静态资源、图片和媒体类，也就是text、image、video等比较清晰明了，不再详细描述。\n#### application类\n* **application/json**  \n\n  随着json这种轻量级的数据交互格式的流行，特别是和脚本交互的便利，使得在前后接口中，越来越多采用json格式。对于http协议来说，最终传输的还是字符。这里不再多进行描述。  \n  \n* **application/x-www-form-urlencoded**\n  作为表单提交中默认的类型，其表明数据以标准的编码格式被编码为键值对。\n  数据被编码成以 '&' 分隔的键-值对, 同时以 '=' 分隔键和值. 非字母或数字的字符会被 percent-encoding: 这也就是为什么这种类型不支持二进制数据的原因 (应使用 multipart/form-data 代替).   \n   我们以新浪为例，可以看到其请求报文(formdata那里选择，view source可以看得比较清楚)：   \n<img src='https://user-gold-cdn.xitu.io/2019/4/14/16a1c6f743d8b587?w=1600&h=468&f=jpeg&s=128274'/>  \n\n* **multipart/form-data**\n  这里为了对比，就也放到这里来说了。  \n  一般用于涉及文件的表单提交，用于post请求，其格式如下：  \n  \n  ```json\n  Content-Type: multipart/form-data; boundary=aBoundaryString\n  ```  \n  其中boundary指明了请求体中每部分的分割符(对于multipart的类目，都会存在该字段，以区分请求体中数据的分割)，其请求体中则是对应表单每部分的内容。每部分都会有自己的请求体和相关内容。  \n例如如下的文档结构：  \n  \n```html\n  <form action=\"http://localhost:8000/\" method=\"post\" enctype=\"multipart/form-data\">\n  <input type=\"text\" name=\"myTextField\">\n  <input type=\"checkbox\" name=\"myCheckBox\">Check</input>\n  <input type=\"file\" name=\"myFile\">\n  <button>Send the file</button>\n</form>\n```   \n\n其请求信息如下：  \n\n```js\nPOST / HTTP/1.1\nHost: localhost:8000\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\n// 以 ---------------------------8721656041911415653955004498 作为分割符\nContent-Type: multipart/form-data; boundary=---------------------------8721656041911415653955004498\nContent-Length: 465\n\n-----------------------------8721656041911415653955004498\n// 分段一 文本相关信息\nContent-Disposition: form-data; name=\"myTextField\"\n// 对应value\nTest\n-----------------------------8721656041911415653955004498\n// checkbox\nContent-Disposition: form-data; name=\"myCheckBox\"\n\non\n-----------------------------8721656041911415653955004498\n// 文件\nContent-Disposition: form-data; name=\"myFile\"; filename=\"test.txt\"\nContent-Type: text/plain\n\nSimple file.\n-----------------------------8721656041911415653955004498--\n```\n\n* **application/javascript application/x-javascript text/javascript**   \n  对于js文件，常见MIME类型为text/javascript，但是前两种应该会有见到过。三者之间多少还是有点区别的。  \n  传统的js程序对应的MIME类型为text/javascript，其他的还有\"application/x-javascript\"（x前缀表示这是实验性类型）， 因为text/javascript是最常见的类型，所以RFC4329定义了“text/javascript”。不过，js文件实际上并不是真正的文本类型，因此推出了application/javascript类型，不过现行的支持性并不好，所以常常会用application/x-javascript来代替。   \n  \n* **application/zip application/gzip**   \n   zip 对应zip压缩文件，gzip是若干种文件压缩程序的简称，通常指GNU计划的实现，此处的gzip代表GNU zip。\n\n* **application/http**  \n   这一种大家可能就不常见了，从类型可以知道，是http请求，但具体用途还是要翻下[规范](https://www.iana.org/assignments/media-types/application/http)才能找到的。  \n   此类型包含的http请求包含在binary消息体中，在邮件协议传输中需要指明Content-Transfer-Encoding。   \n   在批量处理请求时会遇到，其表现如下：  \n\n```js\n--batch_0123456789\nContent-Type: application/http\nContent-ID: \n// 必须的字段，表明传送内容的编码格式 即二进制流\nContent-Transfer-Encoding: binary\n\nPOST https://www.googleapis.com/analytics/v3/management/accounts/XXXXXX/webproperties/UA-XXXXXX-1/customDimensions\nContent-Type: application/json\nContent-Length: 68\n\n{\n \"name\": \"Campaign Group\",\n \"scope\": \"SESSION\",\n \"active\": true\n} \n```    \n    \n#### multipart类型\n正如上文所述，multipart一般对应单个消息头对应多个消息体。\n常见语法如下:\n\n```js\nContent-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08jU534c0p\n```  \n\n其中boundary字段是必须的，用于区分消息体中的数据边界，一般是两个'-'的格式作为该端的开头，例如：\n\n```js\n--gc0p4Jq0M2Yt08jU534c0p\n```\n\n\n我们主要关注的也就是下面几种：  \n\n* **multipart/form-data**\n  见上面application部分。下面这几部分可能不是那么常见，不过还是可以了解一下，以免遇到的时候懵逼。  \n  \n* **multipart/mixed**    \n  该类型用于，消息体由多个独立的部分组成且想连续的展示。并且子数据类型有任一种无法被识别(此处指被浏览器直接识别的类型，例如text等)的类型时，都应该为mixed。  \n概括而言就是该邮件有二进制内容，非可以直接识别的内容  \n  \n例如：\n\n```js\nPOST /batch/farm/v1 HTTP/1.1\nAuthorization: Bearer your_auth_token\nHost: www.googleapis.com\nContent-Type: multipart/mixed; boundary=batch_foobarbaz\nContent-Length: total_content_length\n\n--batch_foobarbaz\n// 子内容为http请求 不过是boundary编码过的\nContent-Type: application/http\nContent-ID: <item1:12930812@barnyard.example.com>\n\nGET /farm/v1/animals/pony\n\n--batch_foobarbaz\nContent-Type: application/http\nContent-ID: <item2:12930812@barnyard.example.com>\n\nPUT /farm/v1/animals/sheep\nContent-Type: application/json\nContent-Length: part_content_length\nIf-Match: \"etag/sheep\"\n\n{\n  \"animalName\": \"sheep\",\n  \"animalAge\": \"5\"\n  \"peltColor\": \"green\",\n}\n\n--batch_foobarbaz\nContent-Type: application/http\nContent-ID: <item3:12930812@barnyard.example.com>\n\nGET /farm/v1/animals\nIf-None-Match: \"etag/animals\"\n\n--batch_foobarbaz--\n```\n这里消息体中的内容就是http请求，在google批量接口协议中用使用。\n   \n* **multipart/alternative**   \n  该类型与mixed的语法相同，但语义不同。其表明，消息体中的不同部分应该是相同信息的不同版本。即内容相同传输类型不同，以适应不同的接受者。  \n还是举例：  \n\n```js \nFrom:  Nathaniel Borenstein <nsb@bellcore.com> \nTo: Ned Freed <ned@innosoft.com> \nSubject: Formatted text mail \nMIME-Version: 1.0 \nContent-Type: multipart/alternative; boundary=boundary42 \n\n\n--boundary42 \nContent-Type: text/plain; charset=us-ascii \n\n...plain text version of message goes here.... \n\n--boundary42 \nContent-Type: text/richtext \n\n.... richtext version of same message goes here ... \n--boundary42 \nContent-Type: text/x-whatever \n\n.... fanciest formatted version of same  message  goes  here \n... \n--boundary42-- \n```   \n假如用户的系统可以识别 text/x-whatever 类型，那么其将会只看到这一部分。不同的用户看到什么内容取决于其系统支持何种类型。   \n  \n## 结束语\n### 参考\n[https://developers.google.com/drive/api/v3/batch?hl=zh-cn](https://developers.google.com/drive/api/v3/batch?hl=zh-cn)   \n[https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)  \n[https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html](https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html)  \n  \n到这里常见的content-type就介绍完了，感谢以上参考文章，此外水平有限可能有错误之处欢迎指出。对于前端同学来说，网络请求也是我们需要关注的部分，提升深度的同时也要注意落款广度，希望对有需要的同学有所裨益。","slug":"content-type","published":1,"updated":"2019-04-16T03:47:48.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1d000cgw927zzw6i1t","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为前端开发，工作中少不了与接口请求打交道。对于常见的content-type，也能说上来几个，感觉还算了解。直到有一天，我要在查看google的批量接口合并时发现Content-Type: multipart/mixed以及Content-Type: application/http时，有点措手不及。赶紧深入研究下Content-Type相关内容来弥补下自己的不足，从前端的角度来看看Content-Type。<br><a id=\"more\"></a></p>\n<h2 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h2><p>Content-Type:实体头部用于指示资源的MIME类型。如果未指定 ContentType，默认为text/html<br>有两种场景：<br>在请求中 (如POST 或 PUT)，客户端告诉服务器实际发送的数据类型。</p>\n<p>在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。</p>\n<p>简而言之就是标识资源或者所需资源的MIME类型。  </p>\n<p>句法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: text/html; charset=utf-8</span><br><span class=\"line\">Content-Type: multipart/form-data; boundary=something</span><br></pre></td></tr></table></figure>\n<p>参数一般media-type、charset、boundary三种。<br>我们的关注点在于media-type的取值以及其适用场景。</p>\n<h3 id=\"media-type\"><a href=\"#media-type\" class=\"headerlink\" title=\"media-type\"></a>media-type</h3><p>更多的是作为MIME type( Multipurpose Internet Mail Extensions)出现，即多用途Internet邮件扩展。<br>其目的是用一种标准化的方式来标识文档的性质和格式。<br>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；<br>因此服务器设置正确以将正确的MIME类型附加到响应对象的头部是非常重要的。  </p>\n<h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><p>MIME 组成结构如下：<br>由类型与子类型两个字符串中间用’/‘分隔而组成。不允许空格存在。对大小写不敏感，但传统都是小写。<br>允许额外参数，如后面所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type/subtype;parameter=value</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<ul>\n<li>type对应通用类目，例如：text/video等。</li>\n<li>subtype对应准确的子类，例如text下面细分为plain(纯文本)、html(html源码)、calendar（.ics）文件等。</li>\n<li>parameter可选一般是charset或者bundaary等。</li>\n</ul>\n<h3 id=\"Types\"><a href=\"#Types\" class=\"headerlink\" title=\"Types\"></a>Types</h3><p>类目包括两种类型：独立类型和Multipart类型。</p>\n<h4 id=\"独立类型\"><a href=\"#独立类型\" class=\"headerlink\" title=\"独立类型\"></a>独立类型</h4><p>独立类型指只代表一个单独的文件或者媒体的类型，表明了对文件的分类。<br>常见类型和实例如下：</p>\n<ul>\n<li>text<br>文本数据包括一些人类可读的内容或者源码。例如：text/plain, text/csv, text/html.</li>\n<li>application<br>数据为二进制的一种，例如application/octet-stream,application/pdf,application/pkcs8,application/zip.  </li>\n<li>audio<br>音频或者音乐数据，例如audio/mpeg, audio/vorbis</li>\n<li>video<br>视频数据或者文件，例如video/mp4</li>\n<li>image<br>图像或图形数据，包括位图和矢量静止图像以及静止图像格式的动画版本。例如image/gif, image/png, image/jpeg, image/bmp, image/webp, image/x-icon</li>\n</ul>\n<h4 id=\"Multipart类型\"><a href=\"#Multipart类型\" class=\"headerlink\" title=\"Multipart类型\"></a>Multipart类型</h4><p>Multipart类型指明被分为几部分的一种文档的类目，且经常有不同的MIME类型。也可以用来表示属于相同事物的多个且独立的文件，这些独立的文件构成一个复杂的文档。在电子邮件场景中常见。<br>有两种Multipart类型：message和multipart。</p>\n<ul>\n<li>message<br>一个包括其他信息的消息，常用于下面的场景，例如指明一个邮件包含转发信息或者在多种信息的情况下，允许以chunk的形式发送数据量很大的信息。包括message/rfc822和message/partial</li>\n<li>multipart<br>由多个不同MIME类型组件构成的数据，例如 multipart/form-data(使用FormData API生成的数据) </li>\n</ul>\n<p>看完了基本定义，下面看看常见的类型及使用场景。</p>\n<h3 id=\"常见类型及使用场景\"><a href=\"#常见类型及使用场景\" class=\"headerlink\" title=\"常见类型及使用场景\"></a>常见类型及使用场景</h3><h4 id=\"静态资源、图片、媒体类\"><a href=\"#静态资源、图片、媒体类\" class=\"headerlink\" title=\"静态资源、图片、媒体类\"></a>静态资源、图片、媒体类</h4><p>对于静态资源、图片和媒体类，也就是text、image、video等比较清晰明了，不再详细描述。</p>\n<h4 id=\"application类\"><a href=\"#application类\" class=\"headerlink\" title=\"application类\"></a>application类</h4><ul>\n<li><p><strong>application/json</strong>  </p>\n<p>随着json这种轻量级的数据交互格式的流行，特别是和脚本交互的便利，使得在前后接口中，越来越多采用json格式。对于http协议来说，最终传输的还是字符。这里不再多进行描述。  </p>\n</li>\n<li><p><strong>application/x-www-form-urlencoded</strong><br>作为表单提交中默认的类型，其表明数据以标准的编码格式被编码为键值对。<br>数据被编码成以 ‘&amp;’ 分隔的键-值对, 同时以 ‘=’ 分隔键和值. 非字母或数字的字符会被 percent-encoding: 这也就是为什么这种类型不支持二进制数据的原因 (应使用 multipart/form-data 代替).<br> 我们以新浪为例，可以看到其请求报文(formdata那里选择，view source可以看得比较清楚)：<br><img src=\"https://user-gold-cdn.xitu.io/2019/4/14/16a1c6f743d8b587?w=1600&h=468&f=jpeg&s=128274\">  </p>\n</li>\n<li><p><strong>multipart/form-data</strong><br>这里为了对比，就也放到这里来说了。<br>一般用于涉及文件的表单提交，用于post请求，其格式如下：  </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  Content-Type: multipart/form-data; boundary=aBoundaryString</span><br><span class=\"line\">  ```  </span><br><span class=\"line\">  其中boundary指明了请求体中每部分的分割符(对于multipart的类目，都会存在该字段，以区分请求体中数据的分割)，其请求体中则是对应表单每部分的内容。每部分都会有自己的请求体和相关内容。  </span><br><span class=\"line\">例如如下的文档结构：  </span><br><span class=\"line\">  </span><br><span class=\"line\">```html</span><br><span class=\"line\">  &lt;form action=\"http://localhost:8000/\" method=\"post\" enctype=\"multipart/form-data\"&gt;</span><br><span class=\"line\">  &lt;input type=\"text\" name=\"myTextField\"&gt;</span><br><span class=\"line\">  &lt;input type=\"checkbox\" name=\"myCheckBox\"&gt;Check&lt;/input&gt;</span><br><span class=\"line\">  &lt;input type=\"file\" name=\"myFile\"&gt;</span><br><span class=\"line\">  &lt;button&gt;Send the file&lt;/button&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">其请求信息如下：  </span><br><span class=\"line\"></span><br><span class=\"line\">```js</span><br><span class=\"line\">POST / HTTP/1.1</span><br><span class=\"line\">Host: localhost:8000</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-US,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">// 以 ---------------------------8721656041911415653955004498 作为分割符</span><br><span class=\"line\">Content-Type: multipart/form-data; boundary=---------------------------8721656041911415653955004498</span><br><span class=\"line\">Content-Length: 465</span><br><span class=\"line\"></span><br><span class=\"line\">-----------------------------8721656041911415653955004498</span><br><span class=\"line\">// 分段一 文本相关信息</span><br><span class=\"line\">Content-Disposition: form-data; name=\"myTextField\"</span><br><span class=\"line\">// 对应value</span><br><span class=\"line\">Test</span><br><span class=\"line\">-----------------------------8721656041911415653955004498</span><br><span class=\"line\">// checkbox</span><br><span class=\"line\">Content-Disposition: form-data; name=\"myCheckBox\"</span><br><span class=\"line\"></span><br><span class=\"line\">on</span><br><span class=\"line\">-----------------------------8721656041911415653955004498</span><br><span class=\"line\">// 文件</span><br><span class=\"line\">Content-Disposition: form-data; name=\"myFile\"; filename=\"test.txt\"</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"></span><br><span class=\"line\">Simple file.</span><br><span class=\"line\">-----------------------------8721656041911415653955004498--</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>application/javascript application/x-javascript text/javascript</strong><br>对于js文件，常见MIME类型为text/javascript，但是前两种应该会有见到过。三者之间多少还是有点区别的。<br>传统的js程序对应的MIME类型为text/javascript，其他的还有”application/x-javascript”（x前缀表示这是实验性类型）， 因为text/javascript是最常见的类型，所以RFC4329定义了“text/javascript”。不过，js文件实际上并不是真正的文本类型，因此推出了application/javascript类型，不过现行的支持性并不好，所以常常会用application/x-javascript来代替。   </p>\n</li>\n<li><p><strong>application/zip application/gzip</strong><br> zip 对应zip压缩文件，gzip是若干种文件压缩程序的简称，通常指GNU计划的实现，此处的gzip代表GNU zip。</p>\n</li>\n<li><p><strong>application/http</strong><br> 这一种大家可能就不常见了，从类型可以知道，是http请求，但具体用途还是要翻下<a href=\"https://www.iana.org/assignments/media-types/application/http\" target=\"_blank\" rel=\"noopener\">规范</a>才能找到的。<br> 此类型包含的http请求包含在binary消息体中，在邮件协议传输中需要指明Content-Transfer-Encoding。<br> 在批量处理请求时会遇到，其表现如下：  </p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--batch_0123456789</span><br><span class=\"line\">Content-Type: application/http</span><br><span class=\"line\">Content-ID: </span><br><span class=\"line\"><span class=\"comment\">// 必须的字段，表明传送内容的编码格式 即二进制流</span></span><br><span class=\"line\">Content-Transfer-Encoding: binary</span><br><span class=\"line\"></span><br><span class=\"line\">POST https:<span class=\"comment\">//www.googleapis.com/analytics/v3/management/accounts/XXXXXX/webproperties/UA-XXXXXX-1/customDimensions</span></span><br><span class=\"line\">Content-Type: application/json</span><br><span class=\"line\">Content-Length: <span class=\"number\">68</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Campaign Group\"</span>,</span><br><span class=\"line\"> <span class=\"string\">\"scope\"</span>: <span class=\"string\">\"SESSION\"</span>,</span><br><span class=\"line\"> <span class=\"string\">\"active\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">#### multipart类型</span></span><br><span class=\"line\"><span class=\"string\">正如上文所述，multipart一般对应单个消息头对应多个消息体。</span></span><br><span class=\"line\"><span class=\"string\">常见语法如下:</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08jU534c0p</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">其中boundary字段是必须的，用于区分消息体中的数据边界，一般是两个'-'的格式作为该端的开头，例如：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">--gc0p4Jq0M2Yt08jU534c0p</span><br></pre></td></tr></table></figure>\n<p>我们主要关注的也就是下面几种：  </p>\n<ul>\n<li><p><strong>multipart/form-data</strong><br>见上面application部分。下面这几部分可能不是那么常见，不过还是可以了解一下，以免遇到的时候懵逼。  </p>\n</li>\n<li><p><strong>multipart/mixed</strong><br>该类型用于，消息体由多个独立的部分组成且想连续的展示。并且子数据类型有任一种无法被识别(此处指被浏览器直接识别的类型，例如text等)的类型时，都应该为mixed。<br>概括而言就是该邮件有二进制内容，非可以直接识别的内容  </p>\n</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /batch/farm/v1 HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Authorization: Bearer your_auth_token</span><br><span class=\"line\">Host: www.googleapis.com</span><br><span class=\"line\">Content-Type: multipart/mixed; boundary=batch_foobarbaz</span><br><span class=\"line\">Content-Length: total_content_length</span><br><span class=\"line\"></span><br><span class=\"line\">--batch_foobarbaz</span><br><span class=\"line\"><span class=\"comment\">// 子内容为http请求 不过是boundary编码过的</span></span><br><span class=\"line\">Content-Type: application/http</span><br><span class=\"line\">Content-ID: &lt;item1:12930812@barnyard.example.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">GET /farm/v1/animals/pony</span><br><span class=\"line\"></span><br><span class=\"line\">--batch_foobarbaz</span><br><span class=\"line\">Content-Type: application/http</span><br><span class=\"line\">Content-ID: &lt;item2:12930812@barnyard.example.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">PUT /farm/v1/animals/sheep</span><br><span class=\"line\">Content-Type: application/json</span><br><span class=\"line\">Content-Length: part_content_length</span><br><span class=\"line\">If-Match: \"etag/sheep\"</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \"animalName\": \"sheep\",</span><br><span class=\"line\">  \"animalAge\": \"5\"</span><br><span class=\"line\">  \"peltColor\": \"green\",</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">--batch_foobarbaz</span><br><span class=\"line\">Content-Type: application/http</span><br><span class=\"line\">Content-ID: &lt;item3:12930812@barnyard.example.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">GET /farm/v1/animals</span><br><span class=\"line\">If-None-Match: \"etag/animals\"</span><br><span class=\"line\"></span><br><span class=\"line\">--batch_foobarbaz--</span><br></pre></td></tr></table></figure>\n<p>这里消息体中的内容就是http请求，在google批量接口协议中用使用。</p>\n<ul>\n<li><strong>multipart/alternative</strong><br>该类型与mixed的语法相同，但语义不同。其表明，消息体中的不同部分应该是相同信息的不同版本。即内容相同传输类型不同，以适应不同的接受者。<br>还是举例：  </li>\n</ul>\n<pre><code class=\"js\">From:  Nathaniel Borenstein &lt;nsb@bellcore.com&gt; \nTo: Ned Freed &lt;ned@innosoft.com&gt; \nSubject: Formatted text mail \nMIME-Version: <span class=\"number\">1.0</span> \nContent-Type: multipart/alternative; boundary=boundary42 \n\n\n--boundary42 \nContent-Type: text/plain; charset=us-ascii \n\n...plain text version <span class=\"keyword\">of</span> message goes here.... \n\n--boundary42 \nContent-Type: text/richtext \n\n.... richtext version <span class=\"keyword\">of</span> same message goes here ... \n--boundary42 \nContent-Type: text/x-whatever \n\n.... fanciest formatted version <span class=\"keyword\">of</span> same  message  goes  here \n... \n--boundary42-- \n</code></pre>\n<p>假如用户的系统可以识别 text/x-whatever 类型，那么其将会只看到这一部分。不同的用户看到什么内容取决于其系统支持何种类型。   </p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://developers.google.com/drive/api/v3/batch?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/drive/api/v3/batch?hl=zh-cn</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a><br><a href=\"https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html\" target=\"_blank\" rel=\"noopener\">https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html</a>  </p>\n<p>到这里常见的content-type就介绍完了，感谢以上参考文章，此外水平有限可能有错误之处欢迎指出。对于前端同学来说，网络请求也是我们需要关注的部分，提升深度的同时也要注意落款广度，希望对有需要的同学有所裨益。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为前端开发，工作中少不了与接口请求打交道。对于常见的content-type，也能说上来几个，感觉还算了解。直到有一天，我要在查看google的批量接口合并时发现Content-Type: multipart/mixed以及Content-Type: application/http时，有点措手不及。赶紧深入研究下Content-Type相关内容来弥补下自己的不足，从前端的角度来看看Content-Type。<br>","more":"</p>\n<h2 id=\"Content-Type\"><a href=\"#Content-Type\" class=\"headerlink\" title=\"Content-Type\"></a>Content-Type</h2><p>Content-Type:实体头部用于指示资源的MIME类型。如果未指定 ContentType，默认为text/html<br>有两种场景：<br>在请求中 (如POST 或 PUT)，客户端告诉服务器实际发送的数据类型。</p>\n<p>在响应中，Content-Type标头告诉客户端实际返回的内容的内容类型。浏览器会在某些情况下进行MIME查找，并不一定遵循此标题的值; 为了防止这种行为，可以将标题 X-Content-Type-Options 设置为 nosniff。</p>\n<p>简而言之就是标识资源或者所需资源的MIME类型。  </p>\n<p>句法如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: text/html; charset=utf-8</span><br><span class=\"line\">Content-Type: multipart/form-data; boundary=something</span><br></pre></td></tr></table></figure>\n<p>参数一般media-type、charset、boundary三种。<br>我们的关注点在于media-type的取值以及其适用场景。</p>\n<h3 id=\"media-type\"><a href=\"#media-type\" class=\"headerlink\" title=\"media-type\"></a>media-type</h3><p>更多的是作为MIME type( Multipurpose Internet Mail Extensions)出现，即多用途Internet邮件扩展。<br>其目的是用一种标准化的方式来标识文档的性质和格式。<br>浏览器通常使用MIME类型（而不是文件扩展名）来确定如何处理文档；<br>因此服务器设置正确以将正确的MIME类型附加到响应对象的头部是非常重要的。  </p>\n<h4 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h4><p>MIME 组成结构如下：<br>由类型与子类型两个字符串中间用’/‘分隔而组成。不允许空格存在。对大小写不敏感，但传统都是小写。<br>允许额外参数，如后面所示：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type/subtype;parameter=value</span><br></pre></td></tr></table></figure>\n<p>其中：</p>\n<ul>\n<li>type对应通用类目，例如：text/video等。</li>\n<li>subtype对应准确的子类，例如text下面细分为plain(纯文本)、html(html源码)、calendar（.ics）文件等。</li>\n<li>parameter可选一般是charset或者bundaary等。</li>\n</ul>\n<h3 id=\"Types\"><a href=\"#Types\" class=\"headerlink\" title=\"Types\"></a>Types</h3><p>类目包括两种类型：独立类型和Multipart类型。</p>\n<h4 id=\"独立类型\"><a href=\"#独立类型\" class=\"headerlink\" title=\"独立类型\"></a>独立类型</h4><p>独立类型指只代表一个单独的文件或者媒体的类型，表明了对文件的分类。<br>常见类型和实例如下：</p>\n<ul>\n<li>text<br>文本数据包括一些人类可读的内容或者源码。例如：text/plain, text/csv, text/html.</li>\n<li>application<br>数据为二进制的一种，例如application/octet-stream,application/pdf,application/pkcs8,application/zip.  </li>\n<li>audio<br>音频或者音乐数据，例如audio/mpeg, audio/vorbis</li>\n<li>video<br>视频数据或者文件，例如video/mp4</li>\n<li>image<br>图像或图形数据，包括位图和矢量静止图像以及静止图像格式的动画版本。例如image/gif, image/png, image/jpeg, image/bmp, image/webp, image/x-icon</li>\n</ul>\n<h4 id=\"Multipart类型\"><a href=\"#Multipart类型\" class=\"headerlink\" title=\"Multipart类型\"></a>Multipart类型</h4><p>Multipart类型指明被分为几部分的一种文档的类目，且经常有不同的MIME类型。也可以用来表示属于相同事物的多个且独立的文件，这些独立的文件构成一个复杂的文档。在电子邮件场景中常见。<br>有两种Multipart类型：message和multipart。</p>\n<ul>\n<li>message<br>一个包括其他信息的消息，常用于下面的场景，例如指明一个邮件包含转发信息或者在多种信息的情况下，允许以chunk的形式发送数据量很大的信息。包括message/rfc822和message/partial</li>\n<li>multipart<br>由多个不同MIME类型组件构成的数据，例如 multipart/form-data(使用FormData API生成的数据) </li>\n</ul>\n<p>看完了基本定义，下面看看常见的类型及使用场景。</p>\n<h3 id=\"常见类型及使用场景\"><a href=\"#常见类型及使用场景\" class=\"headerlink\" title=\"常见类型及使用场景\"></a>常见类型及使用场景</h3><h4 id=\"静态资源、图片、媒体类\"><a href=\"#静态资源、图片、媒体类\" class=\"headerlink\" title=\"静态资源、图片、媒体类\"></a>静态资源、图片、媒体类</h4><p>对于静态资源、图片和媒体类，也就是text、image、video等比较清晰明了，不再详细描述。</p>\n<h4 id=\"application类\"><a href=\"#application类\" class=\"headerlink\" title=\"application类\"></a>application类</h4><ul>\n<li><p><strong>application/json</strong>  </p>\n<p>随着json这种轻量级的数据交互格式的流行，特别是和脚本交互的便利，使得在前后接口中，越来越多采用json格式。对于http协议来说，最终传输的还是字符。这里不再多进行描述。  </p>\n</li>\n<li><p><strong>application/x-www-form-urlencoded</strong><br>作为表单提交中默认的类型，其表明数据以标准的编码格式被编码为键值对。<br>数据被编码成以 ‘&amp;’ 分隔的键-值对, 同时以 ‘=’ 分隔键和值. 非字母或数字的字符会被 percent-encoding: 这也就是为什么这种类型不支持二进制数据的原因 (应使用 multipart/form-data 代替).<br> 我们以新浪为例，可以看到其请求报文(formdata那里选择，view source可以看得比较清楚)：<br><img src=\"https://user-gold-cdn.xitu.io/2019/4/14/16a1c6f743d8b587?w=1600&h=468&f=jpeg&s=128274\">  </p>\n</li>\n<li><p><strong>multipart/form-data</strong><br>这里为了对比，就也放到这里来说了。<br>一般用于涉及文件的表单提交，用于post请求，其格式如下：  </p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  Content-Type: multipart/form-data; boundary=aBoundaryString</span><br><span class=\"line\">  ```  </span><br><span class=\"line\">  其中boundary指明了请求体中每部分的分割符(对于multipart的类目，都会存在该字段，以区分请求体中数据的分割)，其请求体中则是对应表单每部分的内容。每部分都会有自己的请求体和相关内容。  </span><br><span class=\"line\">例如如下的文档结构：  </span><br><span class=\"line\">  </span><br><span class=\"line\">```html</span><br><span class=\"line\">  &lt;form action=\"http://localhost:8000/\" method=\"post\" enctype=\"multipart/form-data\"&gt;</span><br><span class=\"line\">  &lt;input type=\"text\" name=\"myTextField\"&gt;</span><br><span class=\"line\">  &lt;input type=\"checkbox\" name=\"myCheckBox\"&gt;Check&lt;/input&gt;</span><br><span class=\"line\">  &lt;input type=\"file\" name=\"myFile\"&gt;</span><br><span class=\"line\">  &lt;button&gt;Send the file&lt;/button&gt;</span><br><span class=\"line\">&lt;/form&gt;</span><br><span class=\"line\">```   </span><br><span class=\"line\"></span><br><span class=\"line\">其请求信息如下：  </span><br><span class=\"line\"></span><br><span class=\"line\">```js</span><br><span class=\"line\">POST / HTTP/1.1</span><br><span class=\"line\">Host: localhost:8000</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0</span><br><span class=\"line\">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class=\"line\">Accept-Language: en-US,en;q=0.5</span><br><span class=\"line\">Accept-Encoding: gzip, deflate</span><br><span class=\"line\">Connection: keep-alive</span><br><span class=\"line\">Upgrade-Insecure-Requests: 1</span><br><span class=\"line\">// 以 ---------------------------8721656041911415653955004498 作为分割符</span><br><span class=\"line\">Content-Type: multipart/form-data; boundary=---------------------------8721656041911415653955004498</span><br><span class=\"line\">Content-Length: 465</span><br><span class=\"line\"></span><br><span class=\"line\">-----------------------------8721656041911415653955004498</span><br><span class=\"line\">// 分段一 文本相关信息</span><br><span class=\"line\">Content-Disposition: form-data; name=\"myTextField\"</span><br><span class=\"line\">// 对应value</span><br><span class=\"line\">Test</span><br><span class=\"line\">-----------------------------8721656041911415653955004498</span><br><span class=\"line\">// checkbox</span><br><span class=\"line\">Content-Disposition: form-data; name=\"myCheckBox\"</span><br><span class=\"line\"></span><br><span class=\"line\">on</span><br><span class=\"line\">-----------------------------8721656041911415653955004498</span><br><span class=\"line\">// 文件</span><br><span class=\"line\">Content-Disposition: form-data; name=\"myFile\"; filename=\"test.txt\"</span><br><span class=\"line\">Content-Type: text/plain</span><br><span class=\"line\"></span><br><span class=\"line\">Simple file.</span><br><span class=\"line\">-----------------------------8721656041911415653955004498--</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>application/javascript application/x-javascript text/javascript</strong><br>对于js文件，常见MIME类型为text/javascript，但是前两种应该会有见到过。三者之间多少还是有点区别的。<br>传统的js程序对应的MIME类型为text/javascript，其他的还有”application/x-javascript”（x前缀表示这是实验性类型）， 因为text/javascript是最常见的类型，所以RFC4329定义了“text/javascript”。不过，js文件实际上并不是真正的文本类型，因此推出了application/javascript类型，不过现行的支持性并不好，所以常常会用application/x-javascript来代替。   </p>\n</li>\n<li><p><strong>application/zip application/gzip</strong><br> zip 对应zip压缩文件，gzip是若干种文件压缩程序的简称，通常指GNU计划的实现，此处的gzip代表GNU zip。</p>\n</li>\n<li><p><strong>application/http</strong><br> 这一种大家可能就不常见了，从类型可以知道，是http请求，但具体用途还是要翻下<a href=\"https://www.iana.org/assignments/media-types/application/http\" target=\"_blank\" rel=\"noopener\">规范</a>才能找到的。<br> 此类型包含的http请求包含在binary消息体中，在邮件协议传输中需要指明Content-Transfer-Encoding。<br> 在批量处理请求时会遇到，其表现如下：  </p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--batch_0123456789</span><br><span class=\"line\">Content-Type: application/http</span><br><span class=\"line\">Content-ID: </span><br><span class=\"line\"><span class=\"comment\">// 必须的字段，表明传送内容的编码格式 即二进制流</span></span><br><span class=\"line\">Content-Transfer-Encoding: binary</span><br><span class=\"line\"></span><br><span class=\"line\">POST https:<span class=\"comment\">//www.googleapis.com/analytics/v3/management/accounts/XXXXXX/webproperties/UA-XXXXXX-1/customDimensions</span></span><br><span class=\"line\">Content-Type: application/json</span><br><span class=\"line\">Content-Length: <span class=\"number\">68</span></span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Campaign Group\"</span>,</span><br><span class=\"line\"> <span class=\"string\">\"scope\"</span>: <span class=\"string\">\"SESSION\"</span>,</span><br><span class=\"line\"> <span class=\"string\">\"active\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125; </span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">#### multipart类型</span></span><br><span class=\"line\"><span class=\"string\">正如上文所述，multipart一般对应单个消息头对应多个消息体。</span></span><br><span class=\"line\"><span class=\"string\">常见语法如下:</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">Content-Type: multipart/mixed; boundary=gc0p4Jq0M2Yt08jU534c0p</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">其中boundary字段是必须的，用于区分消息体中的数据边界，一般是两个'-'的格式作为该端的开头，例如：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">--gc0p4Jq0M2Yt08jU534c0p</span><br></pre></td></tr></table></figure>\n<p>我们主要关注的也就是下面几种：  </p>\n<ul>\n<li><p><strong>multipart/form-data</strong><br>见上面application部分。下面这几部分可能不是那么常见，不过还是可以了解一下，以免遇到的时候懵逼。  </p>\n</li>\n<li><p><strong>multipart/mixed</strong><br>该类型用于，消息体由多个独立的部分组成且想连续的展示。并且子数据类型有任一种无法被识别(此处指被浏览器直接识别的类型，例如text等)的类型时，都应该为mixed。<br>概括而言就是该邮件有二进制内容，非可以直接识别的内容  </p>\n</li>\n</ul>\n<p>例如：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST /batch/farm/v1 HTTP/<span class=\"number\">1.1</span></span><br><span class=\"line\">Authorization: Bearer your_auth_token</span><br><span class=\"line\">Host: www.googleapis.com</span><br><span class=\"line\">Content-Type: multipart/mixed; boundary=batch_foobarbaz</span><br><span class=\"line\">Content-Length: total_content_length</span><br><span class=\"line\"></span><br><span class=\"line\">--batch_foobarbaz</span><br><span class=\"line\"><span class=\"comment\">// 子内容为http请求 不过是boundary编码过的</span></span><br><span class=\"line\">Content-Type: application/http</span><br><span class=\"line\">Content-ID: &lt;item1:12930812@barnyard.example.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">GET /farm/v1/animals/pony</span><br><span class=\"line\"></span><br><span class=\"line\">--batch_foobarbaz</span><br><span class=\"line\">Content-Type: application/http</span><br><span class=\"line\">Content-ID: &lt;item2:12930812@barnyard.example.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">PUT /farm/v1/animals/sheep</span><br><span class=\"line\">Content-Type: application/json</span><br><span class=\"line\">Content-Length: part_content_length</span><br><span class=\"line\">If-Match: \"etag/sheep\"</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  \"animalName\": \"sheep\",</span><br><span class=\"line\">  \"animalAge\": \"5\"</span><br><span class=\"line\">  \"peltColor\": \"green\",</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">--batch_foobarbaz</span><br><span class=\"line\">Content-Type: application/http</span><br><span class=\"line\">Content-ID: &lt;item3:12930812@barnyard.example.com&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">GET /farm/v1/animals</span><br><span class=\"line\">If-None-Match: \"etag/animals\"</span><br><span class=\"line\"></span><br><span class=\"line\">--batch_foobarbaz--</span><br></pre></td></tr></table></figure>\n<p>这里消息体中的内容就是http请求，在google批量接口协议中用使用。</p>\n<ul>\n<li><strong>multipart/alternative</strong><br>该类型与mixed的语法相同，但语义不同。其表明，消息体中的不同部分应该是相同信息的不同版本。即内容相同传输类型不同，以适应不同的接受者。<br>还是举例：  </li>\n</ul>\n<pre><code class=\"js\">From:  Nathaniel Borenstein &lt;nsb@bellcore.com&gt; \nTo: Ned Freed &lt;ned@innosoft.com&gt; \nSubject: Formatted text mail \nMIME-Version: <span class=\"number\">1.0</span> \nContent-Type: multipart/alternative; boundary=boundary42 \n\n\n--boundary42 \nContent-Type: text/plain; charset=us-ascii \n\n...plain text version <span class=\"keyword\">of</span> message goes here.... \n\n--boundary42 \nContent-Type: text/richtext \n\n.... richtext version <span class=\"keyword\">of</span> same message goes here ... \n--boundary42 \nContent-Type: text/x-whatever \n\n.... fanciest formatted version <span class=\"keyword\">of</span> same  message  goes  here \n... \n--boundary42-- \n</code></pre>\n<p>假如用户的系统可以识别 text/x-whatever 类型，那么其将会只看到这一部分。不同的用户看到什么内容取决于其系统支持何种类型。   </p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://developers.google.com/drive/api/v3/batch?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">https://developers.google.com/drive/api/v3/batch?hl=zh-cn</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types</a><br><a href=\"https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html\" target=\"_blank\" rel=\"noopener\">https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html</a>  </p>\n<p>到这里常见的content-type就介绍完了，感谢以上参考文章，此外水平有限可能有错误之处欢迎指出。对于前端同学来说，网络请求也是我们需要关注的部分，提升深度的同时也要注意落款广度，希望对有需要的同学有所裨益。</p>"},{"title":"回顾数据结构体系","date":"2019-11-14T16:00:00.000Z","_content":"\n## 前言 \n作为前端，随着职业的发展，自然会进阶到需要使用算法和数据结构的地步，例如开发相应的工具，或者需要考虑性能的特殊场景。另外就是作为程序员的基本要素，还是需要拾起这部分内容的。  \n\n<!-- more -->\n\n## 基本数据结构  \n\n### 链表\n用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。  就不适用太官方的话语了。  \n通过节点指向下一个元素的数据结构，虽然是线性，但物理结构上并不体现该顺序，关联关系通过节点元素维护。  \n所以缺点和优点都比较明显：  \n    \n    * 缺点： 遍历时相比于数组等物理线性，速度较慢\n    * 优点：正是物理地址不相连，插入删除都比较灵活，直接改变指向就行了。  \n\n链表在开发中也是经常用到的数据结构，React16的 Fiber Node连接起来形成的Fiber Tree, 就是个单链表结构。  \n\n节点特点：\n两个值，value和link \n\n列表功能：\n1、查找\n2、删除\n3、移动\n4、插入\n\n#### 实现链表结构\n\n```js\n// 节点，维护两个值，一是当前值，另外就是其他位置\nfunction Node(element) {\n    this.element = element;   //当前节点的元素\n    this.next = null;         //下一个节点链接\n}\n\n// 链表\nfunction LList () {\n    this.head = new Node( 'head' );     //头节点\n    this.find = find;                   //查找节点\n    this.insert = insert;               //插入节点\n    this.remove = remove;               //删除节点\n    this.findPrev = findPrev;           //查找前一个节点\n    this.display = display;             //显示链表\n} \n```\n\n常见题目也是实现功能：\n#### 查找所有节点，并列出当前值\n实现思路就是\n\n\n\n","source":"_posts/data-structure.md","raw":"---\ntitle: 回顾数据结构体系\ndate: 2019-11-15\n---\n\n## 前言 \n作为前端，随着职业的发展，自然会进阶到需要使用算法和数据结构的地步，例如开发相应的工具，或者需要考虑性能的特殊场景。另外就是作为程序员的基本要素，还是需要拾起这部分内容的。  \n\n<!-- more -->\n\n## 基本数据结构  \n\n### 链表\n用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。  就不适用太官方的话语了。  \n通过节点指向下一个元素的数据结构，虽然是线性，但物理结构上并不体现该顺序，关联关系通过节点元素维护。  \n所以缺点和优点都比较明显：  \n    \n    * 缺点： 遍历时相比于数组等物理线性，速度较慢\n    * 优点：正是物理地址不相连，插入删除都比较灵活，直接改变指向就行了。  \n\n链表在开发中也是经常用到的数据结构，React16的 Fiber Node连接起来形成的Fiber Tree, 就是个单链表结构。  \n\n节点特点：\n两个值，value和link \n\n列表功能：\n1、查找\n2、删除\n3、移动\n4、插入\n\n#### 实现链表结构\n\n```js\n// 节点，维护两个值，一是当前值，另外就是其他位置\nfunction Node(element) {\n    this.element = element;   //当前节点的元素\n    this.next = null;         //下一个节点链接\n}\n\n// 链表\nfunction LList () {\n    this.head = new Node( 'head' );     //头节点\n    this.find = find;                   //查找节点\n    this.insert = insert;               //插入节点\n    this.remove = remove;               //删除节点\n    this.findPrev = findPrev;           //查找前一个节点\n    this.display = display;             //显示链表\n} \n```\n\n常见题目也是实现功能：\n#### 查找所有节点，并列出当前值\n实现思路就是\n\n\n\n","slug":"data-structure","published":1,"updated":"2019-11-05T11:39:11.749Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1h000fgw92x656xgzi","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为前端，随着职业的发展，自然会进阶到需要使用算法和数据结构的地步，例如开发相应的工具，或者需要考虑性能的特殊场景。另外就是作为程序员的基本要素，还是需要拾起这部分内容的。  </p>\n<a id=\"more\"></a>\n<h2 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h2><h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><p>用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。  就不适用太官方的话语了。<br>通过节点指向下一个元素的数据结构，虽然是线性，但物理结构上并不体现该顺序，关联关系通过节点元素维护。<br>所以缺点和优点都比较明显：  </p>\n<pre><code>* 缺点： 遍历时相比于数组等物理线性，速度较慢\n* 优点：正是物理地址不相连，插入删除都比较灵活，直接改变指向就行了。  \n</code></pre><p>链表在开发中也是经常用到的数据结构，React16的 Fiber Node连接起来形成的Fiber Tree, 就是个单链表结构。  </p>\n<p>节点特点：<br>两个值，value和link </p>\n<p>列表功能：<br>1、查找<br>2、删除<br>3、移动<br>4、插入</p>\n<h4 id=\"实现链表结构\"><a href=\"#实现链表结构\" class=\"headerlink\" title=\"实现链表结构\"></a>实现链表结构</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 节点，维护两个值，一是当前值，另外就是其他位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Node</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;   <span class=\"comment\">//当前节点的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span>;         <span class=\"comment\">//下一个节点链接</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LList</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"keyword\">new</span> Node( <span class=\"string\">'head'</span> );     <span class=\"comment\">//头节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.find = find;                   <span class=\"comment\">//查找节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.insert = insert;               <span class=\"comment\">//插入节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.remove = remove;               <span class=\"comment\">//删除节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.findPrev = findPrev;           <span class=\"comment\">//查找前一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.display = display;             <span class=\"comment\">//显示链表</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>常见题目也是实现功能：</p>\n<h4 id=\"查找所有节点，并列出当前值\"><a href=\"#查找所有节点，并列出当前值\" class=\"headerlink\" title=\"查找所有节点，并列出当前值\"></a>查找所有节点，并列出当前值</h4><p>实现思路就是</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为前端，随着职业的发展，自然会进阶到需要使用算法和数据结构的地步，例如开发相应的工具，或者需要考虑性能的特殊场景。另外就是作为程序员的基本要素，还是需要拾起这部分内容的。  </p>","more":"<h2 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h2><h3 id=\"链表\"><a href=\"#链表\" class=\"headerlink\" title=\"链表\"></a>链表</h3><p>用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。  就不适用太官方的话语了。<br>通过节点指向下一个元素的数据结构，虽然是线性，但物理结构上并不体现该顺序，关联关系通过节点元素维护。<br>所以缺点和优点都比较明显：  </p>\n<pre><code>* 缺点： 遍历时相比于数组等物理线性，速度较慢\n* 优点：正是物理地址不相连，插入删除都比较灵活，直接改变指向就行了。  \n</code></pre><p>链表在开发中也是经常用到的数据结构，React16的 Fiber Node连接起来形成的Fiber Tree, 就是个单链表结构。  </p>\n<p>节点特点：<br>两个值，value和link </p>\n<p>列表功能：<br>1、查找<br>2、删除<br>3、移动<br>4、插入</p>\n<h4 id=\"实现链表结构\"><a href=\"#实现链表结构\" class=\"headerlink\" title=\"实现链表结构\"></a>实现链表结构</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 节点，维护两个值，一是当前值，另外就是其他位置</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Node</span>(<span class=\"params\">element</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.element = element;   <span class=\"comment\">//当前节点的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.next = <span class=\"literal\">null</span>;         <span class=\"comment\">//下一个节点链接</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 链表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">LList</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.head = <span class=\"keyword\">new</span> Node( <span class=\"string\">'head'</span> );     <span class=\"comment\">//头节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.find = find;                   <span class=\"comment\">//查找节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.insert = insert;               <span class=\"comment\">//插入节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.remove = remove;               <span class=\"comment\">//删除节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.findPrev = findPrev;           <span class=\"comment\">//查找前一个节点</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.display = display;             <span class=\"comment\">//显示链表</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>常见题目也是实现功能：</p>\n<h4 id=\"查找所有节点，并列出当前值\"><a href=\"#查找所有节点，并列出当前值\" class=\"headerlink\" title=\"查找所有节点，并列出当前值\"></a>查找所有节点，并列出当前值</h4><p>实现思路就是</p>"},{"title":"仓库管理模式","date":"2019-12-30T00:00:29.000Z","_content":"# 仓库管理方式\n\n## 前言\n随着功能和业务量级的飙升，前端代码量级也越来越大，再加上后续管理运维，代码仓库的运营管理挑战也浮出水面。主流方案有两种：一是multirepo式的分散式的独立仓库，二是monorepo式的集中管理，各有千秋，下面就结合实际场景一起深入了解下。\n\n## 分散式管理-multirepo\n即按照功能或者其他维度，将项目拆分为不同模块单独维护于各自仓库中。\n\n### 使用场景\n对于敏捷迭代快速开发的新需求，常规做法就是每个模块对应一个仓库，新的需求进行归类，可归入已有仓库则进行迭代，不满足则新建仓库。\n\n### 优势\n#### 1.灵活\n不同模块独立维护，与其他模块天然隔离。各个模块可以选择适合自己的风格、工具等。\n\n#### 2.安全\n得益于模块的拆分，权限控制较为自然。  \n开发时只关注相关部分，不会误操作其他内容。\n发布上线，对其他模块无感知。\n\n### 问题\n作为传统的管理组织方式，发展演进这么久，必然会存在一些限制。突出体现在协作和管理成本上。  \n\n#### 1. 管理成本\n常见的项目交接时，每个人都负责了一堆项目、账号等，只能手动梳理，还存在漏掉的可能。我当初经历过几次大的调整，交接的真是一脸懵逼和心痛。来个需求才发现还有个仓库一直处于遗忘的角落。\n\n#### 2. 协作成本\n涉及多个项目开发时，本地开发需要打开多个IDE在其中切换。  \n对于本地调试等也是个繁琐的过程，虽然存在npm link等方式。\n\n#### 3. 依赖升级\n这种场景一般出现在依赖的核心模块上，特别是自行开发的基础依赖，不得不升级时简直一言难尽，数目直逼上百的项目，每个都要修改发布一次。\n\n上面说的是业务模块，对于开源或者公司内部基础性工具，升级这里的问题更显著一些。对于程序员俩说，出现问题解决问题就是，因此集中式的管理模式就出现了。\n\n## 集中式管理monorepo\nmonorepo 的核心观点是所有的项目在一个代码仓库中。严格的统一和收归，以利于统一的升级和管理。\n不过这并不是说代码没有组织的随意存放。相反，在文件目录上体现出管理结构的要求更高，否则可维护性更低。\n例如Babel，每个模块都在指定的packages目录下。\n### 优势\n既然是基于问题的演进，其实优势比较明显，就是multirepo的局限的解决。\n例如协作、运营管理等成本降低。  \n不过monorepo也不全是益处，相反其局限也比较明显。\n### 问题 \n\n#### 1. 项目体积增加\n随着项目的发展，体积会逐渐增大，甚至成为巨无霸项目体积几个G。\n自然带来一些问题：\n\n* 拉取时间边长\n  拿babel举个例子，虽然只有130M，但时间已经增加不少，更遑论上G的存在。![Jietu20191231-094925-HD](media/15771585486438/Jietu20191231-094925-HD.gif)\n\n* 编译时间很慢\n  很自然，如果每次还是全部编译的话，开发、部署时的等待时间会相当的长\n\n  \n#### 2. 安全性\n全部功能就这样暴露在所有开发者面前，安全性是个大问题。  \n误操作的可能性，如果仅仅寄希望于开发者素质和codereview时的人工复检是不可靠的。\n \n### 解决方案\n当然对于比较成熟的模式，解决方案也是形成了沉淀的。\n \n#### 1. 多模块管理工具\n针对复杂的项目模块，自然需要有贴合实际的管理工具。  \n例如[lerna](https://github.com/lerna/lerna)，自我定位就是:  \nA tool for managing JavaScript projects with multiple packages\n至于详细用法，大家可以通过官网查看。\n\n#### 2. git稀疏检出 \n\n针对开发者只关注相应内容的解决方案可以依托git来实现的。\nGit在1.7版本后，已经支持只Checkout部分内容，即稀疏检出(sparse checkout)\n \n稀疏检出就是本地版本库检出时不检出全部，只将指定的文件从本地版本库检出到工作区，而其他未指定的文件则不予检出（即使这些文件存在于工作区，其修改也会被忽略）。 \n\n也就是我们可以在工作区只关注相关的模块，虽然文件全部pull了下来，但展示和管理式会忽略其他文件，即使展示了其他文件并进行了修改，修改依然会被忽略。\n例如babel中我们只展示 babel-cli 内容部分，操作如下：\n\n```bash\n// 创建文件夹\nmkdir demo && cd demo\n// 初始化git \ngit init\ngit remote add origin https://github.com/babel/babel.git\n// 打开 开关 \ngit config core.sparsecheckout true\n// 指定目录\necho \"packages/babel-cli/\" >> .git/info/sparse-checkout\n// 获取代码\ngit pull origin master\n```  \n这样，我们ls可以查看到文件内容只有：\n\n```bash\npackages/babel-cli\n```\n\n如果需要修改展示目录，直接修改.git/info/sparse-checkout，即可，然后重新进行checkout \n \n```bash\necho \"packages/babel-cli/\" >> .git/info/sparse-checkout\ngit checkout master\n```\n这样增加了安全性。\n\n#### 扩展-浅克隆\n\n稀疏检出只是展示上的部分，本身仍然包含所有的文件和历史。如果只关注最近的提交，可以通过浅克隆实现。\n使用：\n```js\ngit clone --depth 2 https://github.com/babel/babel.git\n```\n\n不过浅克隆限制较多，一般用于对远程版本库的查看和研究。\n\n* 不能从浅克隆版本库克隆出新的版本库。\n* 其他版本库不能从浅克隆获取提交。\n* 其他版本库不能推送提交到浅克隆版本库。\n* 不要从浅克隆版本库推送提交至其他版本库，除非确认推送的目标版本库包含浅克隆版本库中缺失的全部历史提交，否则会造成目标版本库包含不完整的提交历史导致版本库无法操作。\n* 在浅克隆版本库中执行合并操作时，如果所合并的提交出现在浅克隆历史中，则可以顺利合并，否则会出现大量的冲突，就好像和无关的历史进行合并一样。\n\n\n## 结束语\n本文简单介绍了不同的仓库管理模式理念和一些实践方式，个人理解有限，抛砖引玉，欢迎一起讨论。更多内容请转[雨打梨梦三村边](http://xxdy.tech/)，同时感谢以下参考文章。。\n\n### 参考文章\n* [https://www.kloia.com/blog/monorepo-or-multirepo](https://www.kloia.com/blog/monorepo-or-multirepo)\n* [https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html](https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html)  \n* [https://zhuanlan.zhihu.com/p/31289463](https://zhuanlan.zhihu.com/p/31289463)\n\n\n\n","source":"_posts/gitcheckout.md","raw":"---\ntitle: 仓库管理模式\ndate: 2019-12-30 08:00:29\ntags: 前端 工程结构\n---\n# 仓库管理方式\n\n## 前言\n随着功能和业务量级的飙升，前端代码量级也越来越大，再加上后续管理运维，代码仓库的运营管理挑战也浮出水面。主流方案有两种：一是multirepo式的分散式的独立仓库，二是monorepo式的集中管理，各有千秋，下面就结合实际场景一起深入了解下。\n\n## 分散式管理-multirepo\n即按照功能或者其他维度，将项目拆分为不同模块单独维护于各自仓库中。\n\n### 使用场景\n对于敏捷迭代快速开发的新需求，常规做法就是每个模块对应一个仓库，新的需求进行归类，可归入已有仓库则进行迭代，不满足则新建仓库。\n\n### 优势\n#### 1.灵活\n不同模块独立维护，与其他模块天然隔离。各个模块可以选择适合自己的风格、工具等。\n\n#### 2.安全\n得益于模块的拆分，权限控制较为自然。  \n开发时只关注相关部分，不会误操作其他内容。\n发布上线，对其他模块无感知。\n\n### 问题\n作为传统的管理组织方式，发展演进这么久，必然会存在一些限制。突出体现在协作和管理成本上。  \n\n#### 1. 管理成本\n常见的项目交接时，每个人都负责了一堆项目、账号等，只能手动梳理，还存在漏掉的可能。我当初经历过几次大的调整，交接的真是一脸懵逼和心痛。来个需求才发现还有个仓库一直处于遗忘的角落。\n\n#### 2. 协作成本\n涉及多个项目开发时，本地开发需要打开多个IDE在其中切换。  \n对于本地调试等也是个繁琐的过程，虽然存在npm link等方式。\n\n#### 3. 依赖升级\n这种场景一般出现在依赖的核心模块上，特别是自行开发的基础依赖，不得不升级时简直一言难尽，数目直逼上百的项目，每个都要修改发布一次。\n\n上面说的是业务模块，对于开源或者公司内部基础性工具，升级这里的问题更显著一些。对于程序员俩说，出现问题解决问题就是，因此集中式的管理模式就出现了。\n\n## 集中式管理monorepo\nmonorepo 的核心观点是所有的项目在一个代码仓库中。严格的统一和收归，以利于统一的升级和管理。\n不过这并不是说代码没有组织的随意存放。相反，在文件目录上体现出管理结构的要求更高，否则可维护性更低。\n例如Babel，每个模块都在指定的packages目录下。\n### 优势\n既然是基于问题的演进，其实优势比较明显，就是multirepo的局限的解决。\n例如协作、运营管理等成本降低。  \n不过monorepo也不全是益处，相反其局限也比较明显。\n### 问题 \n\n#### 1. 项目体积增加\n随着项目的发展，体积会逐渐增大，甚至成为巨无霸项目体积几个G。\n自然带来一些问题：\n\n* 拉取时间边长\n  拿babel举个例子，虽然只有130M，但时间已经增加不少，更遑论上G的存在。![Jietu20191231-094925-HD](media/15771585486438/Jietu20191231-094925-HD.gif)\n\n* 编译时间很慢\n  很自然，如果每次还是全部编译的话，开发、部署时的等待时间会相当的长\n\n  \n#### 2. 安全性\n全部功能就这样暴露在所有开发者面前，安全性是个大问题。  \n误操作的可能性，如果仅仅寄希望于开发者素质和codereview时的人工复检是不可靠的。\n \n### 解决方案\n当然对于比较成熟的模式，解决方案也是形成了沉淀的。\n \n#### 1. 多模块管理工具\n针对复杂的项目模块，自然需要有贴合实际的管理工具。  \n例如[lerna](https://github.com/lerna/lerna)，自我定位就是:  \nA tool for managing JavaScript projects with multiple packages\n至于详细用法，大家可以通过官网查看。\n\n#### 2. git稀疏检出 \n\n针对开发者只关注相应内容的解决方案可以依托git来实现的。\nGit在1.7版本后，已经支持只Checkout部分内容，即稀疏检出(sparse checkout)\n \n稀疏检出就是本地版本库检出时不检出全部，只将指定的文件从本地版本库检出到工作区，而其他未指定的文件则不予检出（即使这些文件存在于工作区，其修改也会被忽略）。 \n\n也就是我们可以在工作区只关注相关的模块，虽然文件全部pull了下来，但展示和管理式会忽略其他文件，即使展示了其他文件并进行了修改，修改依然会被忽略。\n例如babel中我们只展示 babel-cli 内容部分，操作如下：\n\n```bash\n// 创建文件夹\nmkdir demo && cd demo\n// 初始化git \ngit init\ngit remote add origin https://github.com/babel/babel.git\n// 打开 开关 \ngit config core.sparsecheckout true\n// 指定目录\necho \"packages/babel-cli/\" >> .git/info/sparse-checkout\n// 获取代码\ngit pull origin master\n```  \n这样，我们ls可以查看到文件内容只有：\n\n```bash\npackages/babel-cli\n```\n\n如果需要修改展示目录，直接修改.git/info/sparse-checkout，即可，然后重新进行checkout \n \n```bash\necho \"packages/babel-cli/\" >> .git/info/sparse-checkout\ngit checkout master\n```\n这样增加了安全性。\n\n#### 扩展-浅克隆\n\n稀疏检出只是展示上的部分，本身仍然包含所有的文件和历史。如果只关注最近的提交，可以通过浅克隆实现。\n使用：\n```js\ngit clone --depth 2 https://github.com/babel/babel.git\n```\n\n不过浅克隆限制较多，一般用于对远程版本库的查看和研究。\n\n* 不能从浅克隆版本库克隆出新的版本库。\n* 其他版本库不能从浅克隆获取提交。\n* 其他版本库不能推送提交到浅克隆版本库。\n* 不要从浅克隆版本库推送提交至其他版本库，除非确认推送的目标版本库包含浅克隆版本库中缺失的全部历史提交，否则会造成目标版本库包含不完整的提交历史导致版本库无法操作。\n* 在浅克隆版本库中执行合并操作时，如果所合并的提交出现在浅克隆历史中，则可以顺利合并，否则会出现大量的冲突，就好像和无关的历史进行合并一样。\n\n\n## 结束语\n本文简单介绍了不同的仓库管理模式理念和一些实践方式，个人理解有限，抛砖引玉，欢迎一起讨论。更多内容请转[雨打梨梦三村边](http://xxdy.tech/)，同时感谢以下参考文章。。\n\n### 参考文章\n* [https://www.kloia.com/blog/monorepo-or-multirepo](https://www.kloia.com/blog/monorepo-or-multirepo)\n* [https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html](https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html)  \n* [https://zhuanlan.zhihu.com/p/31289463](https://zhuanlan.zhihu.com/p/31289463)\n\n\n\n","slug":"gitcheckout","published":1,"updated":"2019-12-31T03:44:40.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1j000hgw923edlvxr9","content":"<h1 id=\"仓库管理方式\"><a href=\"#仓库管理方式\" class=\"headerlink\" title=\"仓库管理方式\"></a>仓库管理方式</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>随着功能和业务量级的飙升，前端代码量级也越来越大，再加上后续管理运维，代码仓库的运营管理挑战也浮出水面。主流方案有两种：一是multirepo式的分散式的独立仓库，二是monorepo式的集中管理，各有千秋，下面就结合实际场景一起深入了解下。</p>\n<h2 id=\"分散式管理-multirepo\"><a href=\"#分散式管理-multirepo\" class=\"headerlink\" title=\"分散式管理-multirepo\"></a>分散式管理-multirepo</h2><p>即按照功能或者其他维度，将项目拆分为不同模块单独维护于各自仓库中。</p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>对于敏捷迭代快速开发的新需求，常规做法就是每个模块对应一个仓库，新的需求进行归类，可归入已有仓库则进行迭代，不满足则新建仓库。</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><h4 id=\"1-灵活\"><a href=\"#1-灵活\" class=\"headerlink\" title=\"1.灵活\"></a>1.灵活</h4><p>不同模块独立维护，与其他模块天然隔离。各个模块可以选择适合自己的风格、工具等。</p>\n<h4 id=\"2-安全\"><a href=\"#2-安全\" class=\"headerlink\" title=\"2.安全\"></a>2.安全</h4><p>得益于模块的拆分，权限控制较为自然。<br>开发时只关注相关部分，不会误操作其他内容。<br>发布上线，对其他模块无感知。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>作为传统的管理组织方式，发展演进这么久，必然会存在一些限制。突出体现在协作和管理成本上。  </p>\n<h4 id=\"1-管理成本\"><a href=\"#1-管理成本\" class=\"headerlink\" title=\"1. 管理成本\"></a>1. 管理成本</h4><p>常见的项目交接时，每个人都负责了一堆项目、账号等，只能手动梳理，还存在漏掉的可能。我当初经历过几次大的调整，交接的真是一脸懵逼和心痛。来个需求才发现还有个仓库一直处于遗忘的角落。</p>\n<h4 id=\"2-协作成本\"><a href=\"#2-协作成本\" class=\"headerlink\" title=\"2. 协作成本\"></a>2. 协作成本</h4><p>涉及多个项目开发时，本地开发需要打开多个IDE在其中切换。<br>对于本地调试等也是个繁琐的过程，虽然存在npm link等方式。</p>\n<h4 id=\"3-依赖升级\"><a href=\"#3-依赖升级\" class=\"headerlink\" title=\"3. 依赖升级\"></a>3. 依赖升级</h4><p>这种场景一般出现在依赖的核心模块上，特别是自行开发的基础依赖，不得不升级时简直一言难尽，数目直逼上百的项目，每个都要修改发布一次。</p>\n<p>上面说的是业务模块，对于开源或者公司内部基础性工具，升级这里的问题更显著一些。对于程序员俩说，出现问题解决问题就是，因此集中式的管理模式就出现了。</p>\n<h2 id=\"集中式管理monorepo\"><a href=\"#集中式管理monorepo\" class=\"headerlink\" title=\"集中式管理monorepo\"></a>集中式管理monorepo</h2><p>monorepo 的核心观点是所有的项目在一个代码仓库中。严格的统一和收归，以利于统一的升级和管理。<br>不过这并不是说代码没有组织的随意存放。相反，在文件目录上体现出管理结构的要求更高，否则可维护性更低。<br>例如Babel，每个模块都在指定的packages目录下。</p>\n<h3 id=\"优势-1\"><a href=\"#优势-1\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>既然是基于问题的演进，其实优势比较明显，就是multirepo的局限的解决。<br>例如协作、运营管理等成本降低。<br>不过monorepo也不全是益处，相反其局限也比较明显。</p>\n<h3 id=\"问题-1\"><a href=\"#问题-1\" class=\"headerlink\" title=\"问题\"></a>问题</h3><h4 id=\"1-项目体积增加\"><a href=\"#1-项目体积增加\" class=\"headerlink\" title=\"1. 项目体积增加\"></a>1. 项目体积增加</h4><p>随着项目的发展，体积会逐渐增大，甚至成为巨无霸项目体积几个G。<br>自然带来一些问题：</p>\n<ul>\n<li><p>拉取时间边长<br>拿babel举个例子，虽然只有130M，但时间已经增加不少，更遑论上G的存在。<img src=\"media/15771585486438/Jietu20191231-094925-HD.gif\" alt=\"Jietu20191231-094925-HD\"></p>\n</li>\n<li><p>编译时间很慢<br>很自然，如果每次还是全部编译的话，开发、部署时的等待时间会相当的长</p>\n</li>\n</ul>\n<h4 id=\"2-安全性\"><a href=\"#2-安全性\" class=\"headerlink\" title=\"2. 安全性\"></a>2. 安全性</h4><p>全部功能就这样暴露在所有开发者面前，安全性是个大问题。<br>误操作的可能性，如果仅仅寄希望于开发者素质和codereview时的人工复检是不可靠的。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>当然对于比较成熟的模式，解决方案也是形成了沉淀的。</p>\n<h4 id=\"1-多模块管理工具\"><a href=\"#1-多模块管理工具\" class=\"headerlink\" title=\"1. 多模块管理工具\"></a>1. 多模块管理工具</h4><p>针对复杂的项目模块，自然需要有贴合实际的管理工具。<br>例如<a href=\"https://github.com/lerna/lerna\" target=\"_blank\" rel=\"noopener\">lerna</a>，自我定位就是:<br>A tool for managing JavaScript projects with multiple packages<br>至于详细用法，大家可以通过官网查看。</p>\n<h4 id=\"2-git稀疏检出\"><a href=\"#2-git稀疏检出\" class=\"headerlink\" title=\"2. git稀疏检出\"></a>2. git稀疏检出</h4><p>针对开发者只关注相应内容的解决方案可以依托git来实现的。<br>Git在1.7版本后，已经支持只Checkout部分内容，即稀疏检出(sparse checkout)</p>\n<p>稀疏检出就是本地版本库检出时不检出全部，只将指定的文件从本地版本库检出到工作区，而其他未指定的文件则不予检出（即使这些文件存在于工作区，其修改也会被忽略）。 </p>\n<p>也就是我们可以在工作区只关注相关的模块，虽然文件全部pull了下来，但展示和管理式会忽略其他文件，即使展示了其他文件并进行了修改，修改依然会被忽略。<br>例如babel中我们只展示 babel-cli 内容部分，操作如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建文件夹</span><br><span class=\"line\">mkdir demo &amp;&amp; <span class=\"built_in\">cd</span> demo</span><br><span class=\"line\">// 初始化git </span><br><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin https://github.com/babel/babel.git</span><br><span class=\"line\">// 打开 开关 </span><br><span class=\"line\">git config core.sparsecheckout <span class=\"literal\">true</span></span><br><span class=\"line\">// 指定目录</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"packages/babel-cli/\"</span> &gt;&gt; .git/info/sparse-checkout</span><br><span class=\"line\">// 获取代码</span><br><span class=\"line\">git pull origin master</span><br><span class=\"line\">```  </span><br><span class=\"line\">这样，我们ls可以查看到文件内容只有：</span><br><span class=\"line\"></span><br><span class=\"line\">```bash</span><br><span class=\"line\">packages/babel-cli</span><br></pre></td></tr></table></figure>\n<p>如果需要修改展示目录，直接修改.git/info/sparse-checkout，即可，然后重新进行checkout </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"packages/babel-cli/\"</span> &gt;&gt; .git/info/sparse-checkout</span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>这样增加了安全性。</p>\n<h4 id=\"扩展-浅克隆\"><a href=\"#扩展-浅克隆\" class=\"headerlink\" title=\"扩展-浅克隆\"></a>扩展-浅克隆</h4><p>稀疏检出只是展示上的部分，本身仍然包含所有的文件和历史。如果只关注最近的提交，可以通过浅克隆实现。<br>使用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone --depth <span class=\"number\">2</span> https:<span class=\"comment\">//github.com/babel/babel.git</span></span><br></pre></td></tr></table></figure></p>\n<p>不过浅克隆限制较多，一般用于对远程版本库的查看和研究。</p>\n<ul>\n<li>不能从浅克隆版本库克隆出新的版本库。</li>\n<li>其他版本库不能从浅克隆获取提交。</li>\n<li>其他版本库不能推送提交到浅克隆版本库。</li>\n<li>不要从浅克隆版本库推送提交至其他版本库，除非确认推送的目标版本库包含浅克隆版本库中缺失的全部历史提交，否则会造成目标版本库包含不完整的提交历史导致版本库无法操作。</li>\n<li>在浅克隆版本库中执行合并操作时，如果所合并的提交出现在浅克隆历史中，则可以顺利合并，否则会出现大量的冲突，就好像和无关的历史进行合并一样。</li>\n</ul>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>本文简单介绍了不同的仓库管理模式理念和一些实践方式，个人理解有限，抛砖引玉，欢迎一起讨论。更多内容请转<a href=\"http://xxdy.tech/\">雨打梨梦三村边</a>，同时感谢以下参考文章。。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"https://www.kloia.com/blog/monorepo-or-multirepo\" target=\"_blank\" rel=\"noopener\">https://www.kloia.com/blog/monorepo-or-multirepo</a></li>\n<li><a href=\"https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html\" target=\"_blank\" rel=\"noopener\">https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html</a>  </li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/31289463\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/31289463</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"仓库管理方式\"><a href=\"#仓库管理方式\" class=\"headerlink\" title=\"仓库管理方式\"></a>仓库管理方式</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>随着功能和业务量级的飙升，前端代码量级也越来越大，再加上后续管理运维，代码仓库的运营管理挑战也浮出水面。主流方案有两种：一是multirepo式的分散式的独立仓库，二是monorepo式的集中管理，各有千秋，下面就结合实际场景一起深入了解下。</p>\n<h2 id=\"分散式管理-multirepo\"><a href=\"#分散式管理-multirepo\" class=\"headerlink\" title=\"分散式管理-multirepo\"></a>分散式管理-multirepo</h2><p>即按照功能或者其他维度，将项目拆分为不同模块单独维护于各自仓库中。</p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>对于敏捷迭代快速开发的新需求，常规做法就是每个模块对应一个仓库，新的需求进行归类，可归入已有仓库则进行迭代，不满足则新建仓库。</p>\n<h3 id=\"优势\"><a href=\"#优势\" class=\"headerlink\" title=\"优势\"></a>优势</h3><h4 id=\"1-灵活\"><a href=\"#1-灵活\" class=\"headerlink\" title=\"1.灵活\"></a>1.灵活</h4><p>不同模块独立维护，与其他模块天然隔离。各个模块可以选择适合自己的风格、工具等。</p>\n<h4 id=\"2-安全\"><a href=\"#2-安全\" class=\"headerlink\" title=\"2.安全\"></a>2.安全</h4><p>得益于模块的拆分，权限控制较为自然。<br>开发时只关注相关部分，不会误操作其他内容。<br>发布上线，对其他模块无感知。</p>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><p>作为传统的管理组织方式，发展演进这么久，必然会存在一些限制。突出体现在协作和管理成本上。  </p>\n<h4 id=\"1-管理成本\"><a href=\"#1-管理成本\" class=\"headerlink\" title=\"1. 管理成本\"></a>1. 管理成本</h4><p>常见的项目交接时，每个人都负责了一堆项目、账号等，只能手动梳理，还存在漏掉的可能。我当初经历过几次大的调整，交接的真是一脸懵逼和心痛。来个需求才发现还有个仓库一直处于遗忘的角落。</p>\n<h4 id=\"2-协作成本\"><a href=\"#2-协作成本\" class=\"headerlink\" title=\"2. 协作成本\"></a>2. 协作成本</h4><p>涉及多个项目开发时，本地开发需要打开多个IDE在其中切换。<br>对于本地调试等也是个繁琐的过程，虽然存在npm link等方式。</p>\n<h4 id=\"3-依赖升级\"><a href=\"#3-依赖升级\" class=\"headerlink\" title=\"3. 依赖升级\"></a>3. 依赖升级</h4><p>这种场景一般出现在依赖的核心模块上，特别是自行开发的基础依赖，不得不升级时简直一言难尽，数目直逼上百的项目，每个都要修改发布一次。</p>\n<p>上面说的是业务模块，对于开源或者公司内部基础性工具，升级这里的问题更显著一些。对于程序员俩说，出现问题解决问题就是，因此集中式的管理模式就出现了。</p>\n<h2 id=\"集中式管理monorepo\"><a href=\"#集中式管理monorepo\" class=\"headerlink\" title=\"集中式管理monorepo\"></a>集中式管理monorepo</h2><p>monorepo 的核心观点是所有的项目在一个代码仓库中。严格的统一和收归，以利于统一的升级和管理。<br>不过这并不是说代码没有组织的随意存放。相反，在文件目录上体现出管理结构的要求更高，否则可维护性更低。<br>例如Babel，每个模块都在指定的packages目录下。</p>\n<h3 id=\"优势-1\"><a href=\"#优势-1\" class=\"headerlink\" title=\"优势\"></a>优势</h3><p>既然是基于问题的演进，其实优势比较明显，就是multirepo的局限的解决。<br>例如协作、运营管理等成本降低。<br>不过monorepo也不全是益处，相反其局限也比较明显。</p>\n<h3 id=\"问题-1\"><a href=\"#问题-1\" class=\"headerlink\" title=\"问题\"></a>问题</h3><h4 id=\"1-项目体积增加\"><a href=\"#1-项目体积增加\" class=\"headerlink\" title=\"1. 项目体积增加\"></a>1. 项目体积增加</h4><p>随着项目的发展，体积会逐渐增大，甚至成为巨无霸项目体积几个G。<br>自然带来一些问题：</p>\n<ul>\n<li><p>拉取时间边长<br>拿babel举个例子，虽然只有130M，但时间已经增加不少，更遑论上G的存在。<img src=\"media/15771585486438/Jietu20191231-094925-HD.gif\" alt=\"Jietu20191231-094925-HD\"></p>\n</li>\n<li><p>编译时间很慢<br>很自然，如果每次还是全部编译的话，开发、部署时的等待时间会相当的长</p>\n</li>\n</ul>\n<h4 id=\"2-安全性\"><a href=\"#2-安全性\" class=\"headerlink\" title=\"2. 安全性\"></a>2. 安全性</h4><p>全部功能就这样暴露在所有开发者面前，安全性是个大问题。<br>误操作的可能性，如果仅仅寄希望于开发者素质和codereview时的人工复检是不可靠的。</p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>当然对于比较成熟的模式，解决方案也是形成了沉淀的。</p>\n<h4 id=\"1-多模块管理工具\"><a href=\"#1-多模块管理工具\" class=\"headerlink\" title=\"1. 多模块管理工具\"></a>1. 多模块管理工具</h4><p>针对复杂的项目模块，自然需要有贴合实际的管理工具。<br>例如<a href=\"https://github.com/lerna/lerna\" target=\"_blank\" rel=\"noopener\">lerna</a>，自我定位就是:<br>A tool for managing JavaScript projects with multiple packages<br>至于详细用法，大家可以通过官网查看。</p>\n<h4 id=\"2-git稀疏检出\"><a href=\"#2-git稀疏检出\" class=\"headerlink\" title=\"2. git稀疏检出\"></a>2. git稀疏检出</h4><p>针对开发者只关注相应内容的解决方案可以依托git来实现的。<br>Git在1.7版本后，已经支持只Checkout部分内容，即稀疏检出(sparse checkout)</p>\n<p>稀疏检出就是本地版本库检出时不检出全部，只将指定的文件从本地版本库检出到工作区，而其他未指定的文件则不予检出（即使这些文件存在于工作区，其修改也会被忽略）。 </p>\n<p>也就是我们可以在工作区只关注相关的模块，虽然文件全部pull了下来，但展示和管理式会忽略其他文件，即使展示了其他文件并进行了修改，修改依然会被忽略。<br>例如babel中我们只展示 babel-cli 内容部分，操作如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 创建文件夹</span><br><span class=\"line\">mkdir demo &amp;&amp; <span class=\"built_in\">cd</span> demo</span><br><span class=\"line\">// 初始化git </span><br><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin https://github.com/babel/babel.git</span><br><span class=\"line\">// 打开 开关 </span><br><span class=\"line\">git config core.sparsecheckout <span class=\"literal\">true</span></span><br><span class=\"line\">// 指定目录</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"packages/babel-cli/\"</span> &gt;&gt; .git/info/sparse-checkout</span><br><span class=\"line\">// 获取代码</span><br><span class=\"line\">git pull origin master</span><br><span class=\"line\">```  </span><br><span class=\"line\">这样，我们ls可以查看到文件内容只有：</span><br><span class=\"line\"></span><br><span class=\"line\">```bash</span><br><span class=\"line\">packages/babel-cli</span><br></pre></td></tr></table></figure>\n<p>如果需要修改展示目录，直接修改.git/info/sparse-checkout，即可，然后重新进行checkout </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">\"packages/babel-cli/\"</span> &gt;&gt; .git/info/sparse-checkout</span><br><span class=\"line\">git checkout master</span><br></pre></td></tr></table></figure>\n<p>这样增加了安全性。</p>\n<h4 id=\"扩展-浅克隆\"><a href=\"#扩展-浅克隆\" class=\"headerlink\" title=\"扩展-浅克隆\"></a>扩展-浅克隆</h4><p>稀疏检出只是展示上的部分，本身仍然包含所有的文件和历史。如果只关注最近的提交，可以通过浅克隆实现。<br>使用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone --depth <span class=\"number\">2</span> https:<span class=\"comment\">//github.com/babel/babel.git</span></span><br></pre></td></tr></table></figure></p>\n<p>不过浅克隆限制较多，一般用于对远程版本库的查看和研究。</p>\n<ul>\n<li>不能从浅克隆版本库克隆出新的版本库。</li>\n<li>其他版本库不能从浅克隆获取提交。</li>\n<li>其他版本库不能推送提交到浅克隆版本库。</li>\n<li>不要从浅克隆版本库推送提交至其他版本库，除非确认推送的目标版本库包含浅克隆版本库中缺失的全部历史提交，否则会造成目标版本库包含不完整的提交历史导致版本库无法操作。</li>\n<li>在浅克隆版本库中执行合并操作时，如果所合并的提交出现在浅克隆历史中，则可以顺利合并，否则会出现大量的冲突，就好像和无关的历史进行合并一样。</li>\n</ul>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>本文简单介绍了不同的仓库管理模式理念和一些实践方式，个人理解有限，抛砖引玉，欢迎一起讨论。更多内容请转<a href=\"http://xxdy.tech/\">雨打梨梦三村边</a>，同时感谢以下参考文章。。</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"https://www.kloia.com/blog/monorepo-or-multirepo\" target=\"_blank\" rel=\"noopener\">https://www.kloia.com/blog/monorepo-or-multirepo</a></li>\n<li><a href=\"https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html\" target=\"_blank\" rel=\"noopener\">https://www.worldhello.net/gotgit/08-git-misc/090-sparse-checkout-and-shallow-clone.html</a>  </li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/31289463\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/31289463</a></li>\n</ul>\n"},{"title":"由自定义事件到vue数据响应","date":"2018-08-25T00:00:29.000Z","_content":"\n## 前言  \n除了大家经常提到的自定义事件之外，浏览器本身也支持我们自定义事件，我们常说的自定义事件一般用于项目中的一些通知机制。最近正好看到了这部分，就一起看了下自定义事件不同的实现，以及vue数据响应的基本原理。\n<!-- more -->\n## 浏览器自定义事件\n### 定义  \n除了我们常见的click，touch等事件之外，浏览器支持我们定义和分发自定义事件。\n创建也十分简单：\n\n```js\n//创建名为test的自定义事件\nvar event = new Event('test')\n//如果是需要更多参数可以这样\nvar event = new CustomEvent('test', { 'detail': elem.dataset.time });\n```\n大多数现代浏览器对new Event/CustomEvent 的支持还算可以（IE除外），可以看下具体情况：\n<img src='https://user-gold-cdn.xitu.io/2018/8/25/16571803c3080b60?w=2554&h=1016&f=png&s=135371'/>\n可以放心大胆的使用，如果非要兼容IE那么有下面的方式\n\n```js\nvar event = document.createEvent('Event');\n//相关参数\nevent.initEvent('test', true, true);\n```\n自定义事件的触发和原生事件类似，可以通过冒泡事件触发。\n\n```html\n<form>\n  <textarea></textarea>\n</form>\n```\n触发如下，这里就偷个懒，直接拿mdn的源码来示例了，毕竟清晰易懂。\n\n```js\nconst form = document.querySelector('form');\nconst textarea = document.querySelector('textarea');\n\n\n//创建新的事件，允许冒泡，支持传递在details中定义的所有数据\nconst eventAwesome = new CustomEvent('awesome', {\n  bubbles: true,\n  detail: { text: () => textarea.value }\n});\n\n  //form元素监听自定义的awesome事件，打印text事件的输出\n  // 也就是text的输出内容\nform.addEventListener('awesome', e => console.log(e.detail.text()));\n  //  \n  // textarea当输入时，触发awesome\ntextarea.addEventListener('input', e => e.target.dispatchEvent(eventAwesome));\n```\n上面例子很清晰的展示了自定义事件定义、监听、触发的整个过程，和原生事件的流程相比看起来多了个触发的步骤，原因在原生事件的触发已经被封装无需手动处理而已。   \n### 应用\n### 各大js类库\n各种js库中用到的也比较多，例如zepto中的tap，原理就是监听touch事件，然后去触发自定的tap事件(当然这种成熟的框架做的是比较严谨的)。可以看下部分代码：\n\n```js\n//这里做了个event的map，来将原始事件对应为自定义事件以便处理\n// 可以只关注下ontouchstart，这里先判断是否移动端，移动端down就对应touchstart，up对应touchend，后面的可以先不关注\neventMap = (__eventMap && ('down' in __eventMap)) ? __eventMap :\n      ('ontouchstart' in document ?\n      { 'down': 'touchstart', 'up': 'touchend',\n        'move': 'touchmove', 'cancel': 'touchcancel' } :\n      'onpointerdown' in document ?\n      { 'down': 'pointerdown', 'up': 'pointerup',\n        'move': 'pointermove', 'cancel': 'pointercancel' } :\n       'onmspointerdown' in document ?\n      { 'down': 'MSPointerDown', 'up': 'MSPointerUp',\n        'move': 'MSPointerMove', 'cancel': 'MSPointerCancel' } : false)\n //监听事件\n     $(document).on(eventMap.up, up)\n      .on(eventMap.down, down)\n      .on(eventMap.move, move)       \n //up事件即touchend时，满足条件的会触发tap    \n var up = function (e) {\n      /* 忽略 */\n       tapTimeout = setTimeout(function () {\n           var event = $.Event('tap')\n            event.cancelTouch = cancelAll\n            if (touch.el) touch.el.trigger(event); \n          },0）\n        }\n     //其他   \n```\n### 发布订阅\n和原生事件一样，大部分都用于观察者模式中。除了上面的库之外，自己开发过程中用到的地方也不少。  \n举个例子，一个输入框表示单价，另一个div表示五本的总价，单价改变总价也会变动。借助自定义事件应该怎么实现呢。\nhtml结构比较简单\n\n```js\n<div >一本书的价格：<input type='text' id='el' value=10 /></div>\n<div >5本书的价格：<span id='el2'>50</span>元</div>\n```\n当改变input值得时候，效果如下[demo地址](http://xxdy.tech/event/index.html) ：\n<img src='https://user-gold-cdn.xitu.io/2018/8/25/165718064234986c?w=600&h=185&f=gif&s=7690486'/>\n\n大概思路捋一下：\n1、自定义事件，priceChange，用来监听改变price的改变\n2、 加个监听事件，priceChange触发时改变total的值。\n3、input value改变的时候，触发priceChange事件\n代码实现如下：\n\n```js\n  const count = document.querySelector('#el'),\n      total1 = document.querySelector('#el2');\n  const eventAwesome = new CustomEvent('priceChange', {\n      bubbles: true,\n      detail: { getprice: () => count.value }\n    });\n  document.addEventListener('priceChange', function (e) {\n      var price = e.detail.getprice() || 0\n      total1.innerHTML=5 * price\n    })\n  el.addEventListener('change', function (e) {\n    var val = e.target.value\n    e.target.dispatchEvent(eventAwesome)\n  });\n```\n代码确实比较简单，当然实现的方式是多样的。但是看起来是不是有点vue数据响应的味道。  \n确实目前大多数框架中都会用到发布订阅的方式来处理数据的变化。例如vue，react等，以vue为例子，我们可以来看看其数据响应的基本原理。  \n## 自定义事件\n这里的自定义事件就是前面提到的第二层定义了，非基于浏览器的事件。这种事件也正是大型前端项目中常用到。对照原生事件，应该具有on、trigger、off三个方法。分别看一下\n1. 对照原生事件很容易理解，绑定一个事件，应该有对应方法名和回调,当然还有一个事件队列\n\n```js\nclass Event1{\n    constructor(){\n      // 事件队列\n      this._events = {}\n    }\n    // type对应事件名称，call回调\n    on(type,call){\n      let funs = this._events[type]\n      // 首次直接赋值，同种类型事件可能多个回调所以数组\n      // 否则push进入队列即可\n      if(funs){\n        funs.push(call)\n      }else{\n        this._events.type=[]\n        this._events.type.push(call)\n      }\n    }\n}\n```\n2. 触发事件trigger\n\n```js\n// 触发事件\n    trigger(type){\n      let funs = this._events.type,\n        [first,...other] = Array.from(arguments)\n      //对应事件类型存在，循环执行回调队列  \n      if(funs){\n        let i = 0,\n            j = funs.length;\n        for (i=0; i < j; i++) {\n          let cb = funs[i];\n          cb.apply(this, other);\n        }\n      }\n    }\n```\n3. 解除绑定：\n\n```js\n// 取消绑定，还是循环查找\n    off(type,func){\n      let funs = this._events.type\n      if(funs){\n        let i = 0,\n          j = funs.length;\n        for (i = 0; i < j; i++) {\n          let cb = funs[i];\n           if (cb === func) {\n            funs.splice(i, 1);\n            return;\n          }\n        }\n      }\n      return this\n    }\n  }\n```\n这样一个简单的事件系统就完成了，结合这个事件系统，我们可以实现下上面那个例子。  \nhtml不变，绑定和触发事件的方式改变一下就好\n\n```js\n // 初始化 event1为了区别原生Event\n  const event1 = new Event1()    \n  \n  // 此处监听 priceChange 即可\n  event1.on('priceChange', function (e) {\n      // 值获取方式修改\n      var price = count.value || 0\n      total1.innerHTML = 5 * price\n    })  \n  el.addEventListener('change', function (e) {\n    var val = e.target.value\n    // 触发事件\n    event1.trigger('priceChange')\n  });\n```\n这样同样可以实现上面的效果，实现了事件系统之后，我们接着实现一下vue里面的数据响应。\n### vue的数据响应  \n说到vue的数据响应，网上相关文章简直太多了，这里就不深入去讨论了。简单搬运一下基本概念。详细的话大家可以自行搜索。  \n### 基本原理\n直接看图比较直观：\n<img src='https://user-gold-cdn.xitu.io/2018/8/25/165718027cb03c89?w=800&h=500&f=png&s=64811'/>\n就是通过观察者模式来实现，不过其通过数据劫持方式实现的更加巧妙。  \n数据劫持是通过Object.defineProperty()来监听各个属性的变化，从而进行一些额外操作。\n举个简单例子：  \n\n```js\nlet a = {\n   b:'1' \n}\nObject.defineProperty(a,'b',{\n        get(){\n            console.log('get>>>',1)\n            return 1\n        },\n        set(newVal){\n            console.log('set>>>11','设置是不被允许的')\n            return 1\n        }\n    })\na.b //'get>>>1'\na.b = 11    //set>>>11 设置是不被允许的\n```\n所谓数据劫持就是在get/set操作时加上额外操作，这里是加了些log，如果在这里去监听某些属性的变化，进而更改其他属性也是可行的。   \n要达到目的，应该对每个属性在get是监听，set的时候出发事件，且每个属性上只注册一次。  \n另外应该每个属性对应一个监听者，这样处理起来比较方便，如果和上面那样全放在一个监听实例里面，有多个属性及复杂操作时，就太难维护了。\n    \n```js\n//基本数据\nlet data = {\n    price: 5,\n    count: 2\n  },\ncallb = null  \n```\n可以对自定义事件进行部分改造,  \n不需要显式指定type，全局维护一个标记即可  \n事件数组一维即可，因为是每个属性对应一个示例  \n\n```js\nclass Events {\n    constructor() {\n      this._events = []\n    }\n    on() {\n      //此处不需要指定tyep了\n      if (callb && !this._events.includes(callb)) {\n        this._events.push(callb)\n      }\n    }\n    triger() {\n      this._events.forEach((callb) => {\n        callb && callb()\n      })\n    }\n  }\n```\n对应上图中vue的Data部分，就是实行数据劫持的地方\n\n```js\nObject.keys(data).forEach((key) => {\n    let initVlue = data[key]\n    const e1 = new Events()\n    Object.defineProperty(data, key, {\n      get() {\n         //内部判断是否需要注册\n        e1.on()\n        // 执行过置否\n        callb = null\n        // get不变更值\n        return initVlue\n      },\n      set(newVal) {\n        initVlue = newVal\n        // set操作触发事件，同步数据变动\n        e1.triger()\n      }\n    })\n  })\n```\n此时数据劫持即事件监听准备完成，大家可能会发现callback始终为null，这始终不能起作用。为了解决该问题，下面的watcher就要出场了。\n\n```js\nfunction watcher(func) {\n    // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    callb = func\n    // 初次执行时，获取对应值自然经过get方法注册事件\n    callb()\n    // 置否避免重复注册\n    callb = null\n  }\n  // 此处指定事件触发回调，注册监听事件\n  watcher(() => {\n    data.total = data.price * data.count\n  })\n```\n这样就保证了会将监听事件挂载上去。到这里，乞丐版数据响应应该就能跑了。   \n再加上dom事件的处理，双向绑定也不难实现。\n可以将下面的完整代码放到console台跑跑看。   \n\n```js\nlet data = {\n    price: 5,\n    count: 2\n  },\n    callb = null\n\n  class Events {\n    constructor() {\n      this._events = []\n    }\n    on() {\n      if (callb && !this._events.includes(callb)) {\n        this._events.push(callb)\n      }\n    }\n    triger() {\n      this._events.forEach((callb) => {\n        callb && callb()\n      })\n    }\n  }\n \n  Object.keys(data).forEach((key) => {\n    let initVlue = data[key]\n    const e1 = new Events()\n    Object.defineProperty(data, key, {\n      get() {\n         //内部判断是否需要注册\n        e1.on()\n        // 执行过置否\n        callb = null\n        // get不变更值\n        return initVlue\n      },\n      set(newVal) {\n        initVlue = newVal\n        // set操作触发事件，同步数据变动\n        e1.triger()\n      }\n    })\n  })\n  function watcher(func) {\n    // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    callb = func\n    // 初次执行时，获取对应值自然经过get方法注册事件\n    callb()\n    // 置否避免重复注册\n    callb = null\n  }\n  // 此处指定事件触发回调，注册监听事件\n  watcher(() => {\n    data.total = data.price * data.count\n  })\n```\n### 结束语\n#### 参考文章\n[vue数据响应的实现](https://medium.com/vue-mastery/the-best-explanation-of-javascript-reactivity-fea6112dd80d)  \n[Creating and triggering events](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events)  \n看到知识盲点，就需要立即行动，不然下次还是盲点。正好是事件相关，就一并总结了下发布订阅相关进而到了数据响应的实现。个人的一点心得记录，分享出来希望共同学习和进步。[更多请移步我的博客](https://github.com/xiaoxiangdaiyu/blog)  \n[demo地址](http://xxdy.tech/event/index.html)  \n[源码地址](https://github.com/xiaoxiangdaiyu/blog/blob/master/source/event/index.html)","source":"_posts/event.md","raw":"---\ntitle: 由自定义事件到vue数据响应\ndate: 2018-08-25 08:00:29\ntags:\n---\n\n## 前言  \n除了大家经常提到的自定义事件之外，浏览器本身也支持我们自定义事件，我们常说的自定义事件一般用于项目中的一些通知机制。最近正好看到了这部分，就一起看了下自定义事件不同的实现，以及vue数据响应的基本原理。\n<!-- more -->\n## 浏览器自定义事件\n### 定义  \n除了我们常见的click，touch等事件之外，浏览器支持我们定义和分发自定义事件。\n创建也十分简单：\n\n```js\n//创建名为test的自定义事件\nvar event = new Event('test')\n//如果是需要更多参数可以这样\nvar event = new CustomEvent('test', { 'detail': elem.dataset.time });\n```\n大多数现代浏览器对new Event/CustomEvent 的支持还算可以（IE除外），可以看下具体情况：\n<img src='https://user-gold-cdn.xitu.io/2018/8/25/16571803c3080b60?w=2554&h=1016&f=png&s=135371'/>\n可以放心大胆的使用，如果非要兼容IE那么有下面的方式\n\n```js\nvar event = document.createEvent('Event');\n//相关参数\nevent.initEvent('test', true, true);\n```\n自定义事件的触发和原生事件类似，可以通过冒泡事件触发。\n\n```html\n<form>\n  <textarea></textarea>\n</form>\n```\n触发如下，这里就偷个懒，直接拿mdn的源码来示例了，毕竟清晰易懂。\n\n```js\nconst form = document.querySelector('form');\nconst textarea = document.querySelector('textarea');\n\n\n//创建新的事件，允许冒泡，支持传递在details中定义的所有数据\nconst eventAwesome = new CustomEvent('awesome', {\n  bubbles: true,\n  detail: { text: () => textarea.value }\n});\n\n  //form元素监听自定义的awesome事件，打印text事件的输出\n  // 也就是text的输出内容\nform.addEventListener('awesome', e => console.log(e.detail.text()));\n  //  \n  // textarea当输入时，触发awesome\ntextarea.addEventListener('input', e => e.target.dispatchEvent(eventAwesome));\n```\n上面例子很清晰的展示了自定义事件定义、监听、触发的整个过程，和原生事件的流程相比看起来多了个触发的步骤，原因在原生事件的触发已经被封装无需手动处理而已。   \n### 应用\n### 各大js类库\n各种js库中用到的也比较多，例如zepto中的tap，原理就是监听touch事件，然后去触发自定的tap事件(当然这种成熟的框架做的是比较严谨的)。可以看下部分代码：\n\n```js\n//这里做了个event的map，来将原始事件对应为自定义事件以便处理\n// 可以只关注下ontouchstart，这里先判断是否移动端，移动端down就对应touchstart，up对应touchend，后面的可以先不关注\neventMap = (__eventMap && ('down' in __eventMap)) ? __eventMap :\n      ('ontouchstart' in document ?\n      { 'down': 'touchstart', 'up': 'touchend',\n        'move': 'touchmove', 'cancel': 'touchcancel' } :\n      'onpointerdown' in document ?\n      { 'down': 'pointerdown', 'up': 'pointerup',\n        'move': 'pointermove', 'cancel': 'pointercancel' } :\n       'onmspointerdown' in document ?\n      { 'down': 'MSPointerDown', 'up': 'MSPointerUp',\n        'move': 'MSPointerMove', 'cancel': 'MSPointerCancel' } : false)\n //监听事件\n     $(document).on(eventMap.up, up)\n      .on(eventMap.down, down)\n      .on(eventMap.move, move)       \n //up事件即touchend时，满足条件的会触发tap    \n var up = function (e) {\n      /* 忽略 */\n       tapTimeout = setTimeout(function () {\n           var event = $.Event('tap')\n            event.cancelTouch = cancelAll\n            if (touch.el) touch.el.trigger(event); \n          },0）\n        }\n     //其他   \n```\n### 发布订阅\n和原生事件一样，大部分都用于观察者模式中。除了上面的库之外，自己开发过程中用到的地方也不少。  \n举个例子，一个输入框表示单价，另一个div表示五本的总价，单价改变总价也会变动。借助自定义事件应该怎么实现呢。\nhtml结构比较简单\n\n```js\n<div >一本书的价格：<input type='text' id='el' value=10 /></div>\n<div >5本书的价格：<span id='el2'>50</span>元</div>\n```\n当改变input值得时候，效果如下[demo地址](http://xxdy.tech/event/index.html) ：\n<img src='https://user-gold-cdn.xitu.io/2018/8/25/165718064234986c?w=600&h=185&f=gif&s=7690486'/>\n\n大概思路捋一下：\n1、自定义事件，priceChange，用来监听改变price的改变\n2、 加个监听事件，priceChange触发时改变total的值。\n3、input value改变的时候，触发priceChange事件\n代码实现如下：\n\n```js\n  const count = document.querySelector('#el'),\n      total1 = document.querySelector('#el2');\n  const eventAwesome = new CustomEvent('priceChange', {\n      bubbles: true,\n      detail: { getprice: () => count.value }\n    });\n  document.addEventListener('priceChange', function (e) {\n      var price = e.detail.getprice() || 0\n      total1.innerHTML=5 * price\n    })\n  el.addEventListener('change', function (e) {\n    var val = e.target.value\n    e.target.dispatchEvent(eventAwesome)\n  });\n```\n代码确实比较简单，当然实现的方式是多样的。但是看起来是不是有点vue数据响应的味道。  \n确实目前大多数框架中都会用到发布订阅的方式来处理数据的变化。例如vue，react等，以vue为例子，我们可以来看看其数据响应的基本原理。  \n## 自定义事件\n这里的自定义事件就是前面提到的第二层定义了，非基于浏览器的事件。这种事件也正是大型前端项目中常用到。对照原生事件，应该具有on、trigger、off三个方法。分别看一下\n1. 对照原生事件很容易理解，绑定一个事件，应该有对应方法名和回调,当然还有一个事件队列\n\n```js\nclass Event1{\n    constructor(){\n      // 事件队列\n      this._events = {}\n    }\n    // type对应事件名称，call回调\n    on(type,call){\n      let funs = this._events[type]\n      // 首次直接赋值，同种类型事件可能多个回调所以数组\n      // 否则push进入队列即可\n      if(funs){\n        funs.push(call)\n      }else{\n        this._events.type=[]\n        this._events.type.push(call)\n      }\n    }\n}\n```\n2. 触发事件trigger\n\n```js\n// 触发事件\n    trigger(type){\n      let funs = this._events.type,\n        [first,...other] = Array.from(arguments)\n      //对应事件类型存在，循环执行回调队列  \n      if(funs){\n        let i = 0,\n            j = funs.length;\n        for (i=0; i < j; i++) {\n          let cb = funs[i];\n          cb.apply(this, other);\n        }\n      }\n    }\n```\n3. 解除绑定：\n\n```js\n// 取消绑定，还是循环查找\n    off(type,func){\n      let funs = this._events.type\n      if(funs){\n        let i = 0,\n          j = funs.length;\n        for (i = 0; i < j; i++) {\n          let cb = funs[i];\n           if (cb === func) {\n            funs.splice(i, 1);\n            return;\n          }\n        }\n      }\n      return this\n    }\n  }\n```\n这样一个简单的事件系统就完成了，结合这个事件系统，我们可以实现下上面那个例子。  \nhtml不变，绑定和触发事件的方式改变一下就好\n\n```js\n // 初始化 event1为了区别原生Event\n  const event1 = new Event1()    \n  \n  // 此处监听 priceChange 即可\n  event1.on('priceChange', function (e) {\n      // 值获取方式修改\n      var price = count.value || 0\n      total1.innerHTML = 5 * price\n    })  \n  el.addEventListener('change', function (e) {\n    var val = e.target.value\n    // 触发事件\n    event1.trigger('priceChange')\n  });\n```\n这样同样可以实现上面的效果，实现了事件系统之后，我们接着实现一下vue里面的数据响应。\n### vue的数据响应  \n说到vue的数据响应，网上相关文章简直太多了，这里就不深入去讨论了。简单搬运一下基本概念。详细的话大家可以自行搜索。  \n### 基本原理\n直接看图比较直观：\n<img src='https://user-gold-cdn.xitu.io/2018/8/25/165718027cb03c89?w=800&h=500&f=png&s=64811'/>\n就是通过观察者模式来实现，不过其通过数据劫持方式实现的更加巧妙。  \n数据劫持是通过Object.defineProperty()来监听各个属性的变化，从而进行一些额外操作。\n举个简单例子：  \n\n```js\nlet a = {\n   b:'1' \n}\nObject.defineProperty(a,'b',{\n        get(){\n            console.log('get>>>',1)\n            return 1\n        },\n        set(newVal){\n            console.log('set>>>11','设置是不被允许的')\n            return 1\n        }\n    })\na.b //'get>>>1'\na.b = 11    //set>>>11 设置是不被允许的\n```\n所谓数据劫持就是在get/set操作时加上额外操作，这里是加了些log，如果在这里去监听某些属性的变化，进而更改其他属性也是可行的。   \n要达到目的，应该对每个属性在get是监听，set的时候出发事件，且每个属性上只注册一次。  \n另外应该每个属性对应一个监听者，这样处理起来比较方便，如果和上面那样全放在一个监听实例里面，有多个属性及复杂操作时，就太难维护了。\n    \n```js\n//基本数据\nlet data = {\n    price: 5,\n    count: 2\n  },\ncallb = null  \n```\n可以对自定义事件进行部分改造,  \n不需要显式指定type，全局维护一个标记即可  \n事件数组一维即可，因为是每个属性对应一个示例  \n\n```js\nclass Events {\n    constructor() {\n      this._events = []\n    }\n    on() {\n      //此处不需要指定tyep了\n      if (callb && !this._events.includes(callb)) {\n        this._events.push(callb)\n      }\n    }\n    triger() {\n      this._events.forEach((callb) => {\n        callb && callb()\n      })\n    }\n  }\n```\n对应上图中vue的Data部分，就是实行数据劫持的地方\n\n```js\nObject.keys(data).forEach((key) => {\n    let initVlue = data[key]\n    const e1 = new Events()\n    Object.defineProperty(data, key, {\n      get() {\n         //内部判断是否需要注册\n        e1.on()\n        // 执行过置否\n        callb = null\n        // get不变更值\n        return initVlue\n      },\n      set(newVal) {\n        initVlue = newVal\n        // set操作触发事件，同步数据变动\n        e1.triger()\n      }\n    })\n  })\n```\n此时数据劫持即事件监听准备完成，大家可能会发现callback始终为null，这始终不能起作用。为了解决该问题，下面的watcher就要出场了。\n\n```js\nfunction watcher(func) {\n    // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    callb = func\n    // 初次执行时，获取对应值自然经过get方法注册事件\n    callb()\n    // 置否避免重复注册\n    callb = null\n  }\n  // 此处指定事件触发回调，注册监听事件\n  watcher(() => {\n    data.total = data.price * data.count\n  })\n```\n这样就保证了会将监听事件挂载上去。到这里，乞丐版数据响应应该就能跑了。   \n再加上dom事件的处理，双向绑定也不难实现。\n可以将下面的完整代码放到console台跑跑看。   \n\n```js\nlet data = {\n    price: 5,\n    count: 2\n  },\n    callb = null\n\n  class Events {\n    constructor() {\n      this._events = []\n    }\n    on() {\n      if (callb && !this._events.includes(callb)) {\n        this._events.push(callb)\n      }\n    }\n    triger() {\n      this._events.forEach((callb) => {\n        callb && callb()\n      })\n    }\n  }\n \n  Object.keys(data).forEach((key) => {\n    let initVlue = data[key]\n    const e1 = new Events()\n    Object.defineProperty(data, key, {\n      get() {\n         //内部判断是否需要注册\n        e1.on()\n        // 执行过置否\n        callb = null\n        // get不变更值\n        return initVlue\n      },\n      set(newVal) {\n        initVlue = newVal\n        // set操作触发事件，同步数据变动\n        e1.triger()\n      }\n    })\n  })\n  function watcher(func) {\n    // 参数赋予callback，执行时触发get方法，进行监听事件注册\n    callb = func\n    // 初次执行时，获取对应值自然经过get方法注册事件\n    callb()\n    // 置否避免重复注册\n    callb = null\n  }\n  // 此处指定事件触发回调，注册监听事件\n  watcher(() => {\n    data.total = data.price * data.count\n  })\n```\n### 结束语\n#### 参考文章\n[vue数据响应的实现](https://medium.com/vue-mastery/the-best-explanation-of-javascript-reactivity-fea6112dd80d)  \n[Creating and triggering events](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events)  \n看到知识盲点，就需要立即行动，不然下次还是盲点。正好是事件相关，就一并总结了下发布订阅相关进而到了数据响应的实现。个人的一点心得记录，分享出来希望共同学习和进步。[更多请移步我的博客](https://github.com/xiaoxiangdaiyu/blog)  \n[demo地址](http://xxdy.tech/event/index.html)  \n[源码地址](https://github.com/xiaoxiangdaiyu/blog/blob/master/source/event/index.html)","slug":"event","published":1,"updated":"2018-08-26T01:31:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1l000jgw92itdkokxi","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>除了大家经常提到的自定义事件之外，浏览器本身也支持我们自定义事件，我们常说的自定义事件一般用于项目中的一些通知机制。最近正好看到了这部分，就一起看了下自定义事件不同的实现，以及vue数据响应的基本原理。<br><a id=\"more\"></a></p>\n<h2 id=\"浏览器自定义事件\"><a href=\"#浏览器自定义事件\" class=\"headerlink\" title=\"浏览器自定义事件\"></a>浏览器自定义事件</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>除了我们常见的click，touch等事件之外，浏览器支持我们定义和分发自定义事件。<br>创建也十分简单：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建名为test的自定义事件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> Event(<span class=\"string\">'test'</span>)</span><br><span class=\"line\"><span class=\"comment\">//如果是需要更多参数可以这样</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> CustomEvent(<span class=\"string\">'test'</span>, &#123; <span class=\"string\">'detail'</span>: elem.dataset.time &#125;);</span><br></pre></td></tr></table></figure>\n<p>大多数现代浏览器对new Event/CustomEvent 的支持还算可以（IE除外），可以看下具体情况：<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/25/16571803c3080b60?w=2554&h=1016&f=png&s=135371\"><br>可以放心大胆的使用，如果非要兼容IE那么有下面的方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"built_in\">document</span>.createEvent(<span class=\"string\">'Event'</span>);</span><br><span class=\"line\"><span class=\"comment\">//相关参数</span></span><br><span class=\"line\">event.initEvent(<span class=\"string\">'test'</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>自定义事件的触发和原生事件类似，可以通过冒泡事件触发。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">textarea</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>触发如下，这里就偷个懒，直接拿mdn的源码来示例了，毕竟清晰易懂。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> form = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'form'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> textarea = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'textarea'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建新的事件，允许冒泡，支持传递在details中定义的所有数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> eventAwesome = <span class=\"keyword\">new</span> CustomEvent(<span class=\"string\">'awesome'</span>, &#123;</span><br><span class=\"line\">  bubbles: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  detail: &#123; <span class=\"attr\">text</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> textarea.value &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//form元素监听自定义的awesome事件，打印text事件的输出</span></span><br><span class=\"line\">  <span class=\"comment\">// 也就是text的输出内容</span></span><br><span class=\"line\">form.addEventListener(<span class=\"string\">'awesome'</span>, e =&gt; <span class=\"built_in\">console</span>.log(e.detail.text()));</span><br><span class=\"line\">  <span class=\"comment\">//  </span></span><br><span class=\"line\">  <span class=\"comment\">// textarea当输入时，触发awesome</span></span><br><span class=\"line\">textarea.addEventListener(<span class=\"string\">'input'</span>, e =&gt; e.target.dispatchEvent(eventAwesome));</span><br></pre></td></tr></table></figure>\n<p>上面例子很清晰的展示了自定义事件定义、监听、触发的整个过程，和原生事件的流程相比看起来多了个触发的步骤，原因在原生事件的触发已经被封装无需手动处理而已。   </p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h3 id=\"各大js类库\"><a href=\"#各大js类库\" class=\"headerlink\" title=\"各大js类库\"></a>各大js类库</h3><p>各种js库中用到的也比较多，例如zepto中的tap，原理就是监听touch事件，然后去触发自定的tap事件(当然这种成熟的框架做的是比较严谨的)。可以看下部分代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这里做了个event的map，来将原始事件对应为自定义事件以便处理</span></span><br><span class=\"line\"><span class=\"comment\">// 可以只关注下ontouchstart，这里先判断是否移动端，移动端down就对应touchstart，up对应touchend，后面的可以先不关注</span></span><br><span class=\"line\">eventMap = (__eventMap &amp;&amp; (<span class=\"string\">'down'</span> <span class=\"keyword\">in</span> __eventMap)) ? __eventMap :</span><br><span class=\"line\">      (<span class=\"string\">'ontouchstart'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span> ?</span><br><span class=\"line\">      &#123; <span class=\"string\">'down'</span>: <span class=\"string\">'touchstart'</span>, <span class=\"string\">'up'</span>: <span class=\"string\">'touchend'</span>,</span><br><span class=\"line\">        <span class=\"string\">'move'</span>: <span class=\"string\">'touchmove'</span>, <span class=\"string\">'cancel'</span>: <span class=\"string\">'touchcancel'</span> &#125; :</span><br><span class=\"line\">      <span class=\"string\">'onpointerdown'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span> ?</span><br><span class=\"line\">      &#123; <span class=\"string\">'down'</span>: <span class=\"string\">'pointerdown'</span>, <span class=\"string\">'up'</span>: <span class=\"string\">'pointerup'</span>,</span><br><span class=\"line\">        <span class=\"string\">'move'</span>: <span class=\"string\">'pointermove'</span>, <span class=\"string\">'cancel'</span>: <span class=\"string\">'pointercancel'</span> &#125; :</span><br><span class=\"line\">       <span class=\"string\">'onmspointerdown'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span> ?</span><br><span class=\"line\">      &#123; <span class=\"string\">'down'</span>: <span class=\"string\">'MSPointerDown'</span>, <span class=\"string\">'up'</span>: <span class=\"string\">'MSPointerUp'</span>,</span><br><span class=\"line\">        <span class=\"string\">'move'</span>: <span class=\"string\">'MSPointerMove'</span>, <span class=\"string\">'cancel'</span>: <span class=\"string\">'MSPointerCancel'</span> &#125; : <span class=\"literal\">false</span>)</span><br><span class=\"line\"> <span class=\"comment\">//监听事件</span></span><br><span class=\"line\">     $(<span class=\"built_in\">document</span>).on(eventMap.up, up)</span><br><span class=\"line\">      .on(eventMap.down, down)</span><br><span class=\"line\">      .on(eventMap.move, move)       </span><br><span class=\"line\"> <span class=\"comment\">//up事件即touchend时，满足条件的会触发tap    </span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> up = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/* 忽略 */</span></span><br><span class=\"line\">       tapTimeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">var</span> event = $.Event(<span class=\"string\">'tap'</span>)</span><br><span class=\"line\">            event.cancelTouch = cancelAll</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (touch.el) touch.el.trigger(event); </span><br><span class=\"line\">          &#125;,<span class=\"number\">0</span>）</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     <span class=\"comment\">//其他</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h3><p>和原生事件一样，大部分都用于观察者模式中。除了上面的库之外，自己开发过程中用到的地方也不少。<br>举个例子，一个输入框表示单价，另一个div表示五本的总价，单价改变总价也会变动。借助自定义事件应该怎么实现呢。<br>html结构比较简单</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div &gt;一本书的价格：&lt;input type=<span class=\"string\">'text'</span> id=<span class=\"string\">'el'</span> value=<span class=\"number\">10</span> /&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;div &gt;<span class=\"number\">5</span>本书的价格：&lt;span id=<span class=\"string\">'el2'</span>&gt;<span class=\"number\">50</span>&lt;<span class=\"regexp\">/span&gt;元&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n<p>当改变input值得时候，效果如下<a href=\"http://xxdy.tech/event/index.html\">demo地址</a> ：<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/25/165718064234986c?w=600&h=185&f=gif&s=7690486\"></p>\n<p>大概思路捋一下：<br>1、自定义事件，priceChange，用来监听改变price的改变<br>2、 加个监听事件，priceChange触发时改变total的值。<br>3、input value改变的时候，触发priceChange事件<br>代码实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#el'</span>),</span><br><span class=\"line\">    total1 = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#el2'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> eventAwesome = <span class=\"keyword\">new</span> CustomEvent(<span class=\"string\">'priceChange'</span>, &#123;</span><br><span class=\"line\">    bubbles: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    detail: &#123; <span class=\"attr\">getprice</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'priceChange'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price = e.detail.getprice() || <span class=\"number\">0</span></span><br><span class=\"line\">    total1.innerHTML=<span class=\"number\">5</span> * price</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">el.addEventListener(<span class=\"string\">'change'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> val = e.target.value</span><br><span class=\"line\">  e.target.dispatchEvent(eventAwesome)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>代码确实比较简单，当然实现的方式是多样的。但是看起来是不是有点vue数据响应的味道。<br>确实目前大多数框架中都会用到发布订阅的方式来处理数据的变化。例如vue，react等，以vue为例子，我们可以来看看其数据响应的基本原理。  </p>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><p>这里的自定义事件就是前面提到的第二层定义了，非基于浏览器的事件。这种事件也正是大型前端项目中常用到。对照原生事件，应该具有on、trigger、off三个方法。分别看一下</p>\n<ol>\n<li>对照原生事件很容易理解，绑定一个事件，应该有对应方法名和回调,当然还有一个事件队列</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event1</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 事件队列</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>._events = &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// type对应事件名称，call回调</span></span><br><span class=\"line\">    on(type,call)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> funs = <span class=\"keyword\">this</span>._events[type]</span><br><span class=\"line\">      <span class=\"comment\">// 首次直接赋值，同种类型事件可能多个回调所以数组</span></span><br><span class=\"line\">      <span class=\"comment\">// 否则push进入队列即可</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(funs)&#123;</span><br><span class=\"line\">        funs.push(call)</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._events.type=[]</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._events.type.push(call)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>触发事件trigger</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">    trigger(type)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> funs = <span class=\"keyword\">this</span>._events.type,</span><br><span class=\"line\">        [first,...other] = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">      <span class=\"comment\">//对应事件类型存在，循环执行回调队列  </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(funs)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>,</span><br><span class=\"line\">            j = funs.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i &lt; j; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> cb = funs[i];</span><br><span class=\"line\">          cb.apply(<span class=\"keyword\">this</span>, other);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>解除绑定：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 取消绑定，还是循环查找</span></span><br><span class=\"line\">    off(type,func)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> funs = <span class=\"keyword\">this</span>._events.type</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(funs)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>,</span><br><span class=\"line\">          j = funs.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; j; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> cb = funs[i];</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (cb === func) &#123;</span><br><span class=\"line\">            funs.splice(i, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这样一个简单的事件系统就完成了，结合这个事件系统，我们可以实现下上面那个例子。<br>html不变，绑定和触发事件的方式改变一下就好</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化 event1为了区别原生Event</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> event1 = <span class=\"keyword\">new</span> Event1()    </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 此处监听 priceChange 即可</span></span><br><span class=\"line\"> event1.on(<span class=\"string\">'priceChange'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// 值获取方式修改</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> price = count.value || <span class=\"number\">0</span></span><br><span class=\"line\">     total1.innerHTML = <span class=\"number\">5</span> * price</span><br><span class=\"line\">   &#125;)  </span><br><span class=\"line\"> el.addEventListener(<span class=\"string\">'change'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> val = e.target.value</span><br><span class=\"line\">   <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">   event1.trigger(<span class=\"string\">'priceChange'</span>)</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n<p>这样同样可以实现上面的效果，实现了事件系统之后，我们接着实现一下vue里面的数据响应。</p>\n<h3 id=\"vue的数据响应\"><a href=\"#vue的数据响应\" class=\"headerlink\" title=\"vue的数据响应\"></a>vue的数据响应</h3><p>说到vue的数据响应，网上相关文章简直太多了，这里就不深入去讨论了。简单搬运一下基本概念。详细的话大家可以自行搜索。  </p>\n<h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><p>直接看图比较直观：<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/25/165718027cb03c89?w=800&h=500&f=png&s=64811\"><br>就是通过观察者模式来实现，不过其通过数据劫持方式实现的更加巧妙。<br>数据劫持是通过Object.defineProperty()来监听各个属性的变化，从而进行一些额外操作。<br>举个简单例子：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;</span><br><span class=\"line\">   b:<span class=\"string\">'1'</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a,<span class=\"string\">'b'</span>,&#123;</span><br><span class=\"line\">        get()&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'get&gt;&gt;&gt;'</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set(newVal)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'set&gt;&gt;&gt;11'</span>,<span class=\"string\">'设置是不被允许的'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">a.b <span class=\"comment\">//'get&gt;&gt;&gt;1'</span></span><br><span class=\"line\">a.b = <span class=\"number\">11</span>    <span class=\"comment\">//set&gt;&gt;&gt;11 设置是不被允许的</span></span><br></pre></td></tr></table></figure>\n<p>所谓数据劫持就是在get/set操作时加上额外操作，这里是加了些log，如果在这里去监听某些属性的变化，进而更改其他属性也是可行的。<br>要达到目的，应该对每个属性在get是监听，set的时候出发事件，且每个属性上只注册一次。<br>另外应该每个属性对应一个监听者，这样处理起来比较方便，如果和上面那样全放在一个监听实例里面，有多个属性及复杂操作时，就太难维护了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本数据</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">    price: <span class=\"number\">5</span>,</span><br><span class=\"line\">    count: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">callb = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>可以对自定义事件进行部分改造,<br>不需要显式指定type，全局维护一个标记即可<br>事件数组一维即可，因为是每个属性对应一个示例  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Events</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._events = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    on() &#123;</span><br><span class=\"line\">      <span class=\"comment\">//此处不需要指定tyep了</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callb &amp;&amp; !<span class=\"keyword\">this</span>._events.includes(callb)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._events.push(callb)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    triger() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._events.forEach(<span class=\"function\">(<span class=\"params\">callb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        callb &amp;&amp; callb()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>对应上图中vue的Data部分，就是实行数据劫持的地方</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(data).forEach(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> initVlue = data[key]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> e1 = <span class=\"keyword\">new</span> Events()</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(data, key, &#123;</span><br><span class=\"line\">      get() &#123;</span><br><span class=\"line\">         <span class=\"comment\">//内部判断是否需要注册</span></span><br><span class=\"line\">        e1.on()</span><br><span class=\"line\">        <span class=\"comment\">// 执行过置否</span></span><br><span class=\"line\">        callb = <span class=\"literal\">null</span></span><br><span class=\"line\">        <span class=\"comment\">// get不变更值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> initVlue</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      set(newVal) &#123;</span><br><span class=\"line\">        initVlue = newVal</span><br><span class=\"line\">        <span class=\"comment\">// set操作触发事件，同步数据变动</span></span><br><span class=\"line\">        e1.triger()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>此时数据劫持即事件监听准备完成，大家可能会发现callback始终为null，这始终不能起作用。为了解决该问题，下面的watcher就要出场了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watcher</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 参数赋予callback，执行时触发get方法，进行监听事件注册</span></span><br><span class=\"line\">    callb = func</span><br><span class=\"line\">    <span class=\"comment\">// 初次执行时，获取对应值自然经过get方法注册事件</span></span><br><span class=\"line\">    callb()</span><br><span class=\"line\">    <span class=\"comment\">// 置否避免重复注册</span></span><br><span class=\"line\">    callb = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 此处指定事件触发回调，注册监听事件</span></span><br><span class=\"line\">  watcher(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    data.total = data.price * data.count</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>这样就保证了会将监听事件挂载上去。到这里，乞丐版数据响应应该就能跑了。<br>再加上dom事件的处理，双向绑定也不难实现。<br>可以将下面的完整代码放到console台跑跑看。   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">    price: <span class=\"number\">5</span>,</span><br><span class=\"line\">    count: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">    callb = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Events</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._events = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    on() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callb &amp;&amp; !<span class=\"keyword\">this</span>._events.includes(callb)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._events.push(callb)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    triger() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._events.forEach(<span class=\"function\">(<span class=\"params\">callb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        callb &amp;&amp; callb()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(data).forEach(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> initVlue = data[key]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> e1 = <span class=\"keyword\">new</span> Events()</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(data, key, &#123;</span><br><span class=\"line\">      get() &#123;</span><br><span class=\"line\">         <span class=\"comment\">//内部判断是否需要注册</span></span><br><span class=\"line\">        e1.on()</span><br><span class=\"line\">        <span class=\"comment\">// 执行过置否</span></span><br><span class=\"line\">        callb = <span class=\"literal\">null</span></span><br><span class=\"line\">        <span class=\"comment\">// get不变更值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> initVlue</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      set(newVal) &#123;</span><br><span class=\"line\">        initVlue = newVal</span><br><span class=\"line\">        <span class=\"comment\">// set操作触发事件，同步数据变动</span></span><br><span class=\"line\">        e1.triger()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watcher</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 参数赋予callback，执行时触发get方法，进行监听事件注册</span></span><br><span class=\"line\">    callb = func</span><br><span class=\"line\">    <span class=\"comment\">// 初次执行时，获取对应值自然经过get方法注册事件</span></span><br><span class=\"line\">    callb()</span><br><span class=\"line\">    <span class=\"comment\">// 置否避免重复注册</span></span><br><span class=\"line\">    callb = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 此处指定事件触发回调，注册监听事件</span></span><br><span class=\"line\">  watcher(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    data.total = data.price * data.count</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"https://medium.com/vue-mastery/the-best-explanation-of-javascript-reactivity-fea6112dd80d\" target=\"_blank\" rel=\"noopener\">vue数据响应的实现</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events\" target=\"_blank\" rel=\"noopener\">Creating and triggering events</a><br>看到知识盲点，就需要立即行动，不然下次还是盲点。正好是事件相关，就一并总结了下发布订阅相关进而到了数据响应的实现。个人的一点心得记录，分享出来希望共同学习和进步。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">更多请移步我的博客</a><br><a href=\"http://xxdy.tech/event/index.html\">demo地址</a><br><a href=\"https://github.com/xiaoxiangdaiyu/blog/blob/master/source/event/index.html\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>除了大家经常提到的自定义事件之外，浏览器本身也支持我们自定义事件，我们常说的自定义事件一般用于项目中的一些通知机制。最近正好看到了这部分，就一起看了下自定义事件不同的实现，以及vue数据响应的基本原理。<br>","more":"</p>\n<h2 id=\"浏览器自定义事件\"><a href=\"#浏览器自定义事件\" class=\"headerlink\" title=\"浏览器自定义事件\"></a>浏览器自定义事件</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>除了我们常见的click，touch等事件之外，浏览器支持我们定义和分发自定义事件。<br>创建也十分简单：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//创建名为test的自定义事件</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> Event(<span class=\"string\">'test'</span>)</span><br><span class=\"line\"><span class=\"comment\">//如果是需要更多参数可以这样</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"keyword\">new</span> CustomEvent(<span class=\"string\">'test'</span>, &#123; <span class=\"string\">'detail'</span>: elem.dataset.time &#125;);</span><br></pre></td></tr></table></figure>\n<p>大多数现代浏览器对new Event/CustomEvent 的支持还算可以（IE除外），可以看下具体情况：<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/25/16571803c3080b60?w=2554&h=1016&f=png&s=135371\"><br>可以放心大胆的使用，如果非要兼容IE那么有下面的方式</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> event = <span class=\"built_in\">document</span>.createEvent(<span class=\"string\">'Event'</span>);</span><br><span class=\"line\"><span class=\"comment\">//相关参数</span></span><br><span class=\"line\">event.initEvent(<span class=\"string\">'test'</span>, <span class=\"literal\">true</span>, <span class=\"literal\">true</span>);</span><br></pre></td></tr></table></figure>\n<p>自定义事件的触发和原生事件类似，可以通过冒泡事件触发。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">textarea</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">textarea</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>触发如下，这里就偷个懒，直接拿mdn的源码来示例了，毕竟清晰易懂。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> form = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'form'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> textarea = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'textarea'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//创建新的事件，允许冒泡，支持传递在details中定义的所有数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> eventAwesome = <span class=\"keyword\">new</span> CustomEvent(<span class=\"string\">'awesome'</span>, &#123;</span><br><span class=\"line\">  bubbles: <span class=\"literal\">true</span>,</span><br><span class=\"line\">  detail: &#123; <span class=\"attr\">text</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> textarea.value &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//form元素监听自定义的awesome事件，打印text事件的输出</span></span><br><span class=\"line\">  <span class=\"comment\">// 也就是text的输出内容</span></span><br><span class=\"line\">form.addEventListener(<span class=\"string\">'awesome'</span>, e =&gt; <span class=\"built_in\">console</span>.log(e.detail.text()));</span><br><span class=\"line\">  <span class=\"comment\">//  </span></span><br><span class=\"line\">  <span class=\"comment\">// textarea当输入时，触发awesome</span></span><br><span class=\"line\">textarea.addEventListener(<span class=\"string\">'input'</span>, e =&gt; e.target.dispatchEvent(eventAwesome));</span><br></pre></td></tr></table></figure>\n<p>上面例子很清晰的展示了自定义事件定义、监听、触发的整个过程，和原生事件的流程相比看起来多了个触发的步骤，原因在原生事件的触发已经被封装无需手动处理而已。   </p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><h3 id=\"各大js类库\"><a href=\"#各大js类库\" class=\"headerlink\" title=\"各大js类库\"></a>各大js类库</h3><p>各种js库中用到的也比较多，例如zepto中的tap，原理就是监听touch事件，然后去触发自定的tap事件(当然这种成熟的框架做的是比较严谨的)。可以看下部分代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这里做了个event的map，来将原始事件对应为自定义事件以便处理</span></span><br><span class=\"line\"><span class=\"comment\">// 可以只关注下ontouchstart，这里先判断是否移动端，移动端down就对应touchstart，up对应touchend，后面的可以先不关注</span></span><br><span class=\"line\">eventMap = (__eventMap &amp;&amp; (<span class=\"string\">'down'</span> <span class=\"keyword\">in</span> __eventMap)) ? __eventMap :</span><br><span class=\"line\">      (<span class=\"string\">'ontouchstart'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span> ?</span><br><span class=\"line\">      &#123; <span class=\"string\">'down'</span>: <span class=\"string\">'touchstart'</span>, <span class=\"string\">'up'</span>: <span class=\"string\">'touchend'</span>,</span><br><span class=\"line\">        <span class=\"string\">'move'</span>: <span class=\"string\">'touchmove'</span>, <span class=\"string\">'cancel'</span>: <span class=\"string\">'touchcancel'</span> &#125; :</span><br><span class=\"line\">      <span class=\"string\">'onpointerdown'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span> ?</span><br><span class=\"line\">      &#123; <span class=\"string\">'down'</span>: <span class=\"string\">'pointerdown'</span>, <span class=\"string\">'up'</span>: <span class=\"string\">'pointerup'</span>,</span><br><span class=\"line\">        <span class=\"string\">'move'</span>: <span class=\"string\">'pointermove'</span>, <span class=\"string\">'cancel'</span>: <span class=\"string\">'pointercancel'</span> &#125; :</span><br><span class=\"line\">       <span class=\"string\">'onmspointerdown'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">document</span> ?</span><br><span class=\"line\">      &#123; <span class=\"string\">'down'</span>: <span class=\"string\">'MSPointerDown'</span>, <span class=\"string\">'up'</span>: <span class=\"string\">'MSPointerUp'</span>,</span><br><span class=\"line\">        <span class=\"string\">'move'</span>: <span class=\"string\">'MSPointerMove'</span>, <span class=\"string\">'cancel'</span>: <span class=\"string\">'MSPointerCancel'</span> &#125; : <span class=\"literal\">false</span>)</span><br><span class=\"line\"> <span class=\"comment\">//监听事件</span></span><br><span class=\"line\">     $(<span class=\"built_in\">document</span>).on(eventMap.up, up)</span><br><span class=\"line\">      .on(eventMap.down, down)</span><br><span class=\"line\">      .on(eventMap.move, move)       </span><br><span class=\"line\"> <span class=\"comment\">//up事件即touchend时，满足条件的会触发tap    </span></span><br><span class=\"line\"> <span class=\"keyword\">var</span> up = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">/* 忽略 */</span></span><br><span class=\"line\">       tapTimeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">           <span class=\"keyword\">var</span> event = $.Event(<span class=\"string\">'tap'</span>)</span><br><span class=\"line\">            event.cancelTouch = cancelAll</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (touch.el) touch.el.trigger(event); </span><br><span class=\"line\">          &#125;,<span class=\"number\">0</span>）</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">     <span class=\"comment\">//其他</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"发布订阅\"><a href=\"#发布订阅\" class=\"headerlink\" title=\"发布订阅\"></a>发布订阅</h3><p>和原生事件一样，大部分都用于观察者模式中。除了上面的库之外，自己开发过程中用到的地方也不少。<br>举个例子，一个输入框表示单价，另一个div表示五本的总价，单价改变总价也会变动。借助自定义事件应该怎么实现呢。<br>html结构比较简单</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div &gt;一本书的价格：&lt;input type=<span class=\"string\">'text'</span> id=<span class=\"string\">'el'</span> value=<span class=\"number\">10</span> /&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">&lt;div &gt;<span class=\"number\">5</span>本书的价格：&lt;span id=<span class=\"string\">'el2'</span>&gt;<span class=\"number\">50</span>&lt;<span class=\"regexp\">/span&gt;元&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>\n<p>当改变input值得时候，效果如下<a href=\"http://xxdy.tech/event/index.html\">demo地址</a> ：<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/25/165718064234986c?w=600&h=185&f=gif&s=7690486\"></p>\n<p>大概思路捋一下：<br>1、自定义事件，priceChange，用来监听改变price的改变<br>2、 加个监听事件，priceChange触发时改变total的值。<br>3、input value改变的时候，触发priceChange事件<br>代码实现如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> count = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#el'</span>),</span><br><span class=\"line\">    total1 = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'#el2'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> eventAwesome = <span class=\"keyword\">new</span> CustomEvent(<span class=\"string\">'priceChange'</span>, &#123;</span><br><span class=\"line\">    bubbles: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    detail: &#123; <span class=\"attr\">getprice</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> count.value &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"><span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'priceChange'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> price = e.detail.getprice() || <span class=\"number\">0</span></span><br><span class=\"line\">    total1.innerHTML=<span class=\"number\">5</span> * price</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">el.addEventListener(<span class=\"string\">'change'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> val = e.target.value</span><br><span class=\"line\">  e.target.dispatchEvent(eventAwesome)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>代码确实比较简单，当然实现的方式是多样的。但是看起来是不是有点vue数据响应的味道。<br>确实目前大多数框架中都会用到发布订阅的方式来处理数据的变化。例如vue，react等，以vue为例子，我们可以来看看其数据响应的基本原理。  </p>\n<h2 id=\"自定义事件\"><a href=\"#自定义事件\" class=\"headerlink\" title=\"自定义事件\"></a>自定义事件</h2><p>这里的自定义事件就是前面提到的第二层定义了，非基于浏览器的事件。这种事件也正是大型前端项目中常用到。对照原生事件，应该具有on、trigger、off三个方法。分别看一下</p>\n<ol>\n<li>对照原生事件很容易理解，绑定一个事件，应该有对应方法名和回调,当然还有一个事件队列</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Event1</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">      <span class=\"comment\">// 事件队列</span></span><br><span class=\"line\">      <span class=\"keyword\">this</span>._events = &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// type对应事件名称，call回调</span></span><br><span class=\"line\">    on(type,call)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> funs = <span class=\"keyword\">this</span>._events[type]</span><br><span class=\"line\">      <span class=\"comment\">// 首次直接赋值，同种类型事件可能多个回调所以数组</span></span><br><span class=\"line\">      <span class=\"comment\">// 否则push进入队列即可</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(funs)&#123;</span><br><span class=\"line\">        funs.push(call)</span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._events.type=[]</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._events.type.push(call)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>触发事件trigger</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">    trigger(type)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> funs = <span class=\"keyword\">this</span>._events.type,</span><br><span class=\"line\">        [first,...other] = <span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">      <span class=\"comment\">//对应事件类型存在，循环执行回调队列  </span></span><br><span class=\"line\">      <span class=\"keyword\">if</span>(funs)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>,</span><br><span class=\"line\">            j = funs.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i=<span class=\"number\">0</span>; i &lt; j; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> cb = funs[i];</span><br><span class=\"line\">          cb.apply(<span class=\"keyword\">this</span>, other);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>解除绑定：</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 取消绑定，还是循环查找</span></span><br><span class=\"line\">    off(type,func)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> funs = <span class=\"keyword\">this</span>._events.type</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(funs)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>,</span><br><span class=\"line\">          j = funs.length;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; j; i++) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">let</span> cb = funs[i];</span><br><span class=\"line\">           <span class=\"keyword\">if</span> (cb === func) &#123;</span><br><span class=\"line\">            funs.splice(i, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>这样一个简单的事件系统就完成了，结合这个事件系统，我们可以实现下上面那个例子。<br>html不变，绑定和触发事件的方式改变一下就好</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化 event1为了区别原生Event</span></span><br><span class=\"line\"> <span class=\"keyword\">const</span> event1 = <span class=\"keyword\">new</span> Event1()    </span><br><span class=\"line\"> </span><br><span class=\"line\"> <span class=\"comment\">// 此处监听 priceChange 即可</span></span><br><span class=\"line\"> event1.on(<span class=\"string\">'priceChange'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// 值获取方式修改</span></span><br><span class=\"line\">     <span class=\"keyword\">var</span> price = count.value || <span class=\"number\">0</span></span><br><span class=\"line\">     total1.innerHTML = <span class=\"number\">5</span> * price</span><br><span class=\"line\">   &#125;)  </span><br><span class=\"line\"> el.addEventListener(<span class=\"string\">'change'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> val = e.target.value</span><br><span class=\"line\">   <span class=\"comment\">// 触发事件</span></span><br><span class=\"line\">   event1.trigger(<span class=\"string\">'priceChange'</span>)</span><br><span class=\"line\"> &#125;);</span><br></pre></td></tr></table></figure>\n<p>这样同样可以实现上面的效果，实现了事件系统之后，我们接着实现一下vue里面的数据响应。</p>\n<h3 id=\"vue的数据响应\"><a href=\"#vue的数据响应\" class=\"headerlink\" title=\"vue的数据响应\"></a>vue的数据响应</h3><p>说到vue的数据响应，网上相关文章简直太多了，这里就不深入去讨论了。简单搬运一下基本概念。详细的话大家可以自行搜索。  </p>\n<h3 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h3><p>直接看图比较直观：<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/25/165718027cb03c89?w=800&h=500&f=png&s=64811\"><br>就是通过观察者模式来实现，不过其通过数据劫持方式实现的更加巧妙。<br>数据劫持是通过Object.defineProperty()来监听各个属性的变化，从而进行一些额外操作。<br>举个简单例子：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> a = &#123;</span><br><span class=\"line\">   b:<span class=\"string\">'1'</span> </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a,<span class=\"string\">'b'</span>,&#123;</span><br><span class=\"line\">        get()&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'get&gt;&gt;&gt;'</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        set(newVal)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'set&gt;&gt;&gt;11'</span>,<span class=\"string\">'设置是不被允许的'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">a.b <span class=\"comment\">//'get&gt;&gt;&gt;1'</span></span><br><span class=\"line\">a.b = <span class=\"number\">11</span>    <span class=\"comment\">//set&gt;&gt;&gt;11 设置是不被允许的</span></span><br></pre></td></tr></table></figure>\n<p>所谓数据劫持就是在get/set操作时加上额外操作，这里是加了些log，如果在这里去监听某些属性的变化，进而更改其他属性也是可行的。<br>要达到目的，应该对每个属性在get是监听，set的时候出发事件，且每个属性上只注册一次。<br>另外应该每个属性对应一个监听者，这样处理起来比较方便，如果和上面那样全放在一个监听实例里面，有多个属性及复杂操作时，就太难维护了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//基本数据</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">    price: <span class=\"number\">5</span>,</span><br><span class=\"line\">    count: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">callb = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>可以对自定义事件进行部分改造,<br>不需要显式指定type，全局维护一个标记即可<br>事件数组一维即可，因为是每个属性对应一个示例  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Events</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._events = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    on() &#123;</span><br><span class=\"line\">      <span class=\"comment\">//此处不需要指定tyep了</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callb &amp;&amp; !<span class=\"keyword\">this</span>._events.includes(callb)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._events.push(callb)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    triger() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._events.forEach(<span class=\"function\">(<span class=\"params\">callb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        callb &amp;&amp; callb()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>对应上图中vue的Data部分，就是实行数据劫持的地方</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.keys(data).forEach(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> initVlue = data[key]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> e1 = <span class=\"keyword\">new</span> Events()</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(data, key, &#123;</span><br><span class=\"line\">      get() &#123;</span><br><span class=\"line\">         <span class=\"comment\">//内部判断是否需要注册</span></span><br><span class=\"line\">        e1.on()</span><br><span class=\"line\">        <span class=\"comment\">// 执行过置否</span></span><br><span class=\"line\">        callb = <span class=\"literal\">null</span></span><br><span class=\"line\">        <span class=\"comment\">// get不变更值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> initVlue</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      set(newVal) &#123;</span><br><span class=\"line\">        initVlue = newVal</span><br><span class=\"line\">        <span class=\"comment\">// set操作触发事件，同步数据变动</span></span><br><span class=\"line\">        e1.triger()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>此时数据劫持即事件监听准备完成，大家可能会发现callback始终为null，这始终不能起作用。为了解决该问题，下面的watcher就要出场了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watcher</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 参数赋予callback，执行时触发get方法，进行监听事件注册</span></span><br><span class=\"line\">    callb = func</span><br><span class=\"line\">    <span class=\"comment\">// 初次执行时，获取对应值自然经过get方法注册事件</span></span><br><span class=\"line\">    callb()</span><br><span class=\"line\">    <span class=\"comment\">// 置否避免重复注册</span></span><br><span class=\"line\">    callb = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 此处指定事件触发回调，注册监听事件</span></span><br><span class=\"line\">  watcher(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    data.total = data.price * data.count</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>这样就保证了会将监听事件挂载上去。到这里，乞丐版数据响应应该就能跑了。<br>再加上dom事件的处理，双向绑定也不难实现。<br>可以将下面的完整代码放到console台跑跑看。   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> data = &#123;</span><br><span class=\"line\">    price: <span class=\"number\">5</span>,</span><br><span class=\"line\">    count: <span class=\"number\">2</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">    callb = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Events</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._events = []</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    on() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (callb &amp;&amp; !<span class=\"keyword\">this</span>._events.includes(callb)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._events.push(callb)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    triger() &#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>._events.forEach(<span class=\"function\">(<span class=\"params\">callb</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        callb &amp;&amp; callb()</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"built_in\">Object</span>.keys(data).forEach(<span class=\"function\">(<span class=\"params\">key</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> initVlue = data[key]</span><br><span class=\"line\">    <span class=\"keyword\">const</span> e1 = <span class=\"keyword\">new</span> Events()</span><br><span class=\"line\">    <span class=\"built_in\">Object</span>.defineProperty(data, key, &#123;</span><br><span class=\"line\">      get() &#123;</span><br><span class=\"line\">         <span class=\"comment\">//内部判断是否需要注册</span></span><br><span class=\"line\">        e1.on()</span><br><span class=\"line\">        <span class=\"comment\">// 执行过置否</span></span><br><span class=\"line\">        callb = <span class=\"literal\">null</span></span><br><span class=\"line\">        <span class=\"comment\">// get不变更值</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> initVlue</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      set(newVal) &#123;</span><br><span class=\"line\">        initVlue = newVal</span><br><span class=\"line\">        <span class=\"comment\">// set操作触发事件，同步数据变动</span></span><br><span class=\"line\">        e1.triger()</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">watcher</span>(<span class=\"params\">func</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 参数赋予callback，执行时触发get方法，进行监听事件注册</span></span><br><span class=\"line\">    callb = func</span><br><span class=\"line\">    <span class=\"comment\">// 初次执行时，获取对应值自然经过get方法注册事件</span></span><br><span class=\"line\">    callb()</span><br><span class=\"line\">    <span class=\"comment\">// 置否避免重复注册</span></span><br><span class=\"line\">    callb = <span class=\"literal\">null</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 此处指定事件触发回调，注册监听事件</span></span><br><span class=\"line\">  watcher(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    data.total = data.price * data.count</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"https://medium.com/vue-mastery/the-best-explanation-of-javascript-reactivity-fea6112dd80d\" target=\"_blank\" rel=\"noopener\">vue数据响应的实现</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events\" target=\"_blank\" rel=\"noopener\">Creating and triggering events</a><br>看到知识盲点，就需要立即行动，不然下次还是盲点。正好是事件相关，就一并总结了下发布订阅相关进而到了数据响应的实现。个人的一点心得记录，分享出来希望共同学习和进步。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">更多请移步我的博客</a><br><a href=\"http://xxdy.tech/event/index.html\">demo地址</a><br><a href=\"https://github.com/xiaoxiangdaiyu/blog/blob/master/source/event/index.html\" target=\"_blank\" rel=\"noopener\">源码地址</a></p>"},{"title":"开篇","date":"2017-09-13T16:00:00.000Z","_content":"原本也有些技术总结和学习笔记，不给过一直都是放在[博客园](http://www.cnblogs.com/pqjwyn/)和[掘金](https://juejin.im/user/584e46a2ac502e006c749486)上面。当时的想法是，既然第三方已经提供了成熟的博客系统，其实也没必要自己折腾了，有这个时间还不如干点别的(说到底还是懒)。就这样坚持了一段时间，最终让我自己动起来的原因在于，搞了下PWA，结果发现只能自己本地调试，打算偷个懒发现还不能加载js。算了还是把gitpages利用起来好了。就这样开始折腾了，先大致搞出来东西再说\n<!-- more -->\n## [早期博客](http://www.cnblogs.com/pqjwyn/p/) \n","source":"_posts/index.md","raw":"---\ntitle: 开篇\ndate: 2017-09-14\n---\n原本也有些技术总结和学习笔记，不给过一直都是放在[博客园](http://www.cnblogs.com/pqjwyn/)和[掘金](https://juejin.im/user/584e46a2ac502e006c749486)上面。当时的想法是，既然第三方已经提供了成熟的博客系统，其实也没必要自己折腾了，有这个时间还不如干点别的(说到底还是懒)。就这样坚持了一段时间，最终让我自己动起来的原因在于，搞了下PWA，结果发现只能自己本地调试，打算偷个懒发现还不能加载js。算了还是把gitpages利用起来好了。就这样开始折腾了，先大致搞出来东西再说\n<!-- more -->\n## [早期博客](http://www.cnblogs.com/pqjwyn/p/) \n","slug":"index","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1n000mgw92jf6l4l0z","content":"<p>原本也有些技术总结和学习笔记，不给过一直都是放在<a href=\"http://www.cnblogs.com/pqjwyn/\" target=\"_blank\" rel=\"noopener\">博客园</a>和<a href=\"https://juejin.im/user/584e46a2ac502e006c749486\" target=\"_blank\" rel=\"noopener\">掘金</a>上面。当时的想法是，既然第三方已经提供了成熟的博客系统，其实也没必要自己折腾了，有这个时间还不如干点别的(说到底还是懒)。就这样坚持了一段时间，最终让我自己动起来的原因在于，搞了下PWA，结果发现只能自己本地调试，打算偷个懒发现还不能加载js。算了还是把gitpages利用起来好了。就这样开始折腾了，先大致搞出来东西再说<br><a id=\"more\"></a></p>\n<h2 id=\"早期博客\"><a href=\"#早期博客\" class=\"headerlink\" title=\"早期博客\"></a><a href=\"http://www.cnblogs.com/pqjwyn/p/\" target=\"_blank\" rel=\"noopener\">早期博客</a></h2>","site":{"data":{}},"excerpt":"<p>原本也有些技术总结和学习笔记，不给过一直都是放在<a href=\"http://www.cnblogs.com/pqjwyn/\" target=\"_blank\" rel=\"noopener\">博客园</a>和<a href=\"https://juejin.im/user/584e46a2ac502e006c749486\" target=\"_blank\" rel=\"noopener\">掘金</a>上面。当时的想法是，既然第三方已经提供了成熟的博客系统，其实也没必要自己折腾了，有这个时间还不如干点别的(说到底还是懒)。就这样坚持了一段时间，最终让我自己动起来的原因在于，搞了下PWA，结果发现只能自己本地调试，打算偷个懒发现还不能加载js。算了还是把gitpages利用起来好了。就这样开始折腾了，先大致搞出来东西再说<br>","more":"</p>\n<h2 id=\"早期博客\"><a href=\"#早期博客\" class=\"headerlink\" title=\"早期博客\"></a><a href=\"http://www.cnblogs.com/pqjwyn/p/\" target=\"_blank\" rel=\"noopener\">早期博客</a></h2>"},{"title":"f5到底刷新了点什么，你知道吗","date":"2018-11-17T16:00:00.000Z","_content":"## 引言\n前面翻到了http缓存相关内容，关于强制缓存和协商缓存，他们之间的差别可能大家比较清楚。  \n并且常规情况下是否该使用缓存以及使用哪种缓存，  \n相关文章多且全，这里不再赘述。  \n不过用户的不同行为会打破原有规范，  \n本文就会去探究下不同行为下的浏览器缓存表现。也就是f5到底刷新了哪些内容 \n<!-- more -->\n## 浏览器缓存\n\n说道浏览器缓存，脑海中常见的应该是那么几种关键词：  \nCache-Control、Expires、ETag、If-Match、If-None-Match、Last-Modified等。  \n根据不同标识的作用，再次访问某个资源时，  \n需要缓存的情况下，主要有下面两种缓存方式 \n\n### 强缓存\n\n一旦资源命中强缓存, 浏览器便不会向服务器发送请求, 而是直接读取缓存.  \nChrome下的现象是 200 OK (from disk cache) 或者 200 OK (from memory cache).\n\n### 协商缓存 \n\n也就是我们常见的304状态码。  \n\n缓存过期后, 继续请求该资源,  \n对于现代浏览器, 存在如下两种做法:\n\n* 根据上次响应中的ETag_value, 自动往request header中添加If-None-Match字段.  \n服务器收到请求后, 拿If-None-Match字段的值与资源的ETag值进行比较, \n若相同, 则命中协商缓存, 返回304响应.\n* 根据上次响应中的Last-Modified_value, 自动往request header中添加If-Modified-Since字段. 服务器收到请求后, 拿If-Modified-Since字段的值与资源的Last-Modified值进行比较, 若相同, 则命中协商缓存, 返回304响应.\n\nETag是http/1.1新增标识，也是为了解决Last-Modified存在的一些问题。  \n例如服务器和客户端时间不同步等问题，  \n所以比Last-Modified的优先级高。\n  \n因此常见情况下，资源的缓存就是按照上面的顺序，强缓存=>协商缓存=>重新获取。  \n但是，缓存策略是与用户的操作相关的，平时不可避免会用到刷新。  \n刷新的方式是多种多样的。刷新按钮，command+r，shift+command+r等。他们之间的区别是什么呢。以[http://xxdy.tech/](http://xxdy.tech/)作为例子来看一下。 \n\n### 再次访问(地址栏回车)\n可以看到资源分下面几类：\n先看下直观的请求\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e047c0ba4bc?w=2792&h=804&f=jpeg&s=257017'/>\n大部分都是200强缓存，只有文稿是304\n\n1. 无缓存的，maxage=0的资源 \n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e0479ca2b8c?w=2436&h=1417&f=jpeg&s=314035'/>\n\n\n\n此类资源，请求的时候总会从服务端重新加载\n\n2. status为200，但是后面有提示from memory cache 或者disk cache的标识。  这种缓存的字体为灰色，跟上面的200还是比较容易看出来差别的。  \n\ncss资源的响应，来自硬盘缓存。\n\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e047750f409?w=2322&h=754&f=jpeg&s=172566'/>\n\njs的响应，即来自memory的缓存\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e047b391817?w=2240&h=528&f=jpeg&s=126209'/>\n\n这里就是强缓存，直接从本地缓存中读取。  \n因为Cache-Control:max-age=600 刷新时未过期，所以会从本地缓存中获取。\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e04799f47b4?w=1640&h=788&f=jpeg&s=182548'/>\n\n这里截两张图的原因在于两者缓存存放的位置是不同。\n概述一下(详细请找资料细究)\n\n* 内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性\n    快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取  \n    时效性：一旦该进程关闭，则该进程的内存则会清空。\n    \n* 硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。  \n\n    \n在浏览器中，大部分情况下浏览器会在js和图片等文件解析执行后直接存入内存缓存中，  \n那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；  \n而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)\n\n3. 协商缓存    \n\nstatus为304，意为与服务端对比之后文件未改变，返回原有缓存资源。\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e047ca6b703?w=2052&h=1064&f=jpeg&s=225389'/>\n\n \n  \n此资源请求头里面有Cache-Control: max-age=0 ，  \n所以每次请求都回去服务端询问，不会走强缓存，因为服务端也未更新，etag相同，所以返回缓存资源。  \n\n\n\n#### 总结\n地址栏回车的话，就是我们正常访问，遵循浏览器的缓存策略。\n  \n### f5刷新(mac 即command + r)\nf5刷新的时候，会有什么不同吗，先直观对比下。\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e05e17eef09?w=2872&h=922&f=jpeg&s=312384'/>  \n\n好像没什么不同，具体到文件也是与直接回车相同的状态。\n\n#### 总结\n那么f5的刷新到底是什么呢，  \n可以看到f5可以被称为soft refresh 其只是reload page而已。  \n即与回车地址相同，正常规则下的缓存还是会涉及到。\n\n### 强制刷新(command+shift+r)\n\n此时可以看下请求结果,前面列出的304和from cache的项目都是重新load。 \n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e05e17eef09?w=2872&h=922&f=jpeg&s=312384'/>   \n\n具体查看相应请求可以看到，  \n在request中多了个属性：\n都有Cache-Control: no-cache的标识。  \n这表明每次都需要服务器评估是否有效，不要理解为直接不使用缓存。  \n此外可以注意到request中没有可以匹配response中ETag的If-None-Match属性，  \n所以会重新加载。    \n\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e05e96a0246?w=2118&h=984&f=jpeg&s=195526'/>\n\n#### 总结而言\n\n此时的刷新可以称为hard refresh，  \n请求会加上一个Cache-Control:no-cache的标识来表明突破cache-control的限制，  \n需要服务端重新判断有效性，即不走强缓存。    \n另外请求header中去掉If-None-Match，这样就不能使用协商缓存。拉到新的资源    \n\n#### tip\n这里硬性重新加载,有些文件是依旧使用缓存的，我这边看到是有些小的image，没有找到合理的解释。具体我需要在研究一下，后面补上\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e05fdde9b86?w=1854&h=1086&f=jpeg&s=241473'/>\n\n\n  \n### 停用缓存并刷新\n\n针对上面提到的哪些文件，此时就需要到下面这种清空缓存并硬性重新加载了。\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e060babe54f?w=846&h=370&f=jpeg&s=40828'/>\n\n\n操作完之后就完全不使用缓存了。   \n### 规则\n上面提到那么几种刷新方式对应的效果，可能不同浏览器的实现也不同。找了个相对完善的大家可以参考一下。  \n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e07244920a8?w=791&h=443&f=png&s=24777'/>\n\n\n### 结束语  \n到这里，关于刷新与缓存的个人一些关掉就结束了，抛砖引玉，希望能对有需要的人有所帮助，也希望有大神有所指教。[更多个人博客请移步](https://github.com/xiaoxiangdaiyu/blog)  \n此外感谢下面的参考文章：   \n[https://stackoverflow.com/questions/8589760/difference-between-f5-ctrl-f5-and-click-or-refresh-button](https://stackoverflow.com/questions/8589760/difference-between-f5-ctrl-f5-and-click-or-refresh-button)  \n[https://stackoverflow.com/questions/385367/what-requests-do-browsers-f5-and-ctrl-f5-refreshes-generate](https://stackoverflow.com/questions/385367/what-requests-do-browsers-f5-and-ctrl-f5-refreshes-generate)\n\n\n\n","source":"_posts/f5.md","raw":"---\ntitle: f5到底刷新了点什么，你知道吗\ndate: 2018-11-18\n---\n## 引言\n前面翻到了http缓存相关内容，关于强制缓存和协商缓存，他们之间的差别可能大家比较清楚。  \n并且常规情况下是否该使用缓存以及使用哪种缓存，  \n相关文章多且全，这里不再赘述。  \n不过用户的不同行为会打破原有规范，  \n本文就会去探究下不同行为下的浏览器缓存表现。也就是f5到底刷新了哪些内容 \n<!-- more -->\n## 浏览器缓存\n\n说道浏览器缓存，脑海中常见的应该是那么几种关键词：  \nCache-Control、Expires、ETag、If-Match、If-None-Match、Last-Modified等。  \n根据不同标识的作用，再次访问某个资源时，  \n需要缓存的情况下，主要有下面两种缓存方式 \n\n### 强缓存\n\n一旦资源命中强缓存, 浏览器便不会向服务器发送请求, 而是直接读取缓存.  \nChrome下的现象是 200 OK (from disk cache) 或者 200 OK (from memory cache).\n\n### 协商缓存 \n\n也就是我们常见的304状态码。  \n\n缓存过期后, 继续请求该资源,  \n对于现代浏览器, 存在如下两种做法:\n\n* 根据上次响应中的ETag_value, 自动往request header中添加If-None-Match字段.  \n服务器收到请求后, 拿If-None-Match字段的值与资源的ETag值进行比较, \n若相同, 则命中协商缓存, 返回304响应.\n* 根据上次响应中的Last-Modified_value, 自动往request header中添加If-Modified-Since字段. 服务器收到请求后, 拿If-Modified-Since字段的值与资源的Last-Modified值进行比较, 若相同, 则命中协商缓存, 返回304响应.\n\nETag是http/1.1新增标识，也是为了解决Last-Modified存在的一些问题。  \n例如服务器和客户端时间不同步等问题，  \n所以比Last-Modified的优先级高。\n  \n因此常见情况下，资源的缓存就是按照上面的顺序，强缓存=>协商缓存=>重新获取。  \n但是，缓存策略是与用户的操作相关的，平时不可避免会用到刷新。  \n刷新的方式是多种多样的。刷新按钮，command+r，shift+command+r等。他们之间的区别是什么呢。以[http://xxdy.tech/](http://xxdy.tech/)作为例子来看一下。 \n\n### 再次访问(地址栏回车)\n可以看到资源分下面几类：\n先看下直观的请求\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e047c0ba4bc?w=2792&h=804&f=jpeg&s=257017'/>\n大部分都是200强缓存，只有文稿是304\n\n1. 无缓存的，maxage=0的资源 \n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e0479ca2b8c?w=2436&h=1417&f=jpeg&s=314035'/>\n\n\n\n此类资源，请求的时候总会从服务端重新加载\n\n2. status为200，但是后面有提示from memory cache 或者disk cache的标识。  这种缓存的字体为灰色，跟上面的200还是比较容易看出来差别的。  \n\ncss资源的响应，来自硬盘缓存。\n\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e047750f409?w=2322&h=754&f=jpeg&s=172566'/>\n\njs的响应，即来自memory的缓存\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e047b391817?w=2240&h=528&f=jpeg&s=126209'/>\n\n这里就是强缓存，直接从本地缓存中读取。  \n因为Cache-Control:max-age=600 刷新时未过期，所以会从本地缓存中获取。\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e04799f47b4?w=1640&h=788&f=jpeg&s=182548'/>\n\n这里截两张图的原因在于两者缓存存放的位置是不同。\n概述一下(详细请找资料细究)\n\n* 内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性\n    快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取  \n    时效性：一旦该进程关闭，则该进程的内存则会清空。\n    \n* 硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。  \n\n    \n在浏览器中，大部分情况下浏览器会在js和图片等文件解析执行后直接存入内存缓存中，  \n那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；  \n而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)\n\n3. 协商缓存    \n\nstatus为304，意为与服务端对比之后文件未改变，返回原有缓存资源。\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e047ca6b703?w=2052&h=1064&f=jpeg&s=225389'/>\n\n \n  \n此资源请求头里面有Cache-Control: max-age=0 ，  \n所以每次请求都回去服务端询问，不会走强缓存，因为服务端也未更新，etag相同，所以返回缓存资源。  \n\n\n\n#### 总结\n地址栏回车的话，就是我们正常访问，遵循浏览器的缓存策略。\n  \n### f5刷新(mac 即command + r)\nf5刷新的时候，会有什么不同吗，先直观对比下。\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e05e17eef09?w=2872&h=922&f=jpeg&s=312384'/>  \n\n好像没什么不同，具体到文件也是与直接回车相同的状态。\n\n#### 总结\n那么f5的刷新到底是什么呢，  \n可以看到f5可以被称为soft refresh 其只是reload page而已。  \n即与回车地址相同，正常规则下的缓存还是会涉及到。\n\n### 强制刷新(command+shift+r)\n\n此时可以看下请求结果,前面列出的304和from cache的项目都是重新load。 \n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e05e17eef09?w=2872&h=922&f=jpeg&s=312384'/>   \n\n具体查看相应请求可以看到，  \n在request中多了个属性：\n都有Cache-Control: no-cache的标识。  \n这表明每次都需要服务器评估是否有效，不要理解为直接不使用缓存。  \n此外可以注意到request中没有可以匹配response中ETag的If-None-Match属性，  \n所以会重新加载。    \n\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e05e96a0246?w=2118&h=984&f=jpeg&s=195526'/>\n\n#### 总结而言\n\n此时的刷新可以称为hard refresh，  \n请求会加上一个Cache-Control:no-cache的标识来表明突破cache-control的限制，  \n需要服务端重新判断有效性，即不走强缓存。    \n另外请求header中去掉If-None-Match，这样就不能使用协商缓存。拉到新的资源    \n\n#### tip\n这里硬性重新加载,有些文件是依旧使用缓存的，我这边看到是有些小的image，没有找到合理的解释。具体我需要在研究一下，后面补上\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e05fdde9b86?w=1854&h=1086&f=jpeg&s=241473'/>\n\n\n  \n### 停用缓存并刷新\n\n针对上面提到的哪些文件，此时就需要到下面这种清空缓存并硬性重新加载了。\n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e060babe54f?w=846&h=370&f=jpeg&s=40828'/>\n\n\n操作完之后就完全不使用缓存了。   \n### 规则\n上面提到那么几种刷新方式对应的效果，可能不同浏览器的实现也不同。找了个相对完善的大家可以参考一下。  \n<img src='https://user-gold-cdn.xitu.io/2018/11/27/16753e07244920a8?w=791&h=443&f=png&s=24777'/>\n\n\n### 结束语  \n到这里，关于刷新与缓存的个人一些关掉就结束了，抛砖引玉，希望能对有需要的人有所帮助，也希望有大神有所指教。[更多个人博客请移步](https://github.com/xiaoxiangdaiyu/blog)  \n此外感谢下面的参考文章：   \n[https://stackoverflow.com/questions/8589760/difference-between-f5-ctrl-f5-and-click-or-refresh-button](https://stackoverflow.com/questions/8589760/difference-between-f5-ctrl-f5-and-click-or-refresh-button)  \n[https://stackoverflow.com/questions/385367/what-requests-do-browsers-f5-and-ctrl-f5-refreshes-generate](https://stackoverflow.com/questions/385367/what-requests-do-browsers-f5-and-ctrl-f5-refreshes-generate)\n\n\n\n","slug":"f5","published":1,"updated":"2018-11-30T03:20:07.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1o000ngw92v7x5eimx","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>前面翻到了http缓存相关内容，关于强制缓存和协商缓存，他们之间的差别可能大家比较清楚。<br>并且常规情况下是否该使用缓存以及使用哪种缓存，<br>相关文章多且全，这里不再赘述。<br>不过用户的不同行为会打破原有规范，<br>本文就会去探究下不同行为下的浏览器缓存表现。也就是f5到底刷新了哪些内容<br><a id=\"more\"></a></p>\n<h2 id=\"浏览器缓存\"><a href=\"#浏览器缓存\" class=\"headerlink\" title=\"浏览器缓存\"></a>浏览器缓存</h2><p>说道浏览器缓存，脑海中常见的应该是那么几种关键词：<br>Cache-Control、Expires、ETag、If-Match、If-None-Match、Last-Modified等。<br>根据不同标识的作用，再次访问某个资源时，<br>需要缓存的情况下，主要有下面两种缓存方式 </p>\n<h3 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h3><p>一旦资源命中强缓存, 浏览器便不会向服务器发送请求, 而是直接读取缓存.<br>Chrome下的现象是 200 OK (from disk cache) 或者 200 OK (from memory cache).</p>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><p>也就是我们常见的304状态码。  </p>\n<p>缓存过期后, 继续请求该资源,<br>对于现代浏览器, 存在如下两种做法:</p>\n<ul>\n<li>根据上次响应中的ETag_value, 自动往request header中添加If-None-Match字段.<br>服务器收到请求后, 拿If-None-Match字段的值与资源的ETag值进行比较,<br>若相同, 则命中协商缓存, 返回304响应.</li>\n<li>根据上次响应中的Last-Modified_value, 自动往request header中添加If-Modified-Since字段. 服务器收到请求后, 拿If-Modified-Since字段的值与资源的Last-Modified值进行比较, 若相同, 则命中协商缓存, 返回304响应.</li>\n</ul>\n<p>ETag是http/1.1新增标识，也是为了解决Last-Modified存在的一些问题。<br>例如服务器和客户端时间不同步等问题，<br>所以比Last-Modified的优先级高。</p>\n<p>因此常见情况下，资源的缓存就是按照上面的顺序，强缓存=&gt;协商缓存=&gt;重新获取。<br>但是，缓存策略是与用户的操作相关的，平时不可避免会用到刷新。<br>刷新的方式是多种多样的。刷新按钮，command+r，shift+command+r等。他们之间的区别是什么呢。以<a href=\"http://xxdy.tech/\">http://xxdy.tech/</a>作为例子来看一下。 </p>\n<h3 id=\"再次访问-地址栏回车\"><a href=\"#再次访问-地址栏回车\" class=\"headerlink\" title=\"再次访问(地址栏回车)\"></a>再次访问(地址栏回车)</h3><p>可以看到资源分下面几类：<br>先看下直观的请求<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e047c0ba4bc?w=2792&h=804&f=jpeg&s=257017\"><br>大部分都是200强缓存，只有文稿是304</p>\n<ol>\n<li>无缓存的，maxage=0的资源<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e0479ca2b8c?w=2436&h=1417&f=jpeg&s=314035\"></li>\n</ol>\n<p>此类资源，请求的时候总会从服务端重新加载</p>\n<ol start=\"2\">\n<li>status为200，但是后面有提示from memory cache 或者disk cache的标识。  这种缓存的字体为灰色，跟上面的200还是比较容易看出来差别的。  </li>\n</ol>\n<p>css资源的响应，来自硬盘缓存。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e047750f409?w=2322&h=754&f=jpeg&s=172566\"></p>\n<p>js的响应，即来自memory的缓存<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e047b391817?w=2240&h=528&f=jpeg&s=126209\"></p>\n<p>这里就是强缓存，直接从本地缓存中读取。<br>因为Cache-Control:max-age=600 刷新时未过期，所以会从本地缓存中获取。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e04799f47b4?w=1640&h=788&f=jpeg&s=182548\"></p>\n<p>这里截两张图的原因在于两者缓存存放的位置是不同。<br>概述一下(详细请找资料细究)</p>\n<ul>\n<li><p>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性<br>  快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取<br>  时效性：一旦该进程关闭，则该进程的内存则会清空。</p>\n</li>\n<li><p>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。  </p>\n</li>\n</ul>\n<p>在浏览器中，大部分情况下浏览器会在js和图片等文件解析执行后直接存入内存缓存中，<br>那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；<br>而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)</p>\n<ol start=\"3\">\n<li>协商缓存    </li>\n</ol>\n<p>status为304，意为与服务端对比之后文件未改变，返回原有缓存资源。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e047ca6b703?w=2052&h=1064&f=jpeg&s=225389\"></p>\n<p>此资源请求头里面有Cache-Control: max-age=0 ，<br>所以每次请求都回去服务端询问，不会走强缓存，因为服务端也未更新，etag相同，所以返回缓存资源。  </p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>地址栏回车的话，就是我们正常访问，遵循浏览器的缓存策略。</p>\n<h3 id=\"f5刷新-mac-即command-r\"><a href=\"#f5刷新-mac-即command-r\" class=\"headerlink\" title=\"f5刷新(mac 即command + r)\"></a>f5刷新(mac 即command + r)</h3><p>f5刷新的时候，会有什么不同吗，先直观对比下。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e05e17eef09?w=2872&h=922&f=jpeg&s=312384\">  </p>\n<p>好像没什么不同，具体到文件也是与直接回车相同的状态。</p>\n<h4 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>那么f5的刷新到底是什么呢，<br>可以看到f5可以被称为soft refresh 其只是reload page而已。<br>即与回车地址相同，正常规则下的缓存还是会涉及到。</p>\n<h3 id=\"强制刷新-command-shift-r\"><a href=\"#强制刷新-command-shift-r\" class=\"headerlink\" title=\"强制刷新(command+shift+r)\"></a>强制刷新(command+shift+r)</h3><p>此时可以看下请求结果,前面列出的304和from cache的项目都是重新load。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e05e17eef09?w=2872&h=922&f=jpeg&s=312384\">   </p>\n<p>具体查看相应请求可以看到，<br>在request中多了个属性：<br>都有Cache-Control: no-cache的标识。<br>这表明每次都需要服务器评估是否有效，不要理解为直接不使用缓存。<br>此外可以注意到request中没有可以匹配response中ETag的If-None-Match属性，<br>所以会重新加载。    </p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e05e96a0246?w=2118&h=984&f=jpeg&s=195526\"></p>\n<h4 id=\"总结而言\"><a href=\"#总结而言\" class=\"headerlink\" title=\"总结而言\"></a>总结而言</h4><p>此时的刷新可以称为hard refresh，<br>请求会加上一个Cache-Control:no-cache的标识来表明突破cache-control的限制，<br>需要服务端重新判断有效性，即不走强缓存。<br>另外请求header中去掉If-None-Match，这样就不能使用协商缓存。拉到新的资源    </p>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><p>这里硬性重新加载,有些文件是依旧使用缓存的，我这边看到是有些小的image，没有找到合理的解释。具体我需要在研究一下，后面补上<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e05fdde9b86?w=1854&h=1086&f=jpeg&s=241473\"></p>\n<h3 id=\"停用缓存并刷新\"><a href=\"#停用缓存并刷新\" class=\"headerlink\" title=\"停用缓存并刷新\"></a>停用缓存并刷新</h3><p>针对上面提到的哪些文件，此时就需要到下面这种清空缓存并硬性重新加载了。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e060babe54f?w=846&h=370&f=jpeg&s=40828\"></p>\n<p>操作完之后就完全不使用缓存了。   </p>\n<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><p>上面提到那么几种刷新方式对应的效果，可能不同浏览器的实现也不同。找了个相对完善的大家可以参考一下。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e07244920a8?w=791&h=443&f=png&s=24777\"></p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>到这里，关于刷新与缓存的个人一些关掉就结束了，抛砖引玉，希望能对有需要的人有所帮助，也希望有大神有所指教。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">更多个人博客请移步</a><br>此外感谢下面的参考文章：<br><a href=\"https://stackoverflow.com/questions/8589760/difference-between-f5-ctrl-f5-and-click-or-refresh-button\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/8589760/difference-between-f5-ctrl-f5-and-click-or-refresh-button</a><br><a href=\"https://stackoverflow.com/questions/385367/what-requests-do-browsers-f5-and-ctrl-f5-refreshes-generate\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/385367/what-requests-do-browsers-f5-and-ctrl-f5-refreshes-generate</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>前面翻到了http缓存相关内容，关于强制缓存和协商缓存，他们之间的差别可能大家比较清楚。<br>并且常规情况下是否该使用缓存以及使用哪种缓存，<br>相关文章多且全，这里不再赘述。<br>不过用户的不同行为会打破原有规范，<br>本文就会去探究下不同行为下的浏览器缓存表现。也就是f5到底刷新了哪些内容<br>","more":"</p>\n<h2 id=\"浏览器缓存\"><a href=\"#浏览器缓存\" class=\"headerlink\" title=\"浏览器缓存\"></a>浏览器缓存</h2><p>说道浏览器缓存，脑海中常见的应该是那么几种关键词：<br>Cache-Control、Expires、ETag、If-Match、If-None-Match、Last-Modified等。<br>根据不同标识的作用，再次访问某个资源时，<br>需要缓存的情况下，主要有下面两种缓存方式 </p>\n<h3 id=\"强缓存\"><a href=\"#强缓存\" class=\"headerlink\" title=\"强缓存\"></a>强缓存</h3><p>一旦资源命中强缓存, 浏览器便不会向服务器发送请求, 而是直接读取缓存.<br>Chrome下的现象是 200 OK (from disk cache) 或者 200 OK (from memory cache).</p>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><p>也就是我们常见的304状态码。  </p>\n<p>缓存过期后, 继续请求该资源,<br>对于现代浏览器, 存在如下两种做法:</p>\n<ul>\n<li>根据上次响应中的ETag_value, 自动往request header中添加If-None-Match字段.<br>服务器收到请求后, 拿If-None-Match字段的值与资源的ETag值进行比较,<br>若相同, 则命中协商缓存, 返回304响应.</li>\n<li>根据上次响应中的Last-Modified_value, 自动往request header中添加If-Modified-Since字段. 服务器收到请求后, 拿If-Modified-Since字段的值与资源的Last-Modified值进行比较, 若相同, 则命中协商缓存, 返回304响应.</li>\n</ul>\n<p>ETag是http/1.1新增标识，也是为了解决Last-Modified存在的一些问题。<br>例如服务器和客户端时间不同步等问题，<br>所以比Last-Modified的优先级高。</p>\n<p>因此常见情况下，资源的缓存就是按照上面的顺序，强缓存=&gt;协商缓存=&gt;重新获取。<br>但是，缓存策略是与用户的操作相关的，平时不可避免会用到刷新。<br>刷新的方式是多种多样的。刷新按钮，command+r，shift+command+r等。他们之间的区别是什么呢。以<a href=\"http://xxdy.tech/\">http://xxdy.tech/</a>作为例子来看一下。 </p>\n<h3 id=\"再次访问-地址栏回车\"><a href=\"#再次访问-地址栏回车\" class=\"headerlink\" title=\"再次访问(地址栏回车)\"></a>再次访问(地址栏回车)</h3><p>可以看到资源分下面几类：<br>先看下直观的请求<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e047c0ba4bc?w=2792&h=804&f=jpeg&s=257017\"><br>大部分都是200强缓存，只有文稿是304</p>\n<ol>\n<li>无缓存的，maxage=0的资源<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e0479ca2b8c?w=2436&h=1417&f=jpeg&s=314035\"></li>\n</ol>\n<p>此类资源，请求的时候总会从服务端重新加载</p>\n<ol start=\"2\">\n<li>status为200，但是后面有提示from memory cache 或者disk cache的标识。  这种缓存的字体为灰色，跟上面的200还是比较容易看出来差别的。  </li>\n</ol>\n<p>css资源的响应，来自硬盘缓存。</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e047750f409?w=2322&h=754&f=jpeg&s=172566\"></p>\n<p>js的响应，即来自memory的缓存<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e047b391817?w=2240&h=528&f=jpeg&s=126209\"></p>\n<p>这里就是强缓存，直接从本地缓存中读取。<br>因为Cache-Control:max-age=600 刷新时未过期，所以会从本地缓存中获取。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e04799f47b4?w=1640&h=788&f=jpeg&s=182548\"></p>\n<p>这里截两张图的原因在于两者缓存存放的位置是不同。<br>概述一下(详细请找资料细究)</p>\n<ul>\n<li><p>内存缓存(from memory cache)：内存缓存具有两个特点，分别是快速读取和时效性<br>  快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取<br>  时效性：一旦该进程关闭，则该进程的内存则会清空。</p>\n</li>\n<li><p>硬盘缓存(from disk cache)：硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。  </p>\n</li>\n</ul>\n<p>在浏览器中，大部分情况下浏览器会在js和图片等文件解析执行后直接存入内存缓存中，<br>那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；<br>而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)</p>\n<ol start=\"3\">\n<li>协商缓存    </li>\n</ol>\n<p>status为304，意为与服务端对比之后文件未改变，返回原有缓存资源。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e047ca6b703?w=2052&h=1064&f=jpeg&s=225389\"></p>\n<p>此资源请求头里面有Cache-Control: max-age=0 ，<br>所以每次请求都回去服务端询问，不会走强缓存，因为服务端也未更新，etag相同，所以返回缓存资源。  </p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>地址栏回车的话，就是我们正常访问，遵循浏览器的缓存策略。</p>\n<h3 id=\"f5刷新-mac-即command-r\"><a href=\"#f5刷新-mac-即command-r\" class=\"headerlink\" title=\"f5刷新(mac 即command + r)\"></a>f5刷新(mac 即command + r)</h3><p>f5刷新的时候，会有什么不同吗，先直观对比下。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e05e17eef09?w=2872&h=922&f=jpeg&s=312384\">  </p>\n<p>好像没什么不同，具体到文件也是与直接回车相同的状态。</p>\n<h4 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>那么f5的刷新到底是什么呢，<br>可以看到f5可以被称为soft refresh 其只是reload page而已。<br>即与回车地址相同，正常规则下的缓存还是会涉及到。</p>\n<h3 id=\"强制刷新-command-shift-r\"><a href=\"#强制刷新-command-shift-r\" class=\"headerlink\" title=\"强制刷新(command+shift+r)\"></a>强制刷新(command+shift+r)</h3><p>此时可以看下请求结果,前面列出的304和from cache的项目都是重新load。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e05e17eef09?w=2872&h=922&f=jpeg&s=312384\">   </p>\n<p>具体查看相应请求可以看到，<br>在request中多了个属性：<br>都有Cache-Control: no-cache的标识。<br>这表明每次都需要服务器评估是否有效，不要理解为直接不使用缓存。<br>此外可以注意到request中没有可以匹配response中ETag的If-None-Match属性，<br>所以会重新加载。    </p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e05e96a0246?w=2118&h=984&f=jpeg&s=195526\"></p>\n<h4 id=\"总结而言\"><a href=\"#总结而言\" class=\"headerlink\" title=\"总结而言\"></a>总结而言</h4><p>此时的刷新可以称为hard refresh，<br>请求会加上一个Cache-Control:no-cache的标识来表明突破cache-control的限制，<br>需要服务端重新判断有效性，即不走强缓存。<br>另外请求header中去掉If-None-Match，这样就不能使用协商缓存。拉到新的资源    </p>\n<h4 id=\"tip\"><a href=\"#tip\" class=\"headerlink\" title=\"tip\"></a>tip</h4><p>这里硬性重新加载,有些文件是依旧使用缓存的，我这边看到是有些小的image，没有找到合理的解释。具体我需要在研究一下，后面补上<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e05fdde9b86?w=1854&h=1086&f=jpeg&s=241473\"></p>\n<h3 id=\"停用缓存并刷新\"><a href=\"#停用缓存并刷新\" class=\"headerlink\" title=\"停用缓存并刷新\"></a>停用缓存并刷新</h3><p>针对上面提到的哪些文件，此时就需要到下面这种清空缓存并硬性重新加载了。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e060babe54f?w=846&h=370&f=jpeg&s=40828\"></p>\n<p>操作完之后就完全不使用缓存了。   </p>\n<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><p>上面提到那么几种刷新方式对应的效果，可能不同浏览器的实现也不同。找了个相对完善的大家可以参考一下。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/27/16753e07244920a8?w=791&h=443&f=png&s=24777\"></p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>到这里，关于刷新与缓存的个人一些关掉就结束了，抛砖引玉，希望能对有需要的人有所帮助，也希望有大神有所指教。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">更多个人博客请移步</a><br>此外感谢下面的参考文章：<br><a href=\"https://stackoverflow.com/questions/8589760/difference-between-f5-ctrl-f5-and-click-or-refresh-button\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/8589760/difference-between-f5-ctrl-f5-and-click-or-refresh-button</a><br><a href=\"https://stackoverflow.com/questions/385367/what-requests-do-browsers-f5-and-ctrl-f5-refreshes-generate\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/385367/what-requests-do-browsers-f5-and-ctrl-f5-refreshes-generate</a></p>"},{"title":"DOMContentLoaded、readystatechange、load、ready详谈","date":"2017-12-16T16:00:00.000Z","_content":"对前端同学而言，loade,unload,DOMContentLoaded等页面加载过程中会触发的事件肯定是都接触过，不过要是具体问各个事件的区别，我就不是那么能清晰的解答上来的了。正好刚刚在无阻塞脚本那看到了DOMContentLoaded事件，就来翻翻具体文档详细看一下各个事件吧。常言道温故而知新，让我们一起回头看一下  \n<!-- more -->\n## 触发时机\n先看下各个事件的触发时机(参考自[MDN](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded))  \n### DOMContentLoaded   \n当初始html文档完全加载并解析之后触发，无需等待样式、图片、子frame结束。作为明显的对比，load事件只有一个页面完全被加载时才触发。改用DOMContentLoaded的地方常常是load来代替，这是错误的。\ntips: 有许多通用和独立的库提供跨浏览器方法来检测 DOM 是否已准备就绪即ready事件，后面我们可以看下zepto的实现\n### load\n当一个资源及其依赖的资源结束加载时触发。从这里可以看到需要等待依赖资源的结束加载。\n### readystatechange\ndocument有readyState属性来描述document的loading状态，readyState的改变会触发readystatechange事件.  \n\n* loading  \n\n    文档仍然在加载  \n* interactive  \n\n\n  文档结束加载并且被解析，但是想图片，样式，frame之类的子资源仍在加载  \n* complete    \n\n  \n  文档和子资源已经结束加载，该状态表明将要触发load事件。  \n\n因此，我们同样可以使用该事件来判断dom的加载状态。  \n但并非所有对象都会经历 readyState 的这几个阶段，有时候需要\n### beforeunload\n当浏览器窗口，文档或其资源将要卸载时，会触发beforeunload事件。这个文档是依然可见的，并且这个事件在这一刻是可以取消的.  \n如果处理函数为Event对象的returnValue属性赋值非空字符串，浏览器会弹出一个对话框，来询问用户是否确定要离开当前页面（如下示例）。有些浏览器会将返回的字符串展示在弹框里，但有些其他浏览器只展示它们自定义的信息。没有赋值时，该事件不做任何响应。\ntip:2011年5月25号起，html5中指出，该事件中调用window.alert(), window.confirm(), and window.prompt()方法将会被忽略。\n### unload\n当文档或者一个子资源将要被卸载时，在beforeunload 、pagehide两个事件之后触发。  \n文档会处于一个特定状态。  \n\n* 所有资源仍存在 (图片, iframe 等.)\n* 对于终端用户所有资源均不可见\n* 界面交互无效 (window.open, alert, confirm 等.)\n* 错误不会停止卸载文档的过程  \n\n\n## 页面加载中的执行顺序  \n  \n从上面的定义，我们可以得出一个比较清晰的顺序了。  \n  \n1. 页面加载开始，首先肯定是先发出加载资源的请求，加载未完成之前，不触发任何事件。\n2. document加载结束并解析，此时css等其他资源未加载完成。\n\n   此时readyState为'interactive'，表明document已经load并解析完成，触发 readystatechange，然后触发DOMContentLoaded(在大多数浏览器上的表现如此)。捎带提一句，此时，加载完成且带有defer标记的脚本，会按顺序开始执行。  \n      \n3.  css、img等子资源加载完成之后  \n\n    此时触发window.load事件  \n4.  点击关闭标签或者刷新时，会依次触发beforeunload、unload事件。  \n\n可能概念看的有点枯燥，还是看下代码比较清晰。大家可以看下，下面的代码会依次输出什么。  \n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <title>文档加载事件</title>\n    <script>\n            document.addEventListener(\"DOMContentLoaded\", function (event) {\n                console.log(\"初始DOM 加载并解析\");\n            });\n            window.addEventListener(\"load\", function (event) {\n                console.log(\"window 所有资源加载完成\");\n            });\n    \n            document.onreadystatechange = function () {\n                console.log(document.readyState)\n                if (document.readyState === \"complete\") {\n                    console.log('初始DOM,加载解析完成')\n                }\n            }\n            window.addEventListener(\"beforeunload\", function (event) {\n                console.log('即将关闭')\n                event.returnValue = \"\\o/\";\n            });\n            window.addEventListener('unload', function (event) {\n                console.log('即将关闭1');\n            });\n        </script>\n    <link rel=\"stylesheet\" href=\"./test.css\">\n</head>\n\n<body>\n    <div id=\"root\">dom事件</div>\n    <script src=\"./index.js\"></script>\n</body>\n\n</html>\n```  \n   \n依次输出如下:  \n    \n```js\n    interactive //(index):15\n    初始DOM 加载并解析 //(index):8\n    complet//(index):15 \n    初始DOM,加载解析完成//(index):17 \n    window 所有资源加载完成//(index):11 \n    //点击关闭按钮\n    即将关闭\n    即将关闭2  \n```    \n### 关于ready  \n像jquery、zepto等类库中都有document一个ready方法，来确保我们的操作在初始dom加载之后进行，原生dom定义里是没有这个api的，是大牛们封装了一下判断的过程，提供我们以便利。  \n有了前面的例子，让我们猜一下他们是怎么实现的。  \n  \n1. ready对应的状态是初始化dom已经加载完成，我们来看一下什么情况下对应该情况。\n\n   有下面几个状态，complete、interactive 还有一个DOMContentLoaded也是初始dom加载完成，当然还有load事件，显然这里不会用到它，相对其他状态而言有点太晚了。 \n2. 确定触发条件之后，下面的实现就简单了，判断就行了。  \n\n   \n以zepto为例，我们看下实现：   \n \n```js \n//声明变量，不只使用interactive，是因为前面提到这些状态不一定全部出现\nreadyRE = /complete|loaded|interactive/\n\nready: function(callback){\n      // need to check if document.body exists for IE as that browser reports\n      // document ready when it hasn't yet created the body element\n      if (readyRE.test(document.readyState) && document.body) callback($)\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\n      return this\n    } \n```  \n\n至此，介绍就结束了。对我而言，明了原来不太清楚的概念，希望对大家也有所帮助。    \n\n\n\n\n\n","source":"_posts/domevent.md","raw":"---\ntitle: DOMContentLoaded、readystatechange、load、ready详谈\ndate: 2017-12-17\n---\n对前端同学而言，loade,unload,DOMContentLoaded等页面加载过程中会触发的事件肯定是都接触过，不过要是具体问各个事件的区别，我就不是那么能清晰的解答上来的了。正好刚刚在无阻塞脚本那看到了DOMContentLoaded事件，就来翻翻具体文档详细看一下各个事件吧。常言道温故而知新，让我们一起回头看一下  \n<!-- more -->\n## 触发时机\n先看下各个事件的触发时机(参考自[MDN](https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded))  \n### DOMContentLoaded   \n当初始html文档完全加载并解析之后触发，无需等待样式、图片、子frame结束。作为明显的对比，load事件只有一个页面完全被加载时才触发。改用DOMContentLoaded的地方常常是load来代替，这是错误的。\ntips: 有许多通用和独立的库提供跨浏览器方法来检测 DOM 是否已准备就绪即ready事件，后面我们可以看下zepto的实现\n### load\n当一个资源及其依赖的资源结束加载时触发。从这里可以看到需要等待依赖资源的结束加载。\n### readystatechange\ndocument有readyState属性来描述document的loading状态，readyState的改变会触发readystatechange事件.  \n\n* loading  \n\n    文档仍然在加载  \n* interactive  \n\n\n  文档结束加载并且被解析，但是想图片，样式，frame之类的子资源仍在加载  \n* complete    \n\n  \n  文档和子资源已经结束加载，该状态表明将要触发load事件。  \n\n因此，我们同样可以使用该事件来判断dom的加载状态。  \n但并非所有对象都会经历 readyState 的这几个阶段，有时候需要\n### beforeunload\n当浏览器窗口，文档或其资源将要卸载时，会触发beforeunload事件。这个文档是依然可见的，并且这个事件在这一刻是可以取消的.  \n如果处理函数为Event对象的returnValue属性赋值非空字符串，浏览器会弹出一个对话框，来询问用户是否确定要离开当前页面（如下示例）。有些浏览器会将返回的字符串展示在弹框里，但有些其他浏览器只展示它们自定义的信息。没有赋值时，该事件不做任何响应。\ntip:2011年5月25号起，html5中指出，该事件中调用window.alert(), window.confirm(), and window.prompt()方法将会被忽略。\n### unload\n当文档或者一个子资源将要被卸载时，在beforeunload 、pagehide两个事件之后触发。  \n文档会处于一个特定状态。  \n\n* 所有资源仍存在 (图片, iframe 等.)\n* 对于终端用户所有资源均不可见\n* 界面交互无效 (window.open, alert, confirm 等.)\n* 错误不会停止卸载文档的过程  \n\n\n## 页面加载中的执行顺序  \n  \n从上面的定义，我们可以得出一个比较清晰的顺序了。  \n  \n1. 页面加载开始，首先肯定是先发出加载资源的请求，加载未完成之前，不触发任何事件。\n2. document加载结束并解析，此时css等其他资源未加载完成。\n\n   此时readyState为'interactive'，表明document已经load并解析完成，触发 readystatechange，然后触发DOMContentLoaded(在大多数浏览器上的表现如此)。捎带提一句，此时，加载完成且带有defer标记的脚本，会按顺序开始执行。  \n      \n3.  css、img等子资源加载完成之后  \n\n    此时触发window.load事件  \n4.  点击关闭标签或者刷新时，会依次触发beforeunload、unload事件。  \n\n可能概念看的有点枯燥，还是看下代码比较清晰。大家可以看下，下面的代码会依次输出什么。  \n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <title>文档加载事件</title>\n    <script>\n            document.addEventListener(\"DOMContentLoaded\", function (event) {\n                console.log(\"初始DOM 加载并解析\");\n            });\n            window.addEventListener(\"load\", function (event) {\n                console.log(\"window 所有资源加载完成\");\n            });\n    \n            document.onreadystatechange = function () {\n                console.log(document.readyState)\n                if (document.readyState === \"complete\") {\n                    console.log('初始DOM,加载解析完成')\n                }\n            }\n            window.addEventListener(\"beforeunload\", function (event) {\n                console.log('即将关闭')\n                event.returnValue = \"\\o/\";\n            });\n            window.addEventListener('unload', function (event) {\n                console.log('即将关闭1');\n            });\n        </script>\n    <link rel=\"stylesheet\" href=\"./test.css\">\n</head>\n\n<body>\n    <div id=\"root\">dom事件</div>\n    <script src=\"./index.js\"></script>\n</body>\n\n</html>\n```  \n   \n依次输出如下:  \n    \n```js\n    interactive //(index):15\n    初始DOM 加载并解析 //(index):8\n    complet//(index):15 \n    初始DOM,加载解析完成//(index):17 \n    window 所有资源加载完成//(index):11 \n    //点击关闭按钮\n    即将关闭\n    即将关闭2  \n```    \n### 关于ready  \n像jquery、zepto等类库中都有document一个ready方法，来确保我们的操作在初始dom加载之后进行，原生dom定义里是没有这个api的，是大牛们封装了一下判断的过程，提供我们以便利。  \n有了前面的例子，让我们猜一下他们是怎么实现的。  \n  \n1. ready对应的状态是初始化dom已经加载完成，我们来看一下什么情况下对应该情况。\n\n   有下面几个状态，complete、interactive 还有一个DOMContentLoaded也是初始dom加载完成，当然还有load事件，显然这里不会用到它，相对其他状态而言有点太晚了。 \n2. 确定触发条件之后，下面的实现就简单了，判断就行了。  \n\n   \n以zepto为例，我们看下实现：   \n \n```js \n//声明变量，不只使用interactive，是因为前面提到这些状态不一定全部出现\nreadyRE = /complete|loaded|interactive/\n\nready: function(callback){\n      // need to check if document.body exists for IE as that browser reports\n      // document ready when it hasn't yet created the body element\n      if (readyRE.test(document.readyState) && document.body) callback($)\n      else document.addEventListener('DOMContentLoaded', function(){ callback($) }, false)\n      return this\n    } \n```  \n\n至此，介绍就结束了。对我而言，明了原来不太清楚的概念，希望对大家也有所帮助。    \n\n\n\n\n\n","slug":"domevent","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1p000ogw92qowl7tcq","content":"<p>对前端同学而言，loade,unload,DOMContentLoaded等页面加载过程中会触发的事件肯定是都接触过，不过要是具体问各个事件的区别，我就不是那么能清晰的解答上来的了。正好刚刚在无阻塞脚本那看到了DOMContentLoaded事件，就来翻翻具体文档详细看一下各个事件吧。常言道温故而知新，让我们一起回头看一下<br><a id=\"more\"></a></p>\n<h2 id=\"触发时机\"><a href=\"#触发时机\" class=\"headerlink\" title=\"触发时机\"></a>触发时机</h2><p>先看下各个事件的触发时机(参考自<a href=\"https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded\" target=\"_blank\" rel=\"noopener\">MDN</a>)  </p>\n<h3 id=\"DOMContentLoaded\"><a href=\"#DOMContentLoaded\" class=\"headerlink\" title=\"DOMContentLoaded\"></a>DOMContentLoaded</h3><p>当初始html文档完全加载并解析之后触发，无需等待样式、图片、子frame结束。作为明显的对比，load事件只有一个页面完全被加载时才触发。改用DOMContentLoaded的地方常常是load来代替，这是错误的。<br>tips: 有许多通用和独立的库提供跨浏览器方法来检测 DOM 是否已准备就绪即ready事件，后面我们可以看下zepto的实现</p>\n<h3 id=\"load\"><a href=\"#load\" class=\"headerlink\" title=\"load\"></a>load</h3><p>当一个资源及其依赖的资源结束加载时触发。从这里可以看到需要等待依赖资源的结束加载。</p>\n<h3 id=\"readystatechange\"><a href=\"#readystatechange\" class=\"headerlink\" title=\"readystatechange\"></a>readystatechange</h3><p>document有readyState属性来描述document的loading状态，readyState的改变会触发readystatechange事件.  </p>\n<ul>\n<li><p>loading  </p>\n<p>  文档仍然在加载  </p>\n</li>\n<li>interactive  </li>\n</ul>\n<p>  文档结束加载并且被解析，但是想图片，样式，frame之类的子资源仍在加载  </p>\n<ul>\n<li>complete    </li>\n</ul>\n<p>  文档和子资源已经结束加载，该状态表明将要触发load事件。  </p>\n<p>因此，我们同样可以使用该事件来判断dom的加载状态。<br>但并非所有对象都会经历 readyState 的这几个阶段，有时候需要</p>\n<h3 id=\"beforeunload\"><a href=\"#beforeunload\" class=\"headerlink\" title=\"beforeunload\"></a>beforeunload</h3><p>当浏览器窗口，文档或其资源将要卸载时，会触发beforeunload事件。这个文档是依然可见的，并且这个事件在这一刻是可以取消的.<br>如果处理函数为Event对象的returnValue属性赋值非空字符串，浏览器会弹出一个对话框，来询问用户是否确定要离开当前页面（如下示例）。有些浏览器会将返回的字符串展示在弹框里，但有些其他浏览器只展示它们自定义的信息。没有赋值时，该事件不做任何响应。<br>tip:2011年5月25号起，html5中指出，该事件中调用window.alert(), window.confirm(), and window.prompt()方法将会被忽略。</p>\n<h3 id=\"unload\"><a href=\"#unload\" class=\"headerlink\" title=\"unload\"></a>unload</h3><p>当文档或者一个子资源将要被卸载时，在beforeunload 、pagehide两个事件之后触发。<br>文档会处于一个特定状态。  </p>\n<ul>\n<li>所有资源仍存在 (图片, iframe 等.)</li>\n<li>对于终端用户所有资源均不可见</li>\n<li>界面交互无效 (window.open, alert, confirm 等.)</li>\n<li>错误不会停止卸载文档的过程  </li>\n</ul>\n<h2 id=\"页面加载中的执行顺序\"><a href=\"#页面加载中的执行顺序\" class=\"headerlink\" title=\"页面加载中的执行顺序\"></a>页面加载中的执行顺序</h2><p>从上面的定义，我们可以得出一个比较清晰的顺序了。  </p>\n<ol>\n<li>页面加载开始，首先肯定是先发出加载资源的请求，加载未完成之前，不触发任何事件。</li>\n<li><p>document加载结束并解析，此时css等其他资源未加载完成。</p>\n<p>此时readyState为’interactive’，表明document已经load并解析完成，触发 readystatechange，然后触发DOMContentLoaded(在大多数浏览器上的表现如此)。捎带提一句，此时，加载完成且带有defer标记的脚本，会按顺序开始执行。  </p>\n</li>\n<li><p>css、img等子资源加载完成之后  </p>\n<p>此时触发window.load事件  </p>\n</li>\n<li>点击关闭标签或者刷新时，会依次触发beforeunload、unload事件。  </li>\n</ol>\n<p>可能概念看的有点枯燥，还是看下代码比较清晰。大家可以看下，下面的代码会依次输出什么。  </p>\n<pre><code class=\"html\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span>\n\n<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>文档加载事件<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span>\n<span class=\"javascript\">            <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">\"DOMContentLoaded\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>{</span>\n<span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"初始DOM 加载并解析\"</span>);</span>\n<span class=\"undefined\">            });</span>\n<span class=\"javascript\">            <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"load\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>{</span>\n<span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"window 所有资源加载完成\"</span>);</span>\n<span class=\"undefined\">            });</span>\n<span class=\"undefined\"></span>\n<span class=\"javascript\">            <span class=\"built_in\">document</span>.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{</span>\n<span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.readyState)</span>\n<span class=\"javascript\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.readyState === <span class=\"string\">\"complete\"</span>) {</span>\n<span class=\"javascript\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">'初始DOM,加载解析完成'</span>)</span>\n<span class=\"undefined\">                }</span>\n<span class=\"undefined\">            }</span>\n<span class=\"javascript\">            <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"beforeunload\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>{</span>\n<span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'即将关闭'</span>)</span>\n<span class=\"javascript\">                event.returnValue = <span class=\"string\">\"\\o/\"</span>;</span>\n<span class=\"undefined\">            });</span>\n<span class=\"javascript\">            <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'unload'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>{</span>\n<span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'即将关闭1'</span>);</span>\n<span class=\"undefined\">            });</span>\n<span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"./test.css\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span>\n\n<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"root\"</span>&gt;</span>dom事件<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span>\n\n<span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span>\n</code></pre>\n<p>依次输出如下:  </p>\n<pre><code class=\"js\">interactive <span class=\"comment\">//(index):15</span>\n初始DOM 加载并解析 <span class=\"comment\">//(index):8</span>\ncomplet<span class=\"comment\">//(index):15 </span>\n初始DOM,加载解析完成<span class=\"comment\">//(index):17 </span>\n<span class=\"built_in\">window</span> 所有资源加载完成<span class=\"comment\">//(index):11 </span>\n<span class=\"comment\">//点击关闭按钮</span>\n即将关闭\n即将关闭<span class=\"number\">2</span>  \n</code></pre>\n<h3 id=\"关于ready\"><a href=\"#关于ready\" class=\"headerlink\" title=\"关于ready\"></a>关于ready</h3><p>像jquery、zepto等类库中都有document一个ready方法，来确保我们的操作在初始dom加载之后进行，原生dom定义里是没有这个api的，是大牛们封装了一下判断的过程，提供我们以便利。<br>有了前面的例子，让我们猜一下他们是怎么实现的。  </p>\n<ol>\n<li><p>ready对应的状态是初始化dom已经加载完成，我们来看一下什么情况下对应该情况。</p>\n<p>有下面几个状态，complete、interactive 还有一个DOMContentLoaded也是初始dom加载完成，当然还有load事件，显然这里不会用到它，相对其他状态而言有点太晚了。 </p>\n</li>\n<li>确定触发条件之后，下面的实现就简单了，判断就行了。  </li>\n</ol>\n<p>以zepto为例，我们看下实现：   </p>\n<pre><code class=\"js\"><span class=\"comment\">//声明变量，不只使用interactive，是因为前面提到这些状态不一定全部出现</span>\nreadyRE = <span class=\"regexp\">/complete|loaded|interactive/</span>\n\nready: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>)</span>{\n      <span class=\"comment\">// need to check if document.body exists for IE as that browser reports</span>\n      <span class=\"comment\">// document ready when it hasn't yet created the body element</span>\n      <span class=\"keyword\">if</span> (readyRE.test(<span class=\"built_in\">document</span>.readyState) &amp;&amp; <span class=\"built_in\">document</span>.body) callback($)\n      <span class=\"keyword\">else</span> <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'DOMContentLoaded'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>{ callback($) }, <span class=\"literal\">false</span>)\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>\n    } \n</code></pre>\n<p>至此，介绍就结束了。对我而言，明了原来不太清楚的概念，希望对大家也有所帮助。    </p>\n","site":{"data":{}},"excerpt":"<p>对前端同学而言，loade,unload,DOMContentLoaded等页面加载过程中会触发的事件肯定是都接触过，不过要是具体问各个事件的区别，我就不是那么能清晰的解答上来的了。正好刚刚在无阻塞脚本那看到了DOMContentLoaded事件，就来翻翻具体文档详细看一下各个事件吧。常言道温故而知新，让我们一起回头看一下<br>","more":"</p>\n<h2 id=\"触发时机\"><a href=\"#触发时机\" class=\"headerlink\" title=\"触发时机\"></a>触发时机</h2><p>先看下各个事件的触发时机(参考自<a href=\"https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded\" target=\"_blank\" rel=\"noopener\">MDN</a>)  </p>\n<h3 id=\"DOMContentLoaded\"><a href=\"#DOMContentLoaded\" class=\"headerlink\" title=\"DOMContentLoaded\"></a>DOMContentLoaded</h3><p>当初始html文档完全加载并解析之后触发，无需等待样式、图片、子frame结束。作为明显的对比，load事件只有一个页面完全被加载时才触发。改用DOMContentLoaded的地方常常是load来代替，这是错误的。<br>tips: 有许多通用和独立的库提供跨浏览器方法来检测 DOM 是否已准备就绪即ready事件，后面我们可以看下zepto的实现</p>\n<h3 id=\"load\"><a href=\"#load\" class=\"headerlink\" title=\"load\"></a>load</h3><p>当一个资源及其依赖的资源结束加载时触发。从这里可以看到需要等待依赖资源的结束加载。</p>\n<h3 id=\"readystatechange\"><a href=\"#readystatechange\" class=\"headerlink\" title=\"readystatechange\"></a>readystatechange</h3><p>document有readyState属性来描述document的loading状态，readyState的改变会触发readystatechange事件.  </p>\n<ul>\n<li><p>loading  </p>\n<p>  文档仍然在加载  </p>\n</li>\n<li>interactive  </li>\n</ul>\n<p>  文档结束加载并且被解析，但是想图片，样式，frame之类的子资源仍在加载  </p>\n<ul>\n<li>complete    </li>\n</ul>\n<p>  文档和子资源已经结束加载，该状态表明将要触发load事件。  </p>\n<p>因此，我们同样可以使用该事件来判断dom的加载状态。<br>但并非所有对象都会经历 readyState 的这几个阶段，有时候需要</p>\n<h3 id=\"beforeunload\"><a href=\"#beforeunload\" class=\"headerlink\" title=\"beforeunload\"></a>beforeunload</h3><p>当浏览器窗口，文档或其资源将要卸载时，会触发beforeunload事件。这个文档是依然可见的，并且这个事件在这一刻是可以取消的.<br>如果处理函数为Event对象的returnValue属性赋值非空字符串，浏览器会弹出一个对话框，来询问用户是否确定要离开当前页面（如下示例）。有些浏览器会将返回的字符串展示在弹框里，但有些其他浏览器只展示它们自定义的信息。没有赋值时，该事件不做任何响应。<br>tip:2011年5月25号起，html5中指出，该事件中调用window.alert(), window.confirm(), and window.prompt()方法将会被忽略。</p>\n<h3 id=\"unload\"><a href=\"#unload\" class=\"headerlink\" title=\"unload\"></a>unload</h3><p>当文档或者一个子资源将要被卸载时，在beforeunload 、pagehide两个事件之后触发。<br>文档会处于一个特定状态。  </p>\n<ul>\n<li>所有资源仍存在 (图片, iframe 等.)</li>\n<li>对于终端用户所有资源均不可见</li>\n<li>界面交互无效 (window.open, alert, confirm 等.)</li>\n<li>错误不会停止卸载文档的过程  </li>\n</ul>\n<h2 id=\"页面加载中的执行顺序\"><a href=\"#页面加载中的执行顺序\" class=\"headerlink\" title=\"页面加载中的执行顺序\"></a>页面加载中的执行顺序</h2><p>从上面的定义，我们可以得出一个比较清晰的顺序了。  </p>\n<ol>\n<li>页面加载开始，首先肯定是先发出加载资源的请求，加载未完成之前，不触发任何事件。</li>\n<li><p>document加载结束并解析，此时css等其他资源未加载完成。</p>\n<p>此时readyState为’interactive’，表明document已经load并解析完成，触发 readystatechange，然后触发DOMContentLoaded(在大多数浏览器上的表现如此)。捎带提一句，此时，加载完成且带有defer标记的脚本，会按顺序开始执行。  </p>\n</li>\n<li><p>css、img等子资源加载完成之后  </p>\n<p>此时触发window.load事件  </p>\n</li>\n<li>点击关闭标签或者刷新时，会依次触发beforeunload、unload事件。  </li>\n</ol>\n<p>可能概念看的有点枯燥，还是看下代码比较清晰。大家可以看下，下面的代码会依次输出什么。  </p>\n<pre><code class=\"html\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span>\n<span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span>\n\n<span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>文档加载事件<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"undefined\"></span>\n<span class=\"javascript\">            <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">\"DOMContentLoaded\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>{</span>\n<span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"初始DOM 加载并解析\"</span>);</span>\n<span class=\"undefined\">            });</span>\n<span class=\"javascript\">            <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"load\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>{</span>\n<span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">\"window 所有资源加载完成\"</span>);</span>\n<span class=\"undefined\">            });</span>\n<span class=\"undefined\"></span>\n<span class=\"javascript\">            <span class=\"built_in\">document</span>.onreadystatechange = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{</span>\n<span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"built_in\">document</span>.readyState)</span>\n<span class=\"javascript\">                <span class=\"keyword\">if</span> (<span class=\"built_in\">document</span>.readyState === <span class=\"string\">\"complete\"</span>) {</span>\n<span class=\"javascript\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">'初始DOM,加载解析完成'</span>)</span>\n<span class=\"undefined\">                }</span>\n<span class=\"undefined\">            }</span>\n<span class=\"javascript\">            <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">\"beforeunload\"</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>{</span>\n<span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'即将关闭'</span>)</span>\n<span class=\"javascript\">                event.returnValue = <span class=\"string\">\"\\o/\"</span>;</span>\n<span class=\"undefined\">            });</span>\n<span class=\"javascript\">            <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'unload'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>{</span>\n<span class=\"javascript\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'即将关闭1'</span>);</span>\n<span class=\"undefined\">            });</span>\n<span class=\"undefined\">        </span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"./test.css\"</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span>\n\n<span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"root\"</span>&gt;</span>dom事件<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>\n    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"./index.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span>\n<span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span>\n\n<span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span>\n</code></pre>\n<p>依次输出如下:  </p>\n<pre><code class=\"js\">interactive <span class=\"comment\">//(index):15</span>\n初始DOM 加载并解析 <span class=\"comment\">//(index):8</span>\ncomplet<span class=\"comment\">//(index):15 </span>\n初始DOM,加载解析完成<span class=\"comment\">//(index):17 </span>\n<span class=\"built_in\">window</span> 所有资源加载完成<span class=\"comment\">//(index):11 </span>\n<span class=\"comment\">//点击关闭按钮</span>\n即将关闭\n即将关闭<span class=\"number\">2</span>  \n</code></pre>\n<h3 id=\"关于ready\"><a href=\"#关于ready\" class=\"headerlink\" title=\"关于ready\"></a>关于ready</h3><p>像jquery、zepto等类库中都有document一个ready方法，来确保我们的操作在初始dom加载之后进行，原生dom定义里是没有这个api的，是大牛们封装了一下判断的过程，提供我们以便利。<br>有了前面的例子，让我们猜一下他们是怎么实现的。  </p>\n<ol>\n<li><p>ready对应的状态是初始化dom已经加载完成，我们来看一下什么情况下对应该情况。</p>\n<p>有下面几个状态，complete、interactive 还有一个DOMContentLoaded也是初始dom加载完成，当然还有load事件，显然这里不会用到它，相对其他状态而言有点太晚了。 </p>\n</li>\n<li>确定触发条件之后，下面的实现就简单了，判断就行了。  </li>\n</ol>\n<p>以zepto为例，我们看下实现：   </p>\n<pre><code class=\"js\"><span class=\"comment\">//声明变量，不只使用interactive，是因为前面提到这些状态不一定全部出现</span>\nreadyRE = <span class=\"regexp\">/complete|loaded|interactive/</span>\n\nready: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">callback</span>)</span>{\n      <span class=\"comment\">// need to check if document.body exists for IE as that browser reports</span>\n      <span class=\"comment\">// document ready when it hasn't yet created the body element</span>\n      <span class=\"keyword\">if</span> (readyRE.test(<span class=\"built_in\">document</span>.readyState) &amp;&amp; <span class=\"built_in\">document</span>.body) callback($)\n      <span class=\"keyword\">else</span> <span class=\"built_in\">document</span>.addEventListener(<span class=\"string\">'DOMContentLoaded'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>{ callback($) }, <span class=\"literal\">false</span>)\n      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>\n    } \n</code></pre>\n<p>至此，介绍就结束了。对我而言，明了原来不太清楚的概念，希望对大家也有所帮助。    </p>"},{"title":"provisional headers are shown  知多少","date":"2018-11-30T00:00:29.000Z","_content":"\n## 前言 \n请求里面provisional headers are shown(显示临时报头) 出现的情况很多，但原因是多样的。  \n如果你去直接匹配关键字搜索，得到的结果可能与你自己的情况大相径庭。  \n网上大部分都是在跨域时出现，或者是请求被插件拦截，但关于缓存时的请求很少。  \n我在[上文查看缓存的时候发现了这个问题](https://juejin.im/post/5bfcd79e6fb9a04a08215cf3),当时查找资料都是聚焦于请求被拦截，  \n所以本文就简单整理一下相关情况。\n<!-- more -->\n## 问题描述\n\n当刷新页面时，想要查看http请求header中相关信息时，  \n发现使用缓存的请求（from disk cache或者from memory cache）header相关信息不能查看\n\n<img src='https://user-gold-cdn.xitu.io/2018/11/30/1676251cabb19a3f?w=2826&h=1670&f=jpeg&s=411272'/>\n\n第一次看到确实有点疑惑，那么就去搜索了下。  \n碰到这个提示的情况挺多，但细看下与我们的场景不太符合。\n<img src='https://user-gold-cdn.xitu.io/2018/11/30/1676251ca86991f9?w=1910&h=1374&f=jpeg&s=410863'/>\n基本上遇到的都是provisional headers are shown，阻止了请求的正常加载。  \n而我们只是在使用缓存的时候遇到，而看起来请求没有被block掉。好像不太符合。  \n  \n## 问题定位\n\n虽然没有看到匹配度十分相关的信息，但看到了[有启发的一篇文章(详情点击)](https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger)。  \n\n摘抄部分如下：  \n\n*The resource could be being blocked by an extension (AdBlock in my case).\nThe message is there because the request to retrieve that resource was never made, so the headers being shown are not the real thing. As explained in the issue you referenced, the real headers are updated when the server responds, but there is no response if the request was blocked.*\n \n资源可能被一些扩展程序拦截 。  \n\n另外还有一句：  \n  \n*I believe it happens when the actual request is not sent. Usually happens when you are loading a cached resource.*\n\n真正请求并未被发送，当使用缓存时经常发生。\n\n之所以会出现这个信息是因为获取相关资源的请求并没有发出，  \n所以headers被展示并不是真正的信息。  \n就像提到的那样，真正的header只有在服务端返回的时候会更新。  \n当请求被拦截后，并没有返回。   \n基于这个情况开始猜测原因所在：\n\n### 猜测一、请求跨域被拦截  \n\n虽然现在网站的静态资源都会存在专门的静态域名下面，和html域名可能不一致。  \n但是基本都是基于CORS来解决这个问题，所以不存在这个问题。   \n再有就是，我们这种情况首次请求的时候不会发生，如果有跨域，应该都被block。  \n另外如果是被拦截，那么请求应该不会被响应的，我们这里显然得到了正确的响应。\n这种被排除。\n\n### 猜测二、服务器未及时响应   \n\n这种猜测和一差不多，特定情况下才会出现，跟服务器关联不大。 \n \n### 猜测三、被扩展程序拦截  \n\n作为一个开发人员，大家的chrome上肯定装了不少的插件。这种原因还是有可能的。  \n我们可以通过 chrome://net-internals 来根据关键字查找相关请求，\n然后具体去看相关状态。  \n例如我们http://xxdy.tech/css/main.css?v=5.1.4请求\n<img src='https://user-gold-cdn.xitu.io/2018/11/30/1676251ca84e838b?w=2546&h=1068&f=jpeg&s=250219' />\n可以看到并没有出现block，timeout等字段，只能看到比较明显的DISK_CACHE。  \n因此这种情况也不满足，我们应该是和本地缓存强烈相关的。  \n\n### 本地缓存\n\n结合上面的分析，我们可以缩小到缓存上面。冲着这个目标，我们继续去看下相关资料。  \n最后在一篇[日文资料](https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/)里找到了相关解释。  \n似乎只从缓存中获得的通信显示为“显示临时标题”（或“执行”）  \n因为该文件是从缓存中获取的，并且未进行通信\n所以详细标头并不会显示。\n\n#### 原因：未与服务端正确通信  \n\n回过头来看，前面提到的那么多情况其实都是与服务器没有进行或者完成正确的通信，所以只展示临时信息。\n\n####  常见状况\n\nprovisional headers are shown出现的情况有这么几种：  \n\n1. 跨域，请求被浏览器拦截\n2. 请求被浏览器插件拦截\n3. 服务器出错或者超时，没有真正的返回\n4. 强缓存from disk cache或者from memory cache，此时也不会显示 \n\n## 结束语\n  \n到这里provisional headers are shown相关总结就结束了，本身并不是一个问题，但在自身不了解的情况下还是要去研究一下，不然永远是个问题。本文抛砖引玉，给自己一个总结，同时希望能给有需要人一些帮助。   \n\n### 参考文章  \n[https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger](https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger)  \n[https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/](https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/)   \n[http://www.techfolks.net/provisional-headers-are-shown-in-google-chrome-browser-debugger/](http://www.techfolks.net/provisional-headers-are-shown-in-google-chrome-browser-debugger/)\n\n\n","source":"_posts/header.md","raw":"---\ntitle: provisional headers are shown  知多少\ndate: 2018-11-30 08:00:29\ntags:\n---\n\n## 前言 \n请求里面provisional headers are shown(显示临时报头) 出现的情况很多，但原因是多样的。  \n如果你去直接匹配关键字搜索，得到的结果可能与你自己的情况大相径庭。  \n网上大部分都是在跨域时出现，或者是请求被插件拦截，但关于缓存时的请求很少。  \n我在[上文查看缓存的时候发现了这个问题](https://juejin.im/post/5bfcd79e6fb9a04a08215cf3),当时查找资料都是聚焦于请求被拦截，  \n所以本文就简单整理一下相关情况。\n<!-- more -->\n## 问题描述\n\n当刷新页面时，想要查看http请求header中相关信息时，  \n发现使用缓存的请求（from disk cache或者from memory cache）header相关信息不能查看\n\n<img src='https://user-gold-cdn.xitu.io/2018/11/30/1676251cabb19a3f?w=2826&h=1670&f=jpeg&s=411272'/>\n\n第一次看到确实有点疑惑，那么就去搜索了下。  \n碰到这个提示的情况挺多，但细看下与我们的场景不太符合。\n<img src='https://user-gold-cdn.xitu.io/2018/11/30/1676251ca86991f9?w=1910&h=1374&f=jpeg&s=410863'/>\n基本上遇到的都是provisional headers are shown，阻止了请求的正常加载。  \n而我们只是在使用缓存的时候遇到，而看起来请求没有被block掉。好像不太符合。  \n  \n## 问题定位\n\n虽然没有看到匹配度十分相关的信息，但看到了[有启发的一篇文章(详情点击)](https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger)。  \n\n摘抄部分如下：  \n\n*The resource could be being blocked by an extension (AdBlock in my case).\nThe message is there because the request to retrieve that resource was never made, so the headers being shown are not the real thing. As explained in the issue you referenced, the real headers are updated when the server responds, but there is no response if the request was blocked.*\n \n资源可能被一些扩展程序拦截 。  \n\n另外还有一句：  \n  \n*I believe it happens when the actual request is not sent. Usually happens when you are loading a cached resource.*\n\n真正请求并未被发送，当使用缓存时经常发生。\n\n之所以会出现这个信息是因为获取相关资源的请求并没有发出，  \n所以headers被展示并不是真正的信息。  \n就像提到的那样，真正的header只有在服务端返回的时候会更新。  \n当请求被拦截后，并没有返回。   \n基于这个情况开始猜测原因所在：\n\n### 猜测一、请求跨域被拦截  \n\n虽然现在网站的静态资源都会存在专门的静态域名下面，和html域名可能不一致。  \n但是基本都是基于CORS来解决这个问题，所以不存在这个问题。   \n再有就是，我们这种情况首次请求的时候不会发生，如果有跨域，应该都被block。  \n另外如果是被拦截，那么请求应该不会被响应的，我们这里显然得到了正确的响应。\n这种被排除。\n\n### 猜测二、服务器未及时响应   \n\n这种猜测和一差不多，特定情况下才会出现，跟服务器关联不大。 \n \n### 猜测三、被扩展程序拦截  \n\n作为一个开发人员，大家的chrome上肯定装了不少的插件。这种原因还是有可能的。  \n我们可以通过 chrome://net-internals 来根据关键字查找相关请求，\n然后具体去看相关状态。  \n例如我们http://xxdy.tech/css/main.css?v=5.1.4请求\n<img src='https://user-gold-cdn.xitu.io/2018/11/30/1676251ca84e838b?w=2546&h=1068&f=jpeg&s=250219' />\n可以看到并没有出现block，timeout等字段，只能看到比较明显的DISK_CACHE。  \n因此这种情况也不满足，我们应该是和本地缓存强烈相关的。  \n\n### 本地缓存\n\n结合上面的分析，我们可以缩小到缓存上面。冲着这个目标，我们继续去看下相关资料。  \n最后在一篇[日文资料](https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/)里找到了相关解释。  \n似乎只从缓存中获得的通信显示为“显示临时标题”（或“执行”）  \n因为该文件是从缓存中获取的，并且未进行通信\n所以详细标头并不会显示。\n\n#### 原因：未与服务端正确通信  \n\n回过头来看，前面提到的那么多情况其实都是与服务器没有进行或者完成正确的通信，所以只展示临时信息。\n\n####  常见状况\n\nprovisional headers are shown出现的情况有这么几种：  \n\n1. 跨域，请求被浏览器拦截\n2. 请求被浏览器插件拦截\n3. 服务器出错或者超时，没有真正的返回\n4. 强缓存from disk cache或者from memory cache，此时也不会显示 \n\n## 结束语\n  \n到这里provisional headers are shown相关总结就结束了，本身并不是一个问题，但在自身不了解的情况下还是要去研究一下，不然永远是个问题。本文抛砖引玉，给自己一个总结，同时希望能给有需要人一些帮助。   \n\n### 参考文章  \n[https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger](https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger)  \n[https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/](https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/)   \n[http://www.techfolks.net/provisional-headers-are-shown-in-google-chrome-browser-debugger/](http://www.techfolks.net/provisional-headers-are-shown-in-google-chrome-browser-debugger/)\n\n\n","slug":"header","published":1,"updated":"2018-11-30T03:20:02.474Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1q000qgw925url9mpg","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>请求里面provisional headers are shown(显示临时报头) 出现的情况很多，但原因是多样的。<br>如果你去直接匹配关键字搜索，得到的结果可能与你自己的情况大相径庭。<br>网上大部分都是在跨域时出现，或者是请求被插件拦截，但关于缓存时的请求很少。<br>我在<a href=\"https://juejin.im/post/5bfcd79e6fb9a04a08215cf3\" target=\"_blank\" rel=\"noopener\">上文查看缓存的时候发现了这个问题</a>,当时查找资料都是聚焦于请求被拦截，<br>所以本文就简单整理一下相关情况。<br><a id=\"more\"></a></p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>当刷新页面时，想要查看http请求header中相关信息时，<br>发现使用缓存的请求（from disk cache或者from memory cache）header相关信息不能查看</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/30/1676251cabb19a3f?w=2826&h=1670&f=jpeg&s=411272\"></p>\n<p>第一次看到确实有点疑惑，那么就去搜索了下。<br>碰到这个提示的情况挺多，但细看下与我们的场景不太符合。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/30/1676251ca86991f9?w=1910&h=1374&f=jpeg&s=410863\"><br>基本上遇到的都是provisional headers are shown，阻止了请求的正常加载。<br>而我们只是在使用缓存的时候遇到，而看起来请求没有被block掉。好像不太符合。  </p>\n<h2 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h2><p>虽然没有看到匹配度十分相关的信息，但看到了<a href=\"https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger\" target=\"_blank\" rel=\"noopener\">有启发的一篇文章(详情点击)</a>。  </p>\n<p>摘抄部分如下：  </p>\n<p><em>The resource could be being blocked by an extension (AdBlock in my case).<br>The message is there because the request to retrieve that resource was never made, so the headers being shown are not the real thing. As explained in the issue you referenced, the real headers are updated when the server responds, but there is no response if the request was blocked.</em></p>\n<p>资源可能被一些扩展程序拦截 。  </p>\n<p>另外还有一句：  </p>\n<p><em>I believe it happens when the actual request is not sent. Usually happens when you are loading a cached resource.</em></p>\n<p>真正请求并未被发送，当使用缓存时经常发生。</p>\n<p>之所以会出现这个信息是因为获取相关资源的请求并没有发出，<br>所以headers被展示并不是真正的信息。<br>就像提到的那样，真正的header只有在服务端返回的时候会更新。<br>当请求被拦截后，并没有返回。<br>基于这个情况开始猜测原因所在：</p>\n<h3 id=\"猜测一、请求跨域被拦截\"><a href=\"#猜测一、请求跨域被拦截\" class=\"headerlink\" title=\"猜测一、请求跨域被拦截\"></a>猜测一、请求跨域被拦截</h3><p>虽然现在网站的静态资源都会存在专门的静态域名下面，和html域名可能不一致。<br>但是基本都是基于CORS来解决这个问题，所以不存在这个问题。<br>再有就是，我们这种情况首次请求的时候不会发生，如果有跨域，应该都被block。<br>另外如果是被拦截，那么请求应该不会被响应的，我们这里显然得到了正确的响应。<br>这种被排除。</p>\n<h3 id=\"猜测二、服务器未及时响应\"><a href=\"#猜测二、服务器未及时响应\" class=\"headerlink\" title=\"猜测二、服务器未及时响应\"></a>猜测二、服务器未及时响应</h3><p>这种猜测和一差不多，特定情况下才会出现，跟服务器关联不大。 </p>\n<h3 id=\"猜测三、被扩展程序拦截\"><a href=\"#猜测三、被扩展程序拦截\" class=\"headerlink\" title=\"猜测三、被扩展程序拦截\"></a>猜测三、被扩展程序拦截</h3><p>作为一个开发人员，大家的chrome上肯定装了不少的插件。这种原因还是有可能的。<br>我们可以通过 chrome://net-internals 来根据关键字查找相关请求，<br>然后具体去看相关状态。<br>例如我们<a href=\"http://xxdy.tech/css/main.css?v=5.1.4请求\">http://xxdy.tech/css/main.css?v=5.1.4请求</a><br><img src=\"https://user-gold-cdn.xitu.io/2018/11/30/1676251ca84e838b?w=2546&h=1068&f=jpeg&s=250219\"><br>可以看到并没有出现block，timeout等字段，只能看到比较明显的DISK_CACHE。<br>因此这种情况也不满足，我们应该是和本地缓存强烈相关的。  </p>\n<h3 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"本地缓存\"></a>本地缓存</h3><p>结合上面的分析，我们可以缩小到缓存上面。冲着这个目标，我们继续去看下相关资料。<br>最后在一篇<a href=\"https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/\" target=\"_blank\" rel=\"noopener\">日文资料</a>里找到了相关解释。<br>似乎只从缓存中获得的通信显示为“显示临时标题”（或“执行”）<br>因为该文件是从缓存中获取的，并且未进行通信<br>所以详细标头并不会显示。</p>\n<h4 id=\"原因：未与服务端正确通信\"><a href=\"#原因：未与服务端正确通信\" class=\"headerlink\" title=\"原因：未与服务端正确通信\"></a>原因：未与服务端正确通信</h4><p>回过头来看，前面提到的那么多情况其实都是与服务器没有进行或者完成正确的通信，所以只展示临时信息。</p>\n<h4 id=\"常见状况\"><a href=\"#常见状况\" class=\"headerlink\" title=\"常见状况\"></a>常见状况</h4><p>provisional headers are shown出现的情况有这么几种：  </p>\n<ol>\n<li>跨域，请求被浏览器拦截</li>\n<li>请求被浏览器插件拦截</li>\n<li>服务器出错或者超时，没有真正的返回</li>\n<li>强缓存from disk cache或者from memory cache，此时也不会显示 </li>\n</ol>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>到这里provisional headers are shown相关总结就结束了，本身并不是一个问题，但在自身不了解的情况下还是要去研究一下，不然永远是个问题。本文抛砖引玉，给自己一个总结，同时希望能给有需要人一些帮助。   </p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger</a><br><a href=\"https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/\" target=\"_blank\" rel=\"noopener\">https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/</a><br><a href=\"http://www.techfolks.net/provisional-headers-are-shown-in-google-chrome-browser-debugger/\" target=\"_blank\" rel=\"noopener\">http://www.techfolks.net/provisional-headers-are-shown-in-google-chrome-browser-debugger/</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>请求里面provisional headers are shown(显示临时报头) 出现的情况很多，但原因是多样的。<br>如果你去直接匹配关键字搜索，得到的结果可能与你自己的情况大相径庭。<br>网上大部分都是在跨域时出现，或者是请求被插件拦截，但关于缓存时的请求很少。<br>我在<a href=\"https://juejin.im/post/5bfcd79e6fb9a04a08215cf3\" target=\"_blank\" rel=\"noopener\">上文查看缓存的时候发现了这个问题</a>,当时查找资料都是聚焦于请求被拦截，<br>所以本文就简单整理一下相关情况。<br>","more":"</p>\n<h2 id=\"问题描述\"><a href=\"#问题描述\" class=\"headerlink\" title=\"问题描述\"></a>问题描述</h2><p>当刷新页面时，想要查看http请求header中相关信息时，<br>发现使用缓存的请求（from disk cache或者from memory cache）header相关信息不能查看</p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2018/11/30/1676251cabb19a3f?w=2826&h=1670&f=jpeg&s=411272\"></p>\n<p>第一次看到确实有点疑惑，那么就去搜索了下。<br>碰到这个提示的情况挺多，但细看下与我们的场景不太符合。<br><img src=\"https://user-gold-cdn.xitu.io/2018/11/30/1676251ca86991f9?w=1910&h=1374&f=jpeg&s=410863\"><br>基本上遇到的都是provisional headers are shown，阻止了请求的正常加载。<br>而我们只是在使用缓存的时候遇到，而看起来请求没有被block掉。好像不太符合。  </p>\n<h2 id=\"问题定位\"><a href=\"#问题定位\" class=\"headerlink\" title=\"问题定位\"></a>问题定位</h2><p>虽然没有看到匹配度十分相关的信息，但看到了<a href=\"https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger\" target=\"_blank\" rel=\"noopener\">有启发的一篇文章(详情点击)</a>。  </p>\n<p>摘抄部分如下：  </p>\n<p><em>The resource could be being blocked by an extension (AdBlock in my case).<br>The message is there because the request to retrieve that resource was never made, so the headers being shown are not the real thing. As explained in the issue you referenced, the real headers are updated when the server responds, but there is no response if the request was blocked.</em></p>\n<p>资源可能被一些扩展程序拦截 。  </p>\n<p>另外还有一句：  </p>\n<p><em>I believe it happens when the actual request is not sent. Usually happens when you are loading a cached resource.</em></p>\n<p>真正请求并未被发送，当使用缓存时经常发生。</p>\n<p>之所以会出现这个信息是因为获取相关资源的请求并没有发出，<br>所以headers被展示并不是真正的信息。<br>就像提到的那样，真正的header只有在服务端返回的时候会更新。<br>当请求被拦截后，并没有返回。<br>基于这个情况开始猜测原因所在：</p>\n<h3 id=\"猜测一、请求跨域被拦截\"><a href=\"#猜测一、请求跨域被拦截\" class=\"headerlink\" title=\"猜测一、请求跨域被拦截\"></a>猜测一、请求跨域被拦截</h3><p>虽然现在网站的静态资源都会存在专门的静态域名下面，和html域名可能不一致。<br>但是基本都是基于CORS来解决这个问题，所以不存在这个问题。<br>再有就是，我们这种情况首次请求的时候不会发生，如果有跨域，应该都被block。<br>另外如果是被拦截，那么请求应该不会被响应的，我们这里显然得到了正确的响应。<br>这种被排除。</p>\n<h3 id=\"猜测二、服务器未及时响应\"><a href=\"#猜测二、服务器未及时响应\" class=\"headerlink\" title=\"猜测二、服务器未及时响应\"></a>猜测二、服务器未及时响应</h3><p>这种猜测和一差不多，特定情况下才会出现，跟服务器关联不大。 </p>\n<h3 id=\"猜测三、被扩展程序拦截\"><a href=\"#猜测三、被扩展程序拦截\" class=\"headerlink\" title=\"猜测三、被扩展程序拦截\"></a>猜测三、被扩展程序拦截</h3><p>作为一个开发人员，大家的chrome上肯定装了不少的插件。这种原因还是有可能的。<br>我们可以通过 chrome://net-internals 来根据关键字查找相关请求，<br>然后具体去看相关状态。<br>例如我们<a href=\"http://xxdy.tech/css/main.css?v=5.1.4请求\">http://xxdy.tech/css/main.css?v=5.1.4请求</a><br><img src=\"https://user-gold-cdn.xitu.io/2018/11/30/1676251ca84e838b?w=2546&h=1068&f=jpeg&s=250219\"><br>可以看到并没有出现block，timeout等字段，只能看到比较明显的DISK_CACHE。<br>因此这种情况也不满足，我们应该是和本地缓存强烈相关的。  </p>\n<h3 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"本地缓存\"></a>本地缓存</h3><p>结合上面的分析，我们可以缩小到缓存上面。冲着这个目标，我们继续去看下相关资料。<br>最后在一篇<a href=\"https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/\" target=\"_blank\" rel=\"noopener\">日文资料</a>里找到了相关解释。<br>似乎只从缓存中获得的通信显示为“显示临时标题”（或“执行”）<br>因为该文件是从缓存中获取的，并且未进行通信<br>所以详细标头并不会显示。</p>\n<h4 id=\"原因：未与服务端正确通信\"><a href=\"#原因：未与服务端正确通信\" class=\"headerlink\" title=\"原因：未与服务端正确通信\"></a>原因：未与服务端正确通信</h4><p>回过头来看，前面提到的那么多情况其实都是与服务器没有进行或者完成正确的通信，所以只展示临时信息。</p>\n<h4 id=\"常见状况\"><a href=\"#常见状况\" class=\"headerlink\" title=\"常见状况\"></a>常见状况</h4><p>provisional headers are shown出现的情况有这么几种：  </p>\n<ol>\n<li>跨域，请求被浏览器拦截</li>\n<li>请求被浏览器插件拦截</li>\n<li>服务器出错或者超时，没有真正的返回</li>\n<li>强缓存from disk cache或者from memory cache，此时也不会显示 </li>\n</ol>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>到这里provisional headers are shown相关总结就结束了，本身并不是一个问题，但在自身不了解的情况下还是要去研究一下，不然永远是个问题。本文抛砖引玉，给自己一个总结，同时希望能给有需要人一些帮助。   </p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger\" target=\"_blank\" rel=\"noopener\">https://stackoverflow.com/questions/21177387/caution-provisional-headers-are-shown-in-chrome-debugger</a><br><a href=\"https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/\" target=\"_blank\" rel=\"noopener\">https://did2memo.net/2017/01/23/chrome-devtools-provisional-headers-are-shown/</a><br><a href=\"http://www.techfolks.net/provisional-headers-are-shown-in-google-chrome-browser-debugger/\" target=\"_blank\" rel=\"noopener\">http://www.techfolks.net/provisional-headers-are-shown-in-google-chrome-browser-debugger/</a></p>"},{"title":"其实我们可以少写点if else和switch","date":"2019-01-09T16:00:00.000Z","_content":"\n## 前言\n作为搬砖在第一线的底层工人，业务场景从来是没有做不到只有想不到的复杂。  \n不过他强任他强，if-else全搞定，搬就完了。但是随着业务迭代或者项目交接，自己在看自己或者别人的if代码的时候，心情就不再表述了，各自深有体会。所以我们一起看看if还能怎么写\n<!-- more -->\n## 最基本if-else\n  \n假设有这么个场景,不同情况下打印不同值。\n因为涉及到的条件太多，就不提三目运算之类优化了。\n\n```js\nif (a == 1) {\n    console.log('a1')\n} else if (a == 2) {\n    console.log('b2')\n} else if (a == 3) {\n    console.log('c3')\n} else if (a == 4) {\n    console.log('d4')\n}\n/* n..... */\n```\n现在还算能看，因为逻辑简单，如果逻辑复杂，迭代多个版本之后，你还敢动吗。  \n每动一下就战战兢兢，谁知道哪里会遗漏。\n那么换种方式呢\n## switch-case\n这样稍微清晰那么一点,差别好像没什么差别：\n\n```js\nswitch(a){\n    case 1:\n        console.log('a1');\n        break;\n    /* 省略。。。 */  \n    case 40:\n        console.log('a40');\n        break;\n}\n```\n## 分离配置信息与执行动作\n\n### object映射\n定义一个object作为配置对象来存放不同状态，通过链表查找\n\n```js\nconst statusMap = {\n    1:()=>{\n        console.log('a1')\n    },\n    2:()=>{\n        console.log('b2')\n    }\n    /* n.... */\n}\n// 执行\nlet a = 1 \nstatusMap[a || 1]()\n```\n\n这样比较清晰，将条件配置与具体执行分离。如果要增加其他状态，只修改配置对象即可。\n\n### 数组映射\n\n当然在某些状态下可以使用数组，来做这个配置对象。  \n\n```js\n// 这里就涉及其他优化了，例如将执行函数抽离出来，大家不要关注func的内容就好。\n// 它就是个function，内容很复杂\nconst statusArr = [function(){\n    console.log(1)\n},\n    function () {\n        console.log(2)\n    },]\n// 执行\nlet a = 1\nstatusArr[a || 1]()\n```\n数组的要求更高一点，如果是其他key，例如字符串，那么数组就不能满足需求了\n\n## 升级版：不同key相同value\n\n这样看起来好一点了，那么需求又有变动了，  \n前面是每种处理方式都不同，下面有几种情况下处理函数相同的，\n例如1-39的时候，调用a，40之后调用b，如果我们继续来用映射的方式来处理。\n\n```js\nfunction f1 (){\n    console.log(1)\n}\nfunction f2 (){\n    console.log(2)\n}\nconst statusMap={\n    1:f1,\n    2:f1,\n    3:f1,\n    4:f1,\n    //省略\n    40:f2\n}\nlet a = 2\nstatusMap[a]()\n```\n\n这样当然也可以，不过重复写那么多f1，代码看起来不够简洁。\n\n开始重构之前我们先捋一下思路，无非是想把多个key合并起来，对应一个value。  \n也就是说我们的键值不是字符串而是个数组，object显然只支持字符串，\n那么可以将这么多key合并成一个：'1,2,3,4,..,9'。\n\n但是查找的时候有点问题了，我们的参数肯定不能完全匹配。  \n接着走下去，是不是做个遍历加个判断，包含在子集内的都算匹配，那么代码看起来就是下面这个样子。  \n\n```js\n// 将键值key设置为一个拼接之后的字符串\nconst statusMap = {\n    '1,2,3,4,5': f1,\n    //省略\n    40: f2\n}\n// 获取所有的键值，待会遍历用\nconst keys = Object.keys(statusMap),\n    len = keys.length\n// 遍历获取对应的值 \nconst getVal=(param='')=>{\n    // 用for循环的原因在于匹配之后就不需要继续遍历\n    for (let i = 0; i < len; i++) {\n        const key = keys[i],\n            val = statusMap[key]\n        // 这里用什么来判断就随便了，两个字符串都有。    \n        if (key.includes(param)) {\n            return val\n        }\n    }\n}\nlet a = 2,\n    handle = getVal(a)\nhandle() // 1\n```\n\n但是这样来看，增加了个遍历的过程，而且是拼接字符串，万一哪天传了个逗号进来，会得到了预料之外的结果。\n\n### map\n\nes6有个新的数据结构Map，支持任意数据结构作为键值。如果用Map可能更清晰一点。\n\n```js\n/**\n * map键值索引的是引用地址，\n * 如果是下面这样的写法不好意思，永远得不到值\n * map1.set([1,4,5],'引用地址')\n * map1.get([1,4,5])  //输出为undefined\n * 就像直接访问\n * map1.get([1,2,3,4,5]) //同样为undefined\n */\nconst map1 = new Map()\nconst statusArr = [1,2,3,4,5]\nmap1.set(statusArr,f1)\n// 预设默认值，因为不能直接遍历\nlet handle = function(){}\nconst getVal = (param = '') => {\nfor (let value of map1.entries()) {\n    console.log(JSON.stringify(value))\n    if (value[0].includes(param)){\n        console.log(value)\n        // 不能跳出 只能处理了\n        handle = value[1]\n    }\n}\n}\nconst a = 2\ngetVal(a)\nhandle()\n```\n\n个人而言虽然这样减少了重复代码，但是又增加了一步匹配值的操作，优劣就见仁见智吧。  \n\n### 双数组\n\n肯定有部分人就是不想做遍历的操作，既然一个数组不能满足，那么两个数组呢。   \n\n```js\n// 键值数组和value 保持对应关系\nconst keyArr = ['1,2,3,4,5','40']\nconst valArr = [f1,f2]\nconst getVal = (param = '')=>{\n    // 查找参数对应的下标\n    let index = keyArr.findIndex((it)=>{\n        return it.includes(param)\n    })\n    // 获取对应值\n    return valArr[index]\n}\nlet a = 2,\n    handle = getVal(a)\nhandle()\n```\n利用数组提供的下标，将key和value对应起来，进而获取想要的值。  \n这里一直没有达到我最初的目的，即键里面重复的数组，可以不通过多余操作匹配到，上面不管怎么样都进行了处理，这不是懒人的想要的。\n\n## 总结  \n\n这是在写业务需求的时候做的一点总结，数组和对象的映射可能大家都在用。当遇到了不同key相同value的情况时，从懒出发不像重复罗列，就尝试了下。当然了，因为个人水平问题，肯定有更好的处理方式，欢迎一起讨论，抛砖引玉共同进步。此外现有成熟的库里loadsh也是可以到达目的，不过自己思考过之后再去看大神的作品理解会更深入一点。\n\n\n\n","source":"_posts/ifelse.md","raw":"---\ntitle: 其实我们可以少写点if else和switch\ndate: 2019-01-10\n---\n\n## 前言\n作为搬砖在第一线的底层工人，业务场景从来是没有做不到只有想不到的复杂。  \n不过他强任他强，if-else全搞定，搬就完了。但是随着业务迭代或者项目交接，自己在看自己或者别人的if代码的时候，心情就不再表述了，各自深有体会。所以我们一起看看if还能怎么写\n<!-- more -->\n## 最基本if-else\n  \n假设有这么个场景,不同情况下打印不同值。\n因为涉及到的条件太多，就不提三目运算之类优化了。\n\n```js\nif (a == 1) {\n    console.log('a1')\n} else if (a == 2) {\n    console.log('b2')\n} else if (a == 3) {\n    console.log('c3')\n} else if (a == 4) {\n    console.log('d4')\n}\n/* n..... */\n```\n现在还算能看，因为逻辑简单，如果逻辑复杂，迭代多个版本之后，你还敢动吗。  \n每动一下就战战兢兢，谁知道哪里会遗漏。\n那么换种方式呢\n## switch-case\n这样稍微清晰那么一点,差别好像没什么差别：\n\n```js\nswitch(a){\n    case 1:\n        console.log('a1');\n        break;\n    /* 省略。。。 */  \n    case 40:\n        console.log('a40');\n        break;\n}\n```\n## 分离配置信息与执行动作\n\n### object映射\n定义一个object作为配置对象来存放不同状态，通过链表查找\n\n```js\nconst statusMap = {\n    1:()=>{\n        console.log('a1')\n    },\n    2:()=>{\n        console.log('b2')\n    }\n    /* n.... */\n}\n// 执行\nlet a = 1 \nstatusMap[a || 1]()\n```\n\n这样比较清晰，将条件配置与具体执行分离。如果要增加其他状态，只修改配置对象即可。\n\n### 数组映射\n\n当然在某些状态下可以使用数组，来做这个配置对象。  \n\n```js\n// 这里就涉及其他优化了，例如将执行函数抽离出来，大家不要关注func的内容就好。\n// 它就是个function，内容很复杂\nconst statusArr = [function(){\n    console.log(1)\n},\n    function () {\n        console.log(2)\n    },]\n// 执行\nlet a = 1\nstatusArr[a || 1]()\n```\n数组的要求更高一点，如果是其他key，例如字符串，那么数组就不能满足需求了\n\n## 升级版：不同key相同value\n\n这样看起来好一点了，那么需求又有变动了，  \n前面是每种处理方式都不同，下面有几种情况下处理函数相同的，\n例如1-39的时候，调用a，40之后调用b，如果我们继续来用映射的方式来处理。\n\n```js\nfunction f1 (){\n    console.log(1)\n}\nfunction f2 (){\n    console.log(2)\n}\nconst statusMap={\n    1:f1,\n    2:f1,\n    3:f1,\n    4:f1,\n    //省略\n    40:f2\n}\nlet a = 2\nstatusMap[a]()\n```\n\n这样当然也可以，不过重复写那么多f1，代码看起来不够简洁。\n\n开始重构之前我们先捋一下思路，无非是想把多个key合并起来，对应一个value。  \n也就是说我们的键值不是字符串而是个数组，object显然只支持字符串，\n那么可以将这么多key合并成一个：'1,2,3,4,..,9'。\n\n但是查找的时候有点问题了，我们的参数肯定不能完全匹配。  \n接着走下去，是不是做个遍历加个判断，包含在子集内的都算匹配，那么代码看起来就是下面这个样子。  \n\n```js\n// 将键值key设置为一个拼接之后的字符串\nconst statusMap = {\n    '1,2,3,4,5': f1,\n    //省略\n    40: f2\n}\n// 获取所有的键值，待会遍历用\nconst keys = Object.keys(statusMap),\n    len = keys.length\n// 遍历获取对应的值 \nconst getVal=(param='')=>{\n    // 用for循环的原因在于匹配之后就不需要继续遍历\n    for (let i = 0; i < len; i++) {\n        const key = keys[i],\n            val = statusMap[key]\n        // 这里用什么来判断就随便了，两个字符串都有。    \n        if (key.includes(param)) {\n            return val\n        }\n    }\n}\nlet a = 2,\n    handle = getVal(a)\nhandle() // 1\n```\n\n但是这样来看，增加了个遍历的过程，而且是拼接字符串，万一哪天传了个逗号进来，会得到了预料之外的结果。\n\n### map\n\nes6有个新的数据结构Map，支持任意数据结构作为键值。如果用Map可能更清晰一点。\n\n```js\n/**\n * map键值索引的是引用地址，\n * 如果是下面这样的写法不好意思，永远得不到值\n * map1.set([1,4,5],'引用地址')\n * map1.get([1,4,5])  //输出为undefined\n * 就像直接访问\n * map1.get([1,2,3,4,5]) //同样为undefined\n */\nconst map1 = new Map()\nconst statusArr = [1,2,3,4,5]\nmap1.set(statusArr,f1)\n// 预设默认值，因为不能直接遍历\nlet handle = function(){}\nconst getVal = (param = '') => {\nfor (let value of map1.entries()) {\n    console.log(JSON.stringify(value))\n    if (value[0].includes(param)){\n        console.log(value)\n        // 不能跳出 只能处理了\n        handle = value[1]\n    }\n}\n}\nconst a = 2\ngetVal(a)\nhandle()\n```\n\n个人而言虽然这样减少了重复代码，但是又增加了一步匹配值的操作，优劣就见仁见智吧。  \n\n### 双数组\n\n肯定有部分人就是不想做遍历的操作，既然一个数组不能满足，那么两个数组呢。   \n\n```js\n// 键值数组和value 保持对应关系\nconst keyArr = ['1,2,3,4,5','40']\nconst valArr = [f1,f2]\nconst getVal = (param = '')=>{\n    // 查找参数对应的下标\n    let index = keyArr.findIndex((it)=>{\n        return it.includes(param)\n    })\n    // 获取对应值\n    return valArr[index]\n}\nlet a = 2,\n    handle = getVal(a)\nhandle()\n```\n利用数组提供的下标，将key和value对应起来，进而获取想要的值。  \n这里一直没有达到我最初的目的，即键里面重复的数组，可以不通过多余操作匹配到，上面不管怎么样都进行了处理，这不是懒人的想要的。\n\n## 总结  \n\n这是在写业务需求的时候做的一点总结，数组和对象的映射可能大家都在用。当遇到了不同key相同value的情况时，从懒出发不像重复罗列，就尝试了下。当然了，因为个人水平问题，肯定有更好的处理方式，欢迎一起讨论，抛砖引玉共同进步。此外现有成熟的库里loadsh也是可以到达目的，不过自己思考过之后再去看大神的作品理解会更深入一点。\n\n\n\n","slug":"ifelse","published":1,"updated":"2019-01-10T03:21:29.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1r000rgw920qzw487d","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为搬砖在第一线的底层工人，业务场景从来是没有做不到只有想不到的复杂。<br>不过他强任他强，if-else全搞定，搬就完了。但是随着业务迭代或者项目交接，自己在看自己或者别人的if代码的时候，心情就不再表述了，各自深有体会。所以我们一起看看if还能怎么写<br><a id=\"more\"></a></p>\n<h2 id=\"最基本if-else\"><a href=\"#最基本if-else\" class=\"headerlink\" title=\"最基本if-else\"></a>最基本if-else</h2><p>假设有这么个场景,不同情况下打印不同值。<br>因为涉及到的条件太多，就不提三目运算之类优化了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a1'</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b2'</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c3'</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'d4'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* n..... */</span></span><br></pre></td></tr></table></figure>\n<p>现在还算能看，因为逻辑简单，如果逻辑复杂，迭代多个版本之后，你还敢动吗。<br>每动一下就战战兢兢，谁知道哪里会遗漏。<br>那么换种方式呢</p>\n<h2 id=\"switch-case\"><a href=\"#switch-case\" class=\"headerlink\" title=\"switch-case\"></a>switch-case</h2><p>这样稍微清晰那么一点,差别好像没什么差别：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(a)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'a1'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 省略。。。 */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">40</span>:</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'a40'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分离配置信息与执行动作\"><a href=\"#分离配置信息与执行动作\" class=\"headerlink\" title=\"分离配置信息与执行动作\"></a>分离配置信息与执行动作</h2><h3 id=\"object映射\"><a href=\"#object映射\" class=\"headerlink\" title=\"object映射\"></a>object映射</h3><p>定义一个object作为配置对象来存放不同状态，通过链表查找</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> statusMap = &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span>:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'a1'</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"number\">2</span>:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'b2'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* n.... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 执行</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span> </span><br><span class=\"line\">statusMap[a || <span class=\"number\">1</span>]()</span><br></pre></td></tr></table></figure>\n<p>这样比较清晰，将条件配置与具体执行分离。如果要增加其他状态，只修改配置对象即可。</p>\n<h3 id=\"数组映射\"><a href=\"#数组映射\" class=\"headerlink\" title=\"数组映射\"></a>数组映射</h3><p>当然在某些状态下可以使用数组，来做这个配置对象。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里就涉及其他优化了，例如将执行函数抽离出来，大家不要关注func的内容就好。</span></span><br><span class=\"line\"><span class=\"comment\">// 它就是个function，内容很复杂</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> statusArr = [<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;,]</span><br><span class=\"line\"><span class=\"comment\">// 执行</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">statusArr[a || <span class=\"number\">1</span>]()</span><br></pre></td></tr></table></figure>\n<p>数组的要求更高一点，如果是其他key，例如字符串，那么数组就不能满足需求了</p>\n<h2 id=\"升级版：不同key相同value\"><a href=\"#升级版：不同key相同value\" class=\"headerlink\" title=\"升级版：不同key相同value\"></a>升级版：不同key相同value</h2><p>这样看起来好一点了，那么需求又有变动了，<br>前面是每种处理方式都不同，下面有几种情况下处理函数相同的，<br>例如1-39的时候，调用a，40之后调用b，如果我们继续来用映射的方式来处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> statusMap=&#123;</span><br><span class=\"line\">    <span class=\"number\">1</span>:f1,</span><br><span class=\"line\">    <span class=\"number\">2</span>:f1,</span><br><span class=\"line\">    <span class=\"number\">3</span>:f1,</span><br><span class=\"line\">    <span class=\"number\">4</span>:f1,</span><br><span class=\"line\">    <span class=\"comment\">//省略</span></span><br><span class=\"line\">    <span class=\"number\">40</span>:f2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">statusMap[a]()</span><br></pre></td></tr></table></figure>\n<p>这样当然也可以，不过重复写那么多f1，代码看起来不够简洁。</p>\n<p>开始重构之前我们先捋一下思路，无非是想把多个key合并起来，对应一个value。<br>也就是说我们的键值不是字符串而是个数组，object显然只支持字符串，<br>那么可以将这么多key合并成一个：’1,2,3,4,..,9’。</p>\n<p>但是查找的时候有点问题了，我们的参数肯定不能完全匹配。<br>接着走下去，是不是做个遍历加个判断，包含在子集内的都算匹配，那么代码看起来就是下面这个样子。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将键值key设置为一个拼接之后的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> statusMap = &#123;</span><br><span class=\"line\">    <span class=\"string\">'1,2,3,4,5'</span>: f1,</span><br><span class=\"line\">    <span class=\"comment\">//省略</span></span><br><span class=\"line\">    <span class=\"number\">40</span>: f2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取所有的键值，待会遍历用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> keys = <span class=\"built_in\">Object</span>.keys(statusMap),</span><br><span class=\"line\">    len = keys.length</span><br><span class=\"line\"><span class=\"comment\">// 遍历获取对应的值 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> getVal=<span class=\"function\">(<span class=\"params\">param=<span class=\"string\">''</span></span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用for循环的原因在于匹配之后就不需要继续遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> key = keys[i],</span><br><span class=\"line\">            val = statusMap[key]</span><br><span class=\"line\">        <span class=\"comment\">// 这里用什么来判断就随便了，两个字符串都有。    </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.includes(param)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>,</span><br><span class=\"line\">    handle = getVal(a)</span><br><span class=\"line\">handle() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>但是这样来看，增加了个遍历的过程，而且是拼接字符串，万一哪天传了个逗号进来，会得到了预料之外的结果。</p>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p>es6有个新的数据结构Map，支持任意数据结构作为键值。如果用Map可能更清晰一点。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * map键值索引的是引用地址，</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果是下面这样的写法不好意思，永远得不到值</span></span><br><span class=\"line\"><span class=\"comment\"> * map1.set([1,4,5],'引用地址')</span></span><br><span class=\"line\"><span class=\"comment\"> * map1.get([1,4,5])  //输出为undefined</span></span><br><span class=\"line\"><span class=\"comment\"> * 就像直接访问</span></span><br><span class=\"line\"><span class=\"comment\"> * map1.get([1,2,3,4,5]) //同样为undefined</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> map1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\"><span class=\"keyword\">const</span> statusArr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">map1.set(statusArr,f1)</span><br><span class=\"line\"><span class=\"comment\">// 预设默认值，因为不能直接遍历</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> getVal = <span class=\"function\">(<span class=\"params\">param = <span class=\"string\">''</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> map1.entries()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(value))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value[<span class=\"number\">0</span>].includes(param))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">        <span class=\"comment\">// 不能跳出 只能处理了</span></span><br><span class=\"line\">        handle = value[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">getVal(a)</span><br><span class=\"line\">handle()</span><br></pre></td></tr></table></figure>\n<p>个人而言虽然这样减少了重复代码，但是又增加了一步匹配值的操作，优劣就见仁见智吧。  </p>\n<h3 id=\"双数组\"><a href=\"#双数组\" class=\"headerlink\" title=\"双数组\"></a>双数组</h3><p>肯定有部分人就是不想做遍历的操作，既然一个数组不能满足，那么两个数组呢。   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 键值数组和value 保持对应关系</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> keyArr = [<span class=\"string\">'1,2,3,4,5'</span>,<span class=\"string\">'40'</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> valArr = [f1,f2]</span><br><span class=\"line\"><span class=\"keyword\">const</span> getVal = <span class=\"function\">(<span class=\"params\">param = <span class=\"string\">''</span></span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 查找参数对应的下标</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = keyArr.findIndex(<span class=\"function\">(<span class=\"params\">it</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> it.includes(param)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 获取对应值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> valArr[index]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>,</span><br><span class=\"line\">    handle = getVal(a)</span><br><span class=\"line\">handle()</span><br></pre></td></tr></table></figure>\n<p>利用数组提供的下标，将key和value对应起来，进而获取想要的值。<br>这里一直没有达到我最初的目的，即键里面重复的数组，可以不通过多余操作匹配到，上面不管怎么样都进行了处理，这不是懒人的想要的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这是在写业务需求的时候做的一点总结，数组和对象的映射可能大家都在用。当遇到了不同key相同value的情况时，从懒出发不像重复罗列，就尝试了下。当然了，因为个人水平问题，肯定有更好的处理方式，欢迎一起讨论，抛砖引玉共同进步。此外现有成熟的库里loadsh也是可以到达目的，不过自己思考过之后再去看大神的作品理解会更深入一点。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为搬砖在第一线的底层工人，业务场景从来是没有做不到只有想不到的复杂。<br>不过他强任他强，if-else全搞定，搬就完了。但是随着业务迭代或者项目交接，自己在看自己或者别人的if代码的时候，心情就不再表述了，各自深有体会。所以我们一起看看if还能怎么写<br>","more":"</p>\n<h2 id=\"最基本if-else\"><a href=\"#最基本if-else\" class=\"headerlink\" title=\"最基本if-else\"></a>最基本if-else</h2><p>假设有这么个场景,不同情况下打印不同值。<br>因为涉及到的条件太多，就不提三目运算之类优化了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (a == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'a1'</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'b2'</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a == <span class=\"number\">3</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'c3'</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (a == <span class=\"number\">4</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'d4'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* n..... */</span></span><br></pre></td></tr></table></figure>\n<p>现在还算能看，因为逻辑简单，如果逻辑复杂，迭代多个版本之后，你还敢动吗。<br>每动一下就战战兢兢，谁知道哪里会遗漏。<br>那么换种方式呢</p>\n<h2 id=\"switch-case\"><a href=\"#switch-case\" class=\"headerlink\" title=\"switch-case\"></a>switch-case</h2><p>这样稍微清晰那么一点,差别好像没什么差别：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">switch</span>(a)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'a1'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* 省略。。。 */</span>  </span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">40</span>:</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'a40'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"分离配置信息与执行动作\"><a href=\"#分离配置信息与执行动作\" class=\"headerlink\" title=\"分离配置信息与执行动作\"></a>分离配置信息与执行动作</h2><h3 id=\"object映射\"><a href=\"#object映射\" class=\"headerlink\" title=\"object映射\"></a>object映射</h3><p>定义一个object作为配置对象来存放不同状态，通过链表查找</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> statusMap = &#123;</span><br><span class=\"line\">    <span class=\"number\">1</span>:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'a1'</span>)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"number\">2</span>:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'b2'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/* n.... */</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 执行</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span> </span><br><span class=\"line\">statusMap[a || <span class=\"number\">1</span>]()</span><br></pre></td></tr></table></figure>\n<p>这样比较清晰，将条件配置与具体执行分离。如果要增加其他状态，只修改配置对象即可。</p>\n<h3 id=\"数组映射\"><a href=\"#数组映射\" class=\"headerlink\" title=\"数组映射\"></a>数组映射</h3><p>当然在某些状态下可以使用数组，来做这个配置对象。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里就涉及其他优化了，例如将执行函数抽离出来，大家不要关注func的内容就好。</span></span><br><span class=\"line\"><span class=\"comment\">// 它就是个function，内容很复杂</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> statusArr = [<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;,]</span><br><span class=\"line\"><span class=\"comment\">// 执行</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">statusArr[a || <span class=\"number\">1</span>]()</span><br></pre></td></tr></table></figure>\n<p>数组的要求更高一点，如果是其他key，例如字符串，那么数组就不能满足需求了</p>\n<h2 id=\"升级版：不同key相同value\"><a href=\"#升级版：不同key相同value\" class=\"headerlink\" title=\"升级版：不同key相同value\"></a>升级版：不同key相同value</h2><p>这样看起来好一点了，那么需求又有变动了，<br>前面是每种处理方式都不同，下面有几种情况下处理函数相同的，<br>例如1-39的时候，调用a，40之后调用b，如果我们继续来用映射的方式来处理。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> statusMap=&#123;</span><br><span class=\"line\">    <span class=\"number\">1</span>:f1,</span><br><span class=\"line\">    <span class=\"number\">2</span>:f1,</span><br><span class=\"line\">    <span class=\"number\">3</span>:f1,</span><br><span class=\"line\">    <span class=\"number\">4</span>:f1,</span><br><span class=\"line\">    <span class=\"comment\">//省略</span></span><br><span class=\"line\">    <span class=\"number\">40</span>:f2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">statusMap[a]()</span><br></pre></td></tr></table></figure>\n<p>这样当然也可以，不过重复写那么多f1，代码看起来不够简洁。</p>\n<p>开始重构之前我们先捋一下思路，无非是想把多个key合并起来，对应一个value。<br>也就是说我们的键值不是字符串而是个数组，object显然只支持字符串，<br>那么可以将这么多key合并成一个：’1,2,3,4,..,9’。</p>\n<p>但是查找的时候有点问题了，我们的参数肯定不能完全匹配。<br>接着走下去，是不是做个遍历加个判断，包含在子集内的都算匹配，那么代码看起来就是下面这个样子。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将键值key设置为一个拼接之后的字符串</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> statusMap = &#123;</span><br><span class=\"line\">    <span class=\"string\">'1,2,3,4,5'</span>: f1,</span><br><span class=\"line\">    <span class=\"comment\">//省略</span></span><br><span class=\"line\">    <span class=\"number\">40</span>: f2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 获取所有的键值，待会遍历用</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> keys = <span class=\"built_in\">Object</span>.keys(statusMap),</span><br><span class=\"line\">    len = keys.length</span><br><span class=\"line\"><span class=\"comment\">// 遍历获取对应的值 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> getVal=<span class=\"function\">(<span class=\"params\">param=<span class=\"string\">''</span></span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用for循环的原因在于匹配之后就不需要继续遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> key = keys[i],</span><br><span class=\"line\">            val = statusMap[key]</span><br><span class=\"line\">        <span class=\"comment\">// 这里用什么来判断就随便了，两个字符串都有。    </span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key.includes(param)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> val</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>,</span><br><span class=\"line\">    handle = getVal(a)</span><br><span class=\"line\">handle() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>但是这样来看，增加了个遍历的过程，而且是拼接字符串，万一哪天传了个逗号进来，会得到了预料之外的结果。</p>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h3><p>es6有个新的数据结构Map，支持任意数据结构作为键值。如果用Map可能更清晰一点。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * map键值索引的是引用地址，</span></span><br><span class=\"line\"><span class=\"comment\"> * 如果是下面这样的写法不好意思，永远得不到值</span></span><br><span class=\"line\"><span class=\"comment\"> * map1.set([1,4,5],'引用地址')</span></span><br><span class=\"line\"><span class=\"comment\"> * map1.get([1,4,5])  //输出为undefined</span></span><br><span class=\"line\"><span class=\"comment\"> * 就像直接访问</span></span><br><span class=\"line\"><span class=\"comment\"> * map1.get([1,2,3,4,5]) //同样为undefined</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> map1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Map</span>()</span><br><span class=\"line\"><span class=\"keyword\">const</span> statusArr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>]</span><br><span class=\"line\">map1.set(statusArr,f1)</span><br><span class=\"line\"><span class=\"comment\">// 预设默认值，因为不能直接遍历</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> handle = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> getVal = <span class=\"function\">(<span class=\"params\">param = <span class=\"string\">''</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> value <span class=\"keyword\">of</span> map1.entries()) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(value))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value[<span class=\"number\">0</span>].includes(param))&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">        <span class=\"comment\">// 不能跳出 只能处理了</span></span><br><span class=\"line\">        handle = value[<span class=\"number\">1</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">getVal(a)</span><br><span class=\"line\">handle()</span><br></pre></td></tr></table></figure>\n<p>个人而言虽然这样减少了重复代码，但是又增加了一步匹配值的操作，优劣就见仁见智吧。  </p>\n<h3 id=\"双数组\"><a href=\"#双数组\" class=\"headerlink\" title=\"双数组\"></a>双数组</h3><p>肯定有部分人就是不想做遍历的操作，既然一个数组不能满足，那么两个数组呢。   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 键值数组和value 保持对应关系</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> keyArr = [<span class=\"string\">'1,2,3,4,5'</span>,<span class=\"string\">'40'</span>]</span><br><span class=\"line\"><span class=\"keyword\">const</span> valArr = [f1,f2]</span><br><span class=\"line\"><span class=\"keyword\">const</span> getVal = <span class=\"function\">(<span class=\"params\">param = <span class=\"string\">''</span></span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 查找参数对应的下标</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = keyArr.findIndex(<span class=\"function\">(<span class=\"params\">it</span>)=&gt;</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> it.includes(param)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 获取对应值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> valArr[index]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> a = <span class=\"number\">2</span>,</span><br><span class=\"line\">    handle = getVal(a)</span><br><span class=\"line\">handle()</span><br></pre></td></tr></table></figure>\n<p>利用数组提供的下标，将key和value对应起来，进而获取想要的值。<br>这里一直没有达到我最初的目的，即键里面重复的数组，可以不通过多余操作匹配到，上面不管怎么样都进行了处理，这不是懒人的想要的。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这是在写业务需求的时候做的一点总结，数组和对象的映射可能大家都在用。当遇到了不同key相同value的情况时，从懒出发不像重复罗列，就尝试了下。当然了，因为个人水平问题，肯定有更好的处理方式，欢迎一起讨论，抛砖引玉共同进步。此外现有成熟的库里loadsh也是可以到达目的，不过自己思考过之后再去看大神的作品理解会更深入一点。</p>"},{"title":"深入js隐式类型转换","date":"2018-05-23T00:00:29.000Z","_content":"## 前言  \n相信刚开始了解js的时候，都会遇到 2 =='2',但是 1+2 == 1+'2'为false的情况，这时候应该会是一脸懵逼的状态，不得不感慨js弱类型的灵活让人发指，隐式类型转换就是这么猝不及防。结合实际中的情况来看，有意或无意中涉及到隐式类型转换的情况还是很多的。既然要用到，就需要掌握其原理，知其然重要知其所以然更重要。   \n  <!--more  -->\n## js的变量类型  \nJavaScript 是弱类型语言，意味着JavaScript 变量没有预先确定的类型。    \n并且变量的类型是其值的类型。也就是说变量当前的类型由其值所决定,夸张点说上一秒种的string，下一秒可能就是个array了。此外当进行某些操作时，变量可以进行类型转换，我们主动进行的就是显式类型转换，另一种就是隐式类型转换了。例如:\n\n```js\nvar a = '1';   \ntypeof a;//string \n\na =parseInt(a); //显示转换为number\ntypeof a  //number   \n\na == '1' //true\n```\n\n弱类型的特性在给我们带来便利的同时，也会给我们带来困扰。趋利避害，充分利用该特性的前提就是掌握类型转换的原理，下面一起看一下。  \n## js数据类型   \n老生常谈的两大类数据类型：   \n \n1. 原始类型    \n   Undefined、 Null、 String、 Number、 Boolean      \n2. 引用类型  \n   object   \n此外还有一个es6新增的Symbol，先不讨论它。对于这五类原始类型，突然提问可能想不全，没必要去死记硬背，可以想一下为否的常见变量及其对应值即可。   \n  \n| 0 | Number |\n| --: | --: |\n| '' | String |\n| false | Boolean |\n| null | Null |\n| undefined | Undefined |\n\n对于不同的数据格式转换规则是不同的，我们需要分别对待。   \n## 转换规则  \n既然是规范定义的规则，那就不要问为什么了，先大致看一下，争取记住。是在不行经常翻翻看看大佬的博客[es5规范](http://yanhaijing.com/es5/#about)。转换有下面这么几类，我们分别看一下具体规范。（这部分转换规则，完全可以跳过去，看到下面的实例再回头看应该更容易接受一些）  \n   \n* 转换为原始值  \n* 转换为数字  \n* 转换为字符串    \n\n\n### ToPrimitive(转换为原始值)   \n\nToPrimitive 运算符接受一个值，和一个可选的 期望类型 作参数。ToPrimitive 运算符把其值参数转换为非对象类型。如果对象有能力被转换为不止一种原语类型，可以使用可选的 期望类型 来暗示那个类型。根据下表完成转换  \n<img src='http://xxdy.tech/img/jstype/1.png'> \n\n这段定义看起来有点枯燥。转换为原始值，其实就是针对引用数据的，其目的是转换为非对象类型。   \n如果已经是原始类型，当然就不做处理了   \n对于object，返回对应的原始类型，该原始类型是由期望类型决定的，期望类型其实就是我们传递的type。直接看下面比较清楚。  \nToPrimitive方法大概长这么个样子具体如下。  \n\n```js\n/**\n* @obj 需要转换的对象\n* @type 期望转换为的原始数据类型，可选\n*/\nToPrimitive(obj,type)\n```\n\ntype可以为number或者string，两者的执行顺序有一些差别   \n**string:**   \n   \n1. 调用obj的toString方法，如果为原始值，则返回，否则下一步   \n2. 调用obj的valueOf方法，后续同上\n3. 抛出TypeError 异常\n \n**number:**    \n\n1. 调用obj的valueOf方法，如果为原始值，则返回，否则下一步   \n2. 调用obj的toString方法，后续同上\n3. 抛出TypeError 异常    \n\n其实就是调用方法先后，毕竟期望数据类型不同，如果是string当然优先调用toString。反之亦然。   \n当然type参数可以为空，这时候type的默认值会按照下面的规则设置    \n\n1.  该对象为Date，则type被设置为String  \n2.  否则，type被设置为Number \n\n对于Date数据类型，我们更多期望获得的是其转为时间后的字符串，而非毫秒值，如果为number，则会取到对应的毫秒值，显然字符串使用更多。\n其他类型对象按照取值的类型操作即可。  \n\n概括而言，ToPrimitive转成何种原始类型，取决于type，type参数可选，若指定，则按照指定类型转换，若不指定，默认根据实用情况分两种情况，Date为string，其余对象为number。那么什么时候会指定type类型呢，那就要看下面两种转换方式了。  \n\n### toNumber \n\n某些特定情况下需要用到ToNumber方法来转成number \n运算符根据下表将其参数转换为数值类型的值\n<img src='http://xxdy.tech/img/jstype/2.png'>    \n\n对于string类型，情况比较多，只要掌握常见的就行了。和直接调用Number(str)的结果一致，这里就不多提了，主要是太多提不完。  \n需要注意的是，这里调用ToPrimitive的时候，type就指定为number了。下面的toString则为string。\n\n### toString   \n\nToString 运算符根据下表将其参数转换为字符串类型的值：  \n其实了解也很简单，毕竟是个规范，借用大佬一张图：  \n<img src='http://xxdy.tech/img/jstype/3.png'> \n\n虽然是需要死记的东西，还是有些规律可循的。\n对于原始值：  \n  \n* Undefined，null，boolean \n  直接加上引号，例如'null' \n* number 则有比较长的规范,毕竟范围比较大  \n  常见的就是 '1'   NaN则为'NaN'  基本等同于上面一条\n  对于负数，则返回-+字符串 例如 '-2'  其他的先不考虑了。   \n* 对象则是先转为原始值，再按照上面的步骤进行处理。   \n\n### valueOf  \n\n当调用 valueOf 方法，采用如下步骤：\n\n1. 调用ToObject方法得到一个对象O\n2. 原始数据类型转换为对应的内置对象， 引用类型则不变 \n3. 调用该对象(O)内置valueOf方法.\n\n\n不同内置对象的valueOf实现：\n* String => 返回字符串值\n* Number => 返回数字值  \n* Date => 返回一个数字，即时间值,字符串中内容是依赖于具体实现的\n* Boolean => 返回Boolean的this值\n* Object => 返回this  \n\n对照代码更清晰一点    \n\n```js\nvar str = new String('123')\n//123\nconsole.log(str.valueOf())\nvar num = new Number(123)\n//123\nconsole.log(num.valueOf())\nvar date = new Date()\n//1526990889729\nconsole.log(date.valueOf())\nvar bool = new Boolean('123')\n//true\nconsole.log(bool.valueOf())\nvar obj = new Object({valueOf:()=>{\n    return 1\n}})\n//依赖于内部实现\nconsole.log(obj.valueOf())\n\n```\n\n\n## 运算隐式转换  \n前面提了那么多抽象概念，就是为了这里来理解具体转换的。   \n对于+运算来说，规则如下：  \n\n* +号左右分别进行取值，进行ToPrimitive()操作\n* 分别获取左右转换之后的值，如果存在String，则对其进行ToString处理后进行拼接操作。\n* 其他的都进行ToNumber处理\n* 在转换时ToPrimitive，除去Date为string外都按照ToPrimitive type为Number进行处理\n说的自己都迷糊了快，一起结合代码来看一下   \n \n```js\n1+'2'+false\n```\n\n1. 左边取原始值，依旧是Number\n2. 中间为String，则都进行toString操作  \n3. 左边转换按照toString的规则，返回'1'\n4. 得到结果temp值'12'\n5. 右边布尔值和temp同样进行1步骤\n6. temp为string，则布尔值也转为string'false'\n7. 拼接两者 得到最后结果 '12false'\n\n我们看一个复杂的\n\n```js\nvar obj1 = {\n    valueOf:function(){\n        return 1\n    }\n}\nvar obj2 = {\n    toString:function(){\n        return 'a'\n    }\n}\n//2\nconsole.log(1+obj1)\n//1a\nconsole.log('1'+ obj2)\n//1a\nconsole.log(obj1+obj2)\n```\n\n\n不管多复杂，按照上面的顺序来吧。  \n\n* 1+obj1      \n  1. 左边就不说了，number\n  2. 右边obj转为基础类型，按照type为number进行\n  3. 先调用valueOf() 得到结果为1\n  4. 两遍都是number，则进行相加得到2  \n* 1+obj2  \n  1. 左边为number \n  2. 右边同样按照按照type为number进行转化\n  3. 调用obj2.valueOf()得到的不是原始值\n  4. 调用toString() return 'a'\n  5. 依据第二条规则，存在string，则都转换为string进行拼接\n  6. 得到结果1a\n* obj1+obj2  \n  1. 两边都是引用，进行转换 ToPrimitive 默认type为number\n  2. obj1.valueOf()为1 直接返回\n  3. obj2.valueOf()得到的不是原始值\n  4. 调用toString() return 'a'\n  5. 依据第二条规则，存在string，则都转换为string进行拼接\n  6. 得到结果1a \n\n到这里相信大家对+这种运算的类型转换了解的差不多了。下面就看一下另一种隐式类型转换  \n\n### == 抽象相等比较\n\n这种比较分为两大类，\n* 类型相同\n* 类型不同\n相同的就不说了,隐式转换发生在不同类型之间。规律比较复杂，规范比较长，这里也不列举了，[大家可以查看抽象相等算法](http://yanhaijing.com/es5/#104)。简单总结一句，相等比较就不想+运算那样string优先了，是以number优先级为最高。概括而言就是，都尽量转成number来进行处理，这样也可以理解，毕竟比较还是期望比较数值。那么规则大概如下：  \n对于x == y\n\n1. 如果x,y均为number，直接比较\n\n   ```js\n    没什么可解释的了\n    1 == 2 //false\n    ```\n\n2. 如果存在对象，ToPrimitive() type为number进行转换，再进行后面比较\n\n    ```js\n    var obj1 = {\n        valueOf:function(){\n            return '1'\n        }\n    }\n    1 == obj2  //true\n    //obj1转为原始值，调用obj1.valueOf()\n    //返回原始值'1'\n    //'1'toNumber得到 1 然后比较 1 == 1\n    [] == ![] //true\n    //[]作为对象ToPrimitive得到 ''  \n    //![]作为boolean转换得到0 \n    //'' == 0 \n    //转换为 0==0 //true\n    ```\n\n3. 存在boolean，按照ToNumber将boolean转换为1或者0，再进行后面比较   \n     \n   ```js\n   //boolean 先转成number，按照上面的规则得到1  \n   //3 == 1 false\n   //0 == 0 true\n   3 == true // false\n   '0' == false //true \n   ```\n\n4. 如果x为string，y为number，x转成number进行比较\n    \n    ```js\n    //'0' toNumber()得到 0  \n    //0 == 0 true\n    '0' == 0 //true \n    ```\n\n## 结束语   \n\n#### 参考文章  \n[ECMAScript5.1中文版 + ECMAScript3 + ECMAScript（合集）](http://yanhaijing.com/es5/#101)  \n[你所忽略的js隐式转换](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651227769&idx=1&sn=617160e64d2be13169b1b8f4506d8801&chksm=bd495ffd8a3ed6eb226d4ef193ff2ce3958d2d03d1f3047b635915f8215af40996c2f64d5c20&scene=21#wechat_redirect)  \n这篇文章的本意是为自己解惑，写到后面真的感觉比较乏味，毕竟规范性的东西多一点，不过深入了解一下总好过死记硬背。[原文请移步我的博客](https://github.com/xiaoxiangdaiyu/blog)。对于有些观点说这些属于js糟粕，完全不应该深入，怎么说呢，结合自己情况判断吧。本人水平有限，抛砖引玉共同学习。\n\n\n","source":"_posts/jstype.md","raw":"---\ntitle: 深入js隐式类型转换\ndate: 2018-05-23 08:00:29\ntags:\n---\n## 前言  \n相信刚开始了解js的时候，都会遇到 2 =='2',但是 1+2 == 1+'2'为false的情况，这时候应该会是一脸懵逼的状态，不得不感慨js弱类型的灵活让人发指，隐式类型转换就是这么猝不及防。结合实际中的情况来看，有意或无意中涉及到隐式类型转换的情况还是很多的。既然要用到，就需要掌握其原理，知其然重要知其所以然更重要。   \n  <!--more  -->\n## js的变量类型  \nJavaScript 是弱类型语言，意味着JavaScript 变量没有预先确定的类型。    \n并且变量的类型是其值的类型。也就是说变量当前的类型由其值所决定,夸张点说上一秒种的string，下一秒可能就是个array了。此外当进行某些操作时，变量可以进行类型转换，我们主动进行的就是显式类型转换，另一种就是隐式类型转换了。例如:\n\n```js\nvar a = '1';   \ntypeof a;//string \n\na =parseInt(a); //显示转换为number\ntypeof a  //number   \n\na == '1' //true\n```\n\n弱类型的特性在给我们带来便利的同时，也会给我们带来困扰。趋利避害，充分利用该特性的前提就是掌握类型转换的原理，下面一起看一下。  \n## js数据类型   \n老生常谈的两大类数据类型：   \n \n1. 原始类型    \n   Undefined、 Null、 String、 Number、 Boolean      \n2. 引用类型  \n   object   \n此外还有一个es6新增的Symbol，先不讨论它。对于这五类原始类型，突然提问可能想不全，没必要去死记硬背，可以想一下为否的常见变量及其对应值即可。   \n  \n| 0 | Number |\n| --: | --: |\n| '' | String |\n| false | Boolean |\n| null | Null |\n| undefined | Undefined |\n\n对于不同的数据格式转换规则是不同的，我们需要分别对待。   \n## 转换规则  \n既然是规范定义的规则，那就不要问为什么了，先大致看一下，争取记住。是在不行经常翻翻看看大佬的博客[es5规范](http://yanhaijing.com/es5/#about)。转换有下面这么几类，我们分别看一下具体规范。（这部分转换规则，完全可以跳过去，看到下面的实例再回头看应该更容易接受一些）  \n   \n* 转换为原始值  \n* 转换为数字  \n* 转换为字符串    \n\n\n### ToPrimitive(转换为原始值)   \n\nToPrimitive 运算符接受一个值，和一个可选的 期望类型 作参数。ToPrimitive 运算符把其值参数转换为非对象类型。如果对象有能力被转换为不止一种原语类型，可以使用可选的 期望类型 来暗示那个类型。根据下表完成转换  \n<img src='http://xxdy.tech/img/jstype/1.png'> \n\n这段定义看起来有点枯燥。转换为原始值，其实就是针对引用数据的，其目的是转换为非对象类型。   \n如果已经是原始类型，当然就不做处理了   \n对于object，返回对应的原始类型，该原始类型是由期望类型决定的，期望类型其实就是我们传递的type。直接看下面比较清楚。  \nToPrimitive方法大概长这么个样子具体如下。  \n\n```js\n/**\n* @obj 需要转换的对象\n* @type 期望转换为的原始数据类型，可选\n*/\nToPrimitive(obj,type)\n```\n\ntype可以为number或者string，两者的执行顺序有一些差别   \n**string:**   \n   \n1. 调用obj的toString方法，如果为原始值，则返回，否则下一步   \n2. 调用obj的valueOf方法，后续同上\n3. 抛出TypeError 异常\n \n**number:**    \n\n1. 调用obj的valueOf方法，如果为原始值，则返回，否则下一步   \n2. 调用obj的toString方法，后续同上\n3. 抛出TypeError 异常    \n\n其实就是调用方法先后，毕竟期望数据类型不同，如果是string当然优先调用toString。反之亦然。   \n当然type参数可以为空，这时候type的默认值会按照下面的规则设置    \n\n1.  该对象为Date，则type被设置为String  \n2.  否则，type被设置为Number \n\n对于Date数据类型，我们更多期望获得的是其转为时间后的字符串，而非毫秒值，如果为number，则会取到对应的毫秒值，显然字符串使用更多。\n其他类型对象按照取值的类型操作即可。  \n\n概括而言，ToPrimitive转成何种原始类型，取决于type，type参数可选，若指定，则按照指定类型转换，若不指定，默认根据实用情况分两种情况，Date为string，其余对象为number。那么什么时候会指定type类型呢，那就要看下面两种转换方式了。  \n\n### toNumber \n\n某些特定情况下需要用到ToNumber方法来转成number \n运算符根据下表将其参数转换为数值类型的值\n<img src='http://xxdy.tech/img/jstype/2.png'>    \n\n对于string类型，情况比较多，只要掌握常见的就行了。和直接调用Number(str)的结果一致，这里就不多提了，主要是太多提不完。  \n需要注意的是，这里调用ToPrimitive的时候，type就指定为number了。下面的toString则为string。\n\n### toString   \n\nToString 运算符根据下表将其参数转换为字符串类型的值：  \n其实了解也很简单，毕竟是个规范，借用大佬一张图：  \n<img src='http://xxdy.tech/img/jstype/3.png'> \n\n虽然是需要死记的东西，还是有些规律可循的。\n对于原始值：  \n  \n* Undefined，null，boolean \n  直接加上引号，例如'null' \n* number 则有比较长的规范,毕竟范围比较大  \n  常见的就是 '1'   NaN则为'NaN'  基本等同于上面一条\n  对于负数，则返回-+字符串 例如 '-2'  其他的先不考虑了。   \n* 对象则是先转为原始值，再按照上面的步骤进行处理。   \n\n### valueOf  \n\n当调用 valueOf 方法，采用如下步骤：\n\n1. 调用ToObject方法得到一个对象O\n2. 原始数据类型转换为对应的内置对象， 引用类型则不变 \n3. 调用该对象(O)内置valueOf方法.\n\n\n不同内置对象的valueOf实现：\n* String => 返回字符串值\n* Number => 返回数字值  \n* Date => 返回一个数字，即时间值,字符串中内容是依赖于具体实现的\n* Boolean => 返回Boolean的this值\n* Object => 返回this  \n\n对照代码更清晰一点    \n\n```js\nvar str = new String('123')\n//123\nconsole.log(str.valueOf())\nvar num = new Number(123)\n//123\nconsole.log(num.valueOf())\nvar date = new Date()\n//1526990889729\nconsole.log(date.valueOf())\nvar bool = new Boolean('123')\n//true\nconsole.log(bool.valueOf())\nvar obj = new Object({valueOf:()=>{\n    return 1\n}})\n//依赖于内部实现\nconsole.log(obj.valueOf())\n\n```\n\n\n## 运算隐式转换  \n前面提了那么多抽象概念，就是为了这里来理解具体转换的。   \n对于+运算来说，规则如下：  \n\n* +号左右分别进行取值，进行ToPrimitive()操作\n* 分别获取左右转换之后的值，如果存在String，则对其进行ToString处理后进行拼接操作。\n* 其他的都进行ToNumber处理\n* 在转换时ToPrimitive，除去Date为string外都按照ToPrimitive type为Number进行处理\n说的自己都迷糊了快，一起结合代码来看一下   \n \n```js\n1+'2'+false\n```\n\n1. 左边取原始值，依旧是Number\n2. 中间为String，则都进行toString操作  \n3. 左边转换按照toString的规则，返回'1'\n4. 得到结果temp值'12'\n5. 右边布尔值和temp同样进行1步骤\n6. temp为string，则布尔值也转为string'false'\n7. 拼接两者 得到最后结果 '12false'\n\n我们看一个复杂的\n\n```js\nvar obj1 = {\n    valueOf:function(){\n        return 1\n    }\n}\nvar obj2 = {\n    toString:function(){\n        return 'a'\n    }\n}\n//2\nconsole.log(1+obj1)\n//1a\nconsole.log('1'+ obj2)\n//1a\nconsole.log(obj1+obj2)\n```\n\n\n不管多复杂，按照上面的顺序来吧。  \n\n* 1+obj1      \n  1. 左边就不说了，number\n  2. 右边obj转为基础类型，按照type为number进行\n  3. 先调用valueOf() 得到结果为1\n  4. 两遍都是number，则进行相加得到2  \n* 1+obj2  \n  1. 左边为number \n  2. 右边同样按照按照type为number进行转化\n  3. 调用obj2.valueOf()得到的不是原始值\n  4. 调用toString() return 'a'\n  5. 依据第二条规则，存在string，则都转换为string进行拼接\n  6. 得到结果1a\n* obj1+obj2  \n  1. 两边都是引用，进行转换 ToPrimitive 默认type为number\n  2. obj1.valueOf()为1 直接返回\n  3. obj2.valueOf()得到的不是原始值\n  4. 调用toString() return 'a'\n  5. 依据第二条规则，存在string，则都转换为string进行拼接\n  6. 得到结果1a \n\n到这里相信大家对+这种运算的类型转换了解的差不多了。下面就看一下另一种隐式类型转换  \n\n### == 抽象相等比较\n\n这种比较分为两大类，\n* 类型相同\n* 类型不同\n相同的就不说了,隐式转换发生在不同类型之间。规律比较复杂，规范比较长，这里也不列举了，[大家可以查看抽象相等算法](http://yanhaijing.com/es5/#104)。简单总结一句，相等比较就不想+运算那样string优先了，是以number优先级为最高。概括而言就是，都尽量转成number来进行处理，这样也可以理解，毕竟比较还是期望比较数值。那么规则大概如下：  \n对于x == y\n\n1. 如果x,y均为number，直接比较\n\n   ```js\n    没什么可解释的了\n    1 == 2 //false\n    ```\n\n2. 如果存在对象，ToPrimitive() type为number进行转换，再进行后面比较\n\n    ```js\n    var obj1 = {\n        valueOf:function(){\n            return '1'\n        }\n    }\n    1 == obj2  //true\n    //obj1转为原始值，调用obj1.valueOf()\n    //返回原始值'1'\n    //'1'toNumber得到 1 然后比较 1 == 1\n    [] == ![] //true\n    //[]作为对象ToPrimitive得到 ''  \n    //![]作为boolean转换得到0 \n    //'' == 0 \n    //转换为 0==0 //true\n    ```\n\n3. 存在boolean，按照ToNumber将boolean转换为1或者0，再进行后面比较   \n     \n   ```js\n   //boolean 先转成number，按照上面的规则得到1  \n   //3 == 1 false\n   //0 == 0 true\n   3 == true // false\n   '0' == false //true \n   ```\n\n4. 如果x为string，y为number，x转成number进行比较\n    \n    ```js\n    //'0' toNumber()得到 0  \n    //0 == 0 true\n    '0' == 0 //true \n    ```\n\n## 结束语   \n\n#### 参考文章  \n[ECMAScript5.1中文版 + ECMAScript3 + ECMAScript（合集）](http://yanhaijing.com/es5/#101)  \n[你所忽略的js隐式转换](https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651227769&idx=1&sn=617160e64d2be13169b1b8f4506d8801&chksm=bd495ffd8a3ed6eb226d4ef193ff2ce3958d2d03d1f3047b635915f8215af40996c2f64d5c20&scene=21#wechat_redirect)  \n这篇文章的本意是为自己解惑，写到后面真的感觉比较乏味，毕竟规范性的东西多一点，不过深入了解一下总好过死记硬背。[原文请移步我的博客](https://github.com/xiaoxiangdaiyu/blog)。对于有些观点说这些属于js糟粕，完全不应该深入，怎么说呢，结合自己情况判断吧。本人水平有限，抛砖引玉共同学习。\n\n\n","slug":"jstype","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1s000sgw92ukx5s0lc","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>相信刚开始了解js的时候，都会遇到 2 ==’2’,但是 1+2 == 1+’2’为false的情况，这时候应该会是一脸懵逼的状态，不得不感慨js弱类型的灵活让人发指，隐式类型转换就是这么猝不及防。结合实际中的情况来看，有意或无意中涉及到隐式类型转换的情况还是很多的。既然要用到，就需要掌握其原理，知其然重要知其所以然更重要。<br>  <a id=\"more\"></a></p>\n<h2 id=\"js的变量类型\"><a href=\"#js的变量类型\" class=\"headerlink\" title=\"js的变量类型\"></a>js的变量类型</h2><p>JavaScript 是弱类型语言，意味着JavaScript 变量没有预先确定的类型。<br>并且变量的类型是其值的类型。也就是说变量当前的类型由其值所决定,夸张点说上一秒种的string，下一秒可能就是个array了。此外当进行某些操作时，变量可以进行类型转换，我们主动进行的就是显式类型转换，另一种就是隐式类型转换了。例如:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'1'</span>;   </span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a;<span class=\"comment\">//string </span></span><br><span class=\"line\"></span><br><span class=\"line\">a =<span class=\"built_in\">parseInt</span>(a); <span class=\"comment\">//显示转换为number</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a  <span class=\"comment\">//number   </span></span><br><span class=\"line\"></span><br><span class=\"line\">a == <span class=\"string\">'1'</span> <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>弱类型的特性在给我们带来便利的同时，也会给我们带来困扰。趋利避害，充分利用该特性的前提就是掌握类型转换的原理，下面一起看一下。  </p>\n<h2 id=\"js数据类型\"><a href=\"#js数据类型\" class=\"headerlink\" title=\"js数据类型\"></a>js数据类型</h2><p>老生常谈的两大类数据类型：   </p>\n<ol>\n<li>原始类型<br>Undefined、 Null、 String、 Number、 Boolean      </li>\n<li>引用类型<br>object<br>此外还有一个es6新增的Symbol，先不讨论它。对于这五类原始类型，突然提问可能想不全，没必要去死记硬背，可以想一下为否的常见变量及其对应值即可。   </li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:right\">0</th>\n<th style=\"text-align:right\">Number</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">‘’</td>\n<td style=\"text-align:right\">String</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">false</td>\n<td style=\"text-align:right\">Boolean</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">null</td>\n<td style=\"text-align:right\">Null</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">undefined</td>\n<td style=\"text-align:right\">Undefined</td>\n</tr>\n</tbody>\n</table>\n<p>对于不同的数据格式转换规则是不同的，我们需要分别对待。   </p>\n<h2 id=\"转换规则\"><a href=\"#转换规则\" class=\"headerlink\" title=\"转换规则\"></a>转换规则</h2><p>既然是规范定义的规则，那就不要问为什么了，先大致看一下，争取记住。是在不行经常翻翻看看大佬的博客<a href=\"http://yanhaijing.com/es5/#about\" target=\"_blank\" rel=\"noopener\">es5规范</a>。转换有下面这么几类，我们分别看一下具体规范。（这部分转换规则，完全可以跳过去，看到下面的实例再回头看应该更容易接受一些）  </p>\n<ul>\n<li>转换为原始值  </li>\n<li>转换为数字  </li>\n<li>转换为字符串    </li>\n</ul>\n<h3 id=\"ToPrimitive-转换为原始值\"><a href=\"#ToPrimitive-转换为原始值\" class=\"headerlink\" title=\"ToPrimitive(转换为原始值)\"></a>ToPrimitive(转换为原始值)</h3><p>ToPrimitive 运算符接受一个值，和一个可选的 期望类型 作参数。ToPrimitive 运算符把其值参数转换为非对象类型。如果对象有能力被转换为不止一种原语类型，可以使用可选的 期望类型 来暗示那个类型。根据下表完成转换<br><img src=\"http://xxdy.tech/img/jstype/1.png\"> </p>\n<p>这段定义看起来有点枯燥。转换为原始值，其实就是针对引用数据的，其目的是转换为非对象类型。<br>如果已经是原始类型，当然就不做处理了<br>对于object，返回对应的原始类型，该原始类型是由期望类型决定的，期望类型其实就是我们传递的type。直接看下面比较清楚。<br>ToPrimitive方法大概长这么个样子具体如下。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* @obj 需要转换的对象</span></span><br><span class=\"line\"><span class=\"comment\">* @type 期望转换为的原始数据类型，可选</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">ToPrimitive(obj,type)</span><br></pre></td></tr></table></figure>\n<p>type可以为number或者string，两者的执行顺序有一些差别<br><strong>string:</strong>   </p>\n<ol>\n<li>调用obj的toString方法，如果为原始值，则返回，否则下一步   </li>\n<li>调用obj的valueOf方法，后续同上</li>\n<li>抛出TypeError 异常</li>\n</ol>\n<p><strong>number:</strong>    </p>\n<ol>\n<li>调用obj的valueOf方法，如果为原始值，则返回，否则下一步   </li>\n<li>调用obj的toString方法，后续同上</li>\n<li>抛出TypeError 异常    </li>\n</ol>\n<p>其实就是调用方法先后，毕竟期望数据类型不同，如果是string当然优先调用toString。反之亦然。<br>当然type参数可以为空，这时候type的默认值会按照下面的规则设置    </p>\n<ol>\n<li>该对象为Date，则type被设置为String  </li>\n<li>否则，type被设置为Number </li>\n</ol>\n<p>对于Date数据类型，我们更多期望获得的是其转为时间后的字符串，而非毫秒值，如果为number，则会取到对应的毫秒值，显然字符串使用更多。<br>其他类型对象按照取值的类型操作即可。  </p>\n<p>概括而言，ToPrimitive转成何种原始类型，取决于type，type参数可选，若指定，则按照指定类型转换，若不指定，默认根据实用情况分两种情况，Date为string，其余对象为number。那么什么时候会指定type类型呢，那就要看下面两种转换方式了。  </p>\n<h3 id=\"toNumber\"><a href=\"#toNumber\" class=\"headerlink\" title=\"toNumber\"></a>toNumber</h3><p>某些特定情况下需要用到ToNumber方法来转成number<br>运算符根据下表将其参数转换为数值类型的值<br><img src=\"http://xxdy.tech/img/jstype/2.png\">    </p>\n<p>对于string类型，情况比较多，只要掌握常见的就行了。和直接调用Number(str)的结果一致，这里就不多提了，主要是太多提不完。<br>需要注意的是，这里调用ToPrimitive的时候，type就指定为number了。下面的toString则为string。</p>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h3><p>ToString 运算符根据下表将其参数转换为字符串类型的值：<br>其实了解也很简单，毕竟是个规范，借用大佬一张图：<br><img src=\"http://xxdy.tech/img/jstype/3.png\"> </p>\n<p>虽然是需要死记的东西，还是有些规律可循的。<br>对于原始值：  </p>\n<ul>\n<li>Undefined，null，boolean<br>直接加上引号，例如’null’ </li>\n<li>number 则有比较长的规范,毕竟范围比较大<br>常见的就是 ‘1’   NaN则为’NaN’  基本等同于上面一条<br>对于负数，则返回-+字符串 例如 ‘-2’  其他的先不考虑了。   </li>\n<li>对象则是先转为原始值，再按照上面的步骤进行处理。   </li>\n</ul>\n<h3 id=\"valueOf-NaN\"><a href=\"#valueOf-NaN\" class=\"headerlink\" title=\"valueOf\"></a>valueOf</h3><p>当调用 valueOf 方法，采用如下步骤：</p>\n<ol>\n<li>调用ToObject方法得到一个对象O</li>\n<li>原始数据类型转换为对应的内置对象， 引用类型则不变 </li>\n<li>调用该对象(O)内置valueOf方法.</li>\n</ol>\n<p>不同内置对象的valueOf实现：</p>\n<ul>\n<li>String =&gt; 返回字符串值</li>\n<li>Number =&gt; 返回数字值  </li>\n<li>Date =&gt; 返回一个数字，即时间值,字符串中内容是依赖于具体实现的</li>\n<li>Boolean =&gt; 返回Boolean的this值</li>\n<li>Object =&gt; 返回this  </li>\n</ul>\n<p>对照代码更清晰一点    </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'123'</span>)</span><br><span class=\"line\"><span class=\"comment\">//123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.valueOf())</span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">123</span>)</span><br><span class=\"line\"><span class=\"comment\">//123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.valueOf())</span><br><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\"><span class=\"comment\">//1526990889729</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(date.valueOf())</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"string\">'123'</span>)</span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool.valueOf())</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(&#123;<span class=\"attr\">valueOf</span>:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;&#125;)</span><br><span class=\"line\"><span class=\"comment\">//依赖于内部实现</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.valueOf())</span><br></pre></td></tr></table></figure>\n<h2 id=\"运算隐式转换\"><a href=\"#运算隐式转换\" class=\"headerlink\" title=\"运算隐式转换\"></a>运算隐式转换</h2><p>前面提了那么多抽象概念，就是为了这里来理解具体转换的。<br>对于+运算来说，规则如下：  </p>\n<ul>\n<li>+号左右分别进行取值，进行ToPrimitive()操作</li>\n<li>分别获取左右转换之后的值，如果存在String，则对其进行ToString处理后进行拼接操作。</li>\n<li>其他的都进行ToNumber处理</li>\n<li>在转换时ToPrimitive，除去Date为string外都按照ToPrimitive type为Number进行处理<br>说的自己都迷糊了快，一起结合代码来看一下   </li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>+<span class=\"string\">'2'</span>+<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>左边取原始值，依旧是Number</li>\n<li>中间为String，则都进行toString操作  </li>\n<li>左边转换按照toString的规则，返回’1’</li>\n<li>得到结果temp值’12’</li>\n<li>右边布尔值和temp同样进行1步骤</li>\n<li>temp为string，则布尔值也转为string’false’</li>\n<li>拼接两者 得到最后结果 ‘12false’</li>\n</ol>\n<p>我们看一个复杂的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    valueOf:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    toString:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'a'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>+obj1)</span><br><span class=\"line\"><span class=\"comment\">//1a</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>+ obj2)</span><br><span class=\"line\"><span class=\"comment\">//1a</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1+obj2)</span><br></pre></td></tr></table></figure>\n<p>不管多复杂，按照上面的顺序来吧。  </p>\n<ul>\n<li>1+obj1      <ol>\n<li>左边就不说了，number</li>\n<li>右边obj转为基础类型，按照type为number进行</li>\n<li>先调用valueOf() 得到结果为1</li>\n<li>两遍都是number，则进行相加得到2  </li>\n</ol>\n</li>\n<li>1+obj2  <ol>\n<li>左边为number </li>\n<li>右边同样按照按照type为number进行转化</li>\n<li>调用obj2.valueOf()得到的不是原始值</li>\n<li>调用toString() return ‘a’</li>\n<li>依据第二条规则，存在string，则都转换为string进行拼接</li>\n<li>得到结果1a</li>\n</ol>\n</li>\n<li>obj1+obj2  <ol>\n<li>两边都是引用，进行转换 ToPrimitive 默认type为number</li>\n<li>obj1.valueOf()为1 直接返回</li>\n<li>obj2.valueOf()得到的不是原始值</li>\n<li>调用toString() return ‘a’</li>\n<li>依据第二条规则，存在string，则都转换为string进行拼接</li>\n<li>得到结果1a </li>\n</ol>\n</li>\n</ul>\n<p>到这里相信大家对+这种运算的类型转换了解的差不多了。下面就看一下另一种隐式类型转换  </p>\n<h3 id=\"抽象相等比较\"><a href=\"#抽象相等比较\" class=\"headerlink\" title=\"== 抽象相等比较\"></a>== 抽象相等比较</h3><p>这种比较分为两大类，</p>\n<ul>\n<li>类型相同</li>\n<li>类型不同<br>相同的就不说了,隐式转换发生在不同类型之间。规律比较复杂，规范比较长，这里也不列举了，<a href=\"http://yanhaijing.com/es5/#104\" target=\"_blank\" rel=\"noopener\">大家可以查看抽象相等算法</a>。简单总结一句，相等比较就不想+运算那样string优先了，是以number优先级为最高。概括而言就是，都尽量转成number来进行处理，这样也可以理解，毕竟比较还是期望比较数值。那么规则大概如下：<br>对于x == y</li>\n</ul>\n<ol>\n<li><p>如果x,y均为number，直接比较</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">没什么可解释的了</span><br><span class=\"line\"><span class=\"number\">1</span> == <span class=\"number\">2</span> <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果存在对象，ToPrimitive() type为number进行转换，再进行后面比较</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    valueOf:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'1'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1</span> == obj2  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//obj1转为原始值，调用obj1.valueOf()</span></span><br><span class=\"line\"><span class=\"comment\">//返回原始值'1'</span></span><br><span class=\"line\"><span class=\"comment\">//'1'toNumber得到 1 然后比较 1 == 1</span></span><br><span class=\"line\">[] == ![] <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//[]作为对象ToPrimitive得到 ''  </span></span><br><span class=\"line\"><span class=\"comment\">//![]作为boolean转换得到0 </span></span><br><span class=\"line\"><span class=\"comment\">//'' == 0 </span></span><br><span class=\"line\"><span class=\"comment\">//转换为 0==0 //true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>存在boolean，按照ToNumber将boolean转换为1或者0，再进行后面比较   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//boolean 先转成number，按照上面的规则得到1  </span></span><br><span class=\"line\"><span class=\"comment\">//3 == 1 false</span></span><br><span class=\"line\"><span class=\"comment\">//0 == 0 true</span></span><br><span class=\"line\"><span class=\"number\">3</span> == <span class=\"literal\">true</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"string\">'0'</span> == <span class=\"literal\">false</span> <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果x为string，y为number，x转成number进行比较</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//'0' toNumber()得到 0  </span></span><br><span class=\"line\"><span class=\"comment\">//0 == 0 true</span></span><br><span class=\"line\"><span class=\"string\">'0'</span> == <span class=\"number\">0</span> <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://yanhaijing.com/es5/#101\" target=\"_blank\" rel=\"noopener\">ECMAScript5.1中文版 + ECMAScript3 + ECMAScript（合集）</a><br><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227769&amp;idx=1&amp;sn=617160e64d2be13169b1b8f4506d8801&amp;chksm=bd495ffd8a3ed6eb226d4ef193ff2ce3958d2d03d1f3047b635915f8215af40996c2f64d5c20&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">你所忽略的js隐式转换</a><br>这篇文章的本意是为自己解惑，写到后面真的感觉比较乏味，毕竟规范性的东西多一点，不过深入了解一下总好过死记硬背。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">原文请移步我的博客</a>。对于有些观点说这些属于js糟粕，完全不应该深入，怎么说呢，结合自己情况判断吧。本人水平有限，抛砖引玉共同学习。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>相信刚开始了解js的时候，都会遇到 2 ==’2’,但是 1+2 == 1+’2’为false的情况，这时候应该会是一脸懵逼的状态，不得不感慨js弱类型的灵活让人发指，隐式类型转换就是这么猝不及防。结合实际中的情况来看，有意或无意中涉及到隐式类型转换的情况还是很多的。既然要用到，就需要掌握其原理，知其然重要知其所以然更重要。<br>","more":"</p>\n<h2 id=\"js的变量类型\"><a href=\"#js的变量类型\" class=\"headerlink\" title=\"js的变量类型\"></a>js的变量类型</h2><p>JavaScript 是弱类型语言，意味着JavaScript 变量没有预先确定的类型。<br>并且变量的类型是其值的类型。也就是说变量当前的类型由其值所决定,夸张点说上一秒种的string，下一秒可能就是个array了。此外当进行某些操作时，变量可以进行类型转换，我们主动进行的就是显式类型转换，另一种就是隐式类型转换了。例如:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'1'</span>;   </span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a;<span class=\"comment\">//string </span></span><br><span class=\"line\"></span><br><span class=\"line\">a =<span class=\"built_in\">parseInt</span>(a); <span class=\"comment\">//显示转换为number</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a  <span class=\"comment\">//number   </span></span><br><span class=\"line\"></span><br><span class=\"line\">a == <span class=\"string\">'1'</span> <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>弱类型的特性在给我们带来便利的同时，也会给我们带来困扰。趋利避害，充分利用该特性的前提就是掌握类型转换的原理，下面一起看一下。  </p>\n<h2 id=\"js数据类型\"><a href=\"#js数据类型\" class=\"headerlink\" title=\"js数据类型\"></a>js数据类型</h2><p>老生常谈的两大类数据类型：   </p>\n<ol>\n<li>原始类型<br>Undefined、 Null、 String、 Number、 Boolean      </li>\n<li>引用类型<br>object<br>此外还有一个es6新增的Symbol，先不讨论它。对于这五类原始类型，突然提问可能想不全，没必要去死记硬背，可以想一下为否的常见变量及其对应值即可。   </li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:right\">0</th>\n<th style=\"text-align:right\">Number</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:right\">‘’</td>\n<td style=\"text-align:right\">String</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">false</td>\n<td style=\"text-align:right\">Boolean</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">null</td>\n<td style=\"text-align:right\">Null</td>\n</tr>\n<tr>\n<td style=\"text-align:right\">undefined</td>\n<td style=\"text-align:right\">Undefined</td>\n</tr>\n</tbody>\n</table>\n<p>对于不同的数据格式转换规则是不同的，我们需要分别对待。   </p>\n<h2 id=\"转换规则\"><a href=\"#转换规则\" class=\"headerlink\" title=\"转换规则\"></a>转换规则</h2><p>既然是规范定义的规则，那就不要问为什么了，先大致看一下，争取记住。是在不行经常翻翻看看大佬的博客<a href=\"http://yanhaijing.com/es5/#about\" target=\"_blank\" rel=\"noopener\">es5规范</a>。转换有下面这么几类，我们分别看一下具体规范。（这部分转换规则，完全可以跳过去，看到下面的实例再回头看应该更容易接受一些）  </p>\n<ul>\n<li>转换为原始值  </li>\n<li>转换为数字  </li>\n<li>转换为字符串    </li>\n</ul>\n<h3 id=\"ToPrimitive-转换为原始值\"><a href=\"#ToPrimitive-转换为原始值\" class=\"headerlink\" title=\"ToPrimitive(转换为原始值)\"></a>ToPrimitive(转换为原始值)</h3><p>ToPrimitive 运算符接受一个值，和一个可选的 期望类型 作参数。ToPrimitive 运算符把其值参数转换为非对象类型。如果对象有能力被转换为不止一种原语类型，可以使用可选的 期望类型 来暗示那个类型。根据下表完成转换<br><img src=\"http://xxdy.tech/img/jstype/1.png\"> </p>\n<p>这段定义看起来有点枯燥。转换为原始值，其实就是针对引用数据的，其目的是转换为非对象类型。<br>如果已经是原始类型，当然就不做处理了<br>对于object，返回对应的原始类型，该原始类型是由期望类型决定的，期望类型其实就是我们传递的type。直接看下面比较清楚。<br>ToPrimitive方法大概长这么个样子具体如下。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* @obj 需要转换的对象</span></span><br><span class=\"line\"><span class=\"comment\">* @type 期望转换为的原始数据类型，可选</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">ToPrimitive(obj,type)</span><br></pre></td></tr></table></figure>\n<p>type可以为number或者string，两者的执行顺序有一些差别<br><strong>string:</strong>   </p>\n<ol>\n<li>调用obj的toString方法，如果为原始值，则返回，否则下一步   </li>\n<li>调用obj的valueOf方法，后续同上</li>\n<li>抛出TypeError 异常</li>\n</ol>\n<p><strong>number:</strong>    </p>\n<ol>\n<li>调用obj的valueOf方法，如果为原始值，则返回，否则下一步   </li>\n<li>调用obj的toString方法，后续同上</li>\n<li>抛出TypeError 异常    </li>\n</ol>\n<p>其实就是调用方法先后，毕竟期望数据类型不同，如果是string当然优先调用toString。反之亦然。<br>当然type参数可以为空，这时候type的默认值会按照下面的规则设置    </p>\n<ol>\n<li>该对象为Date，则type被设置为String  </li>\n<li>否则，type被设置为Number </li>\n</ol>\n<p>对于Date数据类型，我们更多期望获得的是其转为时间后的字符串，而非毫秒值，如果为number，则会取到对应的毫秒值，显然字符串使用更多。<br>其他类型对象按照取值的类型操作即可。  </p>\n<p>概括而言，ToPrimitive转成何种原始类型，取决于type，type参数可选，若指定，则按照指定类型转换，若不指定，默认根据实用情况分两种情况，Date为string，其余对象为number。那么什么时候会指定type类型呢，那就要看下面两种转换方式了。  </p>\n<h3 id=\"toNumber\"><a href=\"#toNumber\" class=\"headerlink\" title=\"toNumber\"></a>toNumber</h3><p>某些特定情况下需要用到ToNumber方法来转成number<br>运算符根据下表将其参数转换为数值类型的值<br><img src=\"http://xxdy.tech/img/jstype/2.png\">    </p>\n<p>对于string类型，情况比较多，只要掌握常见的就行了。和直接调用Number(str)的结果一致，这里就不多提了，主要是太多提不完。<br>需要注意的是，这里调用ToPrimitive的时候，type就指定为number了。下面的toString则为string。</p>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString\"></a>toString</h3><p>ToString 运算符根据下表将其参数转换为字符串类型的值：<br>其实了解也很简单，毕竟是个规范，借用大佬一张图：<br><img src=\"http://xxdy.tech/img/jstype/3.png\"> </p>\n<p>虽然是需要死记的东西，还是有些规律可循的。<br>对于原始值：  </p>\n<ul>\n<li>Undefined，null，boolean<br>直接加上引号，例如’null’ </li>\n<li>number 则有比较长的规范,毕竟范围比较大<br>常见的就是 ‘1’   NaN则为’NaN’  基本等同于上面一条<br>对于负数，则返回-+字符串 例如 ‘-2’  其他的先不考虑了。   </li>\n<li>对象则是先转为原始值，再按照上面的步骤进行处理。   </li>\n</ul>\n<h3 id=\"valueOf-NaN\"><a href=\"#valueOf-NaN\" class=\"headerlink\" title=\"valueOf\"></a>valueOf</h3><p>当调用 valueOf 方法，采用如下步骤：</p>\n<ol>\n<li>调用ToObject方法得到一个对象O</li>\n<li>原始数据类型转换为对应的内置对象， 引用类型则不变 </li>\n<li>调用该对象(O)内置valueOf方法.</li>\n</ol>\n<p>不同内置对象的valueOf实现：</p>\n<ul>\n<li>String =&gt; 返回字符串值</li>\n<li>Number =&gt; 返回数字值  </li>\n<li>Date =&gt; 返回一个数字，即时间值,字符串中内容是依赖于具体实现的</li>\n<li>Boolean =&gt; 返回Boolean的this值</li>\n<li>Object =&gt; 返回this  </li>\n</ul>\n<p>对照代码更清晰一点    </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> str = <span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(<span class=\"string\">'123'</span>)</span><br><span class=\"line\"><span class=\"comment\">//123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(str.valueOf())</span><br><span class=\"line\"><span class=\"keyword\">var</span> num = <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">123</span>)</span><br><span class=\"line\"><span class=\"comment\">//123</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(num.valueOf())</span><br><span class=\"line\"><span class=\"keyword\">var</span> date = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\"><span class=\"comment\">//1526990889729</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(date.valueOf())</span><br><span class=\"line\"><span class=\"keyword\">var</span> bool = <span class=\"keyword\">new</span> <span class=\"built_in\">Boolean</span>(<span class=\"string\">'123'</span>)</span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bool.valueOf())</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>(&#123;<span class=\"attr\">valueOf</span>:<span class=\"function\"><span class=\"params\">()</span>=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">&#125;&#125;)</span><br><span class=\"line\"><span class=\"comment\">//依赖于内部实现</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.valueOf())</span><br></pre></td></tr></table></figure>\n<h2 id=\"运算隐式转换\"><a href=\"#运算隐式转换\" class=\"headerlink\" title=\"运算隐式转换\"></a>运算隐式转换</h2><p>前面提了那么多抽象概念，就是为了这里来理解具体转换的。<br>对于+运算来说，规则如下：  </p>\n<ul>\n<li>+号左右分别进行取值，进行ToPrimitive()操作</li>\n<li>分别获取左右转换之后的值，如果存在String，则对其进行ToString处理后进行拼接操作。</li>\n<li>其他的都进行ToNumber处理</li>\n<li>在转换时ToPrimitive，除去Date为string外都按照ToPrimitive type为Number进行处理<br>说的自己都迷糊了快，一起结合代码来看一下   </li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>+<span class=\"string\">'2'</span>+<span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>左边取原始值，依旧是Number</li>\n<li>中间为String，则都进行toString操作  </li>\n<li>左边转换按照toString的规则，返回’1’</li>\n<li>得到结果temp值’12’</li>\n<li>右边布尔值和temp同样进行1步骤</li>\n<li>temp为string，则布尔值也转为string’false’</li>\n<li>拼接两者 得到最后结果 ‘12false’</li>\n</ol>\n<p>我们看一个复杂的</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    valueOf:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">    toString:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'a'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>+obj1)</span><br><span class=\"line\"><span class=\"comment\">//1a</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>+ obj2)</span><br><span class=\"line\"><span class=\"comment\">//1a</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj1+obj2)</span><br></pre></td></tr></table></figure>\n<p>不管多复杂，按照上面的顺序来吧。  </p>\n<ul>\n<li>1+obj1      <ol>\n<li>左边就不说了，number</li>\n<li>右边obj转为基础类型，按照type为number进行</li>\n<li>先调用valueOf() 得到结果为1</li>\n<li>两遍都是number，则进行相加得到2  </li>\n</ol>\n</li>\n<li>1+obj2  <ol>\n<li>左边为number </li>\n<li>右边同样按照按照type为number进行转化</li>\n<li>调用obj2.valueOf()得到的不是原始值</li>\n<li>调用toString() return ‘a’</li>\n<li>依据第二条规则，存在string，则都转换为string进行拼接</li>\n<li>得到结果1a</li>\n</ol>\n</li>\n<li>obj1+obj2  <ol>\n<li>两边都是引用，进行转换 ToPrimitive 默认type为number</li>\n<li>obj1.valueOf()为1 直接返回</li>\n<li>obj2.valueOf()得到的不是原始值</li>\n<li>调用toString() return ‘a’</li>\n<li>依据第二条规则，存在string，则都转换为string进行拼接</li>\n<li>得到结果1a </li>\n</ol>\n</li>\n</ul>\n<p>到这里相信大家对+这种运算的类型转换了解的差不多了。下面就看一下另一种隐式类型转换  </p>\n<h3 id=\"抽象相等比较\"><a href=\"#抽象相等比较\" class=\"headerlink\" title=\"== 抽象相等比较\"></a>== 抽象相等比较</h3><p>这种比较分为两大类，</p>\n<ul>\n<li>类型相同</li>\n<li>类型不同<br>相同的就不说了,隐式转换发生在不同类型之间。规律比较复杂，规范比较长，这里也不列举了，<a href=\"http://yanhaijing.com/es5/#104\" target=\"_blank\" rel=\"noopener\">大家可以查看抽象相等算法</a>。简单总结一句，相等比较就不想+运算那样string优先了，是以number优先级为最高。概括而言就是，都尽量转成number来进行处理，这样也可以理解，毕竟比较还是期望比较数值。那么规则大概如下：<br>对于x == y</li>\n</ul>\n<ol>\n<li><p>如果x,y均为number，直接比较</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">没什么可解释的了</span><br><span class=\"line\"><span class=\"number\">1</span> == <span class=\"number\">2</span> <span class=\"comment\">//false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果存在对象，ToPrimitive() type为number进行转换，再进行后面比较</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">    valueOf:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'1'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1</span> == obj2  <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//obj1转为原始值，调用obj1.valueOf()</span></span><br><span class=\"line\"><span class=\"comment\">//返回原始值'1'</span></span><br><span class=\"line\"><span class=\"comment\">//'1'toNumber得到 1 然后比较 1 == 1</span></span><br><span class=\"line\">[] == ![] <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"comment\">//[]作为对象ToPrimitive得到 ''  </span></span><br><span class=\"line\"><span class=\"comment\">//![]作为boolean转换得到0 </span></span><br><span class=\"line\"><span class=\"comment\">//'' == 0 </span></span><br><span class=\"line\"><span class=\"comment\">//转换为 0==0 //true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>存在boolean，按照ToNumber将boolean转换为1或者0，再进行后面比较   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//boolean 先转成number，按照上面的规则得到1  </span></span><br><span class=\"line\"><span class=\"comment\">//3 == 1 false</span></span><br><span class=\"line\"><span class=\"comment\">//0 == 0 true</span></span><br><span class=\"line\"><span class=\"number\">3</span> == <span class=\"literal\">true</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"string\">'0'</span> == <span class=\"literal\">false</span> <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果x为string，y为number，x转成number进行比较</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//'0' toNumber()得到 0  </span></span><br><span class=\"line\"><span class=\"comment\">//0 == 0 true</span></span><br><span class=\"line\"><span class=\"string\">'0'</span> == <span class=\"number\">0</span> <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://yanhaijing.com/es5/#101\" target=\"_blank\" rel=\"noopener\">ECMAScript5.1中文版 + ECMAScript3 + ECMAScript（合集）</a><br><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651227769&amp;idx=1&amp;sn=617160e64d2be13169b1b8f4506d8801&amp;chksm=bd495ffd8a3ed6eb226d4ef193ff2ce3958d2d03d1f3047b635915f8215af40996c2f64d5c20&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">你所忽略的js隐式转换</a><br>这篇文章的本意是为自己解惑，写到后面真的感觉比较乏味，毕竟规范性的东西多一点，不过深入了解一下总好过死记硬背。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">原文请移步我的博客</a>。对于有些观点说这些属于js糟粕，完全不应该深入，怎么说呢，结合自己情况判断吧。本人水平有限，抛砖引玉共同学习。</p>"},{"title":"前端数据范式化","date":"2019-02-17T16:00:00.000Z","_content":"  \n# 前端数据范式化\n## 前言\n\n现代web应用的飞速发展，特别是数据驱动思想指导下的React、vue等框架的出现，让我们越来越需要关注数据的组织管理。随着应用复杂度的提升，如果不对数据进行有效合理的设计拆分，那么从性能、可维护性等方面来看会逐渐成为一种阻碍。所以我们需要关注前端数据设计。  \n<!-- more -->\n其实没有一种很明确的规范告诉我们具体到前端的数据结构应该如何去设计。关系数据库设计有很多范式，借鉴而不照搬结合前端自身特点，才是好的前端数据范式化的实践。  \n\n## 范式化\n在深入了解数据范式化之前，我们可以先看个例子\n### 举个栗子：  \n实际业务中，迭代比较多的业务，我们一般会配置化，即除了业务数据之外将页面布局展示相关的内容也由接口控制。 \n那么后端返回的数据可能如下： \n\n```js\n{\n    info: [\n        {\n            key:'a',\n            txt:'展示1',\n            value:0\n        },\n        {\n            key:'b',\n            txt:'展示2',\n            value:1\n        }\n    ]\n}\n```\n\n这样响应操作的时候，需要更新每一项的值如果直接修改info这个数组，存在着很大的不便。  \n如果你说还好，但这样将就操作之后，提交的时候发现这一大串冗余数据后端也不需要呀，还是要处理value。   \n此时的数据还不是那么的复杂，不过层层嵌套的对象见过吧，让人心头一惊的数据格式，如果还在上面操作，可能下个迭代你自己都不知道到底该操作哪个字段了。\n \n这时候如果将展示和逻辑相分离，抽出来一个专门的属性用来存放与后端交互的数据，看起来是简洁了一些，后期可维护性也增强了不少。\n\n```js\n{\n    info: [\n        {\n            key:'a',\n            txt:'展示1'\n        },\n        {\n            key:'b',\n            txt:'展示2'\n        }\n    ],\n    values:{\n        a:0,\n        b:1\n    }\n}\n```\n\n这样其实就可以认为是我们提到范式化或者说是扁平化了。具体到前端数据范式化之前  我们来看看数据库的范式吧  \n\n### 具体到前端数据范式化之前  我们来看看数据库的范式吧  \n \n**什么是范式：**  \n顾名思义，一个规范模式(虽然有点粗暴，但好像就是这么回事)。\n本来想找段定义贴在下面，不过看了看太生硬了，写下个人见解好了。  \n\n**第一范式 1NF**\n表的列具有原子性，不可再分解。\n只要是关系型数据库就满足1NF  \n\n**第二范式 2NF**\n前提是满足1NF，在1NF的基础上。每一行或者实例必须唯一可以被区分，即需要我们说的主键(key)。  \n\n**第三范式 3NF**\n满足1NF和2NF，且一个数据库表中不包含已在其他表中包含的非主键字段。   \n也就是说表中不冗余，可以通过关系从其他表中获取就不要单独存放了，也就是相关信息可以通过外键相关联。 有个图表达的很不错，借来一用：  \n<img src='https://p1.meituan.net/dpnewvc/79de24890fe932435cb6ee08a1da03df503526.png'/>\n\n当然后面还有其他范式这里就先不提了。  \n\n总结一下，范式就是为了减少冗余，提高效率\n遵循的范式越高，冗余越小，但也要具体分析，不可一味追求符合范式。\n有些时候一昧的追求范式减少冗余，反而会降低数据读写的效率，这个时候就要反范式，利用空间来换时间。  \n  \n### redux中的state设计要求\n\nredux针对state的设计也提出了范式化的要求，对于复杂的数据结构，除了数据重复之外，还可能有下面这些问题:    \n\n*  当数据在多处冗余后，需要更新时，很难保证所有的数据都进行更新。\n*  嵌套的数据意味着 reducer 逻辑嵌套更多、复杂度更高。尤其是在打算更新深层嵌套数据时。  \n*  不可变的数据在更新时需要状态树的祖先数据进行复制和更新，并且新的对象引用会导致与之 connect 的所有 UI 组件都重复 render。尽管要显示的数据没有发生任何改变，对深层嵌套的数据对象进行更新也会强制完全无关的 UI 组件重复 render  \n\n\n所以，在 Redux Store 中管理关系数据或嵌套数据的推荐做法是将这一部分视为数据库，并且将数据按范式化存储。\n有这么几点概念：  \n  \n*  任何类型的数据在 state 中都有自己的 “表”。\n*  任何 “数据表” 应将各个项目存储在对象中，其中每个项目的 ID 作为 key，项目本身作为 value。\n*  任何对单个项目的引用都应该根据存储项目的 ID 来完成。\n*  ID 数组应该用于排序。   \n\n\n### 具体实践-Normalizr \n\n这里就需要提到[Normalizr](https://github.com/paularmstrong/normalizr)了，对于复杂数据管理，基本都会提到它。其作用很直白的通过其简介体现出来：Normalizes nested JSON according to a schema。依据模式规范化的处理json。   \n其用法这里就不介绍了，只提供下转换前后的数据做个对比。有兴趣的大家去官网一看便知。  \n\n**原始数据:**  \n\n```js\n{\n  \"id\": \"123\",\n  \"author\": {\n    \"id\": \"1\",\n    \"name\": \"Paul\"\n  },\n  \"title\": \"My awesome blog post\",\n  \"comments\": [\n    {\n      \"id\": \"324\",\n      \"commenter\": {\n        \"id\": \"2\",\n        \"name\": \"Nicole\"\n      }\n    }\n  ]\n}\n```  \n**转换后**  \n\n```js\n{\n  result: \"123\",\n  entities: {\n    \"articles\": {\n      \"123\": {\n        id: \"123\",\n        author: \"1\",\n        title: \"My awesome blog post\",\n        comments: [ \"324\" ]\n      }\n    },\n    \"users\": {\n      \"1\": { \"id\": \"1\", \"name\": \"Paul\" },\n      \"2\": { \"id\": \"2\", \"name\": \"Nicole\" }\n    },\n    \"comments\": {\n      \"324\": { id: \"324\", \"commenter\": \"2\" }\n    }\n  }\n}\n```\n这样的数据就比较符合我们前面redux设计要求了。\n  \n## 结束语  \n到这里前端数据的范式化也就介绍的差不多了，一个感悟是js中的数据结构设计何尝不是数据库设计，去遵循相应的范式会让我们的数据结构更加清晰明了。就算开始没考虑到，随着业务量级的上升原本结构遇到的问题，开发的时候自然也会去往更优雅的方向去靠，这就是进步的过程。  \n通篇文章为个人见解，抛砖引玉有不对的地方欢迎指出\n\n### 参考文章:  \n[https://blog.csdn.net/qq_35401191/article/details/82760301](https://blog.csdn.net/qq_35401191/article/details/82760301)   \n[https://zhuanlan.zhihu.com/p/36487766](https://zhuanlan.zhihu.com/p/36487766)   \n[http://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html](http://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html)\n\n\n\n\n\n","source":"_posts/normalize.md","raw":"---\ntitle: 前端数据范式化\ndate: 2019-02-18\n---\n  \n# 前端数据范式化\n## 前言\n\n现代web应用的飞速发展，特别是数据驱动思想指导下的React、vue等框架的出现，让我们越来越需要关注数据的组织管理。随着应用复杂度的提升，如果不对数据进行有效合理的设计拆分，那么从性能、可维护性等方面来看会逐渐成为一种阻碍。所以我们需要关注前端数据设计。  \n<!-- more -->\n其实没有一种很明确的规范告诉我们具体到前端的数据结构应该如何去设计。关系数据库设计有很多范式，借鉴而不照搬结合前端自身特点，才是好的前端数据范式化的实践。  \n\n## 范式化\n在深入了解数据范式化之前，我们可以先看个例子\n### 举个栗子：  \n实际业务中，迭代比较多的业务，我们一般会配置化，即除了业务数据之外将页面布局展示相关的内容也由接口控制。 \n那么后端返回的数据可能如下： \n\n```js\n{\n    info: [\n        {\n            key:'a',\n            txt:'展示1',\n            value:0\n        },\n        {\n            key:'b',\n            txt:'展示2',\n            value:1\n        }\n    ]\n}\n```\n\n这样响应操作的时候，需要更新每一项的值如果直接修改info这个数组，存在着很大的不便。  \n如果你说还好，但这样将就操作之后，提交的时候发现这一大串冗余数据后端也不需要呀，还是要处理value。   \n此时的数据还不是那么的复杂，不过层层嵌套的对象见过吧，让人心头一惊的数据格式，如果还在上面操作，可能下个迭代你自己都不知道到底该操作哪个字段了。\n \n这时候如果将展示和逻辑相分离，抽出来一个专门的属性用来存放与后端交互的数据，看起来是简洁了一些，后期可维护性也增强了不少。\n\n```js\n{\n    info: [\n        {\n            key:'a',\n            txt:'展示1'\n        },\n        {\n            key:'b',\n            txt:'展示2'\n        }\n    ],\n    values:{\n        a:0,\n        b:1\n    }\n}\n```\n\n这样其实就可以认为是我们提到范式化或者说是扁平化了。具体到前端数据范式化之前  我们来看看数据库的范式吧  \n\n### 具体到前端数据范式化之前  我们来看看数据库的范式吧  \n \n**什么是范式：**  \n顾名思义，一个规范模式(虽然有点粗暴，但好像就是这么回事)。\n本来想找段定义贴在下面，不过看了看太生硬了，写下个人见解好了。  \n\n**第一范式 1NF**\n表的列具有原子性，不可再分解。\n只要是关系型数据库就满足1NF  \n\n**第二范式 2NF**\n前提是满足1NF，在1NF的基础上。每一行或者实例必须唯一可以被区分，即需要我们说的主键(key)。  \n\n**第三范式 3NF**\n满足1NF和2NF，且一个数据库表中不包含已在其他表中包含的非主键字段。   \n也就是说表中不冗余，可以通过关系从其他表中获取就不要单独存放了，也就是相关信息可以通过外键相关联。 有个图表达的很不错，借来一用：  \n<img src='https://p1.meituan.net/dpnewvc/79de24890fe932435cb6ee08a1da03df503526.png'/>\n\n当然后面还有其他范式这里就先不提了。  \n\n总结一下，范式就是为了减少冗余，提高效率\n遵循的范式越高，冗余越小，但也要具体分析，不可一味追求符合范式。\n有些时候一昧的追求范式减少冗余，反而会降低数据读写的效率，这个时候就要反范式，利用空间来换时间。  \n  \n### redux中的state设计要求\n\nredux针对state的设计也提出了范式化的要求，对于复杂的数据结构，除了数据重复之外，还可能有下面这些问题:    \n\n*  当数据在多处冗余后，需要更新时，很难保证所有的数据都进行更新。\n*  嵌套的数据意味着 reducer 逻辑嵌套更多、复杂度更高。尤其是在打算更新深层嵌套数据时。  \n*  不可变的数据在更新时需要状态树的祖先数据进行复制和更新，并且新的对象引用会导致与之 connect 的所有 UI 组件都重复 render。尽管要显示的数据没有发生任何改变，对深层嵌套的数据对象进行更新也会强制完全无关的 UI 组件重复 render  \n\n\n所以，在 Redux Store 中管理关系数据或嵌套数据的推荐做法是将这一部分视为数据库，并且将数据按范式化存储。\n有这么几点概念：  \n  \n*  任何类型的数据在 state 中都有自己的 “表”。\n*  任何 “数据表” 应将各个项目存储在对象中，其中每个项目的 ID 作为 key，项目本身作为 value。\n*  任何对单个项目的引用都应该根据存储项目的 ID 来完成。\n*  ID 数组应该用于排序。   \n\n\n### 具体实践-Normalizr \n\n这里就需要提到[Normalizr](https://github.com/paularmstrong/normalizr)了，对于复杂数据管理，基本都会提到它。其作用很直白的通过其简介体现出来：Normalizes nested JSON according to a schema。依据模式规范化的处理json。   \n其用法这里就不介绍了，只提供下转换前后的数据做个对比。有兴趣的大家去官网一看便知。  \n\n**原始数据:**  \n\n```js\n{\n  \"id\": \"123\",\n  \"author\": {\n    \"id\": \"1\",\n    \"name\": \"Paul\"\n  },\n  \"title\": \"My awesome blog post\",\n  \"comments\": [\n    {\n      \"id\": \"324\",\n      \"commenter\": {\n        \"id\": \"2\",\n        \"name\": \"Nicole\"\n      }\n    }\n  ]\n}\n```  \n**转换后**  \n\n```js\n{\n  result: \"123\",\n  entities: {\n    \"articles\": {\n      \"123\": {\n        id: \"123\",\n        author: \"1\",\n        title: \"My awesome blog post\",\n        comments: [ \"324\" ]\n      }\n    },\n    \"users\": {\n      \"1\": { \"id\": \"1\", \"name\": \"Paul\" },\n      \"2\": { \"id\": \"2\", \"name\": \"Nicole\" }\n    },\n    \"comments\": {\n      \"324\": { id: \"324\", \"commenter\": \"2\" }\n    }\n  }\n}\n```\n这样的数据就比较符合我们前面redux设计要求了。\n  \n## 结束语  \n到这里前端数据的范式化也就介绍的差不多了，一个感悟是js中的数据结构设计何尝不是数据库设计，去遵循相应的范式会让我们的数据结构更加清晰明了。就算开始没考虑到，随着业务量级的上升原本结构遇到的问题，开发的时候自然也会去往更优雅的方向去靠，这就是进步的过程。  \n通篇文章为个人见解，抛砖引玉有不对的地方欢迎指出\n\n### 参考文章:  \n[https://blog.csdn.net/qq_35401191/article/details/82760301](https://blog.csdn.net/qq_35401191/article/details/82760301)   \n[https://zhuanlan.zhihu.com/p/36487766](https://zhuanlan.zhihu.com/p/36487766)   \n[http://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html](http://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html)\n\n\n\n\n\n","slug":"normalize","published":1,"updated":"2019-02-19T08:37:16.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1s000tgw92p1qa42po","content":"<h1 id=\"前端数据范式化\"><a href=\"#前端数据范式化\" class=\"headerlink\" title=\"前端数据范式化\"></a>前端数据范式化</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>现代web应用的飞速发展，特别是数据驱动思想指导下的React、vue等框架的出现，让我们越来越需要关注数据的组织管理。随着应用复杂度的提升，如果不对数据进行有效合理的设计拆分，那么从性能、可维护性等方面来看会逐渐成为一种阻碍。所以我们需要关注前端数据设计。<br><a id=\"more\"></a><br>其实没有一种很明确的规范告诉我们具体到前端的数据结构应该如何去设计。关系数据库设计有很多范式，借鉴而不照搬结合前端自身特点，才是好的前端数据范式化的实践。  </p>\n<h2 id=\"范式化\"><a href=\"#范式化\" class=\"headerlink\" title=\"范式化\"></a>范式化</h2><p>在深入了解数据范式化之前，我们可以先看个例子</p>\n<h3 id=\"举个栗子：\"><a href=\"#举个栗子：\" class=\"headerlink\" title=\"举个栗子：\"></a>举个栗子：</h3><p>实际业务中，迭代比较多的业务，我们一般会配置化，即除了业务数据之外将页面布局展示相关的内容也由接口控制。<br>那么后端返回的数据可能如下： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    info: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            key:<span class=\"string\">'a'</span>,</span><br><span class=\"line\">            txt:<span class=\"string\">'展示1'</span>,</span><br><span class=\"line\">            value:<span class=\"number\">0</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            key:<span class=\"string\">'b'</span>,</span><br><span class=\"line\">            txt:<span class=\"string\">'展示2'</span>,</span><br><span class=\"line\">            value:<span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样响应操作的时候，需要更新每一项的值如果直接修改info这个数组，存在着很大的不便。<br>如果你说还好，但这样将就操作之后，提交的时候发现这一大串冗余数据后端也不需要呀，还是要处理value。<br>此时的数据还不是那么的复杂，不过层层嵌套的对象见过吧，让人心头一惊的数据格式，如果还在上面操作，可能下个迭代你自己都不知道到底该操作哪个字段了。</p>\n<p>这时候如果将展示和逻辑相分离，抽出来一个专门的属性用来存放与后端交互的数据，看起来是简洁了一些，后期可维护性也增强了不少。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    info: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            key:<span class=\"string\">'a'</span>,</span><br><span class=\"line\">            txt:<span class=\"string\">'展示1'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            key:<span class=\"string\">'b'</span>,</span><br><span class=\"line\">            txt:<span class=\"string\">'展示2'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    values:&#123;</span><br><span class=\"line\">        a:<span class=\"number\">0</span>,</span><br><span class=\"line\">        b:<span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样其实就可以认为是我们提到范式化或者说是扁平化了。具体到前端数据范式化之前  我们来看看数据库的范式吧  </p>\n<h3 id=\"具体到前端数据范式化之前-我们来看看数据库的范式吧\"><a href=\"#具体到前端数据范式化之前-我们来看看数据库的范式吧\" class=\"headerlink\" title=\"具体到前端数据范式化之前  我们来看看数据库的范式吧\"></a>具体到前端数据范式化之前  我们来看看数据库的范式吧</h3><p><strong>什么是范式：</strong><br>顾名思义，一个规范模式(虽然有点粗暴，但好像就是这么回事)。<br>本来想找段定义贴在下面，不过看了看太生硬了，写下个人见解好了。  </p>\n<p><strong>第一范式 1NF</strong><br>表的列具有原子性，不可再分解。<br>只要是关系型数据库就满足1NF  </p>\n<p><strong>第二范式 2NF</strong><br>前提是满足1NF，在1NF的基础上。每一行或者实例必须唯一可以被区分，即需要我们说的主键(key)。  </p>\n<p><strong>第三范式 3NF</strong><br>满足1NF和2NF，且一个数据库表中不包含已在其他表中包含的非主键字段。<br>也就是说表中不冗余，可以通过关系从其他表中获取就不要单独存放了，也就是相关信息可以通过外键相关联。 有个图表达的很不错，借来一用：<br><img src=\"https://p1.meituan.net/dpnewvc/79de24890fe932435cb6ee08a1da03df503526.png\"></p>\n<p>当然后面还有其他范式这里就先不提了。  </p>\n<p>总结一下，范式就是为了减少冗余，提高效率<br>遵循的范式越高，冗余越小，但也要具体分析，不可一味追求符合范式。<br>有些时候一昧的追求范式减少冗余，反而会降低数据读写的效率，这个时候就要反范式，利用空间来换时间。  </p>\n<h3 id=\"redux中的state设计要求\"><a href=\"#redux中的state设计要求\" class=\"headerlink\" title=\"redux中的state设计要求\"></a>redux中的state设计要求</h3><p>redux针对state的设计也提出了范式化的要求，对于复杂的数据结构，除了数据重复之外，还可能有下面这些问题:    </p>\n<ul>\n<li>当数据在多处冗余后，需要更新时，很难保证所有的数据都进行更新。</li>\n<li>嵌套的数据意味着 reducer 逻辑嵌套更多、复杂度更高。尤其是在打算更新深层嵌套数据时。  </li>\n<li>不可变的数据在更新时需要状态树的祖先数据进行复制和更新，并且新的对象引用会导致与之 connect 的所有 UI 组件都重复 render。尽管要显示的数据没有发生任何改变，对深层嵌套的数据对象进行更新也会强制完全无关的 UI 组件重复 render  </li>\n</ul>\n<p>所以，在 Redux Store 中管理关系数据或嵌套数据的推荐做法是将这一部分视为数据库，并且将数据按范式化存储。<br>有这么几点概念：  </p>\n<ul>\n<li>任何类型的数据在 state 中都有自己的 “表”。</li>\n<li>任何 “数据表” 应将各个项目存储在对象中，其中每个项目的 ID 作为 key，项目本身作为 value。</li>\n<li>任何对单个项目的引用都应该根据存储项目的 ID 来完成。</li>\n<li>ID 数组应该用于排序。   </li>\n</ul>\n<h3 id=\"具体实践-Normalizr\"><a href=\"#具体实践-Normalizr\" class=\"headerlink\" title=\"具体实践-Normalizr\"></a>具体实践-Normalizr</h3><p>这里就需要提到<a href=\"https://github.com/paularmstrong/normalizr\" target=\"_blank\" rel=\"noopener\">Normalizr</a>了，对于复杂数据管理，基本都会提到它。其作用很直白的通过其简介体现出来：Normalizes nested JSON according to a schema。依据模式规范化的处理json。<br>其用法这里就不介绍了，只提供下转换前后的数据做个对比。有兴趣的大家去官网一看便知。  </p>\n<p><strong>原始数据:</strong>  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"id\"</span>: <span class=\"string\">\"123\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"author\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"id\"</span>: <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Paul\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span>: <span class=\"string\">\"My awesome blog post\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"comments\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"id\"</span>: <span class=\"string\">\"324\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"commenter\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"id\"</span>: <span class=\"string\">\"2\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Nicole\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">**转换后**  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  result: <span class=\"string\">\"123\"</span>,</span><br><span class=\"line\">  entities: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"articles\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"123\"</span>: &#123;</span><br><span class=\"line\">        id: <span class=\"string\">\"123\"</span>,</span><br><span class=\"line\">        author: <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">        title: <span class=\"string\">\"My awesome blog post\"</span>,</span><br><span class=\"line\">        comments: [ <span class=\"string\">\"324\"</span> ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"users\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"1\"</span>: &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"1\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Paul\"</span> &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"2\"</span>: &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"2\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Nicole\"</span> &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"comments\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"324\"</span>: &#123; <span class=\"attr\">id</span>: <span class=\"string\">\"324\"</span>, <span class=\"string\">\"commenter\"</span>: <span class=\"string\">\"2\"</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的数据就比较符合我们前面redux设计要求了。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>到这里前端数据的范式化也就介绍的差不多了，一个感悟是js中的数据结构设计何尝不是数据库设计，去遵循相应的范式会让我们的数据结构更加清晰明了。就算开始没考虑到，随着业务量级的上升原本结构遇到的问题，开发的时候自然也会去往更优雅的方向去靠，这就是进步的过程。<br>通篇文章为个人见解，抛砖引玉有不对的地方欢迎指出</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"></a>参考文章:</h3><p><a href=\"https://blog.csdn.net/qq_35401191/article/details/82760301\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_35401191/article/details/82760301</a><br><a href=\"https://zhuanlan.zhihu.com/p/36487766\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/36487766</a><br><a href=\"http://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html\" target=\"_blank\" rel=\"noopener\">http://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"前端数据范式化\"><a href=\"#前端数据范式化\" class=\"headerlink\" title=\"前端数据范式化\"></a>前端数据范式化</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>现代web应用的飞速发展，特别是数据驱动思想指导下的React、vue等框架的出现，让我们越来越需要关注数据的组织管理。随着应用复杂度的提升，如果不对数据进行有效合理的设计拆分，那么从性能、可维护性等方面来看会逐渐成为一种阻碍。所以我们需要关注前端数据设计。<br>","more":"<br>其实没有一种很明确的规范告诉我们具体到前端的数据结构应该如何去设计。关系数据库设计有很多范式，借鉴而不照搬结合前端自身特点，才是好的前端数据范式化的实践。  </p>\n<h2 id=\"范式化\"><a href=\"#范式化\" class=\"headerlink\" title=\"范式化\"></a>范式化</h2><p>在深入了解数据范式化之前，我们可以先看个例子</p>\n<h3 id=\"举个栗子：\"><a href=\"#举个栗子：\" class=\"headerlink\" title=\"举个栗子：\"></a>举个栗子：</h3><p>实际业务中，迭代比较多的业务，我们一般会配置化，即除了业务数据之外将页面布局展示相关的内容也由接口控制。<br>那么后端返回的数据可能如下： </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    info: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            key:<span class=\"string\">'a'</span>,</span><br><span class=\"line\">            txt:<span class=\"string\">'展示1'</span>,</span><br><span class=\"line\">            value:<span class=\"number\">0</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            key:<span class=\"string\">'b'</span>,</span><br><span class=\"line\">            txt:<span class=\"string\">'展示2'</span>,</span><br><span class=\"line\">            value:<span class=\"number\">1</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样响应操作的时候，需要更新每一项的值如果直接修改info这个数组，存在着很大的不便。<br>如果你说还好，但这样将就操作之后，提交的时候发现这一大串冗余数据后端也不需要呀，还是要处理value。<br>此时的数据还不是那么的复杂，不过层层嵌套的对象见过吧，让人心头一惊的数据格式，如果还在上面操作，可能下个迭代你自己都不知道到底该操作哪个字段了。</p>\n<p>这时候如果将展示和逻辑相分离，抽出来一个专门的属性用来存放与后端交互的数据，看起来是简洁了一些，后期可维护性也增强了不少。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    info: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            key:<span class=\"string\">'a'</span>,</span><br><span class=\"line\">            txt:<span class=\"string\">'展示1'</span></span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            key:<span class=\"string\">'b'</span>,</span><br><span class=\"line\">            txt:<span class=\"string\">'展示2'</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    values:&#123;</span><br><span class=\"line\">        a:<span class=\"number\">0</span>,</span><br><span class=\"line\">        b:<span class=\"number\">1</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样其实就可以认为是我们提到范式化或者说是扁平化了。具体到前端数据范式化之前  我们来看看数据库的范式吧  </p>\n<h3 id=\"具体到前端数据范式化之前-我们来看看数据库的范式吧\"><a href=\"#具体到前端数据范式化之前-我们来看看数据库的范式吧\" class=\"headerlink\" title=\"具体到前端数据范式化之前  我们来看看数据库的范式吧\"></a>具体到前端数据范式化之前  我们来看看数据库的范式吧</h3><p><strong>什么是范式：</strong><br>顾名思义，一个规范模式(虽然有点粗暴，但好像就是这么回事)。<br>本来想找段定义贴在下面，不过看了看太生硬了，写下个人见解好了。  </p>\n<p><strong>第一范式 1NF</strong><br>表的列具有原子性，不可再分解。<br>只要是关系型数据库就满足1NF  </p>\n<p><strong>第二范式 2NF</strong><br>前提是满足1NF，在1NF的基础上。每一行或者实例必须唯一可以被区分，即需要我们说的主键(key)。  </p>\n<p><strong>第三范式 3NF</strong><br>满足1NF和2NF，且一个数据库表中不包含已在其他表中包含的非主键字段。<br>也就是说表中不冗余，可以通过关系从其他表中获取就不要单独存放了，也就是相关信息可以通过外键相关联。 有个图表达的很不错，借来一用：<br><img src=\"https://p1.meituan.net/dpnewvc/79de24890fe932435cb6ee08a1da03df503526.png\"></p>\n<p>当然后面还有其他范式这里就先不提了。  </p>\n<p>总结一下，范式就是为了减少冗余，提高效率<br>遵循的范式越高，冗余越小，但也要具体分析，不可一味追求符合范式。<br>有些时候一昧的追求范式减少冗余，反而会降低数据读写的效率，这个时候就要反范式，利用空间来换时间。  </p>\n<h3 id=\"redux中的state设计要求\"><a href=\"#redux中的state设计要求\" class=\"headerlink\" title=\"redux中的state设计要求\"></a>redux中的state设计要求</h3><p>redux针对state的设计也提出了范式化的要求，对于复杂的数据结构，除了数据重复之外，还可能有下面这些问题:    </p>\n<ul>\n<li>当数据在多处冗余后，需要更新时，很难保证所有的数据都进行更新。</li>\n<li>嵌套的数据意味着 reducer 逻辑嵌套更多、复杂度更高。尤其是在打算更新深层嵌套数据时。  </li>\n<li>不可变的数据在更新时需要状态树的祖先数据进行复制和更新，并且新的对象引用会导致与之 connect 的所有 UI 组件都重复 render。尽管要显示的数据没有发生任何改变，对深层嵌套的数据对象进行更新也会强制完全无关的 UI 组件重复 render  </li>\n</ul>\n<p>所以，在 Redux Store 中管理关系数据或嵌套数据的推荐做法是将这一部分视为数据库，并且将数据按范式化存储。<br>有这么几点概念：  </p>\n<ul>\n<li>任何类型的数据在 state 中都有自己的 “表”。</li>\n<li>任何 “数据表” 应将各个项目存储在对象中，其中每个项目的 ID 作为 key，项目本身作为 value。</li>\n<li>任何对单个项目的引用都应该根据存储项目的 ID 来完成。</li>\n<li>ID 数组应该用于排序。   </li>\n</ul>\n<h3 id=\"具体实践-Normalizr\"><a href=\"#具体实践-Normalizr\" class=\"headerlink\" title=\"具体实践-Normalizr\"></a>具体实践-Normalizr</h3><p>这里就需要提到<a href=\"https://github.com/paularmstrong/normalizr\" target=\"_blank\" rel=\"noopener\">Normalizr</a>了，对于复杂数据管理，基本都会提到它。其作用很直白的通过其简介体现出来：Normalizes nested JSON according to a schema。依据模式规范化的处理json。<br>其用法这里就不介绍了，只提供下转换前后的数据做个对比。有兴趣的大家去官网一看便知。  </p>\n<p><strong>原始数据:</strong>  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"id\"</span>: <span class=\"string\">\"123\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"author\"</span>: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"id\"</span>: <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Paul\"</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"string\">\"title\"</span>: <span class=\"string\">\"My awesome blog post\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"comments\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"string\">\"id\"</span>: <span class=\"string\">\"324\"</span>,</span><br><span class=\"line\">      <span class=\"string\">\"commenter\"</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">\"id\"</span>: <span class=\"string\">\"2\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Nicole\"</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">**转换后**  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  result: <span class=\"string\">\"123\"</span>,</span><br><span class=\"line\">  entities: &#123;</span><br><span class=\"line\">    <span class=\"string\">\"articles\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"123\"</span>: &#123;</span><br><span class=\"line\">        id: <span class=\"string\">\"123\"</span>,</span><br><span class=\"line\">        author: <span class=\"string\">\"1\"</span>,</span><br><span class=\"line\">        title: <span class=\"string\">\"My awesome blog post\"</span>,</span><br><span class=\"line\">        comments: [ <span class=\"string\">\"324\"</span> ]</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"users\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"1\"</span>: &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"1\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Paul\"</span> &#125;,</span><br><span class=\"line\">      <span class=\"string\">\"2\"</span>: &#123; <span class=\"string\">\"id\"</span>: <span class=\"string\">\"2\"</span>, <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Nicole\"</span> &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"comments\"</span>: &#123;</span><br><span class=\"line\">      <span class=\"string\">\"324\"</span>: &#123; <span class=\"attr\">id</span>: <span class=\"string\">\"324\"</span>, <span class=\"string\">\"commenter\"</span>: <span class=\"string\">\"2\"</span> &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样的数据就比较符合我们前面redux设计要求了。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>到这里前端数据的范式化也就介绍的差不多了，一个感悟是js中的数据结构设计何尝不是数据库设计，去遵循相应的范式会让我们的数据结构更加清晰明了。就算开始没考虑到，随着业务量级的上升原本结构遇到的问题，开发的时候自然也会去往更优雅的方向去靠，这就是进步的过程。<br>通篇文章为个人见解，抛砖引玉有不对的地方欢迎指出</p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章:\"></a>参考文章:</h3><p><a href=\"https://blog.csdn.net/qq_35401191/article/details/82760301\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_35401191/article/details/82760301</a><br><a href=\"https://zhuanlan.zhihu.com/p/36487766\" target=\"_blank\" rel=\"noopener\">https://zhuanlan.zhihu.com/p/36487766</a><br><a href=\"http://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html\" target=\"_blank\" rel=\"noopener\">http://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html</a></p>"},{"title":"前端解读控制反转(IOC)","date":"2018-10-18T16:00:00.000Z","_content":"  \n## 前言\n随着前端承担的职责越来越重，前端应用向着复杂化、规模化的方向发展。大型项目模块化是一种趋势，不可避免模块之间要相互依赖，此外还有很多第三方包。这样的话如何去管理这些繁杂的文件，是一个不可避免的话题。此时作为一种已经被实践证明过的思想模式一直得到大家的青睐，这就是控制反转(IOC)。\n<!-- more -->\n## IOC定义\n先看一下维基百科上的定义：  \n控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 \n\n### 原则 \n\n1. 高层模块不应该依赖低层模块。两个都应该依赖抽象 \n2. 抽象不应该依赖具体实现\n3. 面向接口编程，而非面向实现编程\n\n针对前端来说，接口的概念不那么清晰明了，不像强类型语言。\n概念是比较枯燥的，下面结合例子来看一下可能更好理解一点。  \n\n### 目的\n根据概念可以看到最主要的目的就是降低耦合，提高扩展性。在深究之前，我们先看下代码耦合\n  \n#### 代码耦合  \n所谓耦合，可以如下图显示：\n<img src='https://user-gold-cdn.xitu.io/2018/10/24/166a60f1cb4bdc20?w=808&h=580&f=png&s=32302'/>\n比较清晰明了，代码相互之间的联系太直接：\n假如obj2报错，那么整个系统也都报错了。  \n所以我们的目的就是降低二者之间的耦合度，   \n结合图来说比较清晰，  \n如果两者不这么直接的发生关系，那么相互影响的概率就小了那么多了。  \n\n另外，这是比较少的模块，常规项目里显然不仅仅是只有这么少，想象一下多个模块的场景：\n<img src='https://user-gold-cdn.xitu.io/2018/10/24/166a60f1ca073f1e?w=1158&h=868&f=png&s=112204' />\n这里除了耦合之外，不同齿轮之间的依赖关系也是个头疼的问题，迭代个几个版本之后发现，这是什么东西，一动就有bug。。。。\n\n所以IOC就是来解决上述问题的。\n其常见方式是依赖注入和依赖查找。在js领域里面最出名的就是angular中大量使用了依赖注入。文字比较苍白，我们可以通过例子来看看。\n\n\n#### 实例 \n\n就从nba来说，有那么一些球星，我们想知道他所属的球队，那么可能就像下面这个情况:\n\n```js\n//球队信息\nclass RTeam {\n    constructor(){\n        this.name = '火箭'\n    }\n}\n// 球员信息\nclass Player{\n    constructor(){\n        this.team = new Team()\n    }\n    info(){\n        console.log(this.team.name)\n    }\n}\n// 球员ym\nlet ym = new Player()\nym.info() // ‘火箭’\n\n```\n\n看起来挺好的，球员player依赖于某个球队RTeam \n当调用的时候主动去加载球队即可。此时的控制权在player这里。\n\n假如这个时候,球员发生交易了，球队信息更换了，转换到team2了。  \n这时候我们就需要去修改player里的代码了，因为球员那里直接写死了对RTeam的依赖，这种可扩展性是很差的。\n这不是我们所想要的，需要重新思考下依赖关系处理了。    \n球员和球队之间非得这么直接粗暴的发生联系吗，  \n一个球员对应一个球队的话，未来会发生变化的可能性太大了，毕竟不止一个球队。    \n如果两者之间不直接发生联系，中间就需要一个中间模块来负责两者关系的处理  \n球员不关注球队从哪来，只要给到我就行了。  \n这样控制权就不是直接落在player这里了，这正是IOC的设计思路。\n\n### 依据IOC 改进\n参照IOC的几条原则，我们进行下改进。\n\n1. 高层模块不应该依赖低层模块。两个都应该依赖抽象 \n    这里player是高层模块，直接依赖了球队这个低级模块。所以我们将两者解耦，player不再直接依赖于该team这个class  \n    \n2. 抽象不应该依赖具体实现，具体实现应该依赖抽象  \n    具体到这里来看我们的player模块不应该直接依赖具体team，而是通过构造函数将抽象的teaminfo实例传递进去，这样就解耦具体实现。\n           \n直接看代码比较清楚：  \n    \n```js\n// 球队信息不依赖具体实现\n// 面向接口即面向抽象编程\nclass TeamInfo {\n    constructor(name) {\n        this.name = name\n    }\n}\nclass Player {\n    // 此处的参数，是teamInfo的一个实例，不直接依赖具体的实例\n    // 面向抽象\n    constructor(team) {\n        this.team = team\n    }\n    info() {\n        console.log(this.team.name)\n    }\n}\n// 将依赖关系放到此处来管理，控制权也放到此处\n// Player和TeamInfo之间不再有直接依赖\n// 原本直接掌握teaminfo控制权的player不再直接依赖\n// 将依赖控制，落在此处(第三方模块专门管理)即为控制反转\nvar ym = new Player(new TeamInfo('火箭'))\nym.info()\nvar kobe = new Player(new TeamInfo('湖人'))\nkobe.info()\n```  \n\n这里发现，TeamInfo和Player之间已经没有直接关联了，依赖关系统一放到getTeamInfo中。  \n所谓控制反转就如何上面一样，将依赖的控制权由player转移到其他地方即我们专门的依赖管理来做了。\n这样再增加一个team3，改动也不大，复用就行了。\n其中之间的关系，如下面这个图：\n<img src='https://user-gold-cdn.xitu.io/2018/10/24/166a60f1c7e53fff?w=1274&h=860&f=png&s=64137'/>\n彼此不直接发生联系，依赖关系统一在中间模块来管理，更加清晰。\n\n### 实现\n上面其实就是最简单的IOC实现了，基于IOC的编程思想，主要有两种实现方式：依赖注入和依赖查找。依赖查不太常用，常见的是依赖注入。    \n\n#### 依赖注入 \n在js中常见的就是依赖注入。从名字上理解，所谓依赖注入，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。\n\n在RequireJS/AMD的模块加载器的实现就是基于依赖注入来的，还有大名鼎鼎的angular，其实现也使用了大量的依赖注入。\n### 结束语\n\n关于控制反转，一句话总结：控制反转这里控制权从使用者本身转移到第三方容器上，而非是转移到被调用者上，这里需要明确不要疑惑。控制反转是一种思想，依赖注入是一种设计模式。\n可能听起来比较抽象，其实我们平时开发中见到和用到的也是蛮多的，可能原来没有对应起来罢了。\n至于依赖注入，前端领域用到的就更多了，[下面我将结合自身实践翻译一篇个人认为很好的文章Dependency-injection-in-JavaScript](https://juejin.im/post/5bd177806fb9a05d30179925)，来进一步深入依赖注入。\n至此，个人见解分享完毕，抛砖引玉，希望共同学习进步。\n\n","source":"_posts/ioc.md","raw":"---\ntitle: 前端解读控制反转(IOC)\ndate: 2018-10-19\n---\n  \n## 前言\n随着前端承担的职责越来越重，前端应用向着复杂化、规模化的方向发展。大型项目模块化是一种趋势，不可避免模块之间要相互依赖，此外还有很多第三方包。这样的话如何去管理这些繁杂的文件，是一个不可避免的话题。此时作为一种已经被实践证明过的思想模式一直得到大家的青睐，这就是控制反转(IOC)。\n<!-- more -->\n## IOC定义\n先看一下维基百科上的定义：  \n控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 \n\n### 原则 \n\n1. 高层模块不应该依赖低层模块。两个都应该依赖抽象 \n2. 抽象不应该依赖具体实现\n3. 面向接口编程，而非面向实现编程\n\n针对前端来说，接口的概念不那么清晰明了，不像强类型语言。\n概念是比较枯燥的，下面结合例子来看一下可能更好理解一点。  \n\n### 目的\n根据概念可以看到最主要的目的就是降低耦合，提高扩展性。在深究之前，我们先看下代码耦合\n  \n#### 代码耦合  \n所谓耦合，可以如下图显示：\n<img src='https://user-gold-cdn.xitu.io/2018/10/24/166a60f1cb4bdc20?w=808&h=580&f=png&s=32302'/>\n比较清晰明了，代码相互之间的联系太直接：\n假如obj2报错，那么整个系统也都报错了。  \n所以我们的目的就是降低二者之间的耦合度，   \n结合图来说比较清晰，  \n如果两者不这么直接的发生关系，那么相互影响的概率就小了那么多了。  \n\n另外，这是比较少的模块，常规项目里显然不仅仅是只有这么少，想象一下多个模块的场景：\n<img src='https://user-gold-cdn.xitu.io/2018/10/24/166a60f1ca073f1e?w=1158&h=868&f=png&s=112204' />\n这里除了耦合之外，不同齿轮之间的依赖关系也是个头疼的问题，迭代个几个版本之后发现，这是什么东西，一动就有bug。。。。\n\n所以IOC就是来解决上述问题的。\n其常见方式是依赖注入和依赖查找。在js领域里面最出名的就是angular中大量使用了依赖注入。文字比较苍白，我们可以通过例子来看看。\n\n\n#### 实例 \n\n就从nba来说，有那么一些球星，我们想知道他所属的球队，那么可能就像下面这个情况:\n\n```js\n//球队信息\nclass RTeam {\n    constructor(){\n        this.name = '火箭'\n    }\n}\n// 球员信息\nclass Player{\n    constructor(){\n        this.team = new Team()\n    }\n    info(){\n        console.log(this.team.name)\n    }\n}\n// 球员ym\nlet ym = new Player()\nym.info() // ‘火箭’\n\n```\n\n看起来挺好的，球员player依赖于某个球队RTeam \n当调用的时候主动去加载球队即可。此时的控制权在player这里。\n\n假如这个时候,球员发生交易了，球队信息更换了，转换到team2了。  \n这时候我们就需要去修改player里的代码了，因为球员那里直接写死了对RTeam的依赖，这种可扩展性是很差的。\n这不是我们所想要的，需要重新思考下依赖关系处理了。    \n球员和球队之间非得这么直接粗暴的发生联系吗，  \n一个球员对应一个球队的话，未来会发生变化的可能性太大了，毕竟不止一个球队。    \n如果两者之间不直接发生联系，中间就需要一个中间模块来负责两者关系的处理  \n球员不关注球队从哪来，只要给到我就行了。  \n这样控制权就不是直接落在player这里了，这正是IOC的设计思路。\n\n### 依据IOC 改进\n参照IOC的几条原则，我们进行下改进。\n\n1. 高层模块不应该依赖低层模块。两个都应该依赖抽象 \n    这里player是高层模块，直接依赖了球队这个低级模块。所以我们将两者解耦，player不再直接依赖于该team这个class  \n    \n2. 抽象不应该依赖具体实现，具体实现应该依赖抽象  \n    具体到这里来看我们的player模块不应该直接依赖具体team，而是通过构造函数将抽象的teaminfo实例传递进去，这样就解耦具体实现。\n           \n直接看代码比较清楚：  \n    \n```js\n// 球队信息不依赖具体实现\n// 面向接口即面向抽象编程\nclass TeamInfo {\n    constructor(name) {\n        this.name = name\n    }\n}\nclass Player {\n    // 此处的参数，是teamInfo的一个实例，不直接依赖具体的实例\n    // 面向抽象\n    constructor(team) {\n        this.team = team\n    }\n    info() {\n        console.log(this.team.name)\n    }\n}\n// 将依赖关系放到此处来管理，控制权也放到此处\n// Player和TeamInfo之间不再有直接依赖\n// 原本直接掌握teaminfo控制权的player不再直接依赖\n// 将依赖控制，落在此处(第三方模块专门管理)即为控制反转\nvar ym = new Player(new TeamInfo('火箭'))\nym.info()\nvar kobe = new Player(new TeamInfo('湖人'))\nkobe.info()\n```  \n\n这里发现，TeamInfo和Player之间已经没有直接关联了，依赖关系统一放到getTeamInfo中。  \n所谓控制反转就如何上面一样，将依赖的控制权由player转移到其他地方即我们专门的依赖管理来做了。\n这样再增加一个team3，改动也不大，复用就行了。\n其中之间的关系，如下面这个图：\n<img src='https://user-gold-cdn.xitu.io/2018/10/24/166a60f1c7e53fff?w=1274&h=860&f=png&s=64137'/>\n彼此不直接发生联系，依赖关系统一在中间模块来管理，更加清晰。\n\n### 实现\n上面其实就是最简单的IOC实现了，基于IOC的编程思想，主要有两种实现方式：依赖注入和依赖查找。依赖查不太常用，常见的是依赖注入。    \n\n#### 依赖注入 \n在js中常见的就是依赖注入。从名字上理解，所谓依赖注入，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。\n\n在RequireJS/AMD的模块加载器的实现就是基于依赖注入来的，还有大名鼎鼎的angular，其实现也使用了大量的依赖注入。\n### 结束语\n\n关于控制反转，一句话总结：控制反转这里控制权从使用者本身转移到第三方容器上，而非是转移到被调用者上，这里需要明确不要疑惑。控制反转是一种思想，依赖注入是一种设计模式。\n可能听起来比较抽象，其实我们平时开发中见到和用到的也是蛮多的，可能原来没有对应起来罢了。\n至于依赖注入，前端领域用到的就更多了，[下面我将结合自身实践翻译一篇个人认为很好的文章Dependency-injection-in-JavaScript](https://juejin.im/post/5bd177806fb9a05d30179925)，来进一步深入依赖注入。\n至此，个人见解分享完毕，抛砖引玉，希望共同学习进步。\n\n","slug":"ioc","published":1,"updated":"2018-10-25T08:14:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1t000ugw92oves2v4b","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>随着前端承担的职责越来越重，前端应用向着复杂化、规模化的方向发展。大型项目模块化是一种趋势，不可避免模块之间要相互依赖，此外还有很多第三方包。这样的话如何去管理这些繁杂的文件，是一个不可避免的话题。此时作为一种已经被实践证明过的思想模式一直得到大家的青睐，这就是控制反转(IOC)。<br><a id=\"more\"></a></p>\n<h2 id=\"IOC定义\"><a href=\"#IOC定义\" class=\"headerlink\" title=\"IOC定义\"></a>IOC定义</h2><p>先看一下维基百科上的定义：<br>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 </p>\n<h3 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h3><ol>\n<li>高层模块不应该依赖低层模块。两个都应该依赖抽象 </li>\n<li>抽象不应该依赖具体实现</li>\n<li>面向接口编程，而非面向实现编程</li>\n</ol>\n<p>针对前端来说，接口的概念不那么清晰明了，不像强类型语言。<br>概念是比较枯燥的，下面结合例子来看一下可能更好理解一点。  </p>\n<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>根据概念可以看到最主要的目的就是降低耦合，提高扩展性。在深究之前，我们先看下代码耦合</p>\n<h4 id=\"代码耦合\"><a href=\"#代码耦合\" class=\"headerlink\" title=\"代码耦合\"></a>代码耦合</h4><p>所谓耦合，可以如下图显示：<br><img src=\"https://user-gold-cdn.xitu.io/2018/10/24/166a60f1cb4bdc20?w=808&h=580&f=png&s=32302\"><br>比较清晰明了，代码相互之间的联系太直接：<br>假如obj2报错，那么整个系统也都报错了。<br>所以我们的目的就是降低二者之间的耦合度，<br>结合图来说比较清晰，<br>如果两者不这么直接的发生关系，那么相互影响的概率就小了那么多了。  </p>\n<p>另外，这是比较少的模块，常规项目里显然不仅仅是只有这么少，想象一下多个模块的场景：<br><img src=\"https://user-gold-cdn.xitu.io/2018/10/24/166a60f1ca073f1e?w=1158&h=868&f=png&s=112204\"><br>这里除了耦合之外，不同齿轮之间的依赖关系也是个头疼的问题，迭代个几个版本之后发现，这是什么东西，一动就有bug。。。。</p>\n<p>所以IOC就是来解决上述问题的。<br>其常见方式是依赖注入和依赖查找。在js领域里面最出名的就是angular中大量使用了依赖注入。文字比较苍白，我们可以通过例子来看看。</p>\n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>就从nba来说，有那么一些球星，我们想知道他所属的球队，那么可能就像下面这个情况:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//球队信息</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RTeam</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = <span class=\"string\">'火箭'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 球员信息</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.team = <span class=\"keyword\">new</span> Team()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    info()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.team.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 球员ym</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ym = <span class=\"keyword\">new</span> Player()</span><br><span class=\"line\">ym.info() <span class=\"comment\">// ‘火箭’</span></span><br></pre></td></tr></table></figure>\n<p>看起来挺好的，球员player依赖于某个球队RTeam<br>当调用的时候主动去加载球队即可。此时的控制权在player这里。</p>\n<p>假如这个时候,球员发生交易了，球队信息更换了，转换到team2了。<br>这时候我们就需要去修改player里的代码了，因为球员那里直接写死了对RTeam的依赖，这种可扩展性是很差的。<br>这不是我们所想要的，需要重新思考下依赖关系处理了。<br>球员和球队之间非得这么直接粗暴的发生联系吗，<br>一个球员对应一个球队的话，未来会发生变化的可能性太大了，毕竟不止一个球队。<br>如果两者之间不直接发生联系，中间就需要一个中间模块来负责两者关系的处理<br>球员不关注球队从哪来，只要给到我就行了。<br>这样控制权就不是直接落在player这里了，这正是IOC的设计思路。</p>\n<h3 id=\"依据IOC-改进\"><a href=\"#依据IOC-改进\" class=\"headerlink\" title=\"依据IOC 改进\"></a>依据IOC 改进</h3><p>参照IOC的几条原则，我们进行下改进。</p>\n<ol>\n<li><p>高层模块不应该依赖低层模块。两个都应该依赖抽象<br> 这里player是高层模块，直接依赖了球队这个低级模块。所以我们将两者解耦，player不再直接依赖于该team这个class  </p>\n</li>\n<li><p>抽象不应该依赖具体实现，具体实现应该依赖抽象<br> 具体到这里来看我们的player模块不应该直接依赖具体team，而是通过构造函数将抽象的teaminfo实例传递进去，这样就解耦具体实现。</p>\n</li>\n</ol>\n<p>直接看代码比较清楚：  </p>\n<pre><code class=\"js\"><span class=\"comment\">// 球队信息不依赖具体实现</span>\n<span class=\"comment\">// 面向接口即面向抽象编程</span>\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeamInfo</span> </span>{\n    <span class=\"keyword\">constructor</span>(name) {\n        <span class=\"keyword\">this</span>.name = name\n    }\n}\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> </span>{\n    <span class=\"comment\">// 此处的参数，是teamInfo的一个实例，不直接依赖具体的实例</span>\n    <span class=\"comment\">// 面向抽象</span>\n    <span class=\"keyword\">constructor</span>(team) {\n        <span class=\"keyword\">this</span>.team = team\n    }\n    info() {\n        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.team.name)\n    }\n}\n<span class=\"comment\">// 将依赖关系放到此处来管理，控制权也放到此处</span>\n<span class=\"comment\">// Player和TeamInfo之间不再有直接依赖</span>\n<span class=\"comment\">// 原本直接掌握teaminfo控制权的player不再直接依赖</span>\n<span class=\"comment\">// 将依赖控制，落在此处(第三方模块专门管理)即为控制反转</span>\n<span class=\"keyword\">var</span> ym = <span class=\"keyword\">new</span> Player(<span class=\"keyword\">new</span> TeamInfo(<span class=\"string\">'火箭'</span>))\nym.info()\n<span class=\"keyword\">var</span> kobe = <span class=\"keyword\">new</span> Player(<span class=\"keyword\">new</span> TeamInfo(<span class=\"string\">'湖人'</span>))\nkobe.info()\n</code></pre>\n<p>这里发现，TeamInfo和Player之间已经没有直接关联了，依赖关系统一放到getTeamInfo中。<br>所谓控制反转就如何上面一样，将依赖的控制权由player转移到其他地方即我们专门的依赖管理来做了。<br>这样再增加一个team3，改动也不大，复用就行了。<br>其中之间的关系，如下面这个图：<br><img src=\"https://user-gold-cdn.xitu.io/2018/10/24/166a60f1c7e53fff?w=1274&h=860&f=png&s=64137\"><br>彼此不直接发生联系，依赖关系统一在中间模块来管理，更加清晰。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>上面其实就是最简单的IOC实现了，基于IOC的编程思想，主要有两种实现方式：依赖注入和依赖查找。依赖查不太常用，常见的是依赖注入。    </p>\n<h4 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h4><p>在js中常见的就是依赖注入。从名字上理解，所谓依赖注入，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p>\n<p>在RequireJS/AMD的模块加载器的实现就是基于依赖注入来的，还有大名鼎鼎的angular，其实现也使用了大量的依赖注入。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>关于控制反转，一句话总结：控制反转这里控制权从使用者本身转移到第三方容器上，而非是转移到被调用者上，这里需要明确不要疑惑。控制反转是一种思想，依赖注入是一种设计模式。<br>可能听起来比较抽象，其实我们平时开发中见到和用到的也是蛮多的，可能原来没有对应起来罢了。<br>至于依赖注入，前端领域用到的就更多了，<a href=\"https://juejin.im/post/5bd177806fb9a05d30179925\" target=\"_blank\" rel=\"noopener\">下面我将结合自身实践翻译一篇个人认为很好的文章Dependency-injection-in-JavaScript</a>，来进一步深入依赖注入。<br>至此，个人见解分享完毕，抛砖引玉，希望共同学习进步。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>随着前端承担的职责越来越重，前端应用向着复杂化、规模化的方向发展。大型项目模块化是一种趋势，不可避免模块之间要相互依赖，此外还有很多第三方包。这样的话如何去管理这些繁杂的文件，是一个不可避免的话题。此时作为一种已经被实践证明过的思想模式一直得到大家的青睐，这就是控制反转(IOC)。<br>","more":"</p>\n<h2 id=\"IOC定义\"><a href=\"#IOC定义\" class=\"headerlink\" title=\"IOC定义\"></a>IOC定义</h2><p>先看一下维基百科上的定义：<br>控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。 </p>\n<h3 id=\"原则\"><a href=\"#原则\" class=\"headerlink\" title=\"原则\"></a>原则</h3><ol>\n<li>高层模块不应该依赖低层模块。两个都应该依赖抽象 </li>\n<li>抽象不应该依赖具体实现</li>\n<li>面向接口编程，而非面向实现编程</li>\n</ol>\n<p>针对前端来说，接口的概念不那么清晰明了，不像强类型语言。<br>概念是比较枯燥的，下面结合例子来看一下可能更好理解一点。  </p>\n<h3 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h3><p>根据概念可以看到最主要的目的就是降低耦合，提高扩展性。在深究之前，我们先看下代码耦合</p>\n<h4 id=\"代码耦合\"><a href=\"#代码耦合\" class=\"headerlink\" title=\"代码耦合\"></a>代码耦合</h4><p>所谓耦合，可以如下图显示：<br><img src=\"https://user-gold-cdn.xitu.io/2018/10/24/166a60f1cb4bdc20?w=808&h=580&f=png&s=32302\"><br>比较清晰明了，代码相互之间的联系太直接：<br>假如obj2报错，那么整个系统也都报错了。<br>所以我们的目的就是降低二者之间的耦合度，<br>结合图来说比较清晰，<br>如果两者不这么直接的发生关系，那么相互影响的概率就小了那么多了。  </p>\n<p>另外，这是比较少的模块，常规项目里显然不仅仅是只有这么少，想象一下多个模块的场景：<br><img src=\"https://user-gold-cdn.xitu.io/2018/10/24/166a60f1ca073f1e?w=1158&h=868&f=png&s=112204\"><br>这里除了耦合之外，不同齿轮之间的依赖关系也是个头疼的问题，迭代个几个版本之后发现，这是什么东西，一动就有bug。。。。</p>\n<p>所以IOC就是来解决上述问题的。<br>其常见方式是依赖注入和依赖查找。在js领域里面最出名的就是angular中大量使用了依赖注入。文字比较苍白，我们可以通过例子来看看。</p>\n<h4 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h4><p>就从nba来说，有那么一些球星，我们想知道他所属的球队，那么可能就像下面这个情况:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//球队信息</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">RTeam</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = <span class=\"string\">'火箭'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 球员信息</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.team = <span class=\"keyword\">new</span> Team()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    info()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.team.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 球员ym</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> ym = <span class=\"keyword\">new</span> Player()</span><br><span class=\"line\">ym.info() <span class=\"comment\">// ‘火箭’</span></span><br></pre></td></tr></table></figure>\n<p>看起来挺好的，球员player依赖于某个球队RTeam<br>当调用的时候主动去加载球队即可。此时的控制权在player这里。</p>\n<p>假如这个时候,球员发生交易了，球队信息更换了，转换到team2了。<br>这时候我们就需要去修改player里的代码了，因为球员那里直接写死了对RTeam的依赖，这种可扩展性是很差的。<br>这不是我们所想要的，需要重新思考下依赖关系处理了。<br>球员和球队之间非得这么直接粗暴的发生联系吗，<br>一个球员对应一个球队的话，未来会发生变化的可能性太大了，毕竟不止一个球队。<br>如果两者之间不直接发生联系，中间就需要一个中间模块来负责两者关系的处理<br>球员不关注球队从哪来，只要给到我就行了。<br>这样控制权就不是直接落在player这里了，这正是IOC的设计思路。</p>\n<h3 id=\"依据IOC-改进\"><a href=\"#依据IOC-改进\" class=\"headerlink\" title=\"依据IOC 改进\"></a>依据IOC 改进</h3><p>参照IOC的几条原则，我们进行下改进。</p>\n<ol>\n<li><p>高层模块不应该依赖低层模块。两个都应该依赖抽象<br> 这里player是高层模块，直接依赖了球队这个低级模块。所以我们将两者解耦，player不再直接依赖于该team这个class  </p>\n</li>\n<li><p>抽象不应该依赖具体实现，具体实现应该依赖抽象<br> 具体到这里来看我们的player模块不应该直接依赖具体team，而是通过构造函数将抽象的teaminfo实例传递进去，这样就解耦具体实现。</p>\n</li>\n</ol>\n<p>直接看代码比较清楚：  </p>\n<pre><code class=\"js\"><span class=\"comment\">// 球队信息不依赖具体实现</span>\n<span class=\"comment\">// 面向接口即面向抽象编程</span>\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TeamInfo</span> </span>{\n    <span class=\"keyword\">constructor</span>(name) {\n        <span class=\"keyword\">this</span>.name = name\n    }\n}\n<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Player</span> </span>{\n    <span class=\"comment\">// 此处的参数，是teamInfo的一个实例，不直接依赖具体的实例</span>\n    <span class=\"comment\">// 面向抽象</span>\n    <span class=\"keyword\">constructor</span>(team) {\n        <span class=\"keyword\">this</span>.team = team\n    }\n    info() {\n        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.team.name)\n    }\n}\n<span class=\"comment\">// 将依赖关系放到此处来管理，控制权也放到此处</span>\n<span class=\"comment\">// Player和TeamInfo之间不再有直接依赖</span>\n<span class=\"comment\">// 原本直接掌握teaminfo控制权的player不再直接依赖</span>\n<span class=\"comment\">// 将依赖控制，落在此处(第三方模块专门管理)即为控制反转</span>\n<span class=\"keyword\">var</span> ym = <span class=\"keyword\">new</span> Player(<span class=\"keyword\">new</span> TeamInfo(<span class=\"string\">'火箭'</span>))\nym.info()\n<span class=\"keyword\">var</span> kobe = <span class=\"keyword\">new</span> Player(<span class=\"keyword\">new</span> TeamInfo(<span class=\"string\">'湖人'</span>))\nkobe.info()\n</code></pre>\n<p>这里发现，TeamInfo和Player之间已经没有直接关联了，依赖关系统一放到getTeamInfo中。<br>所谓控制反转就如何上面一样，将依赖的控制权由player转移到其他地方即我们专门的依赖管理来做了。<br>这样再增加一个team3，改动也不大，复用就行了。<br>其中之间的关系，如下面这个图：<br><img src=\"https://user-gold-cdn.xitu.io/2018/10/24/166a60f1c7e53fff?w=1274&h=860&f=png&s=64137\"><br>彼此不直接发生联系，依赖关系统一在中间模块来管理，更加清晰。</p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>上面其实就是最简单的IOC实现了，基于IOC的编程思想，主要有两种实现方式：依赖注入和依赖查找。依赖查不太常用，常见的是依赖注入。    </p>\n<h4 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h4><p>在js中常见的就是依赖注入。从名字上理解，所谓依赖注入，即组件之间的依赖关系由容器在运行期决定，形象的来说，即由容器动态的将某种依赖关系注入到组件之中。</p>\n<p>在RequireJS/AMD的模块加载器的实现就是基于依赖注入来的，还有大名鼎鼎的angular，其实现也使用了大量的依赖注入。</p>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>关于控制反转，一句话总结：控制反转这里控制权从使用者本身转移到第三方容器上，而非是转移到被调用者上，这里需要明确不要疑惑。控制反转是一种思想，依赖注入是一种设计模式。<br>可能听起来比较抽象，其实我们平时开发中见到和用到的也是蛮多的，可能原来没有对应起来罢了。<br>至于依赖注入，前端领域用到的就更多了，<a href=\"https://juejin.im/post/5bd177806fb9a05d30179925\" target=\"_blank\" rel=\"noopener\">下面我将结合自身实践翻译一篇个人认为很好的文章Dependency-injection-in-JavaScript</a>，来进一步深入依赖注入。<br>至此，个人见解分享完毕，抛砖引玉，希望共同学习进步。</p>"},{"title":"硬件、网络及性能","date":"2018-05-06T16:00:00.000Z","_content":"## 提升现代web app的中的页面性能\n前言，本文翻译自[https://docs.google.com/presentation/d/1hBIb0CshY9DlM1fkxSLXVSW3Srg3CxaxAbdocI67NCQ/edit#slide=id.g32e52b1ea6_1_0](https://docs.google.com/presentation/d/1hBIb0CshY9DlM1fkxSLXVSW3Srg3CxaxAbdocI67NCQ/edit#slide=id.g32e52b1ea6_1_0)看到之后感觉讲解的系统清晰明了，实属一篇好文。就加上自己的理解翻译了一下，聊以加深印象。\n<!-- more -->\n### 硬件、网络，对性能的而言始终不能避开的两个物理因素 \n  \n### 一、 硬件如何影响性能  \n硬件（即处理能力）决定了计算密集型任务的表现  \n浏览器必须解析、编译并执行所有的js，如下如所示：\n<img src='/img/performance/1.png'> \n对于每个阶段而言，代码量的差异显然会影响其变现即影响性能，这种差异在低处理能力的机器上的体现尤为明显。  \n当然其他类型的资源请求也会影响性能，相比之下js的影响是比较突出的。  \n所以考虑不同用户cpu的状况，减少js怪物(即缩小js体积)是很必要的。可以从以下几方面着手：\n1. 删除不必要js\n2. 延迟加载非关键js\n3. 借助相关工具\n### 1.1 删除不必要js\n#### 只在必要的时候进行转换 \n仅仅对需要ES5的客户端才进行转换，80%的浏览器已经支持ES2015。(结合自己实际开发情况，移动端而言确实80%+的手机已经支持ES2015，仅仅只遇到oppop，vivio这两中手机不支持。)因为转换之后的代价还是有的，如下所示:   \n\n```js\n//ES2015\nbooks.map(b => b.title);\n//ES5\nbooks.map(function(b) { return b.title; }, this);\n//体积大了一倍\n```\n#### 使用压缩工具/优化工具  \n像UglifyJS & Closure Compiler 之类的工具，在压缩之外还有一些优化功能。\n对大多数的js而言压缩代码中空格移除和符号修改占了95%的工作量，并非是精心的代码转换。\n压缩不应该是盲目的，应该平衡下面几点。  \n* 更好的压缩比\n* 高额的计算机资源消耗\n* 前期准备\n* 可能的副作用 \n压缩可能不是一味的追求体积更小，相对而言，压缩也应该权衡一下其他方面。比较常见就是代码压缩时相比于其他流程，超长的时间消耗。压缩之后可能遇到关键字的问题。  \n如何解决其实应该是从本身项目出发。\n* 尽可能的优化可缓存的静态资源\n* 在压缩体积和时间之间找到一个平衡点  \n\n#### 使用tree-shaking移除没用的代码  \n和压缩代码的目的一致，减小资源大小，不过是从另一个层面的解决方案。像webpack，rollup都提供了该功能。  \ntree-shaking会将没有被用到的exports移除  \n\n```js\n//tool \n//used\nexport function a(){\n    console.log('1')\n}\nexport function b(){\n    console.log('2')\n}\n//app.js\nimport {a} from './tool'\na()\n```   \n \nfunction b 未被使用，最终的打包文件中b将会被删除。\n#### ES2015的模块是静态的，可以使用tree-shaking  \nimport/export 在执行之前就被确定，并且两者只能在顶层，没有条件逻辑的情况下使用(毕竟未执行)  \n#### tree-shaking的局限  \n  \n* 仅仅删除未被使用的导出  \n* 不支持所有的代码库（仅仅ES2015） \n* 可能做不到极致  \n   难以确定删除是否会有副作用，这种打包器只能保留    \n   \n#### 自我排查  \n工具不能做到尽善尽美，并且在执行之前确定某项问题是困难的。  \n当前来说应该从代码规范和代码注释来自我完善。  \n#### 对于框架   \n如果非必须，请不要使用。大的框架至少300kb的体积。   \n当然必要，请基于下面几点来选择：   \n \n* 服务端渲染  \n* 懒加载 \n* 代码优化    \n* 性能  \n\n\n### 1.2 延迟加载非必需js   \n  \n先看一下js不同引入方式的差别  \n\n|  | 默认方式 | Async | Defer |\n| --- | --- | --- | --- |\n| 阻塞渲染 | 是 | 否 | 否 |\n| 执行时机 | 加载完成 | 加载完成 | document解析完成 |\n\n#### 使用代码分割和懒加载  \n* 减少启动时需要加载的js  \n* 尽可能少的加载不相关的js   \n传统的做法是加载Bundle js，代码分割是将代码分成不同的chunk  \n这里同样有两种极端：  \n* 每个模块对应一个js  \n    不好压缩  \n    利于缓存  \n    粒度更小\n* 整个应用只对应一个js   \n    便于压缩  \n    不利于缓存  \n    粒度太大，即可维护性\n忽然有种中庸的感觉了，凡事皆有度，所有单一操作都不能过分苛求极致，兼顾才是合理\n### 1.3 使用其他工具  \n#### 使用html和css   \n某些状况下可能需要vanilla JS(即原生js)，框架带来便利的同时不可避免的有其他的一些性能消耗。提到这里有一篇文章大家可以看一下[我是怎么把我的 React 应用换成 VanillaJS 的（这是不是一个坏主意）](https://www.w3ctech.com/topic/1978)\n举个例子：\nNetflix 降低了他们登录页50%的TTI（传输时间间隔）通过下面的方式：\n* 使用原生js来代替React\n* 当用户登录的时候加载余下的部分   \n\n#### 使用server\n将代价昂贵的库放到server端,使用ssr来代替client-side-render.  \nssr可以将我们初始页面加载事件减少到原来的1/5并减少不同浏览器之间的差异。\nssr确实首屏的优化确实很大，优点不多说。但这里提一句，不要盲目ssr，特别是初次请求响应时间较长的接口\n\n## 二、网络的影响  \n首先了解两个概念：  \n\n* 带宽:  数据吞吐量(比特/秒)\n* 延迟: 延迟数据传输时间(ms)\n\n  \n对于大部分市场来说，带宽是可以满足需求的(这里统计是国外的，平均26兆，国内略低一点)，平均页面大小3.5Mb。传输时间（3.5/26）0.13s。国内会差一点。\n延迟对性能影响比较明显。\n移动网络的延迟  \n\n| 网络 | 延迟ms |\n| --- | :-- |\n| 5G | <=4 |\n| 4G | <=100 |\n| 3G | 100-500 |\n| 3G | 300-1000 |\n\n### 适应移动网络的限制   \n\n应该从下面几方面来分别考虑。   \n  \n* 减少请求数量\n* 优化关键路径  \n* 减少请求大小  \n\n### 2.1 减少请求数量   \n\n#### 新建一次连接的代价是昂贵的，要重复以下过程  \n建立连接需要1至3+响应在数据相应之前。   \n \n1. DNS 查询(可能) \n2. TLS 握手(可能)\n3. 请求资源      \n\n\n#### 初始状态连接不能被充分利用  \n\nTCP slow-start限制了在初始响应里里数据被发送的数量  \n\n#### 发送更多的数据通常情况下比新建连接要划算。    \n\n请求的体积与相应时间并不是线性关系。  \n两次50k的请求消耗比一次100k的大了不少。   \n  \n#### 减少重定向的使用    \n\n* 重定向增加了服务器昂贵的循环  \n* server-side 相对于client-side来说重定向优秀一点（快并且可缓存）\n* 看一下301和302的响应code    \n\n\n#### 使用缓存  \n理想状态下，确实资源是否最新不应该通过网络请求  \n可以通过下面的方式：    \n\n* 使用Content-addressed URLs: \n      即内容与地址对应，log13234d.jpg而非log.jpg    \n* 使用max-age   \n\n这种浏览器调整为Facebook节省了60%的请求  \n\n#### 使用service workers来增强缓存  \n\nservice worker可以帮组我们：  \n  \n* 拦截网络请求 \n* 访问浏览器缓存  \n* 代替发送网络请求来处理过期的资源  \n\n#### 使用http2  \n使用HTTP2时，每个来源只需要一个连接，减少了连接创建的开销。   \n### 2.2 优化关键路径  \n优化页面渲染或者加载时所需的事件以便尽可能的加快完成。  \n\n#### 浏览器优化资源请求   \n对于所有的请求，浏览器对其是有权重处理的，即分不同的优先级来加载。具体来说就是重要会阻塞渲染的优先级比较高。  \n如下图所示： \n<img src='/img/performance/2.png'> \n  \n#### 使用资源提示  \n通过以下方式，提前加载或者请求将要用到的内容：    \n\n* Dns-prefresh  \n* preconnect\n* preconnect\n* Preload（当前页面）\n* Prefetch(下个页面)  \n\n### 2.3 降低请求大小   \n \n* 使用Brotli压缩    \n   相对于gzip \n    更好的压缩比，文件越大越明显\n    更快的解压缩  \n    压缩速度极大提升\n* 减少js体积  \n* 优化图片\n23就不再多提了，方式有很多。   \n \n### 结束语  \n对于好的资源，多读收益还是很明显的。这次翻译感觉体会又多了一些，不过由于本人才疏学浅，如有错误还望多多指正。一言概之，共同学习。   \n","source":"_posts/performance.md","raw":"---\ntitle: 硬件、网络及性能\ndate: 2018-05-07\n---\n## 提升现代web app的中的页面性能\n前言，本文翻译自[https://docs.google.com/presentation/d/1hBIb0CshY9DlM1fkxSLXVSW3Srg3CxaxAbdocI67NCQ/edit#slide=id.g32e52b1ea6_1_0](https://docs.google.com/presentation/d/1hBIb0CshY9DlM1fkxSLXVSW3Srg3CxaxAbdocI67NCQ/edit#slide=id.g32e52b1ea6_1_0)看到之后感觉讲解的系统清晰明了，实属一篇好文。就加上自己的理解翻译了一下，聊以加深印象。\n<!-- more -->\n### 硬件、网络，对性能的而言始终不能避开的两个物理因素 \n  \n### 一、 硬件如何影响性能  \n硬件（即处理能力）决定了计算密集型任务的表现  \n浏览器必须解析、编译并执行所有的js，如下如所示：\n<img src='/img/performance/1.png'> \n对于每个阶段而言，代码量的差异显然会影响其变现即影响性能，这种差异在低处理能力的机器上的体现尤为明显。  \n当然其他类型的资源请求也会影响性能，相比之下js的影响是比较突出的。  \n所以考虑不同用户cpu的状况，减少js怪物(即缩小js体积)是很必要的。可以从以下几方面着手：\n1. 删除不必要js\n2. 延迟加载非关键js\n3. 借助相关工具\n### 1.1 删除不必要js\n#### 只在必要的时候进行转换 \n仅仅对需要ES5的客户端才进行转换，80%的浏览器已经支持ES2015。(结合自己实际开发情况，移动端而言确实80%+的手机已经支持ES2015，仅仅只遇到oppop，vivio这两中手机不支持。)因为转换之后的代价还是有的，如下所示:   \n\n```js\n//ES2015\nbooks.map(b => b.title);\n//ES5\nbooks.map(function(b) { return b.title; }, this);\n//体积大了一倍\n```\n#### 使用压缩工具/优化工具  \n像UglifyJS & Closure Compiler 之类的工具，在压缩之外还有一些优化功能。\n对大多数的js而言压缩代码中空格移除和符号修改占了95%的工作量，并非是精心的代码转换。\n压缩不应该是盲目的，应该平衡下面几点。  \n* 更好的压缩比\n* 高额的计算机资源消耗\n* 前期准备\n* 可能的副作用 \n压缩可能不是一味的追求体积更小，相对而言，压缩也应该权衡一下其他方面。比较常见就是代码压缩时相比于其他流程，超长的时间消耗。压缩之后可能遇到关键字的问题。  \n如何解决其实应该是从本身项目出发。\n* 尽可能的优化可缓存的静态资源\n* 在压缩体积和时间之间找到一个平衡点  \n\n#### 使用tree-shaking移除没用的代码  \n和压缩代码的目的一致，减小资源大小，不过是从另一个层面的解决方案。像webpack，rollup都提供了该功能。  \ntree-shaking会将没有被用到的exports移除  \n\n```js\n//tool \n//used\nexport function a(){\n    console.log('1')\n}\nexport function b(){\n    console.log('2')\n}\n//app.js\nimport {a} from './tool'\na()\n```   \n \nfunction b 未被使用，最终的打包文件中b将会被删除。\n#### ES2015的模块是静态的，可以使用tree-shaking  \nimport/export 在执行之前就被确定，并且两者只能在顶层，没有条件逻辑的情况下使用(毕竟未执行)  \n#### tree-shaking的局限  \n  \n* 仅仅删除未被使用的导出  \n* 不支持所有的代码库（仅仅ES2015） \n* 可能做不到极致  \n   难以确定删除是否会有副作用，这种打包器只能保留    \n   \n#### 自我排查  \n工具不能做到尽善尽美，并且在执行之前确定某项问题是困难的。  \n当前来说应该从代码规范和代码注释来自我完善。  \n#### 对于框架   \n如果非必须，请不要使用。大的框架至少300kb的体积。   \n当然必要，请基于下面几点来选择：   \n \n* 服务端渲染  \n* 懒加载 \n* 代码优化    \n* 性能  \n\n\n### 1.2 延迟加载非必需js   \n  \n先看一下js不同引入方式的差别  \n\n|  | 默认方式 | Async | Defer |\n| --- | --- | --- | --- |\n| 阻塞渲染 | 是 | 否 | 否 |\n| 执行时机 | 加载完成 | 加载完成 | document解析完成 |\n\n#### 使用代码分割和懒加载  \n* 减少启动时需要加载的js  \n* 尽可能少的加载不相关的js   \n传统的做法是加载Bundle js，代码分割是将代码分成不同的chunk  \n这里同样有两种极端：  \n* 每个模块对应一个js  \n    不好压缩  \n    利于缓存  \n    粒度更小\n* 整个应用只对应一个js   \n    便于压缩  \n    不利于缓存  \n    粒度太大，即可维护性\n忽然有种中庸的感觉了，凡事皆有度，所有单一操作都不能过分苛求极致，兼顾才是合理\n### 1.3 使用其他工具  \n#### 使用html和css   \n某些状况下可能需要vanilla JS(即原生js)，框架带来便利的同时不可避免的有其他的一些性能消耗。提到这里有一篇文章大家可以看一下[我是怎么把我的 React 应用换成 VanillaJS 的（这是不是一个坏主意）](https://www.w3ctech.com/topic/1978)\n举个例子：\nNetflix 降低了他们登录页50%的TTI（传输时间间隔）通过下面的方式：\n* 使用原生js来代替React\n* 当用户登录的时候加载余下的部分   \n\n#### 使用server\n将代价昂贵的库放到server端,使用ssr来代替client-side-render.  \nssr可以将我们初始页面加载事件减少到原来的1/5并减少不同浏览器之间的差异。\nssr确实首屏的优化确实很大，优点不多说。但这里提一句，不要盲目ssr，特别是初次请求响应时间较长的接口\n\n## 二、网络的影响  \n首先了解两个概念：  \n\n* 带宽:  数据吞吐量(比特/秒)\n* 延迟: 延迟数据传输时间(ms)\n\n  \n对于大部分市场来说，带宽是可以满足需求的(这里统计是国外的，平均26兆，国内略低一点)，平均页面大小3.5Mb。传输时间（3.5/26）0.13s。国内会差一点。\n延迟对性能影响比较明显。\n移动网络的延迟  \n\n| 网络 | 延迟ms |\n| --- | :-- |\n| 5G | <=4 |\n| 4G | <=100 |\n| 3G | 100-500 |\n| 3G | 300-1000 |\n\n### 适应移动网络的限制   \n\n应该从下面几方面来分别考虑。   \n  \n* 减少请求数量\n* 优化关键路径  \n* 减少请求大小  \n\n### 2.1 减少请求数量   \n\n#### 新建一次连接的代价是昂贵的，要重复以下过程  \n建立连接需要1至3+响应在数据相应之前。   \n \n1. DNS 查询(可能) \n2. TLS 握手(可能)\n3. 请求资源      \n\n\n#### 初始状态连接不能被充分利用  \n\nTCP slow-start限制了在初始响应里里数据被发送的数量  \n\n#### 发送更多的数据通常情况下比新建连接要划算。    \n\n请求的体积与相应时间并不是线性关系。  \n两次50k的请求消耗比一次100k的大了不少。   \n  \n#### 减少重定向的使用    \n\n* 重定向增加了服务器昂贵的循环  \n* server-side 相对于client-side来说重定向优秀一点（快并且可缓存）\n* 看一下301和302的响应code    \n\n\n#### 使用缓存  \n理想状态下，确实资源是否最新不应该通过网络请求  \n可以通过下面的方式：    \n\n* 使用Content-addressed URLs: \n      即内容与地址对应，log13234d.jpg而非log.jpg    \n* 使用max-age   \n\n这种浏览器调整为Facebook节省了60%的请求  \n\n#### 使用service workers来增强缓存  \n\nservice worker可以帮组我们：  \n  \n* 拦截网络请求 \n* 访问浏览器缓存  \n* 代替发送网络请求来处理过期的资源  \n\n#### 使用http2  \n使用HTTP2时，每个来源只需要一个连接，减少了连接创建的开销。   \n### 2.2 优化关键路径  \n优化页面渲染或者加载时所需的事件以便尽可能的加快完成。  \n\n#### 浏览器优化资源请求   \n对于所有的请求，浏览器对其是有权重处理的，即分不同的优先级来加载。具体来说就是重要会阻塞渲染的优先级比较高。  \n如下图所示： \n<img src='/img/performance/2.png'> \n  \n#### 使用资源提示  \n通过以下方式，提前加载或者请求将要用到的内容：    \n\n* Dns-prefresh  \n* preconnect\n* preconnect\n* Preload（当前页面）\n* Prefetch(下个页面)  \n\n### 2.3 降低请求大小   \n \n* 使用Brotli压缩    \n   相对于gzip \n    更好的压缩比，文件越大越明显\n    更快的解压缩  \n    压缩速度极大提升\n* 减少js体积  \n* 优化图片\n23就不再多提了，方式有很多。   \n \n### 结束语  \n对于好的资源，多读收益还是很明显的。这次翻译感觉体会又多了一些，不过由于本人才疏学浅，如有错误还望多多指正。一言概之，共同学习。   \n","slug":"performance","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1u000vgw92v9xmimci","content":"<h2 id=\"提升现代web-app的中的页面性能\"><a href=\"#提升现代web-app的中的页面性能\" class=\"headerlink\" title=\"提升现代web app的中的页面性能\"></a>提升现代web app的中的页面性能</h2><p>前言，本文翻译自<a href=\"https://docs.google.com/presentation/d/1hBIb0CshY9DlM1fkxSLXVSW3Srg3CxaxAbdocI67NCQ/edit#slide=id.g32e52b1ea6_1_0\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/presentation/d/1hBIb0CshY9DlM1fkxSLXVSW3Srg3CxaxAbdocI67NCQ/edit#slide=id.g32e52b1ea6_1_0</a>看到之后感觉讲解的系统清晰明了，实属一篇好文。就加上自己的理解翻译了一下，聊以加深印象。<br><a id=\"more\"></a></p>\n<h3 id=\"硬件、网络，对性能的而言始终不能避开的两个物理因素\"><a href=\"#硬件、网络，对性能的而言始终不能避开的两个物理因素\" class=\"headerlink\" title=\"硬件、网络，对性能的而言始终不能避开的两个物理因素\"></a>硬件、网络，对性能的而言始终不能避开的两个物理因素</h3><h3 id=\"一、-硬件如何影响性能\"><a href=\"#一、-硬件如何影响性能\" class=\"headerlink\" title=\"一、 硬件如何影响性能\"></a>一、 硬件如何影响性能</h3><p>硬件（即处理能力）决定了计算密集型任务的表现<br>浏览器必须解析、编译并执行所有的js，如下如所示：<br><img src=\"/img/performance/1.png\"><br>对于每个阶段而言，代码量的差异显然会影响其变现即影响性能，这种差异在低处理能力的机器上的体现尤为明显。<br>当然其他类型的资源请求也会影响性能，相比之下js的影响是比较突出的。<br>所以考虑不同用户cpu的状况，减少js怪物(即缩小js体积)是很必要的。可以从以下几方面着手：</p>\n<ol>\n<li>删除不必要js</li>\n<li>延迟加载非关键js</li>\n<li>借助相关工具<h3 id=\"1-1-删除不必要js\"><a href=\"#1-1-删除不必要js\" class=\"headerlink\" title=\"1.1 删除不必要js\"></a>1.1 删除不必要js</h3><h4 id=\"只在必要的时候进行转换\"><a href=\"#只在必要的时候进行转换\" class=\"headerlink\" title=\"只在必要的时候进行转换\"></a>只在必要的时候进行转换</h4>仅仅对需要ES5的客户端才进行转换，80%的浏览器已经支持ES2015。(结合自己实际开发情况，移动端而言确实80%+的手机已经支持ES2015，仅仅只遇到oppop，vivio这两中手机不支持。)因为转换之后的代价还是有的，如下所示:   </li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES2015</span></span><br><span class=\"line\">books.map(<span class=\"function\"><span class=\"params\">b</span> =&gt;</span> b.title);</span><br><span class=\"line\"><span class=\"comment\">//ES5</span></span><br><span class=\"line\">books.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123; <span class=\"keyword\">return</span> b.title; &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"comment\">//体积大了一倍</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用压缩工具-优化工具\"><a href=\"#使用压缩工具-优化工具\" class=\"headerlink\" title=\"使用压缩工具/优化工具\"></a>使用压缩工具/优化工具</h4><p>像UglifyJS &amp; Closure Compiler 之类的工具，在压缩之外还有一些优化功能。<br>对大多数的js而言压缩代码中空格移除和符号修改占了95%的工作量，并非是精心的代码转换。<br>压缩不应该是盲目的，应该平衡下面几点。  </p>\n<ul>\n<li>更好的压缩比</li>\n<li>高额的计算机资源消耗</li>\n<li>前期准备</li>\n<li>可能的副作用<br>压缩可能不是一味的追求体积更小，相对而言，压缩也应该权衡一下其他方面。比较常见就是代码压缩时相比于其他流程，超长的时间消耗。压缩之后可能遇到关键字的问题。<br>如何解决其实应该是从本身项目出发。</li>\n<li>尽可能的优化可缓存的静态资源</li>\n<li>在压缩体积和时间之间找到一个平衡点  </li>\n</ul>\n<h4 id=\"使用tree-shaking移除没用的代码\"><a href=\"#使用tree-shaking移除没用的代码\" class=\"headerlink\" title=\"使用tree-shaking移除没用的代码\"></a>使用tree-shaking移除没用的代码</h4><p>和压缩代码的目的一致，减小资源大小，不过是从另一个层面的解决方案。像webpack，rollup都提供了该功能。<br>tree-shaking会将没有被用到的exports移除  </p>\n<pre><code class=\"js\"><span class=\"comment\">//tool </span>\n<span class=\"comment\">//used</span>\n<span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>{\n    <span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>)\n}\n<span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>)</span>{\n    <span class=\"built_in\">console</span>.log(<span class=\"string\">'2'</span>)\n}\n<span class=\"comment\">//app.js</span>\n<span class=\"keyword\">import</span> {a} <span class=\"keyword\">from</span> <span class=\"string\">'./tool'</span>\na()\n</code></pre>\n<p>function b 未被使用，最终的打包文件中b将会被删除。</p>\n<h4 id=\"ES2015的模块是静态的，可以使用tree-shaking\"><a href=\"#ES2015的模块是静态的，可以使用tree-shaking\" class=\"headerlink\" title=\"ES2015的模块是静态的，可以使用tree-shaking\"></a>ES2015的模块是静态的，可以使用tree-shaking</h4><p>import/export 在执行之前就被确定，并且两者只能在顶层，没有条件逻辑的情况下使用(毕竟未执行)  </p>\n<h4 id=\"tree-shaking的局限\"><a href=\"#tree-shaking的局限\" class=\"headerlink\" title=\"tree-shaking的局限\"></a>tree-shaking的局限</h4><ul>\n<li>仅仅删除未被使用的导出  </li>\n<li>不支持所有的代码库（仅仅ES2015） </li>\n<li>可能做不到极致<br> 难以确定删除是否会有副作用，这种打包器只能保留    </li>\n</ul>\n<h4 id=\"自我排查\"><a href=\"#自我排查\" class=\"headerlink\" title=\"自我排查\"></a>自我排查</h4><p>工具不能做到尽善尽美，并且在执行之前确定某项问题是困难的。<br>当前来说应该从代码规范和代码注释来自我完善。  </p>\n<h4 id=\"对于框架\"><a href=\"#对于框架\" class=\"headerlink\" title=\"对于框架\"></a>对于框架</h4><p>如果非必须，请不要使用。大的框架至少300kb的体积。<br>当然必要，请基于下面几点来选择：   </p>\n<ul>\n<li>服务端渲染  </li>\n<li>懒加载 </li>\n<li>代码优化    </li>\n<li>性能  </li>\n</ul>\n<h3 id=\"1-2-延迟加载非必需js\"><a href=\"#1-2-延迟加载非必需js\" class=\"headerlink\" title=\"1.2 延迟加载非必需js\"></a>1.2 延迟加载非必需js</h3><p>先看一下js不同引入方式的差别  </p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>默认方式</th>\n<th>Async</th>\n<th>Defer</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>阻塞渲染</td>\n<td>是</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td>执行时机</td>\n<td>加载完成</td>\n<td>加载完成</td>\n<td>document解析完成</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用代码分割和懒加载\"><a href=\"#使用代码分割和懒加载\" class=\"headerlink\" title=\"使用代码分割和懒加载\"></a>使用代码分割和懒加载</h4><ul>\n<li>减少启动时需要加载的js  </li>\n<li>尽可能少的加载不相关的js<br>传统的做法是加载Bundle js，代码分割是将代码分成不同的chunk<br>这里同样有两种极端：  </li>\n<li>每个模块对应一个js<br>  不好压缩<br>  利于缓存<br>  粒度更小</li>\n<li>整个应用只对应一个js<br>  便于压缩<br>  不利于缓存<br>  粒度太大，即可维护性<br>忽然有种中庸的感觉了，凡事皆有度，所有单一操作都不能过分苛求极致，兼顾才是合理<h3 id=\"1-3-使用其他工具\"><a href=\"#1-3-使用其他工具\" class=\"headerlink\" title=\"1.3 使用其他工具\"></a>1.3 使用其他工具</h3><h4 id=\"使用html和css\"><a href=\"#使用html和css\" class=\"headerlink\" title=\"使用html和css\"></a>使用html和css</h4>某些状况下可能需要vanilla JS(即原生js)，框架带来便利的同时不可避免的有其他的一些性能消耗。提到这里有一篇文章大家可以看一下<a href=\"https://www.w3ctech.com/topic/1978\" target=\"_blank\" rel=\"noopener\">我是怎么把我的 React 应用换成 VanillaJS 的（这是不是一个坏主意）</a><br>举个例子：<br>Netflix 降低了他们登录页50%的TTI（传输时间间隔）通过下面的方式：</li>\n<li>使用原生js来代替React</li>\n<li>当用户登录的时候加载余下的部分   </li>\n</ul>\n<h4 id=\"使用server\"><a href=\"#使用server\" class=\"headerlink\" title=\"使用server\"></a>使用server</h4><p>将代价昂贵的库放到server端,使用ssr来代替client-side-render.<br>ssr可以将我们初始页面加载事件减少到原来的1/5并减少不同浏览器之间的差异。<br>ssr确实首屏的优化确实很大，优点不多说。但这里提一句，不要盲目ssr，特别是初次请求响应时间较长的接口</p>\n<h2 id=\"二、网络的影响\"><a href=\"#二、网络的影响\" class=\"headerlink\" title=\"二、网络的影响\"></a>二、网络的影响</h2><p>首先了解两个概念：  </p>\n<ul>\n<li>带宽:  数据吞吐量(比特/秒)</li>\n<li>延迟: 延迟数据传输时间(ms)</li>\n</ul>\n<p>对于大部分市场来说，带宽是可以满足需求的(这里统计是国外的，平均26兆，国内略低一点)，平均页面大小3.5Mb。传输时间（3.5/26）0.13s。国内会差一点。<br>延迟对性能影响比较明显。<br>移动网络的延迟  </p>\n<table>\n<thead>\n<tr>\n<th>网络</th>\n<th style=\"text-align:left\">延迟ms</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5G</td>\n<td style=\"text-align:left\">&lt;=4</td>\n</tr>\n<tr>\n<td>4G</td>\n<td style=\"text-align:left\">&lt;=100</td>\n</tr>\n<tr>\n<td>3G</td>\n<td style=\"text-align:left\">100-500</td>\n</tr>\n<tr>\n<td>3G</td>\n<td style=\"text-align:left\">300-1000</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"适应移动网络的限制\"><a href=\"#适应移动网络的限制\" class=\"headerlink\" title=\"适应移动网络的限制\"></a>适应移动网络的限制</h3><p>应该从下面几方面来分别考虑。   </p>\n<ul>\n<li>减少请求数量</li>\n<li>优化关键路径  </li>\n<li>减少请求大小  </li>\n</ul>\n<h3 id=\"2-1-减少请求数量\"><a href=\"#2-1-减少请求数量\" class=\"headerlink\" title=\"2.1 减少请求数量\"></a>2.1 减少请求数量</h3><h4 id=\"新建一次连接的代价是昂贵的，要重复以下过程\"><a href=\"#新建一次连接的代价是昂贵的，要重复以下过程\" class=\"headerlink\" title=\"新建一次连接的代价是昂贵的，要重复以下过程\"></a>新建一次连接的代价是昂贵的，要重复以下过程</h4><p>建立连接需要1至3+响应在数据相应之前。   </p>\n<ol>\n<li>DNS 查询(可能) </li>\n<li>TLS 握手(可能)</li>\n<li>请求资源      </li>\n</ol>\n<h4 id=\"初始状态连接不能被充分利用\"><a href=\"#初始状态连接不能被充分利用\" class=\"headerlink\" title=\"初始状态连接不能被充分利用\"></a>初始状态连接不能被充分利用</h4><p>TCP slow-start限制了在初始响应里里数据被发送的数量  </p>\n<h4 id=\"发送更多的数据通常情况下比新建连接要划算。\"><a href=\"#发送更多的数据通常情况下比新建连接要划算。\" class=\"headerlink\" title=\"发送更多的数据通常情况下比新建连接要划算。\"></a>发送更多的数据通常情况下比新建连接要划算。</h4><p>请求的体积与相应时间并不是线性关系。<br>两次50k的请求消耗比一次100k的大了不少。   </p>\n<h4 id=\"减少重定向的使用\"><a href=\"#减少重定向的使用\" class=\"headerlink\" title=\"减少重定向的使用\"></a>减少重定向的使用</h4><ul>\n<li>重定向增加了服务器昂贵的循环  </li>\n<li>server-side 相对于client-side来说重定向优秀一点（快并且可缓存）</li>\n<li>看一下301和302的响应code    </li>\n</ul>\n<h4 id=\"使用缓存\"><a href=\"#使用缓存\" class=\"headerlink\" title=\"使用缓存\"></a>使用缓存</h4><p>理想状态下，确实资源是否最新不应该通过网络请求<br>可以通过下面的方式：    </p>\n<ul>\n<li>使用Content-addressed URLs: <pre><code>即内容与地址对应，log13234d.jpg而非log.jpg    \n</code></pre></li>\n<li>使用max-age   </li>\n</ul>\n<p>这种浏览器调整为Facebook节省了60%的请求  </p>\n<h4 id=\"使用service-workers来增强缓存\"><a href=\"#使用service-workers来增强缓存\" class=\"headerlink\" title=\"使用service workers来增强缓存\"></a>使用service workers来增强缓存</h4><p>service worker可以帮组我们：  </p>\n<ul>\n<li>拦截网络请求 </li>\n<li>访问浏览器缓存  </li>\n<li>代替发送网络请求来处理过期的资源  </li>\n</ul>\n<h4 id=\"使用http2\"><a href=\"#使用http2\" class=\"headerlink\" title=\"使用http2\"></a>使用http2</h4><p>使用HTTP2时，每个来源只需要一个连接，减少了连接创建的开销。   </p>\n<h3 id=\"2-2-优化关键路径\"><a href=\"#2-2-优化关键路径\" class=\"headerlink\" title=\"2.2 优化关键路径\"></a>2.2 优化关键路径</h3><p>优化页面渲染或者加载时所需的事件以便尽可能的加快完成。  </p>\n<h4 id=\"浏览器优化资源请求\"><a href=\"#浏览器优化资源请求\" class=\"headerlink\" title=\"浏览器优化资源请求\"></a>浏览器优化资源请求</h4><p>对于所有的请求，浏览器对其是有权重处理的，即分不同的优先级来加载。具体来说就是重要会阻塞渲染的优先级比较高。<br>如下图所示：<br><img src=\"/img/performance/2.png\"> </p>\n<h4 id=\"使用资源提示\"><a href=\"#使用资源提示\" class=\"headerlink\" title=\"使用资源提示\"></a>使用资源提示</h4><p>通过以下方式，提前加载或者请求将要用到的内容：    </p>\n<ul>\n<li>Dns-prefresh  </li>\n<li>preconnect</li>\n<li>preconnect</li>\n<li>Preload（当前页面）</li>\n<li>Prefetch(下个页面)  </li>\n</ul>\n<h3 id=\"2-3-降低请求大小\"><a href=\"#2-3-降低请求大小\" class=\"headerlink\" title=\"2.3 降低请求大小\"></a>2.3 降低请求大小</h3><ul>\n<li>使用Brotli压缩<br> 相对于gzip<br>  更好的压缩比，文件越大越明显<br>  更快的解压缩<br>  压缩速度极大提升</li>\n<li>减少js体积  </li>\n<li>优化图片<br>23就不再多提了，方式有很多。   </li>\n</ul>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>对于好的资源，多读收益还是很明显的。这次翻译感觉体会又多了一些，不过由于本人才疏学浅，如有错误还望多多指正。一言概之，共同学习。   </p>\n","site":{"data":{}},"excerpt":"<h2 id=\"提升现代web-app的中的页面性能\"><a href=\"#提升现代web-app的中的页面性能\" class=\"headerlink\" title=\"提升现代web app的中的页面性能\"></a>提升现代web app的中的页面性能</h2><p>前言，本文翻译自<a href=\"https://docs.google.com/presentation/d/1hBIb0CshY9DlM1fkxSLXVSW3Srg3CxaxAbdocI67NCQ/edit#slide=id.g32e52b1ea6_1_0\" target=\"_blank\" rel=\"noopener\">https://docs.google.com/presentation/d/1hBIb0CshY9DlM1fkxSLXVSW3Srg3CxaxAbdocI67NCQ/edit#slide=id.g32e52b1ea6_1_0</a>看到之后感觉讲解的系统清晰明了，实属一篇好文。就加上自己的理解翻译了一下，聊以加深印象。<br>","more":"</p>\n<h3 id=\"硬件、网络，对性能的而言始终不能避开的两个物理因素\"><a href=\"#硬件、网络，对性能的而言始终不能避开的两个物理因素\" class=\"headerlink\" title=\"硬件、网络，对性能的而言始终不能避开的两个物理因素\"></a>硬件、网络，对性能的而言始终不能避开的两个物理因素</h3><h3 id=\"一、-硬件如何影响性能\"><a href=\"#一、-硬件如何影响性能\" class=\"headerlink\" title=\"一、 硬件如何影响性能\"></a>一、 硬件如何影响性能</h3><p>硬件（即处理能力）决定了计算密集型任务的表现<br>浏览器必须解析、编译并执行所有的js，如下如所示：<br><img src=\"/img/performance/1.png\"><br>对于每个阶段而言，代码量的差异显然会影响其变现即影响性能，这种差异在低处理能力的机器上的体现尤为明显。<br>当然其他类型的资源请求也会影响性能，相比之下js的影响是比较突出的。<br>所以考虑不同用户cpu的状况，减少js怪物(即缩小js体积)是很必要的。可以从以下几方面着手：</p>\n<ol>\n<li>删除不必要js</li>\n<li>延迟加载非关键js</li>\n<li>借助相关工具<h3 id=\"1-1-删除不必要js\"><a href=\"#1-1-删除不必要js\" class=\"headerlink\" title=\"1.1 删除不必要js\"></a>1.1 删除不必要js</h3><h4 id=\"只在必要的时候进行转换\"><a href=\"#只在必要的时候进行转换\" class=\"headerlink\" title=\"只在必要的时候进行转换\"></a>只在必要的时候进行转换</h4>仅仅对需要ES5的客户端才进行转换，80%的浏览器已经支持ES2015。(结合自己实际开发情况，移动端而言确实80%+的手机已经支持ES2015，仅仅只遇到oppop，vivio这两中手机不支持。)因为转换之后的代价还是有的，如下所示:   </li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ES2015</span></span><br><span class=\"line\">books.map(<span class=\"function\"><span class=\"params\">b</span> =&gt;</span> b.title);</span><br><span class=\"line\"><span class=\"comment\">//ES5</span></span><br><span class=\"line\">books.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123; <span class=\"keyword\">return</span> b.title; &#125;, <span class=\"keyword\">this</span>);</span><br><span class=\"line\"><span class=\"comment\">//体积大了一倍</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"使用压缩工具-优化工具\"><a href=\"#使用压缩工具-优化工具\" class=\"headerlink\" title=\"使用压缩工具/优化工具\"></a>使用压缩工具/优化工具</h4><p>像UglifyJS &amp; Closure Compiler 之类的工具，在压缩之外还有一些优化功能。<br>对大多数的js而言压缩代码中空格移除和符号修改占了95%的工作量，并非是精心的代码转换。<br>压缩不应该是盲目的，应该平衡下面几点。  </p>\n<ul>\n<li>更好的压缩比</li>\n<li>高额的计算机资源消耗</li>\n<li>前期准备</li>\n<li>可能的副作用<br>压缩可能不是一味的追求体积更小，相对而言，压缩也应该权衡一下其他方面。比较常见就是代码压缩时相比于其他流程，超长的时间消耗。压缩之后可能遇到关键字的问题。<br>如何解决其实应该是从本身项目出发。</li>\n<li>尽可能的优化可缓存的静态资源</li>\n<li>在压缩体积和时间之间找到一个平衡点  </li>\n</ul>\n<h4 id=\"使用tree-shaking移除没用的代码\"><a href=\"#使用tree-shaking移除没用的代码\" class=\"headerlink\" title=\"使用tree-shaking移除没用的代码\"></a>使用tree-shaking移除没用的代码</h4><p>和压缩代码的目的一致，减小资源大小，不过是从另一个层面的解决方案。像webpack，rollup都提供了该功能。<br>tree-shaking会将没有被用到的exports移除  </p>\n<pre><code class=\"js\"><span class=\"comment\">//tool </span>\n<span class=\"comment\">//used</span>\n<span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>)</span>{\n    <span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>)\n}\n<span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>)</span>{\n    <span class=\"built_in\">console</span>.log(<span class=\"string\">'2'</span>)\n}\n<span class=\"comment\">//app.js</span>\n<span class=\"keyword\">import</span> {a} <span class=\"keyword\">from</span> <span class=\"string\">'./tool'</span>\na()\n</code></pre>\n<p>function b 未被使用，最终的打包文件中b将会被删除。</p>\n<h4 id=\"ES2015的模块是静态的，可以使用tree-shaking\"><a href=\"#ES2015的模块是静态的，可以使用tree-shaking\" class=\"headerlink\" title=\"ES2015的模块是静态的，可以使用tree-shaking\"></a>ES2015的模块是静态的，可以使用tree-shaking</h4><p>import/export 在执行之前就被确定，并且两者只能在顶层，没有条件逻辑的情况下使用(毕竟未执行)  </p>\n<h4 id=\"tree-shaking的局限\"><a href=\"#tree-shaking的局限\" class=\"headerlink\" title=\"tree-shaking的局限\"></a>tree-shaking的局限</h4><ul>\n<li>仅仅删除未被使用的导出  </li>\n<li>不支持所有的代码库（仅仅ES2015） </li>\n<li>可能做不到极致<br> 难以确定删除是否会有副作用，这种打包器只能保留    </li>\n</ul>\n<h4 id=\"自我排查\"><a href=\"#自我排查\" class=\"headerlink\" title=\"自我排查\"></a>自我排查</h4><p>工具不能做到尽善尽美，并且在执行之前确定某项问题是困难的。<br>当前来说应该从代码规范和代码注释来自我完善。  </p>\n<h4 id=\"对于框架\"><a href=\"#对于框架\" class=\"headerlink\" title=\"对于框架\"></a>对于框架</h4><p>如果非必须，请不要使用。大的框架至少300kb的体积。<br>当然必要，请基于下面几点来选择：   </p>\n<ul>\n<li>服务端渲染  </li>\n<li>懒加载 </li>\n<li>代码优化    </li>\n<li>性能  </li>\n</ul>\n<h3 id=\"1-2-延迟加载非必需js\"><a href=\"#1-2-延迟加载非必需js\" class=\"headerlink\" title=\"1.2 延迟加载非必需js\"></a>1.2 延迟加载非必需js</h3><p>先看一下js不同引入方式的差别  </p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>默认方式</th>\n<th>Async</th>\n<th>Defer</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>阻塞渲染</td>\n<td>是</td>\n<td>否</td>\n<td>否</td>\n</tr>\n<tr>\n<td>执行时机</td>\n<td>加载完成</td>\n<td>加载完成</td>\n<td>document解析完成</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"使用代码分割和懒加载\"><a href=\"#使用代码分割和懒加载\" class=\"headerlink\" title=\"使用代码分割和懒加载\"></a>使用代码分割和懒加载</h4><ul>\n<li>减少启动时需要加载的js  </li>\n<li>尽可能少的加载不相关的js<br>传统的做法是加载Bundle js，代码分割是将代码分成不同的chunk<br>这里同样有两种极端：  </li>\n<li>每个模块对应一个js<br>  不好压缩<br>  利于缓存<br>  粒度更小</li>\n<li>整个应用只对应一个js<br>  便于压缩<br>  不利于缓存<br>  粒度太大，即可维护性<br>忽然有种中庸的感觉了，凡事皆有度，所有单一操作都不能过分苛求极致，兼顾才是合理<h3 id=\"1-3-使用其他工具\"><a href=\"#1-3-使用其他工具\" class=\"headerlink\" title=\"1.3 使用其他工具\"></a>1.3 使用其他工具</h3><h4 id=\"使用html和css\"><a href=\"#使用html和css\" class=\"headerlink\" title=\"使用html和css\"></a>使用html和css</h4>某些状况下可能需要vanilla JS(即原生js)，框架带来便利的同时不可避免的有其他的一些性能消耗。提到这里有一篇文章大家可以看一下<a href=\"https://www.w3ctech.com/topic/1978\" target=\"_blank\" rel=\"noopener\">我是怎么把我的 React 应用换成 VanillaJS 的（这是不是一个坏主意）</a><br>举个例子：<br>Netflix 降低了他们登录页50%的TTI（传输时间间隔）通过下面的方式：</li>\n<li>使用原生js来代替React</li>\n<li>当用户登录的时候加载余下的部分   </li>\n</ul>\n<h4 id=\"使用server\"><a href=\"#使用server\" class=\"headerlink\" title=\"使用server\"></a>使用server</h4><p>将代价昂贵的库放到server端,使用ssr来代替client-side-render.<br>ssr可以将我们初始页面加载事件减少到原来的1/5并减少不同浏览器之间的差异。<br>ssr确实首屏的优化确实很大，优点不多说。但这里提一句，不要盲目ssr，特别是初次请求响应时间较长的接口</p>\n<h2 id=\"二、网络的影响\"><a href=\"#二、网络的影响\" class=\"headerlink\" title=\"二、网络的影响\"></a>二、网络的影响</h2><p>首先了解两个概念：  </p>\n<ul>\n<li>带宽:  数据吞吐量(比特/秒)</li>\n<li>延迟: 延迟数据传输时间(ms)</li>\n</ul>\n<p>对于大部分市场来说，带宽是可以满足需求的(这里统计是国外的，平均26兆，国内略低一点)，平均页面大小3.5Mb。传输时间（3.5/26）0.13s。国内会差一点。<br>延迟对性能影响比较明显。<br>移动网络的延迟  </p>\n<table>\n<thead>\n<tr>\n<th>网络</th>\n<th style=\"text-align:left\">延迟ms</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>5G</td>\n<td style=\"text-align:left\">&lt;=4</td>\n</tr>\n<tr>\n<td>4G</td>\n<td style=\"text-align:left\">&lt;=100</td>\n</tr>\n<tr>\n<td>3G</td>\n<td style=\"text-align:left\">100-500</td>\n</tr>\n<tr>\n<td>3G</td>\n<td style=\"text-align:left\">300-1000</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"适应移动网络的限制\"><a href=\"#适应移动网络的限制\" class=\"headerlink\" title=\"适应移动网络的限制\"></a>适应移动网络的限制</h3><p>应该从下面几方面来分别考虑。   </p>\n<ul>\n<li>减少请求数量</li>\n<li>优化关键路径  </li>\n<li>减少请求大小  </li>\n</ul>\n<h3 id=\"2-1-减少请求数量\"><a href=\"#2-1-减少请求数量\" class=\"headerlink\" title=\"2.1 减少请求数量\"></a>2.1 减少请求数量</h3><h4 id=\"新建一次连接的代价是昂贵的，要重复以下过程\"><a href=\"#新建一次连接的代价是昂贵的，要重复以下过程\" class=\"headerlink\" title=\"新建一次连接的代价是昂贵的，要重复以下过程\"></a>新建一次连接的代价是昂贵的，要重复以下过程</h4><p>建立连接需要1至3+响应在数据相应之前。   </p>\n<ol>\n<li>DNS 查询(可能) </li>\n<li>TLS 握手(可能)</li>\n<li>请求资源      </li>\n</ol>\n<h4 id=\"初始状态连接不能被充分利用\"><a href=\"#初始状态连接不能被充分利用\" class=\"headerlink\" title=\"初始状态连接不能被充分利用\"></a>初始状态连接不能被充分利用</h4><p>TCP slow-start限制了在初始响应里里数据被发送的数量  </p>\n<h4 id=\"发送更多的数据通常情况下比新建连接要划算。\"><a href=\"#发送更多的数据通常情况下比新建连接要划算。\" class=\"headerlink\" title=\"发送更多的数据通常情况下比新建连接要划算。\"></a>发送更多的数据通常情况下比新建连接要划算。</h4><p>请求的体积与相应时间并不是线性关系。<br>两次50k的请求消耗比一次100k的大了不少。   </p>\n<h4 id=\"减少重定向的使用\"><a href=\"#减少重定向的使用\" class=\"headerlink\" title=\"减少重定向的使用\"></a>减少重定向的使用</h4><ul>\n<li>重定向增加了服务器昂贵的循环  </li>\n<li>server-side 相对于client-side来说重定向优秀一点（快并且可缓存）</li>\n<li>看一下301和302的响应code    </li>\n</ul>\n<h4 id=\"使用缓存\"><a href=\"#使用缓存\" class=\"headerlink\" title=\"使用缓存\"></a>使用缓存</h4><p>理想状态下，确实资源是否最新不应该通过网络请求<br>可以通过下面的方式：    </p>\n<ul>\n<li>使用Content-addressed URLs: <pre><code>即内容与地址对应，log13234d.jpg而非log.jpg    \n</code></pre></li>\n<li>使用max-age   </li>\n</ul>\n<p>这种浏览器调整为Facebook节省了60%的请求  </p>\n<h4 id=\"使用service-workers来增强缓存\"><a href=\"#使用service-workers来增强缓存\" class=\"headerlink\" title=\"使用service workers来增强缓存\"></a>使用service workers来增强缓存</h4><p>service worker可以帮组我们：  </p>\n<ul>\n<li>拦截网络请求 </li>\n<li>访问浏览器缓存  </li>\n<li>代替发送网络请求来处理过期的资源  </li>\n</ul>\n<h4 id=\"使用http2\"><a href=\"#使用http2\" class=\"headerlink\" title=\"使用http2\"></a>使用http2</h4><p>使用HTTP2时，每个来源只需要一个连接，减少了连接创建的开销。   </p>\n<h3 id=\"2-2-优化关键路径\"><a href=\"#2-2-优化关键路径\" class=\"headerlink\" title=\"2.2 优化关键路径\"></a>2.2 优化关键路径</h3><p>优化页面渲染或者加载时所需的事件以便尽可能的加快完成。  </p>\n<h4 id=\"浏览器优化资源请求\"><a href=\"#浏览器优化资源请求\" class=\"headerlink\" title=\"浏览器优化资源请求\"></a>浏览器优化资源请求</h4><p>对于所有的请求，浏览器对其是有权重处理的，即分不同的优先级来加载。具体来说就是重要会阻塞渲染的优先级比较高。<br>如下图所示：<br><img src=\"/img/performance/2.png\"> </p>\n<h4 id=\"使用资源提示\"><a href=\"#使用资源提示\" class=\"headerlink\" title=\"使用资源提示\"></a>使用资源提示</h4><p>通过以下方式，提前加载或者请求将要用到的内容：    </p>\n<ul>\n<li>Dns-prefresh  </li>\n<li>preconnect</li>\n<li>preconnect</li>\n<li>Preload（当前页面）</li>\n<li>Prefetch(下个页面)  </li>\n</ul>\n<h3 id=\"2-3-降低请求大小\"><a href=\"#2-3-降低请求大小\" class=\"headerlink\" title=\"2.3 降低请求大小\"></a>2.3 降低请求大小</h3><ul>\n<li>使用Brotli压缩<br> 相对于gzip<br>  更好的压缩比，文件越大越明显<br>  更快的解压缩<br>  压缩速度极大提升</li>\n<li>减少js体积  </li>\n<li>优化图片<br>23就不再多提了，方式有很多。   </li>\n</ul>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><p>对于好的资源，多读收益还是很明显的。这次翻译感觉体会又多了一些，不过由于本人才疏学浅，如有错误还望多多指正。一言概之，共同学习。   </p>"},{"title":"前文回顾","date":"2017-09-14T16:00:00.000Z","_content":"原先多多少少也写了几十篇文章，也不忍心直接丢下。这里放个链接供自己查看吧。  \n<!-- more -->  \n\n## 文章列表   \n* [node实现一个Websocket服务器](https://juejin.im/post/5a2bf66151882546d71f44b2)\n* [实现一个websocket服务器-理论篇](https://juejin.im/post/5a05d89051882540f36305df)\n* [如何开发webpack plugin](https://juejin.im/post/59e8b724f265da431875dd5c)\n* [移动端踩坑之旅-ios下fixed、软键盘相关问题总结](https://juejin.im/post/59e725865188257e0c3246bf)\n* [如何开发webpack loader](https://juejin.im/post/59e6a5de518825469c7461da)\n* [node实现一个Websocket服务器](http://www.cnblogs.com/pqjwyn/p/8012197.html)\n* [node实现一个Websocket服务器](http://www.cnblogs.com/pqjwyn/p/8012197.html)\n* [node实现一个Websocket服务器](http://www.cnblogs.com/pqjwyn/p/8012197.html)","source":"_posts/review.md","raw":"---\ntitle: 前文回顾\ndate: 2017-09-15\n---\n原先多多少少也写了几十篇文章，也不忍心直接丢下。这里放个链接供自己查看吧。  \n<!-- more -->  \n\n## 文章列表   \n* [node实现一个Websocket服务器](https://juejin.im/post/5a2bf66151882546d71f44b2)\n* [实现一个websocket服务器-理论篇](https://juejin.im/post/5a05d89051882540f36305df)\n* [如何开发webpack plugin](https://juejin.im/post/59e8b724f265da431875dd5c)\n* [移动端踩坑之旅-ios下fixed、软键盘相关问题总结](https://juejin.im/post/59e725865188257e0c3246bf)\n* [如何开发webpack loader](https://juejin.im/post/59e6a5de518825469c7461da)\n* [node实现一个Websocket服务器](http://www.cnblogs.com/pqjwyn/p/8012197.html)\n* [node实现一个Websocket服务器](http://www.cnblogs.com/pqjwyn/p/8012197.html)\n* [node实现一个Websocket服务器](http://www.cnblogs.com/pqjwyn/p/8012197.html)","slug":"review","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1u000wgw92xzha2jpl","content":"<p>原先多多少少也写了几十篇文章，也不忍心直接丢下。这里放个链接供自己查看吧。<br><a id=\"more\"></a>  </p>\n<h2 id=\"文章列表\"><a href=\"#文章列表\" class=\"headerlink\" title=\"文章列表\"></a>文章列表</h2><ul>\n<li><a href=\"https://juejin.im/post/5a2bf66151882546d71f44b2\" target=\"_blank\" rel=\"noopener\">node实现一个Websocket服务器</a></li>\n<li><a href=\"https://juejin.im/post/5a05d89051882540f36305df\" target=\"_blank\" rel=\"noopener\">实现一个websocket服务器-理论篇</a></li>\n<li><a href=\"https://juejin.im/post/59e8b724f265da431875dd5c\" target=\"_blank\" rel=\"noopener\">如何开发webpack plugin</a></li>\n<li><a href=\"https://juejin.im/post/59e725865188257e0c3246bf\" target=\"_blank\" rel=\"noopener\">移动端踩坑之旅-ios下fixed、软键盘相关问题总结</a></li>\n<li><a href=\"https://juejin.im/post/59e6a5de518825469c7461da\" target=\"_blank\" rel=\"noopener\">如何开发webpack loader</a></li>\n<li><a href=\"http://www.cnblogs.com/pqjwyn/p/8012197.html\" target=\"_blank\" rel=\"noopener\">node实现一个Websocket服务器</a></li>\n<li><a href=\"http://www.cnblogs.com/pqjwyn/p/8012197.html\" target=\"_blank\" rel=\"noopener\">node实现一个Websocket服务器</a></li>\n<li><a href=\"http://www.cnblogs.com/pqjwyn/p/8012197.html\" target=\"_blank\" rel=\"noopener\">node实现一个Websocket服务器</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>原先多多少少也写了几十篇文章，也不忍心直接丢下。这里放个链接供自己查看吧。<br>","more":"</p>\n<h2 id=\"文章列表\"><a href=\"#文章列表\" class=\"headerlink\" title=\"文章列表\"></a>文章列表</h2><ul>\n<li><a href=\"https://juejin.im/post/5a2bf66151882546d71f44b2\" target=\"_blank\" rel=\"noopener\">node实现一个Websocket服务器</a></li>\n<li><a href=\"https://juejin.im/post/5a05d89051882540f36305df\" target=\"_blank\" rel=\"noopener\">实现一个websocket服务器-理论篇</a></li>\n<li><a href=\"https://juejin.im/post/59e8b724f265da431875dd5c\" target=\"_blank\" rel=\"noopener\">如何开发webpack plugin</a></li>\n<li><a href=\"https://juejin.im/post/59e725865188257e0c3246bf\" target=\"_blank\" rel=\"noopener\">移动端踩坑之旅-ios下fixed、软键盘相关问题总结</a></li>\n<li><a href=\"https://juejin.im/post/59e6a5de518825469c7461da\" target=\"_blank\" rel=\"noopener\">如何开发webpack loader</a></li>\n<li><a href=\"http://www.cnblogs.com/pqjwyn/p/8012197.html\" target=\"_blank\" rel=\"noopener\">node实现一个Websocket服务器</a></li>\n<li><a href=\"http://www.cnblogs.com/pqjwyn/p/8012197.html\" target=\"_blank\" rel=\"noopener\">node实现一个Websocket服务器</a></li>\n<li><a href=\"http://www.cnblogs.com/pqjwyn/p/8012197.html\" target=\"_blank\" rel=\"noopener\">node实现一个Websocket服务器</a></li>\n</ul>"},{"title":"前端er应该了解的PWA","date":"2018-05-08T16:00:00.000Z","_content":"## 一、传统web 应用  \n当前web应用在移动时代并没有达到其在桌面设备上流行的程度，下面有张图来对比与原生应用之间的差别。     \n<img src='/img/pwa/1.png'/>   \n究其原因，无外乎下面不可避免的几点：\n* 移动设备网络限制-不可忽略的加载时间 \n* web应用依赖于浏览器作为入口  \n* 体验与原生的差距 \n<!-- more -->\n假如能解决以上的几点，对web app 来说会有多大的提升可以想象。\n## 二、PWA是什么  \nPWA 全称Progressive Web Apps(渐进式Web应用程序)，旨在使用现有的web技术提供用户更优的使用体验。\n基本要求    \n \n* 可靠（Reliable）\n    即使在不稳定的网络环境下，也能瞬间加载并展现\n* 快速响应（Fast）\n    快速响应，并且有平滑的动画响应用户的操作\n* 粘性(Engaging)\n    像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面   \n    \nPWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。  \n\n除以上的基准要求外，还应该包括以下特性：  \n\n* 渐进式 - 适用于所有浏览器，因为它是以渐进式增强作为宗旨开发的\n* 连接无关性 - 能够借助 Service Worker 在离线或者网络较差的情况下正常访问\n* 类似应用 - 由于是在 App Shell 模型基础上开发，因为应具有 Native App 的交互和导航，给用户 Native App 的体验\n* 持续更新 - 始终是最新的，无版本和更新问题\n* 安全 - 通过 HTTPS 协议提供服务，防止窥探和确保内容不被篡改\n* 可索引 - 应用清单文件和 Service Worker 可以让搜索引擎索引到，从而将其识别为『应用』\n* 粘性 - 通过推送离线通知等，可以让用户回流\n* 可安装 - 用户可以添加常用的 webapp 到桌面，免去去应用商店下载的麻烦\n* 可链接 - 通过链接即可分享内容，无需下载安装  \n\n\n看起来有点眼花缭乱，这又是一个新的飞起的轮子吗？这里重申一下,PWA背后不是一种新的技术，而是集合当前多种web技术的一种集合。分别利用各自的功能来完成渐进式的整体需求。下面就沿着前面提出的问题分别了解一下相关技术  \n\n## 三、技术组成  \n由以下几种技术构成：  \n\n* App Manifest\n* Service Worker\n* Notifications API\n* Push API  \n\n其中Service Worker是PWA技术的关键，它们可以让app满足上面的三基准。其他技术则是锦上添花，让app更加的强大。 \n### 3.1 service worker背景\n#### 离线缓存背景  \n针对网页的体验，从前到后都做了很多努力，极力去降低响应时间，这里就不表述多样的技术手段。\n另一个方向的就是缓存，减少与服务器非必要的交互，不过对于离线的情况下浏览器缓存就无力了，\n这样离线缓存的需求就出现了。\n#### 离线缓存的历程   \nweb应用在离线缓存发展的过程中也不是一簇而就的，经历了逐渐完善的过程。  \n初期的解决方案是AppCache(原来阿波罗的h5接入过)\n 然而，事实证明这是一个失败的尝试，缺陷太多，已经被废弃了。具体可以查看Application Cache is a douchebag\n但是方向还是正确的，那就继续孜孜不倦的探索。\n#### workers \n持久化先放一边，来谈谈另一个问题\n基于浏览器中的 javaScript 单线程的现实逐渐不能满足现代web需求的现状,例如耗时的计算，用户的交互显然会受影响。\n为了将这些耗时操作从主线程中解放出来，早期W3C新增了一个Web Worker 的 API，可以脱离主线程单独执行，并且可以与主线程交互。\n不过Web Worker是临时性的依赖于创建页面 ，不能满足我们持久化的需求。\n冲着这个目标，下面就比较容易解决了，搞个能持久存在的就行了。\n在Web Worker的基础上，W3C新增了service worker来满足我们持久化的需求。\n其生命周期与页面无关，关联页面未关闭时，它也可以退出，没有关联页面时，它也可以启动\n功能  \n\nService Worker虽然满足了离线缓存来，其功能可不仅仅局限于此。  可以提供  \n\n* 丰富的离线体验，\n* 周期的后台同步，\n* 消息推送通知，\n* 拦截和处理网络请求，\n* 管理资源缓存\n这些正好也是PWA的目的，所以说Service Worker是PWA的关键技术。 \n#### 前提条件\nService Worker 出于安全性和其实现原理，在使用的时候有一定的前提条件。\n* 由于 Service Worker 要求 HTTPS 的环境  \n    当然一般浏览器允许调试 Service Worker 的时候 host 为 localhost 或者 127.0.0.1 \n* Service Worker 的缓存机制是依赖 Cache API (略过)\n* 依赖 HTML5 fetch API（略过）\n* 依赖 Promise 实现   \n由上可知，不是所有的浏览器都支持的，支持情况大概如下：  \n\n <img src='/img/pwa/2.png'/>\niOS 内的所有的浏览器都基于 safari，所以iOS要在11.3以上\nIE是放弃支持了，不过Edge好歹支持了。     \n### 3.2 Cache  \n\nCache是Service Worker衍生出来的API，配合Service Worker实现对资源请求的缓存。\n不过cache并不直接缓存字符串，而是直接缓存资源请求（css、js、html等）。  \ncache也是key-value形式，一般来说key就是request，value就是response   \n \n* caches.open(cacheName) 打开一个cache   \n* caches是global对象，返回一个带有cache返回值的Promise\n* cache.keys() 遍历cache中所有键，得到value的集合\n* cache.match(Request|url) 在cache中匹配传入的request，返回Promise；  \n* cache.matchAll只有第一个参数与match不同，需要一个request的数组，当然返回的结果也是response的数组\n* cache.add(Request|url) 并不是单纯的add，因为传入的是request或者url，在cache.add内部会自动去调用fetch取回request的请求结果，然后才是把response存入cache；\n* cache.addAll类似，通常在sw install的时候用cache.addAll把所有需要缓存的文件都请求一遍\n* cache.put(Request, Response) 这个相当于cache.add的第二步，即fetch到response后存入cache\n* cache.delete(Request|url) 删除缓存     \n\n \n### 3.3 注册Service Worker         \n\n注册即声明sw文件的位置，显然应该在主js中引入。大概如下：  \n\n```js\n//基于promise\nfunction registerServiceWorker(){\n    // 注册service worker\n    return navigator.serviceWorker.register('./sw1.js').then(registration => {\n        console.log('注册成功');\n        // 返回\n        return registration;\n    })\n    .catch(err => {\n        console.error('注册失败', err);\n    });\n}\nwindow.onload = function () {\n    //是否支持\n    if (!('serviceWorker' in navigator)) {\n        return;\n    }\n    registerServiceWorker()\n}\n```   \n### 3.4 生命周期      \n\nService worker 有一个独立于web 页面的生命周期。\n如果在网站上安装 serice worker ，你需要注册，注册后浏览器会在后台安装 service worker。然后进入下面的不同阶段。\n激活之后，service worker 将控制所有的页面，纳入它的范围，不过第一次在页面注册 service worker 时不会控制页面，直到它再次加载。\n service worker 生效之后,它会处于下面两种状态之一：  \n \n* service worker 终止来节省内存，\n* 页面发起网络请求后，它将处理请求获取和消息事件。  \n\n\n由上图看知，分为这么几个阶段：  \n  \n* Installing   \n           发生在 Service Worker 注册之后，表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存 \n* Installed\n           Service Worker 已经完成了安装，并且等待其他的 Service Worker 线程被关闭。\n* Activating \n          在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装\n* Activated   \n          在这个状态会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、sync (后台同步)、push (推送)\n* Redundant\n         被替换，即被销毁  \n         \n了解声明周期其实是为了我们在不同时间段去监听事件来完成相应操作。对PWA来说主要两个事件。\n \n* install 事件回调：\n \nevent.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。\nself.skipWaiting()：self 是当前 context 的 global 变量，执行该方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。\n \n* activate 回调：\n \nevent.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。\nself.clients.claim()：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。   \n\n```js \nconst CURCACHE = 'CURCACHE_test_1'\nconst RUNTIME = 'runtime';\nconst CURCACHE_URLS = [\n    './',\n    '/asset/sw.jpg',\n    'index.js'\n]\nself.addEventListener('install',e=>{\n    e.waitUntil(\n      //存储缓存路径对应的资源\n        caches.open(CURCACHE).then(cache=>{\n            cache.addAll(CURCACHE_URLS)\n        }).then(\n            self.skipWaiting()\n        )\n    )\n})  \n  //代理请求，使用缓存，请求发送之前\n  self.addEventListener('fetch', e => {\n    e.respondWith(\n      //缓存是否匹配 \n      caches.match(e.request).then(function(response) {\n        if (response != null) {\n          //命中缓存返回缓存，结束请求\n          return response\n        }\n        //未命中缓存，正常请求\n        return fetch(e.request.url)\n      })\n    )\n  });\n```  \n#### 更新service worker  \n\nservice worker 更新步骤如下：   \n\n* 更新 service worker 的文件   \n           网页打开时服务器会进行对比，保持最新  \n* 新的 service worker 启动install\n* 当前页面生效的依然是老的service worker，新的 service worker 会进入 “waiting” 状态。\n* 页面关闭之后，老的 service worker 会被干掉，新的 servicer worker 接管页面\n* 新的 service worker 生效后会触发 activate 事件  \n\n```js\nconst CURCACHE = 'precache_test_1'\n//假设上个版本的key为precache_test_2 反正不等于CURCACHE\nself.addEventListener('activate', e => {\n  e.waitUntil(\n      //遍历当前缓存keys\n      caches.keys().then(cacheNames=>{\n        return Promise.all(\n          cacheNames.map(function(cacheName) {\n            //是否等于当前key,保留自己\n            if (cacheName !== CURCACHE) {\n              return caches.delete(cacheName);\n            }\n          })\n    )}).then(() => self.clients.claim())\n )\n}) \n```  \n\n这样一个简单的service worker离线缓存完成了。控制台可以看到，来源是service worker  \n\n<img src='/img/pwa/3.png'>\n关闭网络之后再次访问，可以同样得到上面的结果，并且sw.js请求未能拿到，但是不影响，旧的文件依然在，这里证明了每次都回去对比sw文件以确保更新\n<img src='/img/pwa/4.png'>  \n到这里，离线缓存就实现了。   \n  \n## 四、添加到主屏幕  \n\n允许将站点添加至主屏幕，是 PWA 提供的一项重要功能。这样就不用再依赖于浏览器作为平台，符合移动端的用户习惯。  \n\n### manifest.json  \n\n需要 manifest.json 文件去配置应用的图标、名称等基本信息如下：\n \n```js\n{\n    //被提示安装应用时出现的文本\n    \"name\": \"PQJ-PWA\",\n    //添加至主屏幕后的文本\n    \"short_name\":\"PQJ\",\n    \"description\": \"测试demo\",\n    //添加之后，启动地址\n    \"start_url\": \"/index.html\",\n    //图标信息\n    \"icons\": {\n      \"128\": \"/asset/sw.jpg\"\n    },\n    \"developer\": {\n      \"name\": \"pqj\",\n      \"url\": \"\"\n    },\n    \"display\": \"standalone\",\n    \"background_color\": \"#287fc5\",\n    \"theme_color\": \"#fff\",\n    \"permissions\": {\n        \"desktop-notification\": {\n          \"description\": \"Needed for creating system notifications.\"\n        }\n      }\n}  \n```  \n然后以如下方式在html中引入\n\n```js\n<link rel=\"manifest\" href=\"/mainfest.json\" />\n```  \n这样完成之后，移动端安卓使用chrome(亲测),首次访问时会提示是否允许安装到主屏幕，以应用icon的形式出现。\n图片和文字即由配置决定。  \n  \n### 五、消息通知  \n消息通知也是使用service worker的通知功能进行的，允许服务器想用户发生通知，而非用户主动请求才去响应某些行为。   \n正常的通知逻辑需要服务器来参与实现，这次展示只实现功能。   \n \n* 首先申请通知权限\n* 注册service worker \n* 处理逻辑，发送通知  \n\n```js \nfunction getPermission(){\n    return new Promise((resolve, reject) => {\n        //权限获取\n        const permissionPromise = Notification.requestPermission(result => {\n            resolve(result);\n        });\n    }).then(result => {\n            //判断条件\n            if (result === 'granted') {\n                execute();\n            }\n            else {\n                console.log('no permission');\n            }\n        });\n} \n```  \n发送通知  \n\n```js\nfunction execute() {\n    // 允许之后执行\n    registerServiceWorker().then(registration => {\n        // 通知\n        registration.showNotification('Hello World!');\n    });\n}  \n```  \n### 结束语   \n#### 参考文档  \n[https://lavas.baidu.com/doc](https://lavas.baidu.com/doc)  \n[https://developer.mozilla.org/zh-CN/Apps/Progressive](https://developer.mozilla.org/zh-CN/Apps/Progressive)\n至此，本文介绍就结束了，更多请参考[实例](https://github.com/xiaoxiangdaiyu/PWA)虽然PWA目前来看，面对的限制还很多，但是也可以看出web组织在更好的提升web应用方向上做的努力。正如一直提到的那句话，未来可期。\n目前国内百度这方面做的比较成熟，新浪微博已经有了pwa 测试版。\n\n  \n\n","source":"_posts/pwa.md","raw":"---\ntitle: 前端er应该了解的PWA\ndate: 2018-05-09\n---\n## 一、传统web 应用  \n当前web应用在移动时代并没有达到其在桌面设备上流行的程度，下面有张图来对比与原生应用之间的差别。     \n<img src='/img/pwa/1.png'/>   \n究其原因，无外乎下面不可避免的几点：\n* 移动设备网络限制-不可忽略的加载时间 \n* web应用依赖于浏览器作为入口  \n* 体验与原生的差距 \n<!-- more -->\n假如能解决以上的几点，对web app 来说会有多大的提升可以想象。\n## 二、PWA是什么  \nPWA 全称Progressive Web Apps(渐进式Web应用程序)，旨在使用现有的web技术提供用户更优的使用体验。\n基本要求    \n \n* 可靠（Reliable）\n    即使在不稳定的网络环境下，也能瞬间加载并展现\n* 快速响应（Fast）\n    快速响应，并且有平滑的动画响应用户的操作\n* 粘性(Engaging)\n    像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面   \n    \nPWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。  \n\n除以上的基准要求外，还应该包括以下特性：  \n\n* 渐进式 - 适用于所有浏览器，因为它是以渐进式增强作为宗旨开发的\n* 连接无关性 - 能够借助 Service Worker 在离线或者网络较差的情况下正常访问\n* 类似应用 - 由于是在 App Shell 模型基础上开发，因为应具有 Native App 的交互和导航，给用户 Native App 的体验\n* 持续更新 - 始终是最新的，无版本和更新问题\n* 安全 - 通过 HTTPS 协议提供服务，防止窥探和确保内容不被篡改\n* 可索引 - 应用清单文件和 Service Worker 可以让搜索引擎索引到，从而将其识别为『应用』\n* 粘性 - 通过推送离线通知等，可以让用户回流\n* 可安装 - 用户可以添加常用的 webapp 到桌面，免去去应用商店下载的麻烦\n* 可链接 - 通过链接即可分享内容，无需下载安装  \n\n\n看起来有点眼花缭乱，这又是一个新的飞起的轮子吗？这里重申一下,PWA背后不是一种新的技术，而是集合当前多种web技术的一种集合。分别利用各自的功能来完成渐进式的整体需求。下面就沿着前面提出的问题分别了解一下相关技术  \n\n## 三、技术组成  \n由以下几种技术构成：  \n\n* App Manifest\n* Service Worker\n* Notifications API\n* Push API  \n\n其中Service Worker是PWA技术的关键，它们可以让app满足上面的三基准。其他技术则是锦上添花，让app更加的强大。 \n### 3.1 service worker背景\n#### 离线缓存背景  \n针对网页的体验，从前到后都做了很多努力，极力去降低响应时间，这里就不表述多样的技术手段。\n另一个方向的就是缓存，减少与服务器非必要的交互，不过对于离线的情况下浏览器缓存就无力了，\n这样离线缓存的需求就出现了。\n#### 离线缓存的历程   \nweb应用在离线缓存发展的过程中也不是一簇而就的，经历了逐渐完善的过程。  \n初期的解决方案是AppCache(原来阿波罗的h5接入过)\n 然而，事实证明这是一个失败的尝试，缺陷太多，已经被废弃了。具体可以查看Application Cache is a douchebag\n但是方向还是正确的，那就继续孜孜不倦的探索。\n#### workers \n持久化先放一边，来谈谈另一个问题\n基于浏览器中的 javaScript 单线程的现实逐渐不能满足现代web需求的现状,例如耗时的计算，用户的交互显然会受影响。\n为了将这些耗时操作从主线程中解放出来，早期W3C新增了一个Web Worker 的 API，可以脱离主线程单独执行，并且可以与主线程交互。\n不过Web Worker是临时性的依赖于创建页面 ，不能满足我们持久化的需求。\n冲着这个目标，下面就比较容易解决了，搞个能持久存在的就行了。\n在Web Worker的基础上，W3C新增了service worker来满足我们持久化的需求。\n其生命周期与页面无关，关联页面未关闭时，它也可以退出，没有关联页面时，它也可以启动\n功能  \n\nService Worker虽然满足了离线缓存来，其功能可不仅仅局限于此。  可以提供  \n\n* 丰富的离线体验，\n* 周期的后台同步，\n* 消息推送通知，\n* 拦截和处理网络请求，\n* 管理资源缓存\n这些正好也是PWA的目的，所以说Service Worker是PWA的关键技术。 \n#### 前提条件\nService Worker 出于安全性和其实现原理，在使用的时候有一定的前提条件。\n* 由于 Service Worker 要求 HTTPS 的环境  \n    当然一般浏览器允许调试 Service Worker 的时候 host 为 localhost 或者 127.0.0.1 \n* Service Worker 的缓存机制是依赖 Cache API (略过)\n* 依赖 HTML5 fetch API（略过）\n* 依赖 Promise 实现   \n由上可知，不是所有的浏览器都支持的，支持情况大概如下：  \n\n <img src='/img/pwa/2.png'/>\niOS 内的所有的浏览器都基于 safari，所以iOS要在11.3以上\nIE是放弃支持了，不过Edge好歹支持了。     \n### 3.2 Cache  \n\nCache是Service Worker衍生出来的API，配合Service Worker实现对资源请求的缓存。\n不过cache并不直接缓存字符串，而是直接缓存资源请求（css、js、html等）。  \ncache也是key-value形式，一般来说key就是request，value就是response   \n \n* caches.open(cacheName) 打开一个cache   \n* caches是global对象，返回一个带有cache返回值的Promise\n* cache.keys() 遍历cache中所有键，得到value的集合\n* cache.match(Request|url) 在cache中匹配传入的request，返回Promise；  \n* cache.matchAll只有第一个参数与match不同，需要一个request的数组，当然返回的结果也是response的数组\n* cache.add(Request|url) 并不是单纯的add，因为传入的是request或者url，在cache.add内部会自动去调用fetch取回request的请求结果，然后才是把response存入cache；\n* cache.addAll类似，通常在sw install的时候用cache.addAll把所有需要缓存的文件都请求一遍\n* cache.put(Request, Response) 这个相当于cache.add的第二步，即fetch到response后存入cache\n* cache.delete(Request|url) 删除缓存     \n\n \n### 3.3 注册Service Worker         \n\n注册即声明sw文件的位置，显然应该在主js中引入。大概如下：  \n\n```js\n//基于promise\nfunction registerServiceWorker(){\n    // 注册service worker\n    return navigator.serviceWorker.register('./sw1.js').then(registration => {\n        console.log('注册成功');\n        // 返回\n        return registration;\n    })\n    .catch(err => {\n        console.error('注册失败', err);\n    });\n}\nwindow.onload = function () {\n    //是否支持\n    if (!('serviceWorker' in navigator)) {\n        return;\n    }\n    registerServiceWorker()\n}\n```   \n### 3.4 生命周期      \n\nService worker 有一个独立于web 页面的生命周期。\n如果在网站上安装 serice worker ，你需要注册，注册后浏览器会在后台安装 service worker。然后进入下面的不同阶段。\n激活之后，service worker 将控制所有的页面，纳入它的范围，不过第一次在页面注册 service worker 时不会控制页面，直到它再次加载。\n service worker 生效之后,它会处于下面两种状态之一：  \n \n* service worker 终止来节省内存，\n* 页面发起网络请求后，它将处理请求获取和消息事件。  \n\n\n由上图看知，分为这么几个阶段：  \n  \n* Installing   \n           发生在 Service Worker 注册之后，表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存 \n* Installed\n           Service Worker 已经完成了安装，并且等待其他的 Service Worker 线程被关闭。\n* Activating \n          在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装\n* Activated   \n          在这个状态会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、sync (后台同步)、push (推送)\n* Redundant\n         被替换，即被销毁  \n         \n了解声明周期其实是为了我们在不同时间段去监听事件来完成相应操作。对PWA来说主要两个事件。\n \n* install 事件回调：\n \nevent.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。\nself.skipWaiting()：self 是当前 context 的 global 变量，执行该方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。\n \n* activate 回调：\n \nevent.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。\nself.clients.claim()：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。   \n\n```js \nconst CURCACHE = 'CURCACHE_test_1'\nconst RUNTIME = 'runtime';\nconst CURCACHE_URLS = [\n    './',\n    '/asset/sw.jpg',\n    'index.js'\n]\nself.addEventListener('install',e=>{\n    e.waitUntil(\n      //存储缓存路径对应的资源\n        caches.open(CURCACHE).then(cache=>{\n            cache.addAll(CURCACHE_URLS)\n        }).then(\n            self.skipWaiting()\n        )\n    )\n})  \n  //代理请求，使用缓存，请求发送之前\n  self.addEventListener('fetch', e => {\n    e.respondWith(\n      //缓存是否匹配 \n      caches.match(e.request).then(function(response) {\n        if (response != null) {\n          //命中缓存返回缓存，结束请求\n          return response\n        }\n        //未命中缓存，正常请求\n        return fetch(e.request.url)\n      })\n    )\n  });\n```  \n#### 更新service worker  \n\nservice worker 更新步骤如下：   \n\n* 更新 service worker 的文件   \n           网页打开时服务器会进行对比，保持最新  \n* 新的 service worker 启动install\n* 当前页面生效的依然是老的service worker，新的 service worker 会进入 “waiting” 状态。\n* 页面关闭之后，老的 service worker 会被干掉，新的 servicer worker 接管页面\n* 新的 service worker 生效后会触发 activate 事件  \n\n```js\nconst CURCACHE = 'precache_test_1'\n//假设上个版本的key为precache_test_2 反正不等于CURCACHE\nself.addEventListener('activate', e => {\n  e.waitUntil(\n      //遍历当前缓存keys\n      caches.keys().then(cacheNames=>{\n        return Promise.all(\n          cacheNames.map(function(cacheName) {\n            //是否等于当前key,保留自己\n            if (cacheName !== CURCACHE) {\n              return caches.delete(cacheName);\n            }\n          })\n    )}).then(() => self.clients.claim())\n )\n}) \n```  \n\n这样一个简单的service worker离线缓存完成了。控制台可以看到，来源是service worker  \n\n<img src='/img/pwa/3.png'>\n关闭网络之后再次访问，可以同样得到上面的结果，并且sw.js请求未能拿到，但是不影响，旧的文件依然在，这里证明了每次都回去对比sw文件以确保更新\n<img src='/img/pwa/4.png'>  \n到这里，离线缓存就实现了。   \n  \n## 四、添加到主屏幕  \n\n允许将站点添加至主屏幕，是 PWA 提供的一项重要功能。这样就不用再依赖于浏览器作为平台，符合移动端的用户习惯。  \n\n### manifest.json  \n\n需要 manifest.json 文件去配置应用的图标、名称等基本信息如下：\n \n```js\n{\n    //被提示安装应用时出现的文本\n    \"name\": \"PQJ-PWA\",\n    //添加至主屏幕后的文本\n    \"short_name\":\"PQJ\",\n    \"description\": \"测试demo\",\n    //添加之后，启动地址\n    \"start_url\": \"/index.html\",\n    //图标信息\n    \"icons\": {\n      \"128\": \"/asset/sw.jpg\"\n    },\n    \"developer\": {\n      \"name\": \"pqj\",\n      \"url\": \"\"\n    },\n    \"display\": \"standalone\",\n    \"background_color\": \"#287fc5\",\n    \"theme_color\": \"#fff\",\n    \"permissions\": {\n        \"desktop-notification\": {\n          \"description\": \"Needed for creating system notifications.\"\n        }\n      }\n}  \n```  \n然后以如下方式在html中引入\n\n```js\n<link rel=\"manifest\" href=\"/mainfest.json\" />\n```  \n这样完成之后，移动端安卓使用chrome(亲测),首次访问时会提示是否允许安装到主屏幕，以应用icon的形式出现。\n图片和文字即由配置决定。  \n  \n### 五、消息通知  \n消息通知也是使用service worker的通知功能进行的，允许服务器想用户发生通知，而非用户主动请求才去响应某些行为。   \n正常的通知逻辑需要服务器来参与实现，这次展示只实现功能。   \n \n* 首先申请通知权限\n* 注册service worker \n* 处理逻辑，发送通知  \n\n```js \nfunction getPermission(){\n    return new Promise((resolve, reject) => {\n        //权限获取\n        const permissionPromise = Notification.requestPermission(result => {\n            resolve(result);\n        });\n    }).then(result => {\n            //判断条件\n            if (result === 'granted') {\n                execute();\n            }\n            else {\n                console.log('no permission');\n            }\n        });\n} \n```  \n发送通知  \n\n```js\nfunction execute() {\n    // 允许之后执行\n    registerServiceWorker().then(registration => {\n        // 通知\n        registration.showNotification('Hello World!');\n    });\n}  \n```  \n### 结束语   \n#### 参考文档  \n[https://lavas.baidu.com/doc](https://lavas.baidu.com/doc)  \n[https://developer.mozilla.org/zh-CN/Apps/Progressive](https://developer.mozilla.org/zh-CN/Apps/Progressive)\n至此，本文介绍就结束了，更多请参考[实例](https://github.com/xiaoxiangdaiyu/PWA)虽然PWA目前来看，面对的限制还很多，但是也可以看出web组织在更好的提升web应用方向上做的努力。正如一直提到的那句话，未来可期。\n目前国内百度这方面做的比较成熟，新浪微博已经有了pwa 测试版。\n\n  \n\n","slug":"pwa","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1v000xgw921glllwi0","content":"<h2 id=\"一、传统web-应用\"><a href=\"#一、传统web-应用\" class=\"headerlink\" title=\"一、传统web 应用\"></a>一、传统web 应用</h2><p>当前web应用在移动时代并没有达到其在桌面设备上流行的程度，下面有张图来对比与原生应用之间的差别。<br><img src=\"/img/pwa/1.png\"><br>究其原因，无外乎下面不可避免的几点：</p>\n<ul>\n<li>移动设备网络限制-不可忽略的加载时间 </li>\n<li>web应用依赖于浏览器作为入口  </li>\n<li><p>体验与原生的差距 </p>\n<a id=\"more\"></a>\n<p>假如能解决以上的几点，对web app 来说会有多大的提升可以想象。</p>\n<h2 id=\"二、PWA是什么\"><a href=\"#二、PWA是什么\" class=\"headerlink\" title=\"二、PWA是什么\"></a>二、PWA是什么</h2><p>PWA 全称Progressive Web Apps(渐进式Web应用程序)，旨在使用现有的web技术提供用户更优的使用体验。<br>基本要求    </p>\n</li>\n<li><p>可靠（Reliable）<br>  即使在不稳定的网络环境下，也能瞬间加载并展现</p>\n</li>\n<li>快速响应（Fast）<br>  快速响应，并且有平滑的动画响应用户的操作</li>\n<li>粘性(Engaging)<br>  像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面   </li>\n</ul>\n<p>PWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。  </p>\n<p>除以上的基准要求外，还应该包括以下特性：  </p>\n<ul>\n<li>渐进式 - 适用于所有浏览器，因为它是以渐进式增强作为宗旨开发的</li>\n<li>连接无关性 - 能够借助 Service Worker 在离线或者网络较差的情况下正常访问</li>\n<li>类似应用 - 由于是在 App Shell 模型基础上开发，因为应具有 Native App 的交互和导航，给用户 Native App 的体验</li>\n<li>持续更新 - 始终是最新的，无版本和更新问题</li>\n<li>安全 - 通过 HTTPS 协议提供服务，防止窥探和确保内容不被篡改</li>\n<li>可索引 - 应用清单文件和 Service Worker 可以让搜索引擎索引到，从而将其识别为『应用』</li>\n<li>粘性 - 通过推送离线通知等，可以让用户回流</li>\n<li>可安装 - 用户可以添加常用的 webapp 到桌面，免去去应用商店下载的麻烦</li>\n<li>可链接 - 通过链接即可分享内容，无需下载安装  </li>\n</ul>\n<p>看起来有点眼花缭乱，这又是一个新的飞起的轮子吗？这里重申一下,PWA背后不是一种新的技术，而是集合当前多种web技术的一种集合。分别利用各自的功能来完成渐进式的整体需求。下面就沿着前面提出的问题分别了解一下相关技术  </p>\n<h2 id=\"三、技术组成\"><a href=\"#三、技术组成\" class=\"headerlink\" title=\"三、技术组成\"></a>三、技术组成</h2><p>由以下几种技术构成：  </p>\n<ul>\n<li>App Manifest</li>\n<li>Service Worker</li>\n<li>Notifications API</li>\n<li>Push API  </li>\n</ul>\n<p>其中Service Worker是PWA技术的关键，它们可以让app满足上面的三基准。其他技术则是锦上添花，让app更加的强大。 </p>\n<h3 id=\"3-1-service-worker背景\"><a href=\"#3-1-service-worker背景\" class=\"headerlink\" title=\"3.1 service worker背景\"></a>3.1 service worker背景</h3><h4 id=\"离线缓存背景\"><a href=\"#离线缓存背景\" class=\"headerlink\" title=\"离线缓存背景\"></a>离线缓存背景</h4><p>针对网页的体验，从前到后都做了很多努力，极力去降低响应时间，这里就不表述多样的技术手段。<br>另一个方向的就是缓存，减少与服务器非必要的交互，不过对于离线的情况下浏览器缓存就无力了，<br>这样离线缓存的需求就出现了。</p>\n<h4 id=\"离线缓存的历程\"><a href=\"#离线缓存的历程\" class=\"headerlink\" title=\"离线缓存的历程\"></a>离线缓存的历程</h4><p>web应用在离线缓存发展的过程中也不是一簇而就的，经历了逐渐完善的过程。<br>初期的解决方案是AppCache(原来阿波罗的h5接入过)<br> 然而，事实证明这是一个失败的尝试，缺陷太多，已经被废弃了。具体可以查看Application Cache is a douchebag<br>但是方向还是正确的，那就继续孜孜不倦的探索。</p>\n<h4 id=\"workers\"><a href=\"#workers\" class=\"headerlink\" title=\"workers\"></a>workers</h4><p>持久化先放一边，来谈谈另一个问题<br>基于浏览器中的 javaScript 单线程的现实逐渐不能满足现代web需求的现状,例如耗时的计算，用户的交互显然会受影响。<br>为了将这些耗时操作从主线程中解放出来，早期W3C新增了一个Web Worker 的 API，可以脱离主线程单独执行，并且可以与主线程交互。<br>不过Web Worker是临时性的依赖于创建页面 ，不能满足我们持久化的需求。<br>冲着这个目标，下面就比较容易解决了，搞个能持久存在的就行了。<br>在Web Worker的基础上，W3C新增了service worker来满足我们持久化的需求。<br>其生命周期与页面无关，关联页面未关闭时，它也可以退出，没有关联页面时，它也可以启动<br>功能  </p>\n<p>Service Worker虽然满足了离线缓存来，其功能可不仅仅局限于此。  可以提供  </p>\n<ul>\n<li>丰富的离线体验，</li>\n<li>周期的后台同步，</li>\n<li>消息推送通知，</li>\n<li>拦截和处理网络请求，</li>\n<li>管理资源缓存<br>这些正好也是PWA的目的，所以说Service Worker是PWA的关键技术。 <h4 id=\"前提条件\"><a href=\"#前提条件\" class=\"headerlink\" title=\"前提条件\"></a>前提条件</h4>Service Worker 出于安全性和其实现原理，在使用的时候有一定的前提条件。</li>\n<li>由于 Service Worker 要求 HTTPS 的环境<br>  当然一般浏览器允许调试 Service Worker 的时候 host 为 localhost 或者 127.0.0.1 </li>\n<li>Service Worker 的缓存机制是依赖 Cache API (略过)</li>\n<li>依赖 HTML5 fetch API（略过）</li>\n<li><p>依赖 Promise 实现<br>由上可知，不是所有的浏览器都支持的，支持情况大概如下：  </p>\n<p><img src=\"/img/pwa/2.png\"><br>iOS 内的所有的浏览器都基于 safari，所以iOS要在11.3以上<br>IE是放弃支持了，不过Edge好歹支持了。     </p>\n<h3 id=\"3-2-Cache\"><a href=\"#3-2-Cache\" class=\"headerlink\" title=\"3.2 Cache\"></a>3.2 Cache</h3></li>\n</ul>\n<p>Cache是Service Worker衍生出来的API，配合Service Worker实现对资源请求的缓存。<br>不过cache并不直接缓存字符串，而是直接缓存资源请求（css、js、html等）。<br>cache也是key-value形式，一般来说key就是request，value就是response   </p>\n<ul>\n<li>caches.open(cacheName) 打开一个cache   </li>\n<li>caches是global对象，返回一个带有cache返回值的Promise</li>\n<li>cache.keys() 遍历cache中所有键，得到value的集合</li>\n<li>cache.match(Request|url) 在cache中匹配传入的request，返回Promise；  </li>\n<li>cache.matchAll只有第一个参数与match不同，需要一个request的数组，当然返回的结果也是response的数组</li>\n<li>cache.add(Request|url) 并不是单纯的add，因为传入的是request或者url，在cache.add内部会自动去调用fetch取回request的请求结果，然后才是把response存入cache；</li>\n<li>cache.addAll类似，通常在sw install的时候用cache.addAll把所有需要缓存的文件都请求一遍</li>\n<li>cache.put(Request, Response) 这个相当于cache.add的第二步，即fetch到response后存入cache</li>\n<li>cache.delete(Request|url) 删除缓存     </li>\n</ul>\n<h3 id=\"3-3-注册Service-Worker\"><a href=\"#3-3-注册Service-Worker\" class=\"headerlink\" title=\"3.3 注册Service Worker\"></a>3.3 注册Service Worker</h3><p>注册即声明sw文件的位置，显然应该在主js中引入。大概如下：  </p>\n<pre><code class=\"js\"><span class=\"comment\">//基于promise</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerServiceWorker</span>(<span class=\"params\"></span>)</span>{\n    <span class=\"comment\">// 注册service worker</span>\n    <span class=\"keyword\">return</span> navigator.serviceWorker.register(<span class=\"string\">'./sw1.js'</span>).then(<span class=\"function\"><span class=\"params\">registration</span> =&gt;</span> {\n        <span class=\"built_in\">console</span>.log(<span class=\"string\">'注册成功'</span>);\n        <span class=\"comment\">// 返回</span>\n        <span class=\"keyword\">return</span> registration;\n    })\n    .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {\n        <span class=\"built_in\">console</span>.error(<span class=\"string\">'注册失败'</span>, err);\n    });\n}\n<span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"comment\">//是否支持</span>\n    <span class=\"keyword\">if</span> (!(<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator)) {\n        <span class=\"keyword\">return</span>;\n    }\n    registerServiceWorker()\n}\n</code></pre>\n<h3 id=\"3-4-生命周期\"><a href=\"#3-4-生命周期\" class=\"headerlink\" title=\"3.4 生命周期\"></a>3.4 生命周期</h3><p>Service worker 有一个独立于web 页面的生命周期。<br>如果在网站上安装 serice worker ，你需要注册，注册后浏览器会在后台安装 service worker。然后进入下面的不同阶段。<br>激活之后，service worker 将控制所有的页面，纳入它的范围，不过第一次在页面注册 service worker 时不会控制页面，直到它再次加载。<br> service worker 生效之后,它会处于下面两种状态之一：  </p>\n<ul>\n<li>service worker 终止来节省内存，</li>\n<li>页面发起网络请求后，它将处理请求获取和消息事件。  </li>\n</ul>\n<p>由上图看知，分为这么几个阶段：  </p>\n<ul>\n<li>Installing   <pre><code>发生在 Service Worker 注册之后，表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存 \n</code></pre></li>\n<li>Installed<pre><code>Service Worker 已经完成了安装，并且等待其他的 Service Worker 线程被关闭。\n</code></pre></li>\n<li>Activating <pre><code>在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装\n</code></pre></li>\n<li>Activated   <pre><code>在这个状态会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、sync (后台同步)、push (推送)\n</code></pre></li>\n<li>Redundant<pre><code>被替换，即被销毁  \n</code></pre></li>\n</ul>\n<p>了解声明周期其实是为了我们在不同时间段去监听事件来完成相应操作。对PWA来说主要两个事件。</p>\n<ul>\n<li>install 事件回调：</li>\n</ul>\n<p>event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。<br>self.skipWaiting()：self 是当前 context 的 global 变量，执行该方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。</p>\n<ul>\n<li>activate 回调：</li>\n</ul>\n<p>event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。<br>self.clients.claim()：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。   </p>\n<pre><code class=\"js\"><span class=\"keyword\">const</span> CURCACHE = <span class=\"string\">'CURCACHE_test_1'</span>\n<span class=\"keyword\">const</span> RUNTIME = <span class=\"string\">'runtime'</span>;\n<span class=\"keyword\">const</span> CURCACHE_URLS = [\n    <span class=\"string\">'./'</span>,\n    <span class=\"string\">'/asset/sw.jpg'</span>,\n    <span class=\"string\">'index.js'</span>\n]\nself.addEventListener(<span class=\"string\">'install'</span>,e=&gt;{\n    e.waitUntil(\n      <span class=\"comment\">//存储缓存路径对应的资源</span>\n        caches.open(CURCACHE).then(<span class=\"function\"><span class=\"params\">cache</span>=&gt;</span>{\n            cache.addAll(CURCACHE_URLS)\n        }).then(\n            self.skipWaiting()\n        )\n    )\n})  \n  <span class=\"comment\">//代理请求，使用缓存，请求发送之前</span>\n  self.addEventListener(<span class=\"string\">'fetch'</span>, e =&gt; {\n    e.respondWith(\n      <span class=\"comment\">//缓存是否匹配 </span>\n      caches.match(e.request).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>{\n        <span class=\"keyword\">if</span> (response != <span class=\"literal\">null</span>) {\n          <span class=\"comment\">//命中缓存返回缓存，结束请求</span>\n          <span class=\"keyword\">return</span> response\n        }\n        <span class=\"comment\">//未命中缓存，正常请求</span>\n        <span class=\"keyword\">return</span> fetch(e.request.url)\n      })\n    )\n  });\n</code></pre>\n<h4 id=\"更新service-worker\"><a href=\"#更新service-worker\" class=\"headerlink\" title=\"更新service worker\"></a>更新service worker</h4><p>service worker 更新步骤如下：   </p>\n<ul>\n<li>更新 service worker 的文件   <pre><code>网页打开时服务器会进行对比，保持最新  \n</code></pre></li>\n<li>新的 service worker 启动install</li>\n<li>当前页面生效的依然是老的service worker，新的 service worker 会进入 “waiting” 状态。</li>\n<li>页面关闭之后，老的 service worker 会被干掉，新的 servicer worker 接管页面</li>\n<li>新的 service worker 生效后会触发 activate 事件  </li>\n</ul>\n<pre><code class=\"js\"><span class=\"keyword\">const</span> CURCACHE = <span class=\"string\">'precache_test_1'</span>\n<span class=\"comment\">//假设上个版本的key为precache_test_2 反正不等于CURCACHE</span>\nself.addEventListener(<span class=\"string\">'activate'</span>, e =&gt; {\n  e.waitUntil(\n      <span class=\"comment\">//遍历当前缓存keys</span>\n      caches.keys().then(<span class=\"function\"><span class=\"params\">cacheNames</span>=&gt;</span>{\n        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(\n          cacheNames.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cacheName</span>) </span>{\n            <span class=\"comment\">//是否等于当前key,保留自己</span>\n            <span class=\"keyword\">if</span> (cacheName !== CURCACHE) {\n              <span class=\"keyword\">return</span> caches.delete(cacheName);\n            }\n          })\n    )}).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> self.clients.claim())\n )\n}) \n</code></pre>\n<p>这样一个简单的service worker离线缓存完成了。控制台可以看到，来源是service worker  </p>\n<p><img src=\"/img/pwa/3.png\"><br>关闭网络之后再次访问，可以同样得到上面的结果，并且sw.js请求未能拿到，但是不影响，旧的文件依然在，这里证明了每次都回去对比sw文件以确保更新<br><img src=\"/img/pwa/4.png\"><br>到这里，离线缓存就实现了。   </p>\n<h2 id=\"四、添加到主屏幕\"><a href=\"#四、添加到主屏幕\" class=\"headerlink\" title=\"四、添加到主屏幕\"></a>四、添加到主屏幕</h2><p>允许将站点添加至主屏幕，是 PWA 提供的一项重要功能。这样就不用再依赖于浏览器作为平台，符合移动端的用户习惯。  </p>\n<h3 id=\"manifest-json\"><a href=\"#manifest-json\" class=\"headerlink\" title=\"manifest.json\"></a>manifest.json</h3><p>需要 manifest.json 文件去配置应用的图标、名称等基本信息如下：</p>\n<pre><code class=\"js\">{\n    <span class=\"comment\">//被提示安装应用时出现的文本</span>\n    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"PQJ-PWA\"</span>,\n    <span class=\"comment\">//添加至主屏幕后的文本</span>\n    <span class=\"string\">\"short_name\"</span>:<span class=\"string\">\"PQJ\"</span>,\n    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"测试demo\"</span>,\n    <span class=\"comment\">//添加之后，启动地址</span>\n    <span class=\"string\">\"start_url\"</span>: <span class=\"string\">\"/index.html\"</span>,\n    <span class=\"comment\">//图标信息</span>\n    <span class=\"string\">\"icons\"</span>: {\n      <span class=\"string\">\"128\"</span>: <span class=\"string\">\"/asset/sw.jpg\"</span>\n    },\n    <span class=\"string\">\"developer\"</span>: {\n      <span class=\"string\">\"name\"</span>: <span class=\"string\">\"pqj\"</span>,\n      <span class=\"string\">\"url\"</span>: <span class=\"string\">\"\"</span>\n    },\n    <span class=\"string\">\"display\"</span>: <span class=\"string\">\"standalone\"</span>,\n    <span class=\"string\">\"background_color\"</span>: <span class=\"string\">\"#287fc5\"</span>,\n    <span class=\"string\">\"theme_color\"</span>: <span class=\"string\">\"#fff\"</span>,\n    <span class=\"string\">\"permissions\"</span>: {\n        <span class=\"string\">\"desktop-notification\"</span>: {\n          <span class=\"string\">\"description\"</span>: <span class=\"string\">\"Needed for creating system notifications.\"</span>\n        }\n      }\n}  \n</code></pre>\n<p>然后以如下方式在html中引入</p>\n<pre><code class=\"js\">&lt;link rel=<span class=\"string\">\"manifest\"</span> href=<span class=\"string\">\"/mainfest.json\"</span> /&gt;\n</code></pre>\n<p>这样完成之后，移动端安卓使用chrome(亲测),首次访问时会提示是否允许安装到主屏幕，以应用icon的形式出现。<br>图片和文字即由配置决定。  </p>\n<h3 id=\"五、消息通知\"><a href=\"#五、消息通知\" class=\"headerlink\" title=\"五、消息通知\"></a>五、消息通知</h3><p>消息通知也是使用service worker的通知功能进行的，允许服务器想用户发生通知，而非用户主动请求才去响应某些行为。<br>正常的通知逻辑需要服务器来参与实现，这次展示只实现功能。   </p>\n<ul>\n<li>首先申请通知权限</li>\n<li>注册service worker </li>\n<li>处理逻辑，发送通知  </li>\n</ul>\n<pre><code class=\"js\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPermission</span>(<span class=\"params\"></span>)</span>{\n    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {\n        <span class=\"comment\">//权限获取</span>\n        <span class=\"keyword\">const</span> permissionPromise = Notification.requestPermission(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> {\n            resolve(result);\n        });\n    }).then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> {\n            <span class=\"comment\">//判断条件</span>\n            <span class=\"keyword\">if</span> (result === <span class=\"string\">'granted'</span>) {\n                execute();\n            }\n            <span class=\"keyword\">else</span> {\n                <span class=\"built_in\">console</span>.log(<span class=\"string\">'no permission'</span>);\n            }\n        });\n} \n</code></pre>\n<p>发送通知  </p>\n<pre><code class=\"js\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"comment\">// 允许之后执行</span>\n    registerServiceWorker().then(<span class=\"function\"><span class=\"params\">registration</span> =&gt;</span> {\n        <span class=\"comment\">// 通知</span>\n        registration.showNotification(<span class=\"string\">'Hello World!'</span>);\n    });\n}  \n</code></pre>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><p><a href=\"https://lavas.baidu.com/doc\" target=\"_blank\" rel=\"noopener\">https://lavas.baidu.com/doc</a><br><a href=\"https://developer.mozilla.org/zh-CN/Apps/Progressive\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/Apps/Progressive</a><br>至此，本文介绍就结束了，更多请参考<a href=\"https://github.com/xiaoxiangdaiyu/PWA\" target=\"_blank\" rel=\"noopener\">实例</a>虽然PWA目前来看，面对的限制还很多，但是也可以看出web组织在更好的提升web应用方向上做的努力。正如一直提到的那句话，未来可期。<br>目前国内百度这方面做的比较成熟，新浪微博已经有了pwa 测试版。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"一、传统web-应用\"><a href=\"#一、传统web-应用\" class=\"headerlink\" title=\"一、传统web 应用\"></a>一、传统web 应用</h2><p>当前web应用在移动时代并没有达到其在桌面设备上流行的程度，下面有张图来对比与原生应用之间的差别。<br><img src=\"/img/pwa/1.png\"><br>究其原因，无外乎下面不可避免的几点：</p>\n<ul>\n<li>移动设备网络限制-不可忽略的加载时间 </li>\n<li>web应用依赖于浏览器作为入口  </li>\n<li><p>体验与原生的差距 </p>","more":"<p>假如能解决以上的几点，对web app 来说会有多大的提升可以想象。</p>\n<h2 id=\"二、PWA是什么\"><a href=\"#二、PWA是什么\" class=\"headerlink\" title=\"二、PWA是什么\"></a>二、PWA是什么</h2><p>PWA 全称Progressive Web Apps(渐进式Web应用程序)，旨在使用现有的web技术提供用户更优的使用体验。<br>基本要求    </p>\n</li>\n<li><p>可靠（Reliable）<br>  即使在不稳定的网络环境下，也能瞬间加载并展现</p>\n</li>\n<li>快速响应（Fast）<br>  快速响应，并且有平滑的动画响应用户的操作</li>\n<li>粘性(Engaging)<br>  像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面   </li>\n</ul>\n<p>PWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。  </p>\n<p>除以上的基准要求外，还应该包括以下特性：  </p>\n<ul>\n<li>渐进式 - 适用于所有浏览器，因为它是以渐进式增强作为宗旨开发的</li>\n<li>连接无关性 - 能够借助 Service Worker 在离线或者网络较差的情况下正常访问</li>\n<li>类似应用 - 由于是在 App Shell 模型基础上开发，因为应具有 Native App 的交互和导航，给用户 Native App 的体验</li>\n<li>持续更新 - 始终是最新的，无版本和更新问题</li>\n<li>安全 - 通过 HTTPS 协议提供服务，防止窥探和确保内容不被篡改</li>\n<li>可索引 - 应用清单文件和 Service Worker 可以让搜索引擎索引到，从而将其识别为『应用』</li>\n<li>粘性 - 通过推送离线通知等，可以让用户回流</li>\n<li>可安装 - 用户可以添加常用的 webapp 到桌面，免去去应用商店下载的麻烦</li>\n<li>可链接 - 通过链接即可分享内容，无需下载安装  </li>\n</ul>\n<p>看起来有点眼花缭乱，这又是一个新的飞起的轮子吗？这里重申一下,PWA背后不是一种新的技术，而是集合当前多种web技术的一种集合。分别利用各自的功能来完成渐进式的整体需求。下面就沿着前面提出的问题分别了解一下相关技术  </p>\n<h2 id=\"三、技术组成\"><a href=\"#三、技术组成\" class=\"headerlink\" title=\"三、技术组成\"></a>三、技术组成</h2><p>由以下几种技术构成：  </p>\n<ul>\n<li>App Manifest</li>\n<li>Service Worker</li>\n<li>Notifications API</li>\n<li>Push API  </li>\n</ul>\n<p>其中Service Worker是PWA技术的关键，它们可以让app满足上面的三基准。其他技术则是锦上添花，让app更加的强大。 </p>\n<h3 id=\"3-1-service-worker背景\"><a href=\"#3-1-service-worker背景\" class=\"headerlink\" title=\"3.1 service worker背景\"></a>3.1 service worker背景</h3><h4 id=\"离线缓存背景\"><a href=\"#离线缓存背景\" class=\"headerlink\" title=\"离线缓存背景\"></a>离线缓存背景</h4><p>针对网页的体验，从前到后都做了很多努力，极力去降低响应时间，这里就不表述多样的技术手段。<br>另一个方向的就是缓存，减少与服务器非必要的交互，不过对于离线的情况下浏览器缓存就无力了，<br>这样离线缓存的需求就出现了。</p>\n<h4 id=\"离线缓存的历程\"><a href=\"#离线缓存的历程\" class=\"headerlink\" title=\"离线缓存的历程\"></a>离线缓存的历程</h4><p>web应用在离线缓存发展的过程中也不是一簇而就的，经历了逐渐完善的过程。<br>初期的解决方案是AppCache(原来阿波罗的h5接入过)<br> 然而，事实证明这是一个失败的尝试，缺陷太多，已经被废弃了。具体可以查看Application Cache is a douchebag<br>但是方向还是正确的，那就继续孜孜不倦的探索。</p>\n<h4 id=\"workers\"><a href=\"#workers\" class=\"headerlink\" title=\"workers\"></a>workers</h4><p>持久化先放一边，来谈谈另一个问题<br>基于浏览器中的 javaScript 单线程的现实逐渐不能满足现代web需求的现状,例如耗时的计算，用户的交互显然会受影响。<br>为了将这些耗时操作从主线程中解放出来，早期W3C新增了一个Web Worker 的 API，可以脱离主线程单独执行，并且可以与主线程交互。<br>不过Web Worker是临时性的依赖于创建页面 ，不能满足我们持久化的需求。<br>冲着这个目标，下面就比较容易解决了，搞个能持久存在的就行了。<br>在Web Worker的基础上，W3C新增了service worker来满足我们持久化的需求。<br>其生命周期与页面无关，关联页面未关闭时，它也可以退出，没有关联页面时，它也可以启动<br>功能  </p>\n<p>Service Worker虽然满足了离线缓存来，其功能可不仅仅局限于此。  可以提供  </p>\n<ul>\n<li>丰富的离线体验，</li>\n<li>周期的后台同步，</li>\n<li>消息推送通知，</li>\n<li>拦截和处理网络请求，</li>\n<li>管理资源缓存<br>这些正好也是PWA的目的，所以说Service Worker是PWA的关键技术。 <h4 id=\"前提条件\"><a href=\"#前提条件\" class=\"headerlink\" title=\"前提条件\"></a>前提条件</h4>Service Worker 出于安全性和其实现原理，在使用的时候有一定的前提条件。</li>\n<li>由于 Service Worker 要求 HTTPS 的环境<br>  当然一般浏览器允许调试 Service Worker 的时候 host 为 localhost 或者 127.0.0.1 </li>\n<li>Service Worker 的缓存机制是依赖 Cache API (略过)</li>\n<li>依赖 HTML5 fetch API（略过）</li>\n<li><p>依赖 Promise 实现<br>由上可知，不是所有的浏览器都支持的，支持情况大概如下：  </p>\n<p><img src=\"/img/pwa/2.png\"><br>iOS 内的所有的浏览器都基于 safari，所以iOS要在11.3以上<br>IE是放弃支持了，不过Edge好歹支持了。     </p>\n<h3 id=\"3-2-Cache\"><a href=\"#3-2-Cache\" class=\"headerlink\" title=\"3.2 Cache\"></a>3.2 Cache</h3></li>\n</ul>\n<p>Cache是Service Worker衍生出来的API，配合Service Worker实现对资源请求的缓存。<br>不过cache并不直接缓存字符串，而是直接缓存资源请求（css、js、html等）。<br>cache也是key-value形式，一般来说key就是request，value就是response   </p>\n<ul>\n<li>caches.open(cacheName) 打开一个cache   </li>\n<li>caches是global对象，返回一个带有cache返回值的Promise</li>\n<li>cache.keys() 遍历cache中所有键，得到value的集合</li>\n<li>cache.match(Request|url) 在cache中匹配传入的request，返回Promise；  </li>\n<li>cache.matchAll只有第一个参数与match不同，需要一个request的数组，当然返回的结果也是response的数组</li>\n<li>cache.add(Request|url) 并不是单纯的add，因为传入的是request或者url，在cache.add内部会自动去调用fetch取回request的请求结果，然后才是把response存入cache；</li>\n<li>cache.addAll类似，通常在sw install的时候用cache.addAll把所有需要缓存的文件都请求一遍</li>\n<li>cache.put(Request, Response) 这个相当于cache.add的第二步，即fetch到response后存入cache</li>\n<li>cache.delete(Request|url) 删除缓存     </li>\n</ul>\n<h3 id=\"3-3-注册Service-Worker\"><a href=\"#3-3-注册Service-Worker\" class=\"headerlink\" title=\"3.3 注册Service Worker\"></a>3.3 注册Service Worker</h3><p>注册即声明sw文件的位置，显然应该在主js中引入。大概如下：  </p>\n<pre><code class=\"js\"><span class=\"comment\">//基于promise</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">registerServiceWorker</span>(<span class=\"params\"></span>)</span>{\n    <span class=\"comment\">// 注册service worker</span>\n    <span class=\"keyword\">return</span> navigator.serviceWorker.register(<span class=\"string\">'./sw1.js'</span>).then(<span class=\"function\"><span class=\"params\">registration</span> =&gt;</span> {\n        <span class=\"built_in\">console</span>.log(<span class=\"string\">'注册成功'</span>);\n        <span class=\"comment\">// 返回</span>\n        <span class=\"keyword\">return</span> registration;\n    })\n    .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> {\n        <span class=\"built_in\">console</span>.error(<span class=\"string\">'注册失败'</span>, err);\n    });\n}\n<span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>{\n    <span class=\"comment\">//是否支持</span>\n    <span class=\"keyword\">if</span> (!(<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator)) {\n        <span class=\"keyword\">return</span>;\n    }\n    registerServiceWorker()\n}\n</code></pre>\n<h3 id=\"3-4-生命周期\"><a href=\"#3-4-生命周期\" class=\"headerlink\" title=\"3.4 生命周期\"></a>3.4 生命周期</h3><p>Service worker 有一个独立于web 页面的生命周期。<br>如果在网站上安装 serice worker ，你需要注册，注册后浏览器会在后台安装 service worker。然后进入下面的不同阶段。<br>激活之后，service worker 将控制所有的页面，纳入它的范围，不过第一次在页面注册 service worker 时不会控制页面，直到它再次加载。<br> service worker 生效之后,它会处于下面两种状态之一：  </p>\n<ul>\n<li>service worker 终止来节省内存，</li>\n<li>页面发起网络请求后，它将处理请求获取和消息事件。  </li>\n</ul>\n<p>由上图看知，分为这么几个阶段：  </p>\n<ul>\n<li>Installing   <pre><code>发生在 Service Worker 注册之后，表示开始安装，触发 install 事件回调指定一些静态资源进行离线缓存 \n</code></pre></li>\n<li>Installed<pre><code>Service Worker 已经完成了安装，并且等待其他的 Service Worker 线程被关闭。\n</code></pre></li>\n<li>Activating <pre><code>在这个状态下没有被其他的 Service Worker 控制的客户端，允许当前的 worker 完成安装\n</code></pre></li>\n<li>Activated   <pre><code>在这个状态会处理 activate 事件回调 (提供了更新缓存策略的机会)。并可以处理功能性的事件 fetch (请求)、sync (后台同步)、push (推送)\n</code></pre></li>\n<li>Redundant<pre><code>被替换，即被销毁  \n</code></pre></li>\n</ul>\n<p>了解声明周期其实是为了我们在不同时间段去监听事件来完成相应操作。对PWA来说主要两个事件。</p>\n<ul>\n<li>install 事件回调：</li>\n</ul>\n<p>event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。<br>self.skipWaiting()：self 是当前 context 的 global 变量，执行该方法表示强制当前处在 waiting 状态的 Service Worker 进入 activate 状态。</p>\n<ul>\n<li>activate 回调：</li>\n</ul>\n<p>event.waitUntil()：传入一个 Promise 为参数，等到该 Promise 为 resolve 状态为止。<br>self.clients.claim()：在 activate 事件回调中执行该方法表示取得页面的控制权, 这样之后打开页面都会使用版本更新的缓存。旧的 Service Worker 脚本不再控制着页面，之后会被停止。   </p>\n<pre><code class=\"js\"><span class=\"keyword\">const</span> CURCACHE = <span class=\"string\">'CURCACHE_test_1'</span>\n<span class=\"keyword\">const</span> RUNTIME = <span class=\"string\">'runtime'</span>;\n<span class=\"keyword\">const</span> CURCACHE_URLS = [\n    <span class=\"string\">'./'</span>,\n    <span class=\"string\">'/asset/sw.jpg'</span>,\n    <span class=\"string\">'index.js'</span>\n]\nself.addEventListener(<span class=\"string\">'install'</span>,e=&gt;{\n    e.waitUntil(\n      <span class=\"comment\">//存储缓存路径对应的资源</span>\n        caches.open(CURCACHE).then(<span class=\"function\"><span class=\"params\">cache</span>=&gt;</span>{\n            cache.addAll(CURCACHE_URLS)\n        }).then(\n            self.skipWaiting()\n        )\n    )\n})  \n  <span class=\"comment\">//代理请求，使用缓存，请求发送之前</span>\n  self.addEventListener(<span class=\"string\">'fetch'</span>, e =&gt; {\n    e.respondWith(\n      <span class=\"comment\">//缓存是否匹配 </span>\n      caches.match(e.request).then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">response</span>) </span>{\n        <span class=\"keyword\">if</span> (response != <span class=\"literal\">null</span>) {\n          <span class=\"comment\">//命中缓存返回缓存，结束请求</span>\n          <span class=\"keyword\">return</span> response\n        }\n        <span class=\"comment\">//未命中缓存，正常请求</span>\n        <span class=\"keyword\">return</span> fetch(e.request.url)\n      })\n    )\n  });\n</code></pre>\n<h4 id=\"更新service-worker\"><a href=\"#更新service-worker\" class=\"headerlink\" title=\"更新service worker\"></a>更新service worker</h4><p>service worker 更新步骤如下：   </p>\n<ul>\n<li>更新 service worker 的文件   <pre><code>网页打开时服务器会进行对比，保持最新  \n</code></pre></li>\n<li>新的 service worker 启动install</li>\n<li>当前页面生效的依然是老的service worker，新的 service worker 会进入 “waiting” 状态。</li>\n<li>页面关闭之后，老的 service worker 会被干掉，新的 servicer worker 接管页面</li>\n<li>新的 service worker 生效后会触发 activate 事件  </li>\n</ul>\n<pre><code class=\"js\"><span class=\"keyword\">const</span> CURCACHE = <span class=\"string\">'precache_test_1'</span>\n<span class=\"comment\">//假设上个版本的key为precache_test_2 反正不等于CURCACHE</span>\nself.addEventListener(<span class=\"string\">'activate'</span>, e =&gt; {\n  e.waitUntil(\n      <span class=\"comment\">//遍历当前缓存keys</span>\n      caches.keys().then(<span class=\"function\"><span class=\"params\">cacheNames</span>=&gt;</span>{\n        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.all(\n          cacheNames.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">cacheName</span>) </span>{\n            <span class=\"comment\">//是否等于当前key,保留自己</span>\n            <span class=\"keyword\">if</span> (cacheName !== CURCACHE) {\n              <span class=\"keyword\">return</span> caches.delete(cacheName);\n            }\n          })\n    )}).then(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> self.clients.claim())\n )\n}) \n</code></pre>\n<p>这样一个简单的service worker离线缓存完成了。控制台可以看到，来源是service worker  </p>\n<p><img src=\"/img/pwa/3.png\"><br>关闭网络之后再次访问，可以同样得到上面的结果，并且sw.js请求未能拿到，但是不影响，旧的文件依然在，这里证明了每次都回去对比sw文件以确保更新<br><img src=\"/img/pwa/4.png\"><br>到这里，离线缓存就实现了。   </p>\n<h2 id=\"四、添加到主屏幕\"><a href=\"#四、添加到主屏幕\" class=\"headerlink\" title=\"四、添加到主屏幕\"></a>四、添加到主屏幕</h2><p>允许将站点添加至主屏幕，是 PWA 提供的一项重要功能。这样就不用再依赖于浏览器作为平台，符合移动端的用户习惯。  </p>\n<h3 id=\"manifest-json\"><a href=\"#manifest-json\" class=\"headerlink\" title=\"manifest.json\"></a>manifest.json</h3><p>需要 manifest.json 文件去配置应用的图标、名称等基本信息如下：</p>\n<pre><code class=\"js\">{\n    <span class=\"comment\">//被提示安装应用时出现的文本</span>\n    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"PQJ-PWA\"</span>,\n    <span class=\"comment\">//添加至主屏幕后的文本</span>\n    <span class=\"string\">\"short_name\"</span>:<span class=\"string\">\"PQJ\"</span>,\n    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"测试demo\"</span>,\n    <span class=\"comment\">//添加之后，启动地址</span>\n    <span class=\"string\">\"start_url\"</span>: <span class=\"string\">\"/index.html\"</span>,\n    <span class=\"comment\">//图标信息</span>\n    <span class=\"string\">\"icons\"</span>: {\n      <span class=\"string\">\"128\"</span>: <span class=\"string\">\"/asset/sw.jpg\"</span>\n    },\n    <span class=\"string\">\"developer\"</span>: {\n      <span class=\"string\">\"name\"</span>: <span class=\"string\">\"pqj\"</span>,\n      <span class=\"string\">\"url\"</span>: <span class=\"string\">\"\"</span>\n    },\n    <span class=\"string\">\"display\"</span>: <span class=\"string\">\"standalone\"</span>,\n    <span class=\"string\">\"background_color\"</span>: <span class=\"string\">\"#287fc5\"</span>,\n    <span class=\"string\">\"theme_color\"</span>: <span class=\"string\">\"#fff\"</span>,\n    <span class=\"string\">\"permissions\"</span>: {\n        <span class=\"string\">\"desktop-notification\"</span>: {\n          <span class=\"string\">\"description\"</span>: <span class=\"string\">\"Needed for creating system notifications.\"</span>\n        }\n      }\n}  \n</code></pre>\n<p>然后以如下方式在html中引入</p>\n<pre><code class=\"js\">&lt;link rel=<span class=\"string\">\"manifest\"</span> href=<span class=\"string\">\"/mainfest.json\"</span> /&gt;\n</code></pre>\n<p>这样完成之后，移动端安卓使用chrome(亲测),首次访问时会提示是否允许安装到主屏幕，以应用icon的形式出现。<br>图片和文字即由配置决定。  </p>\n<h3 id=\"五、消息通知\"><a href=\"#五、消息通知\" class=\"headerlink\" title=\"五、消息通知\"></a>五、消息通知</h3><p>消息通知也是使用service worker的通知功能进行的，允许服务器想用户发生通知，而非用户主动请求才去响应某些行为。<br>正常的通知逻辑需要服务器来参与实现，这次展示只实现功能。   </p>\n<ul>\n<li>首先申请通知权限</li>\n<li>注册service worker </li>\n<li>处理逻辑，发送通知  </li>\n</ul>\n<pre><code class=\"js\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getPermission</span>(<span class=\"params\"></span>)</span>{\n    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> {\n        <span class=\"comment\">//权限获取</span>\n        <span class=\"keyword\">const</span> permissionPromise = Notification.requestPermission(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> {\n            resolve(result);\n        });\n    }).then(<span class=\"function\"><span class=\"params\">result</span> =&gt;</span> {\n            <span class=\"comment\">//判断条件</span>\n            <span class=\"keyword\">if</span> (result === <span class=\"string\">'granted'</span>) {\n                execute();\n            }\n            <span class=\"keyword\">else</span> {\n                <span class=\"built_in\">console</span>.log(<span class=\"string\">'no permission'</span>);\n            }\n        });\n} \n</code></pre>\n<p>发送通知  </p>\n<pre><code class=\"js\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span>(<span class=\"params\"></span>) </span>{\n    <span class=\"comment\">// 允许之后执行</span>\n    registerServiceWorker().then(<span class=\"function\"><span class=\"params\">registration</span> =&gt;</span> {\n        <span class=\"comment\">// 通知</span>\n        registration.showNotification(<span class=\"string\">'Hello World!'</span>);\n    });\n}  \n</code></pre>\n<h3 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h3><h4 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h4><p><a href=\"https://lavas.baidu.com/doc\" target=\"_blank\" rel=\"noopener\">https://lavas.baidu.com/doc</a><br><a href=\"https://developer.mozilla.org/zh-CN/Apps/Progressive\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/Apps/Progressive</a><br>至此，本文介绍就结束了，更多请参考<a href=\"https://github.com/xiaoxiangdaiyu/PWA\" target=\"_blank\" rel=\"noopener\">实例</a>虽然PWA目前来看，面对的限制还很多，但是也可以看出web组织在更好的提升web应用方向上做的努力。正如一直提到的那句话，未来可期。<br>目前国内百度这方面做的比较成熟，新浪微博已经有了pwa 测试版。</p>"},{"title":"带着问题看 react-redux 源码","date":"2019-05-19T16:00:00.000Z","_content":"\n## 前言\nRedux作为通用的状态管理器，可以搭配任意界面框架。所以并搭配react使用的话就要借助redux官方提供的React绑定库react-redux，以高效灵活的在react中使用redux。下面我们一起看看是react-redux如何灵活高效的\n<!-- more -->\n## redux 概述\n在开始之间还是大概提一下redux的内容，以免脱节。[比较早的时候也解读了下redux的源码实现，可以参考一下](https://juejin.im/post/5b208ef06fb9a01e615ed8cb)  \n\nRedux 是 JavaScript 状态容器，旨在提供可预测化的状态管理。\n其包括action、store、reducer等三部分：  \n\n在理解各部分作用之前，我们可以通过一个更新数据的例子来捋下思路：\n\n1. 要更新数据，肯定有个数据库来存储和维护数据。即数据层。\n2. 具体如何更新，需要有负责执行的部分，即逻辑处理层。\n3. 具体何时更新哪个字段、何时更新，同样需要分发层来控制。\n\n根据上面的例子我们再对比下redux的流程图（图片来自阮一峰大佬）：\n<img src='https://user-gold-cdn.xitu.io/2019/5/15/16abbbc0689d7fe1?w=638&h=479&f=jpeg&s=21322'/>\n可以对照着来理解不同部分的作用。  \n\n### action\n就如上面所说负责更新字段和更新时机。  用户接触到的是view(即用户界面)，对应的更新信息通过acton传递给reducer。\n\n```js\nfunction addTodo(text) {\n  return {\n    // 更新类型及具体内容\n    type: ADD_TODO,\n    text\n  }\n}\n```\n\n### reducer\n负责更新数据的具体逻辑。  \n即根据当前state及action携带的信息合成新的数据。\n\n```js\nfunction todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    // 不同更新类型的处理逻辑不同  \n    case ADD_TODO:\n      return Object.assign({}, state, {\n        todos: [\n          ...state.todos,\n          {\n            text: action.text,\n            completed: false\n          }\n        ]\n      })\n    default:\n      return state\n  }\n}\n```\n\n### store\nstore就是负责维护和管理数据。\n此外还有dispatch，subscrible等api来完成更新事件的分发。\n例如：  \n\n```js\nimport { createStore } from 'redux'\nimport todoApp from './reducers'\nlet store = createStore(todoApp)\nimport {\n  addTodo} from './actions'\n// 注册监听事件\nconst unsubscribe = store.subscribe(() => console.log(store.getState()))\n// 发起一系列 action\nstore.dispatch(addTodo('Learn about actions'))\n// 停止监听\nunsubscribe()\n```\n到这里，我们应该就大概明白redux如何更新管理数据的了。\n\n* 通过store.subscribe来监听状态更新，这是响应变化的重要一步。\n* 然后通过stroe.getState()获取相应数据\n* 具体更新通过action和reducer来实现了。\n  \n那么对照react-redux的实例[官方demo](https://github.com/reduxjs/redux/tree/master/examples/todos/src)，来结合React的时候，会发现redux使用有些不同之处。\n\n### 不同之处\n大概可以有下面这三点：  \n\n1. 组件没有显示调用store.subscrible() \n2. state也不是通过Store.getState()来获取。\n3. 多了Provider和connect方法\n\n可以猜测，上述差异是React-redux帮我们封装了绑定监听等过程，避免需要每个应用都重复相同的操作。使得React组件的数据源只关注props和state。\n\n## react-redux\n本质上 react-redux也是react高阶组件HOC的一种实现。其基于 [容器组件和展示组件相分离](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) 的开发思想来实现的。\n其核心是通过两部分来实现：\n1、Provider\n2、container通过connect来解除手动调用store.subscrible\n\n### provider 的实现\nprovider用法如下，绑定之后，再经过connect处理，就可以在组件中通过props访问对应信息了。\n\n```js\nimport React from 'react'\nimport { render } from 'react-dom'\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport todoApp from './reducers'\nimport App from './components/App'\n\nlet store = createStore(todoApp)\nrender(\n  // 绑定store\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n```\n在看源码之前，我们先自行猜测一下。  \n前面也提到了Provider是React组件。  \n那么为了让子组件都能方便的访问到store，store这个属性会如何传递呢。props？context？\n\n#### 核心实现\n\n```js\nimport { Component, Children } from 'react'\nexport default class Provider extends Component {\n  // 声明context 以被子组件获取。\n  getChildContext() {\n    return { store: this.store }\n  }\n\n  constructor(props, context) {\n    super(props, context)\n    // 挂载store到Provider\n    this.store = props.store\n  }\n\n  render() {\n    // 判断是否只有一个child，是则返回该child节点，否则抛错\n    return Children.only(this.props.children)\n  }\n}\n```\n\nProvider将store传递给子组件，具体如何和组件绑定就是conect做的事情了。\n\n### connect\n\nconnect连接组件和store，该操作并不修改原组件而是返回一个新的增强了关联store的组件。  \n根据这个描述，这显然就是个React高阶组件（HOC）吗。先看一下使用：  \n\n```js\nconnect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\n```\n\n接收四个参数，具体每个参数的作用详细可以参考[http://cn.redux.js.org/docs/react-redux/api.html](http://cn.redux.js.org/docs/react-redux/api.html)  \n\n* [mapStateToProps(state, [ownProps]): stateProps] (Function): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。\n* [mapDispatchToProps(dispatch, [ownProps]): dispatchProps](Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名；每个方法将返回一个新的函数，函数中dispatch方法会将 action creator 的返回值作为参数执行。这些属性会被合并到组件的 props 中。\n* [mergeProps(stateProps, dispatchProps, ownProps): props] (Function): 如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。\n* [options] (Object) 如果指定这个参数，可以定制 connector 的行为\n  * [pure = true] (Boolean): 如果为 true，connector 将执行 shouldComponentUpdate 并且浅对比 mergeProps 的结果，避免不必要的更新，默认true\n  * [withRef = false] (Boolean): 如果为 true，connector 会保存一个对被被包含的组件实例的引用，该引用通过 getWrappedInstance() 方法获得。默认false\n\n#### 结合下面的例子能更清晰知道作用是什么。\n\n```js\nimport { connect } from 'react-redux'\nimport { toggleTodo } from '../actions'\nimport TodoList from '../components/TodoList'\nimport { VisibilityFilters } from '../actions'\n\nconst getVisibleTodos = (todos, filter) => {\n  switch (filter) {\n    case VisibilityFilters.SHOW_ALL:\n      return todos\n    case VisibilityFilters.SHOW_COMPLETED:\n      return todos.filter(t => t.completed)\n    case VisibilityFilters.SHOW_ACTIVE:\n      return todos.filter(t => !t.completed)\n    default:\n      throw new Error('Unknown filter: ' + filter)\n  }\n}\n// 将store中的state作为props传递给被包裹组件\n// mapStateToProps对应当前组件所需要的props，不过这个props显然是要从store中抽取的，不是所有store都需要，所以只会取state.todos \nconst mapStateToProps = state => ({\n  todos: getVisibleTodos(state.todos, state.visibilityFilter)\n})\n// 将action 与被包裹组件相绑定。\n// 其实就是将action中的方法赋值到Props上,以便在组件中调用toggleTodo方法\nconst mapDispatchToProps = dispatch => ({\n  toggleTodo: id => dispatch(toggleTodo(id))\n})\n// 被包裹组件就对应TodoList\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n```\n\n### 具体实现\nconnect实现比较复杂一点，返回的是个高阶函数我们可以先看该函数实现了什么。\n\n####  connect函数\n首先该方法接受相关参数，进行参数的判断和兼容处理(不指定使用默认)。\n并返回一个 wrapWithConnect 方法来装饰传入的容器组件。\n\n```js\n// 每个参数的默认实现\nconst defaultMapStateToProps = state => ({}) // eslint-disable-line no-unused-vars\nconst defaultMapDispatchToProps = dispatch => ({ dispatch })\nconst defaultMergeProps = (stateProps, dispatchProps, parentProps) => ({\n  ...parentProps,\n  ...stateProps,\n  ...dispatchProps\n})\n\nexport default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {\n  // 需要store中的state才会去监听\n  const shouldSubscribe = Boolean(mapStateToProps)\n  // 更新state 方法的兼容，无mapStateToProps则使用默认\n  const mapState = mapStateToProps || defaultMapStateToProps\n\n  let mapDispatch\n  // action creater是否为 函数\n  if (typeof mapDispatchToProps === 'function') {\n    // 函数直接赋值\n    mapDispatch = mapDispatchToProps\n  } else if (!mapDispatchToProps) {\n    // 不存在，则使用默认方法\n    mapDispatch = defaultMapDispatchToProps\n  } else {\n    // 否则 将action Creater 包装起来\n    mapDispatch = wrapActionCreators(mapDispatchToProps)\n  }\n\n  const finalMergeProps = mergeProps || defaultMergeProps\n  const { pure = true, withRef = false } = options\n  const checkMergedEquals = pure && finalMergeProps !== defaultMergeProps\nfunction wrapWithConnect(WrappedComponent) {\n    const connectDisplayName = `Connect(${getDisplayName(WrappedComponent)})`\n     class Connect extends Component {/****/}\n    // ****\n    return hoistStatics(Connect, WrappedComponent)\n    }\n```\n#### wrapWithConnect 函数 返回内容\nwrapWithConnect 函数接受一个组件(connect这就是个HOC。返回一个connect组件\n\n```js\n// ****省略*****\n// hoistStatics的作用：常用语高阶组件中，将被包裹元素的静态方法，“同步”到容器元素中。\n// 也就是 connect中那些WrappedComponent属性的mix\nreturn hoistStatics(Connect, WrappedComponent)\n```\n\n这里，就是HOC常见的增加功能的实现了。  也就是增强与redux的关联，让使用者只需要关注props，而非每次都要自己手动绑定。\n\n#### connect组件生命周期\n既然connect存在生命周期，那就顺着生命周期看看\n\n####  构造函数，就是获取store中的state。\n\nthis.store 即Provider中挂载的Store\n\n```js\n// 构造函数，获取store中的state\n      constructor(props, context) {\n        super(props, context)\n        this.version = version\n        // props或者context中，这是provider中挂载的store\n        this.store = props.store || context.store\n        \n        //  获取state\n        const storeState = this.store.getState()\n        // 初始化state\n        this.state = { storeState }\n        this.clearCache()\n      }\n```\n#### shouldComponentUpdate\n\nshouldComponentUpdate这里会根据options里面的参数来看是否 pure 选择不同的更新策略\n\n```js\nshouldComponentUpdate() {\n        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged\n      }\n```\n#### componentDidMount \n componentDidMount 根据前面的shouldSubscribe标识(mapStateToProps是否为true)决定是否增加监听事件\n \n ```js\n componentDidMount() {\n        this.trySubscribe()\n      }\n trySubscribe() {\n        // 存在监听必要 并且没有注册过监听事件\n        if (shouldSubscribe && !this.unsubscribe) {\n          // 业务组件中没有使用的subscribe 在这里实现，这也是HOC的用法之一，公共方法的抽离\n          // 注册完成之后，this.unsubscribe为对一个unsubscribe回调\n          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this))\n          this.handleChange()\n        }\n      }    \n ```\n \n#### componentWillReceiveProps\n \n componentWillReceiveProps 判断是否更新 ，对于pure 组件 这里就涉及到了shallowEqual。\n 通过shallowEqual的实现，我们可以得到Immtable的重要性\n \n```js\ncomponentWillReceiveProps(nextProps) {\n        if (!pure || !shallowEqual(nextProps, this.props)) {\n          this.haveOwnPropsChanged = true\n        }\n      }\n```\n#### shallowEqual浅比较的实现\n由此可以看到Immutable的重要性。对于引用类型的数据，只是比较了引用地址是否相同。  \n对于嵌套引用数据类型，只比较key的长度和value引用地址，并没有进一步深入比较。导致嵌套结构并不适用。  \n \n ```js\n export default function shallowEqual(objA, objB) {\n   // 引用地址是否相同\n  if (objA === objB) {\n    return true\n  }\n\n  const keysA = Object.keys(objA)\n  const keysB = Object.keys(objB)\n  // key长度是否相同 \n  if (keysA.length !== keysB.length) {\n    return false\n  }\n  // 循环比较，vakue思否相同，对于嵌套引用类型，这种比较是不能满足预期的。\n  const hasOwn = Object.prototype.hasOwnProperty\n  for (let i = 0; i < keysA.length; i++) {\n    if (!hasOwn.call(objB, keysA[i]) ||\n        objA[keysA[i]] !== objB[keysA[i]]) {\n      return false\n    }\n  }\n\n  return true\n}\n ```\n \n#### render\n 再下面是render，对于是否更新进行判断，即是否更新传递给子组件的props\n render的关注点在于 传递给WrappedComponent的props如何获得。\n \n ```js\n // this.mergedProps 的计算\n if (withRef) {\n          this.renderedElement = createElement(WrappedComponent, {\n            ...this.mergedProps,\n            ref: 'wrappedInstance'\n          })\n        } else {\n          this.renderedElement = createElement(WrappedComponent,\n            this.mergedProps\n          )\n        }\n ```\n\n计算this.mergedProps 最终传递下去的props是经过mapStateToProps，mapDispatchToProps计算之后，最后再由mergeProps计算之后的state。\n\n```js\n// 简化代码\nthis.mergedProps = nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props)\n\n  /**\n     * 获得最终props 即经过参数中的\n     * @param {*} stateProps 经过mapStateToProps之后的结果\n     * @param {*} dispatchProps mapDispatchToProps之后的结果\n     * @param {*} parentProps 此处即为connect组件的props this.props\n     * @returns\n     */\n    function computeMergedProps(stateProps, dispatchProps, parentProps) {\n      // finalMergeProps 即为参数中的mergeProps 或者 defaultMergeProps。 将前两参数计算结果再进行处理。\n      const mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps)\n      if (process.env.NODE_ENV !== 'production') {\n        checkStateShape(mergedProps, 'mergeProps')\n      }\n      return mergedProps\n    }\n```\n\n到这里connect的作用也体现出来了： \n \n1. 根据参数决定监数据的变化\n2. 将store和action作为warpered的props传入，一共组件使用store中的state和action\n3. 对于部分操作进行缓存优化，提升执行效率\n\n此时再回过头去看上面的例子应该更清晰了。\n\n\n## 结束语\n\n### 参考文章\n[http://cn.redux.js.org/docs/react-redux/api.html](http://cn.redux.js.org/docs/react-redux/api.html)  \n\n到这里就结束了react-redux的源码解析，更多是自己的学习笔记吧。  \n使用一定程度之后再回头看，可能对自己的理解更有帮助。  \n另外阅读源码不是要盲目去读，而是在应用之后带着问题去读。\n这样会更清晰如何去优化如何去提升。因为水平有限肯定有错漏指出，欢迎指出。\n\n\n\n \n\n\n\n\n\n\n","source":"_posts/react-redux.md","raw":"---\ntitle: 带着问题看 react-redux 源码  \ndate: 2019-05-20\n---\n\n## 前言\nRedux作为通用的状态管理器，可以搭配任意界面框架。所以并搭配react使用的话就要借助redux官方提供的React绑定库react-redux，以高效灵活的在react中使用redux。下面我们一起看看是react-redux如何灵活高效的\n<!-- more -->\n## redux 概述\n在开始之间还是大概提一下redux的内容，以免脱节。[比较早的时候也解读了下redux的源码实现，可以参考一下](https://juejin.im/post/5b208ef06fb9a01e615ed8cb)  \n\nRedux 是 JavaScript 状态容器，旨在提供可预测化的状态管理。\n其包括action、store、reducer等三部分：  \n\n在理解各部分作用之前，我们可以通过一个更新数据的例子来捋下思路：\n\n1. 要更新数据，肯定有个数据库来存储和维护数据。即数据层。\n2. 具体如何更新，需要有负责执行的部分，即逻辑处理层。\n3. 具体何时更新哪个字段、何时更新，同样需要分发层来控制。\n\n根据上面的例子我们再对比下redux的流程图（图片来自阮一峰大佬）：\n<img src='https://user-gold-cdn.xitu.io/2019/5/15/16abbbc0689d7fe1?w=638&h=479&f=jpeg&s=21322'/>\n可以对照着来理解不同部分的作用。  \n\n### action\n就如上面所说负责更新字段和更新时机。  用户接触到的是view(即用户界面)，对应的更新信息通过acton传递给reducer。\n\n```js\nfunction addTodo(text) {\n  return {\n    // 更新类型及具体内容\n    type: ADD_TODO,\n    text\n  }\n}\n```\n\n### reducer\n负责更新数据的具体逻辑。  \n即根据当前state及action携带的信息合成新的数据。\n\n```js\nfunction todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    // 不同更新类型的处理逻辑不同  \n    case ADD_TODO:\n      return Object.assign({}, state, {\n        todos: [\n          ...state.todos,\n          {\n            text: action.text,\n            completed: false\n          }\n        ]\n      })\n    default:\n      return state\n  }\n}\n```\n\n### store\nstore就是负责维护和管理数据。\n此外还有dispatch，subscrible等api来完成更新事件的分发。\n例如：  \n\n```js\nimport { createStore } from 'redux'\nimport todoApp from './reducers'\nlet store = createStore(todoApp)\nimport {\n  addTodo} from './actions'\n// 注册监听事件\nconst unsubscribe = store.subscribe(() => console.log(store.getState()))\n// 发起一系列 action\nstore.dispatch(addTodo('Learn about actions'))\n// 停止监听\nunsubscribe()\n```\n到这里，我们应该就大概明白redux如何更新管理数据的了。\n\n* 通过store.subscribe来监听状态更新，这是响应变化的重要一步。\n* 然后通过stroe.getState()获取相应数据\n* 具体更新通过action和reducer来实现了。\n  \n那么对照react-redux的实例[官方demo](https://github.com/reduxjs/redux/tree/master/examples/todos/src)，来结合React的时候，会发现redux使用有些不同之处。\n\n### 不同之处\n大概可以有下面这三点：  \n\n1. 组件没有显示调用store.subscrible() \n2. state也不是通过Store.getState()来获取。\n3. 多了Provider和connect方法\n\n可以猜测，上述差异是React-redux帮我们封装了绑定监听等过程，避免需要每个应用都重复相同的操作。使得React组件的数据源只关注props和state。\n\n## react-redux\n本质上 react-redux也是react高阶组件HOC的一种实现。其基于 [容器组件和展示组件相分离](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0) 的开发思想来实现的。\n其核心是通过两部分来实现：\n1、Provider\n2、container通过connect来解除手动调用store.subscrible\n\n### provider 的实现\nprovider用法如下，绑定之后，再经过connect处理，就可以在组件中通过props访问对应信息了。\n\n```js\nimport React from 'react'\nimport { render } from 'react-dom'\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport todoApp from './reducers'\nimport App from './components/App'\n\nlet store = createStore(todoApp)\nrender(\n  // 绑定store\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n```\n在看源码之前，我们先自行猜测一下。  \n前面也提到了Provider是React组件。  \n那么为了让子组件都能方便的访问到store，store这个属性会如何传递呢。props？context？\n\n#### 核心实现\n\n```js\nimport { Component, Children } from 'react'\nexport default class Provider extends Component {\n  // 声明context 以被子组件获取。\n  getChildContext() {\n    return { store: this.store }\n  }\n\n  constructor(props, context) {\n    super(props, context)\n    // 挂载store到Provider\n    this.store = props.store\n  }\n\n  render() {\n    // 判断是否只有一个child，是则返回该child节点，否则抛错\n    return Children.only(this.props.children)\n  }\n}\n```\n\nProvider将store传递给子组件，具体如何和组件绑定就是conect做的事情了。\n\n### connect\n\nconnect连接组件和store，该操作并不修改原组件而是返回一个新的增强了关联store的组件。  \n根据这个描述，这显然就是个React高阶组件（HOC）吗。先看一下使用：  \n\n```js\nconnect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\n```\n\n接收四个参数，具体每个参数的作用详细可以参考[http://cn.redux.js.org/docs/react-redux/api.html](http://cn.redux.js.org/docs/react-redux/api.html)  \n\n* [mapStateToProps(state, [ownProps]): stateProps] (Function): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。\n* [mapDispatchToProps(dispatch, [ownProps]): dispatchProps](Object or Function): 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名；每个方法将返回一个新的函数，函数中dispatch方法会将 action creator 的返回值作为参数执行。这些属性会被合并到组件的 props 中。\n* [mergeProps(stateProps, dispatchProps, ownProps): props] (Function): 如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。\n* [options] (Object) 如果指定这个参数，可以定制 connector 的行为\n  * [pure = true] (Boolean): 如果为 true，connector 将执行 shouldComponentUpdate 并且浅对比 mergeProps 的结果，避免不必要的更新，默认true\n  * [withRef = false] (Boolean): 如果为 true，connector 会保存一个对被被包含的组件实例的引用，该引用通过 getWrappedInstance() 方法获得。默认false\n\n#### 结合下面的例子能更清晰知道作用是什么。\n\n```js\nimport { connect } from 'react-redux'\nimport { toggleTodo } from '../actions'\nimport TodoList from '../components/TodoList'\nimport { VisibilityFilters } from '../actions'\n\nconst getVisibleTodos = (todos, filter) => {\n  switch (filter) {\n    case VisibilityFilters.SHOW_ALL:\n      return todos\n    case VisibilityFilters.SHOW_COMPLETED:\n      return todos.filter(t => t.completed)\n    case VisibilityFilters.SHOW_ACTIVE:\n      return todos.filter(t => !t.completed)\n    default:\n      throw new Error('Unknown filter: ' + filter)\n  }\n}\n// 将store中的state作为props传递给被包裹组件\n// mapStateToProps对应当前组件所需要的props，不过这个props显然是要从store中抽取的，不是所有store都需要，所以只会取state.todos \nconst mapStateToProps = state => ({\n  todos: getVisibleTodos(state.todos, state.visibilityFilter)\n})\n// 将action 与被包裹组件相绑定。\n// 其实就是将action中的方法赋值到Props上,以便在组件中调用toggleTodo方法\nconst mapDispatchToProps = dispatch => ({\n  toggleTodo: id => dispatch(toggleTodo(id))\n})\n// 被包裹组件就对应TodoList\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList)\n```\n\n### 具体实现\nconnect实现比较复杂一点，返回的是个高阶函数我们可以先看该函数实现了什么。\n\n####  connect函数\n首先该方法接受相关参数，进行参数的判断和兼容处理(不指定使用默认)。\n并返回一个 wrapWithConnect 方法来装饰传入的容器组件。\n\n```js\n// 每个参数的默认实现\nconst defaultMapStateToProps = state => ({}) // eslint-disable-line no-unused-vars\nconst defaultMapDispatchToProps = dispatch => ({ dispatch })\nconst defaultMergeProps = (stateProps, dispatchProps, parentProps) => ({\n  ...parentProps,\n  ...stateProps,\n  ...dispatchProps\n})\n\nexport default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) {\n  // 需要store中的state才会去监听\n  const shouldSubscribe = Boolean(mapStateToProps)\n  // 更新state 方法的兼容，无mapStateToProps则使用默认\n  const mapState = mapStateToProps || defaultMapStateToProps\n\n  let mapDispatch\n  // action creater是否为 函数\n  if (typeof mapDispatchToProps === 'function') {\n    // 函数直接赋值\n    mapDispatch = mapDispatchToProps\n  } else if (!mapDispatchToProps) {\n    // 不存在，则使用默认方法\n    mapDispatch = defaultMapDispatchToProps\n  } else {\n    // 否则 将action Creater 包装起来\n    mapDispatch = wrapActionCreators(mapDispatchToProps)\n  }\n\n  const finalMergeProps = mergeProps || defaultMergeProps\n  const { pure = true, withRef = false } = options\n  const checkMergedEquals = pure && finalMergeProps !== defaultMergeProps\nfunction wrapWithConnect(WrappedComponent) {\n    const connectDisplayName = `Connect(${getDisplayName(WrappedComponent)})`\n     class Connect extends Component {/****/}\n    // ****\n    return hoistStatics(Connect, WrappedComponent)\n    }\n```\n#### wrapWithConnect 函数 返回内容\nwrapWithConnect 函数接受一个组件(connect这就是个HOC。返回一个connect组件\n\n```js\n// ****省略*****\n// hoistStatics的作用：常用语高阶组件中，将被包裹元素的静态方法，“同步”到容器元素中。\n// 也就是 connect中那些WrappedComponent属性的mix\nreturn hoistStatics(Connect, WrappedComponent)\n```\n\n这里，就是HOC常见的增加功能的实现了。  也就是增强与redux的关联，让使用者只需要关注props，而非每次都要自己手动绑定。\n\n#### connect组件生命周期\n既然connect存在生命周期，那就顺着生命周期看看\n\n####  构造函数，就是获取store中的state。\n\nthis.store 即Provider中挂载的Store\n\n```js\n// 构造函数，获取store中的state\n      constructor(props, context) {\n        super(props, context)\n        this.version = version\n        // props或者context中，这是provider中挂载的store\n        this.store = props.store || context.store\n        \n        //  获取state\n        const storeState = this.store.getState()\n        // 初始化state\n        this.state = { storeState }\n        this.clearCache()\n      }\n```\n#### shouldComponentUpdate\n\nshouldComponentUpdate这里会根据options里面的参数来看是否 pure 选择不同的更新策略\n\n```js\nshouldComponentUpdate() {\n        return !pure || this.haveOwnPropsChanged || this.hasStoreStateChanged\n      }\n```\n#### componentDidMount \n componentDidMount 根据前面的shouldSubscribe标识(mapStateToProps是否为true)决定是否增加监听事件\n \n ```js\n componentDidMount() {\n        this.trySubscribe()\n      }\n trySubscribe() {\n        // 存在监听必要 并且没有注册过监听事件\n        if (shouldSubscribe && !this.unsubscribe) {\n          // 业务组件中没有使用的subscribe 在这里实现，这也是HOC的用法之一，公共方法的抽离\n          // 注册完成之后，this.unsubscribe为对一个unsubscribe回调\n          this.unsubscribe = this.store.subscribe(this.handleChange.bind(this))\n          this.handleChange()\n        }\n      }    \n ```\n \n#### componentWillReceiveProps\n \n componentWillReceiveProps 判断是否更新 ，对于pure 组件 这里就涉及到了shallowEqual。\n 通过shallowEqual的实现，我们可以得到Immtable的重要性\n \n```js\ncomponentWillReceiveProps(nextProps) {\n        if (!pure || !shallowEqual(nextProps, this.props)) {\n          this.haveOwnPropsChanged = true\n        }\n      }\n```\n#### shallowEqual浅比较的实现\n由此可以看到Immutable的重要性。对于引用类型的数据，只是比较了引用地址是否相同。  \n对于嵌套引用数据类型，只比较key的长度和value引用地址，并没有进一步深入比较。导致嵌套结构并不适用。  \n \n ```js\n export default function shallowEqual(objA, objB) {\n   // 引用地址是否相同\n  if (objA === objB) {\n    return true\n  }\n\n  const keysA = Object.keys(objA)\n  const keysB = Object.keys(objB)\n  // key长度是否相同 \n  if (keysA.length !== keysB.length) {\n    return false\n  }\n  // 循环比较，vakue思否相同，对于嵌套引用类型，这种比较是不能满足预期的。\n  const hasOwn = Object.prototype.hasOwnProperty\n  for (let i = 0; i < keysA.length; i++) {\n    if (!hasOwn.call(objB, keysA[i]) ||\n        objA[keysA[i]] !== objB[keysA[i]]) {\n      return false\n    }\n  }\n\n  return true\n}\n ```\n \n#### render\n 再下面是render，对于是否更新进行判断，即是否更新传递给子组件的props\n render的关注点在于 传递给WrappedComponent的props如何获得。\n \n ```js\n // this.mergedProps 的计算\n if (withRef) {\n          this.renderedElement = createElement(WrappedComponent, {\n            ...this.mergedProps,\n            ref: 'wrappedInstance'\n          })\n        } else {\n          this.renderedElement = createElement(WrappedComponent,\n            this.mergedProps\n          )\n        }\n ```\n\n计算this.mergedProps 最终传递下去的props是经过mapStateToProps，mapDispatchToProps计算之后，最后再由mergeProps计算之后的state。\n\n```js\n// 简化代码\nthis.mergedProps = nextMergedProps = computeMergedProps(this.stateProps, this.dispatchProps, this.props)\n\n  /**\n     * 获得最终props 即经过参数中的\n     * @param {*} stateProps 经过mapStateToProps之后的结果\n     * @param {*} dispatchProps mapDispatchToProps之后的结果\n     * @param {*} parentProps 此处即为connect组件的props this.props\n     * @returns\n     */\n    function computeMergedProps(stateProps, dispatchProps, parentProps) {\n      // finalMergeProps 即为参数中的mergeProps 或者 defaultMergeProps。 将前两参数计算结果再进行处理。\n      const mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps)\n      if (process.env.NODE_ENV !== 'production') {\n        checkStateShape(mergedProps, 'mergeProps')\n      }\n      return mergedProps\n    }\n```\n\n到这里connect的作用也体现出来了： \n \n1. 根据参数决定监数据的变化\n2. 将store和action作为warpered的props传入，一共组件使用store中的state和action\n3. 对于部分操作进行缓存优化，提升执行效率\n\n此时再回过头去看上面的例子应该更清晰了。\n\n\n## 结束语\n\n### 参考文章\n[http://cn.redux.js.org/docs/react-redux/api.html](http://cn.redux.js.org/docs/react-redux/api.html)  \n\n到这里就结束了react-redux的源码解析，更多是自己的学习笔记吧。  \n使用一定程度之后再回头看，可能对自己的理解更有帮助。  \n另外阅读源码不是要盲目去读，而是在应用之后带着问题去读。\n这样会更清晰如何去优化如何去提升。因为水平有限肯定有错漏指出，欢迎指出。\n\n\n\n \n\n\n\n\n\n\n","slug":"react-redux","published":1,"updated":"2019-05-20T09:47:03.292Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1w000ygw9231maimyf","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Redux作为通用的状态管理器，可以搭配任意界面框架。所以并搭配react使用的话就要借助redux官方提供的React绑定库react-redux，以高效灵活的在react中使用redux。下面我们一起看看是react-redux如何灵活高效的<br><a id=\"more\"></a></p>\n<h2 id=\"redux-概述\"><a href=\"#redux-概述\" class=\"headerlink\" title=\"redux 概述\"></a>redux 概述</h2><p>在开始之间还是大概提一下redux的内容，以免脱节。<a href=\"https://juejin.im/post/5b208ef06fb9a01e615ed8cb\" target=\"_blank\" rel=\"noopener\">比较早的时候也解读了下redux的源码实现，可以参考一下</a>  </p>\n<p>Redux 是 JavaScript 状态容器，旨在提供可预测化的状态管理。<br>其包括action、store、reducer等三部分：  </p>\n<p>在理解各部分作用之前，我们可以通过一个更新数据的例子来捋下思路：</p>\n<ol>\n<li>要更新数据，肯定有个数据库来存储和维护数据。即数据层。</li>\n<li>具体如何更新，需要有负责执行的部分，即逻辑处理层。</li>\n<li>具体何时更新哪个字段、何时更新，同样需要分发层来控制。</li>\n</ol>\n<p>根据上面的例子我们再对比下redux的流程图（图片来自阮一峰大佬）：<br><img src=\"https://user-gold-cdn.xitu.io/2019/5/15/16abbbc0689d7fe1?w=638&h=479&f=jpeg&s=21322\"><br>可以对照着来理解不同部分的作用。  </p>\n<h3 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h3><p>就如上面所说负责更新字段和更新时机。  用户接触到的是view(即用户界面)，对应的更新信息通过acton传递给reducer。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新类型及具体内容</span></span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a>reducer</h3><p>负责更新数据的具体逻辑。<br>即根据当前state及action携带的信息合成新的数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todoApp</span>(<span class=\"params\">state = initialState, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SET_VISIBILITY_FILTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        visibilityFilter: action.filter</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 不同更新类型的处理逻辑不同  </span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_TODO:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        todos: [</span><br><span class=\"line\">          ...state.todos,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            text: action.text,</span><br><span class=\"line\">            completed: <span class=\"literal\">false</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"store\"></a>store</h3><p>store就是负责维护和管理数据。<br>此外还有dispatch，subscrible等api来完成更新事件的分发。<br>例如：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> todoApp <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(todoApp)</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  addTodo&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"><span class=\"comment\">// 注册监听事件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unsubscribe = store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(store.getState()))</span><br><span class=\"line\"><span class=\"comment\">// 发起一系列 action</span></span><br><span class=\"line\">store.dispatch(addTodo(<span class=\"string\">'Learn about actions'</span>))</span><br><span class=\"line\"><span class=\"comment\">// 停止监听</span></span><br><span class=\"line\">unsubscribe()</span><br></pre></td></tr></table></figure>\n<p>到这里，我们应该就大概明白redux如何更新管理数据的了。</p>\n<ul>\n<li>通过store.subscribe来监听状态更新，这是响应变化的重要一步。</li>\n<li>然后通过stroe.getState()获取相应数据</li>\n<li>具体更新通过action和reducer来实现了。</li>\n</ul>\n<p>那么对照react-redux的实例<a href=\"https://github.com/reduxjs/redux/tree/master/examples/todos/src\" target=\"_blank\" rel=\"noopener\">官方demo</a>，来结合React的时候，会发现redux使用有些不同之处。</p>\n<h3 id=\"不同之处\"><a href=\"#不同之处\" class=\"headerlink\" title=\"不同之处\"></a>不同之处</h3><p>大概可以有下面这三点：  </p>\n<ol>\n<li>组件没有显示调用store.subscrible() </li>\n<li>state也不是通过Store.getState()来获取。</li>\n<li>多了Provider和connect方法</li>\n</ol>\n<p>可以猜测，上述差异是React-redux帮我们封装了绑定监听等过程，避免需要每个应用都重复相同的操作。使得React组件的数据源只关注props和state。</p>\n<h2 id=\"react-redux\"><a href=\"#react-redux\" class=\"headerlink\" title=\"react-redux\"></a>react-redux</h2><p>本质上 react-redux也是react高阶组件HOC的一种实现。其基于 <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\" target=\"_blank\" rel=\"noopener\">容器组件和展示组件相分离</a> 的开发思想来实现的。<br>其核心是通过两部分来实现：<br>1、Provider<br>2、container通过connect来解除手动调用store.subscrible</p>\n<h3 id=\"provider-的实现\"><a href=\"#provider-的实现\" class=\"headerlink\" title=\"provider 的实现\"></a>provider 的实现</h3><p>provider用法如下，绑定之后，再经过connect处理，就可以在组件中通过props访问对应信息了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> todoApp <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./components/App'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(todoApp)</span><br><span class=\"line\">render(</span><br><span class=\"line\">  <span class=\"comment\">// 绑定store</span></span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>在看源码之前，我们先自行猜测一下。<br>前面也提到了Provider是React组件。<br>那么为了让子组件都能方便的访问到store，store这个属性会如何传递呢。props？context？</p>\n<h4 id=\"核心实现\"><a href=\"#核心实现\" class=\"headerlink\" title=\"核心实现\"></a>核心实现</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component, Children &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明context 以被子组件获取。</span></span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">store</span>: <span class=\"keyword\">this</span>.store &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props, context)</span><br><span class=\"line\">    <span class=\"comment\">// 挂载store到Provider</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.store = props.store</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否只有一个child，是则返回该child节点，否则抛错</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Children.only(<span class=\"keyword\">this</span>.props.children)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Provider将store传递给子组件，具体如何和组件绑定就是conect做的事情了。</p>\n<h3 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect\"></a>connect</h3><p>connect连接组件和store，该操作并不修改原组件而是返回一个新的增强了关联store的组件。<br>根据这个描述，这显然就是个React高阶组件（HOC）吗。先看一下使用：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</span><br></pre></td></tr></table></figure>\n<p>接收四个参数，具体每个参数的作用详细可以参考<a href=\"http://cn.redux.js.org/docs/react-redux/api.html\" target=\"_blank\" rel=\"noopener\">http://cn.redux.js.org/docs/react-redux/api.html</a>  </p>\n<ul>\n<li>[mapStateToProps(state, [ownProps]): stateProps] (Function): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。</li>\n<li><a href=\"Object or Function\">mapDispatchToProps(dispatch, [ownProps]): dispatchProps</a>: 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名；每个方法将返回一个新的函数，函数中dispatch方法会将 action creator 的返回值作为参数执行。这些属性会被合并到组件的 props 中。</li>\n<li>[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): 如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。</li>\n<li>[options] (Object) 如果指定这个参数，可以定制 connector 的行为<ul>\n<li>[pure = true] (Boolean): 如果为 true，connector 将执行 shouldComponentUpdate 并且浅对比 mergeProps 的结果，避免不必要的更新，默认true</li>\n<li>[withRef = false] (Boolean): 如果为 true，connector 会保存一个对被被包含的组件实例的引用，该引用通过 getWrappedInstance() 方法获得。默认false</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"结合下面的例子能更清晰知道作用是什么。\"><a href=\"#结合下面的例子能更清晰知道作用是什么。\" class=\"headerlink\" title=\"结合下面的例子能更清晰知道作用是什么。\"></a>结合下面的例子能更清晰知道作用是什么。</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; toggleTodo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">'../components/TodoList'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; VisibilityFilters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getVisibleTodos = <span class=\"function\">(<span class=\"params\">todos, filter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (filter) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> VisibilityFilters.SHOW_ALL:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos</span><br><span class=\"line\">    <span class=\"keyword\">case</span> VisibilityFilters.SHOW_COMPLETED:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos.filter(<span class=\"function\"><span class=\"params\">t</span> =&gt;</span> t.completed)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> VisibilityFilters.SHOW_ACTIVE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos.filter(<span class=\"function\"><span class=\"params\">t</span> =&gt;</span> !t.completed)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Unknown filter: '</span> + filter)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将store中的state作为props传递给被包裹组件</span></span><br><span class=\"line\"><span class=\"comment\">// mapStateToProps对应当前组件所需要的props，不过这个props显然是要从store中抽取的，不是所有store都需要，所以只会取state.todos </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  todos: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 将action 与被包裹组件相绑定。</span></span><br><span class=\"line\"><span class=\"comment\">// 其实就是将action中的方法赋值到Props上,以便在组件中调用toggleTodo方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  toggleTodo: <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> dispatch(toggleTodo(id))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 被包裹组件就对应TodoList</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(TodoList)</span><br></pre></td></tr></table></figure>\n<h3 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><p>connect实现比较复杂一点，返回的是个高阶函数我们可以先看该函数实现了什么。</p>\n<h4 id=\"connect函数\"><a href=\"#connect函数\" class=\"headerlink\" title=\"connect函数\"></a>connect函数</h4><p>首先该方法接受相关参数，进行参数的判断和兼容处理(不指定使用默认)。<br>并返回一个 wrapWithConnect 方法来装饰传入的容器组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个参数的默认实现</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultMapStateToProps = <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> (&#123;&#125;) <span class=\"comment\">// eslint-disable-line no-unused-vars</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultMapDispatchToProps = <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> (&#123; dispatch &#125;)</span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultMergeProps = <span class=\"function\">(<span class=\"params\">stateProps, dispatchProps, parentProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  ...parentProps,</span><br><span class=\"line\">  ...stateProps,</span><br><span class=\"line\">  ...dispatchProps</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">connect</span>(<span class=\"params\">mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 需要store中的state才会去监听</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> shouldSubscribe = <span class=\"built_in\">Boolean</span>(mapStateToProps)</span><br><span class=\"line\">  <span class=\"comment\">// 更新state 方法的兼容，无mapStateToProps则使用默认</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> mapState = mapStateToProps || defaultMapStateToProps</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mapDispatch</span><br><span class=\"line\">  <span class=\"comment\">// action creater是否为 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> mapDispatchToProps === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 函数直接赋值</span></span><br><span class=\"line\">    mapDispatch = mapDispatchToProps</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mapDispatchToProps) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不存在，则使用默认方法</span></span><br><span class=\"line\">    mapDispatch = defaultMapDispatchToProps</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 否则 将action Creater 包装起来</span></span><br><span class=\"line\">    mapDispatch = wrapActionCreators(mapDispatchToProps)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalMergeProps = mergeProps || defaultMergeProps</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; pure = <span class=\"literal\">true</span>, withRef = <span class=\"literal\">false</span> &#125; = options</span><br><span class=\"line\">  <span class=\"keyword\">const</span> checkMergedEquals = pure &amp;&amp; finalMergeProps !== defaultMergeProps</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapWithConnect</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> connectDisplayName = <span class=\"string\">`Connect(<span class=\"subst\">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/****/</span>&#125;</span><br><span class=\"line\">    <span class=\"comment\">// ****</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hoistStatics(Connect, WrappedComponent)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"wrapWithConnect-函数-返回内容\"><a href=\"#wrapWithConnect-函数-返回内容\" class=\"headerlink\" title=\"wrapWithConnect 函数 返回内容\"></a>wrapWithConnect 函数 返回内容</h4><p>wrapWithConnect 函数接受一个组件(connect这就是个HOC。返回一个connect组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ****省略*****</span></span><br><span class=\"line\"><span class=\"comment\">// hoistStatics的作用：常用语高阶组件中，将被包裹元素的静态方法，“同步”到容器元素中。</span></span><br><span class=\"line\"><span class=\"comment\">// 也就是 connect中那些WrappedComponent属性的mix</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> hoistStatics(Connect, WrappedComponent)</span><br></pre></td></tr></table></figure>\n<p>这里，就是HOC常见的增加功能的实现了。  也就是增强与redux的关联，让使用者只需要关注props，而非每次都要自己手动绑定。</p>\n<h4 id=\"connect组件生命周期\"><a href=\"#connect组件生命周期\" class=\"headerlink\" title=\"connect组件生命周期\"></a>connect组件生命周期</h4><p>既然connect存在生命周期，那就顺着生命周期看看</p>\n<h4 id=\"构造函数，就是获取store中的state。\"><a href=\"#构造函数，就是获取store中的state。\" class=\"headerlink\" title=\"构造函数，就是获取store中的state。\"></a>构造函数，就是获取store中的state。</h4><p>this.store 即Provider中挂载的Store</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造函数，获取store中的state</span></span><br><span class=\"line\">      <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props, context)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.version = version</span><br><span class=\"line\">        <span class=\"comment\">// props或者context中，这是provider中挂载的store</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.store = props.store || context.store</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//  获取state</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> storeState = <span class=\"keyword\">this</span>.store.getState()</span><br><span class=\"line\">        <span class=\"comment\">// 初始化state</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; storeState &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.clearCache()</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h4><p>shouldComponentUpdate这里会根据options里面的参数来看是否 pure 选择不同的更新策略</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !pure || <span class=\"keyword\">this</span>.haveOwnPropsChanged || <span class=\"keyword\">this</span>.hasStoreStateChanged</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a>componentDidMount</h4><p> componentDidMount 根据前面的shouldSubscribe标识(mapStateToProps是否为true)决定是否增加监听事件</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.trySubscribe()</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">trySubscribe() &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 存在监听必要 并且没有注册过监听事件</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (shouldSubscribe &amp;&amp; !<span class=\"keyword\">this</span>.unsubscribe) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 业务组件中没有使用的subscribe 在这里实现，这也是HOC的用法之一，公共方法的抽离</span></span><br><span class=\"line\">         <span class=\"comment\">// 注册完成之后，this.unsubscribe为对一个unsubscribe回调</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.unsubscribe = <span class=\"keyword\">this</span>.store.subscribe(<span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.handleChange()</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h4><p> componentWillReceiveProps 判断是否更新 ，对于pure 组件 这里就涉及到了shallowEqual。<br> 通过shallowEqual的实现，我们可以得到Immtable的重要性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!pure || !shallowEqual(nextProps, <span class=\"keyword\">this</span>.props)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.haveOwnPropsChanged = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"shallowEqual浅比较的实现\"><a href=\"#shallowEqual浅比较的实现\" class=\"headerlink\" title=\"shallowEqual浅比较的实现\"></a>shallowEqual浅比较的实现</h4><p>由此可以看到Immutable的重要性。对于引用类型的数据，只是比较了引用地址是否相同。<br>对于嵌套引用数据类型，只比较key的长度和value引用地址，并没有进一步深入比较。导致嵌套结构并不适用。  </p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowEqual</span>(<span class=\"params\">objA, objB</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 引用地址是否相同</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (objA === objB) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysA = <span class=\"built_in\">Object</span>.keys(objA)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysB = <span class=\"built_in\">Object</span>.keys(objB)</span><br><span class=\"line\">  <span class=\"comment\">// key长度是否相同 </span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 循环比较，vakue思否相同，对于嵌套引用类型，这种比较是不能满足预期的。</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hasOwn = <span class=\"built_in\">Object</span>.prototype.hasOwnProperty</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasOwn.call(objB, keysA[i]) ||</span><br><span class=\"line\">        objA[keysA[i]] !== objB[keysA[i]]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h4><p> 再下面是render，对于是否更新进行判断，即是否更新传递给子组件的props<br> render的关注点在于 传递给WrappedComponent的props如何获得。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this.mergedProps 的计算</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (withRef) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.renderedElement = createElement(WrappedComponent, &#123;</span><br><span class=\"line\">           ...this.mergedProps,</span><br><span class=\"line\">           ref: <span class=\"string\">'wrappedInstance'</span></span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.renderedElement = createElement(WrappedComponent,</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.mergedProps</span><br><span class=\"line\">         )</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>计算this.mergedProps 最终传递下去的props是经过mapStateToProps，mapDispatchToProps计算之后，最后再由mergeProps计算之后的state。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简化代码</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.mergedProps = nextMergedProps = computeMergedProps(<span class=\"keyword\">this</span>.stateProps, <span class=\"keyword\">this</span>.dispatchProps, <span class=\"keyword\">this</span>.props)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获得最终props 即经过参数中的</span></span><br><span class=\"line\"><span class=\"comment\">     * @param &#123;*&#125; stateProps 经过mapStateToProps之后的结果</span></span><br><span class=\"line\"><span class=\"comment\">     * @param &#123;*&#125; dispatchProps mapDispatchToProps之后的结果</span></span><br><span class=\"line\"><span class=\"comment\">     * @param &#123;*&#125; parentProps 此处即为connect组件的props this.props</span></span><br><span class=\"line\"><span class=\"comment\">     * @returns</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computeMergedProps</span>(<span class=\"params\">stateProps, dispatchProps, parentProps</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// finalMergeProps 即为参数中的mergeProps 或者 defaultMergeProps。 将前两参数计算结果再进行处理。</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">        checkStateShape(mergedProps, <span class=\"string\">'mergeProps'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mergedProps</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>到这里connect的作用也体现出来了： </p>\n<ol>\n<li>根据参数决定监数据的变化</li>\n<li>将store和action作为warpered的props传入，一共组件使用store中的state和action</li>\n<li>对于部分操作进行缓存优化，提升执行效率</li>\n</ol>\n<p>此时再回过头去看上面的例子应该更清晰了。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"http://cn.redux.js.org/docs/react-redux/api.html\" target=\"_blank\" rel=\"noopener\">http://cn.redux.js.org/docs/react-redux/api.html</a>  </p>\n<p>到这里就结束了react-redux的源码解析，更多是自己的学习笔记吧。<br>使用一定程度之后再回头看，可能对自己的理解更有帮助。<br>另外阅读源码不是要盲目去读，而是在应用之后带着问题去读。<br>这样会更清晰如何去优化如何去提升。因为水平有限肯定有错漏指出，欢迎指出。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Redux作为通用的状态管理器，可以搭配任意界面框架。所以并搭配react使用的话就要借助redux官方提供的React绑定库react-redux，以高效灵活的在react中使用redux。下面我们一起看看是react-redux如何灵活高效的<br>","more":"</p>\n<h2 id=\"redux-概述\"><a href=\"#redux-概述\" class=\"headerlink\" title=\"redux 概述\"></a>redux 概述</h2><p>在开始之间还是大概提一下redux的内容，以免脱节。<a href=\"https://juejin.im/post/5b208ef06fb9a01e615ed8cb\" target=\"_blank\" rel=\"noopener\">比较早的时候也解读了下redux的源码实现，可以参考一下</a>  </p>\n<p>Redux 是 JavaScript 状态容器，旨在提供可预测化的状态管理。<br>其包括action、store、reducer等三部分：  </p>\n<p>在理解各部分作用之前，我们可以通过一个更新数据的例子来捋下思路：</p>\n<ol>\n<li>要更新数据，肯定有个数据库来存储和维护数据。即数据层。</li>\n<li>具体如何更新，需要有负责执行的部分，即逻辑处理层。</li>\n<li>具体何时更新哪个字段、何时更新，同样需要分发层来控制。</li>\n</ol>\n<p>根据上面的例子我们再对比下redux的流程图（图片来自阮一峰大佬）：<br><img src=\"https://user-gold-cdn.xitu.io/2019/5/15/16abbbc0689d7fe1?w=638&h=479&f=jpeg&s=21322\"><br>可以对照着来理解不同部分的作用。  </p>\n<h3 id=\"action\"><a href=\"#action\" class=\"headerlink\" title=\"action\"></a>action</h3><p>就如上面所说负责更新字段和更新时机。  用户接触到的是view(即用户界面)，对应的更新信息通过acton传递给reducer。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 更新类型及具体内容</span></span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a>reducer</h3><p>负责更新数据的具体逻辑。<br>即根据当前state及action携带的信息合成新的数据。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todoApp</span>(<span class=\"params\">state = initialState, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SET_VISIBILITY_FILTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        visibilityFilter: action.filter</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"comment\">// 不同更新类型的处理逻辑不同  </span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_TODO:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        todos: [</span><br><span class=\"line\">          ...state.todos,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            text: action.text,</span><br><span class=\"line\">            completed: <span class=\"literal\">false</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"store\"><a href=\"#store\" class=\"headerlink\" title=\"store\"></a>store</h3><p>store就是负责维护和管理数据。<br>此外还有dispatch，subscrible等api来完成更新事件的分发。<br>例如：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> todoApp <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(todoApp)</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123;</span><br><span class=\"line\">  addTodo&#125; <span class=\"keyword\">from</span> <span class=\"string\">'./actions'</span></span><br><span class=\"line\"><span class=\"comment\">// 注册监听事件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> unsubscribe = store.subscribe(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(store.getState()))</span><br><span class=\"line\"><span class=\"comment\">// 发起一系列 action</span></span><br><span class=\"line\">store.dispatch(addTodo(<span class=\"string\">'Learn about actions'</span>))</span><br><span class=\"line\"><span class=\"comment\">// 停止监听</span></span><br><span class=\"line\">unsubscribe()</span><br></pre></td></tr></table></figure>\n<p>到这里，我们应该就大概明白redux如何更新管理数据的了。</p>\n<ul>\n<li>通过store.subscribe来监听状态更新，这是响应变化的重要一步。</li>\n<li>然后通过stroe.getState()获取相应数据</li>\n<li>具体更新通过action和reducer来实现了。</li>\n</ul>\n<p>那么对照react-redux的实例<a href=\"https://github.com/reduxjs/redux/tree/master/examples/todos/src\" target=\"_blank\" rel=\"noopener\">官方demo</a>，来结合React的时候，会发现redux使用有些不同之处。</p>\n<h3 id=\"不同之处\"><a href=\"#不同之处\" class=\"headerlink\" title=\"不同之处\"></a>不同之处</h3><p>大概可以有下面这三点：  </p>\n<ol>\n<li>组件没有显示调用store.subscrible() </li>\n<li>state也不是通过Store.getState()来获取。</li>\n<li>多了Provider和connect方法</li>\n</ol>\n<p>可以猜测，上述差异是React-redux帮我们封装了绑定监听等过程，避免需要每个应用都重复相同的操作。使得React组件的数据源只关注props和state。</p>\n<h2 id=\"react-redux\"><a href=\"#react-redux\" class=\"headerlink\" title=\"react-redux\"></a>react-redux</h2><p>本质上 react-redux也是react高阶组件HOC的一种实现。其基于 <a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0\" target=\"_blank\" rel=\"noopener\">容器组件和展示组件相分离</a> 的开发思想来实现的。<br>其核心是通过两部分来实现：<br>1、Provider<br>2、container通过connect来解除手动调用store.subscrible</p>\n<h3 id=\"provider-的实现\"><a href=\"#provider-的实现\" class=\"headerlink\" title=\"provider 的实现\"></a>provider 的实现</h3><p>provider用法如下，绑定之后，再经过connect处理，就可以在组件中通过props访问对应信息了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> React <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; render &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-dom'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Provider &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> todoApp <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> App <span class=\"keyword\">from</span> <span class=\"string\">'./components/App'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> store = createStore(todoApp)</span><br><span class=\"line\">render(</span><br><span class=\"line\">  <span class=\"comment\">// 绑定store</span></span><br><span class=\"line\">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class=\"line\">    &lt;App /&gt;</span><br><span class=\"line\">  &lt;<span class=\"regexp\">/Provider&gt;,</span></span><br><span class=\"line\"><span class=\"regexp\">  document.getElementById('root')</span></span><br><span class=\"line\"><span class=\"regexp\">)</span></span><br></pre></td></tr></table></figure>\n<p>在看源码之前，我们先自行猜测一下。<br>前面也提到了Provider是React组件。<br>那么为了让子组件都能方便的访问到store，store这个属性会如何传递呢。props？context？</p>\n<h4 id=\"核心实现\"><a href=\"#核心实现\" class=\"headerlink\" title=\"核心实现\"></a>核心实现</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component, Children &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Provider</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 声明context 以被子组件获取。</span></span><br><span class=\"line\">  getChildContext() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123; <span class=\"attr\">store</span>: <span class=\"keyword\">this</span>.store &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(props, context)</span><br><span class=\"line\">    <span class=\"comment\">// 挂载store到Provider</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.store = props.store</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否只有一个child，是则返回该child节点，否则抛错</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Children.only(<span class=\"keyword\">this</span>.props.children)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Provider将store传递给子组件，具体如何和组件绑定就是conect做的事情了。</p>\n<h3 id=\"connect\"><a href=\"#connect\" class=\"headerlink\" title=\"connect\"></a>connect</h3><p>connect连接组件和store，该操作并不修改原组件而是返回一个新的增强了关联store的组件。<br>根据这个描述，这显然就是个React高阶组件（HOC）吗。先看一下使用：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])</span><br></pre></td></tr></table></figure>\n<p>接收四个参数，具体每个参数的作用详细可以参考<a href=\"http://cn.redux.js.org/docs/react-redux/api.html\" target=\"_blank\" rel=\"noopener\">http://cn.redux.js.org/docs/react-redux/api.html</a>  </p>\n<ul>\n<li>[mapStateToProps(state, [ownProps]): stateProps] (Function): 如果定义该参数，组件将会监听 Redux store 的变化。任何时候，只要 Redux store 发生改变，mapStateToProps 函数就会被调用。该回调函数必须返回一个纯对象，这个对象会与组件的 props 合并。</li>\n<li><a href=\"Object or Function\">mapDispatchToProps(dispatch, [ownProps]): dispatchProps</a>: 如果传递的是一个对象，那么每个定义在该对象的函数都将被当作 Redux action creator，对象所定义的方法名将作为属性名；每个方法将返回一个新的函数，函数中dispatch方法会将 action creator 的返回值作为参数执行。这些属性会被合并到组件的 props 中。</li>\n<li>[mergeProps(stateProps, dispatchProps, ownProps): props] (Function): 如果指定了这个参数，mapStateToProps() 与 mapDispatchToProps() 的执行结果和组件自身的 props 将传入到这个回调函数中。该回调函数返回的对象将作为 props 传递到被包装的组件中。</li>\n<li>[options] (Object) 如果指定这个参数，可以定制 connector 的行为<ul>\n<li>[pure = true] (Boolean): 如果为 true，connector 将执行 shouldComponentUpdate 并且浅对比 mergeProps 的结果，避免不必要的更新，默认true</li>\n<li>[withRef = false] (Boolean): 如果为 true，connector 会保存一个对被被包含的组件实例的引用，该引用通过 getWrappedInstance() 方法获得。默认false</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"结合下面的例子能更清晰知道作用是什么。\"><a href=\"#结合下面的例子能更清晰知道作用是什么。\" class=\"headerlink\" title=\"结合下面的例子能更清晰知道作用是什么。\"></a>结合下面的例子能更清晰知道作用是什么。</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; connect &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react-redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; toggleTodo &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> TodoList <span class=\"keyword\">from</span> <span class=\"string\">'../components/TodoList'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; VisibilityFilters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'../actions'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> getVisibleTodos = <span class=\"function\">(<span class=\"params\">todos, filter</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (filter) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> VisibilityFilters.SHOW_ALL:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos</span><br><span class=\"line\">    <span class=\"keyword\">case</span> VisibilityFilters.SHOW_COMPLETED:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos.filter(<span class=\"function\"><span class=\"params\">t</span> =&gt;</span> t.completed)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> VisibilityFilters.SHOW_ACTIVE:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> todos.filter(<span class=\"function\"><span class=\"params\">t</span> =&gt;</span> !t.completed)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Unknown filter: '</span> + filter)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 将store中的state作为props传递给被包裹组件</span></span><br><span class=\"line\"><span class=\"comment\">// mapStateToProps对应当前组件所需要的props，不过这个props显然是要从store中抽取的，不是所有store都需要，所以只会取state.todos </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapStateToProps = <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  todos: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 将action 与被包裹组件相绑定。</span></span><br><span class=\"line\"><span class=\"comment\">// 其实就是将action中的方法赋值到Props上,以便在组件中调用toggleTodo方法</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> mapDispatchToProps = <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  toggleTodo: <span class=\"function\"><span class=\"params\">id</span> =&gt;</span> dispatch(toggleTodo(id))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 被包裹组件就对应TodoList</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> connect(</span><br><span class=\"line\">  mapStateToProps,</span><br><span class=\"line\">  mapDispatchToProps</span><br><span class=\"line\">)(TodoList)</span><br></pre></td></tr></table></figure>\n<h3 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h3><p>connect实现比较复杂一点，返回的是个高阶函数我们可以先看该函数实现了什么。</p>\n<h4 id=\"connect函数\"><a href=\"#connect函数\" class=\"headerlink\" title=\"connect函数\"></a>connect函数</h4><p>首先该方法接受相关参数，进行参数的判断和兼容处理(不指定使用默认)。<br>并返回一个 wrapWithConnect 方法来装饰传入的容器组件。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 每个参数的默认实现</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultMapStateToProps = <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> (&#123;&#125;) <span class=\"comment\">// eslint-disable-line no-unused-vars</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultMapDispatchToProps = <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> (&#123; dispatch &#125;)</span><br><span class=\"line\"><span class=\"keyword\">const</span> defaultMergeProps = <span class=\"function\">(<span class=\"params\">stateProps, dispatchProps, parentProps</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  ...parentProps,</span><br><span class=\"line\">  ...stateProps,</span><br><span class=\"line\">  ...dispatchProps</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">connect</span>(<span class=\"params\">mapStateToProps, mapDispatchToProps, mergeProps, options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 需要store中的state才会去监听</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> shouldSubscribe = <span class=\"built_in\">Boolean</span>(mapStateToProps)</span><br><span class=\"line\">  <span class=\"comment\">// 更新state 方法的兼容，无mapStateToProps则使用默认</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> mapState = mapStateToProps || defaultMapStateToProps</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> mapDispatch</span><br><span class=\"line\">  <span class=\"comment\">// action creater是否为 函数</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> mapDispatchToProps === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 函数直接赋值</span></span><br><span class=\"line\">    mapDispatch = mapDispatchToProps</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!mapDispatchToProps) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 不存在，则使用默认方法</span></span><br><span class=\"line\">    mapDispatch = defaultMapDispatchToProps</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 否则 将action Creater 包装起来</span></span><br><span class=\"line\">    mapDispatch = wrapActionCreators(mapDispatchToProps)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalMergeProps = mergeProps || defaultMergeProps</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; pure = <span class=\"literal\">true</span>, withRef = <span class=\"literal\">false</span> &#125; = options</span><br><span class=\"line\">  <span class=\"keyword\">const</span> checkMergedEquals = pure &amp;&amp; finalMergeProps !== defaultMergeProps</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">wrapWithConnect</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> connectDisplayName = <span class=\"string\">`Connect(<span class=\"subst\">$&#123;getDisplayName(WrappedComponent)&#125;</span>)`</span></span><br><span class=\"line\">     <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Connect</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;<span class=\"comment\">/****/</span>&#125;</span><br><span class=\"line\">    <span class=\"comment\">// ****</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hoistStatics(Connect, WrappedComponent)</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"wrapWithConnect-函数-返回内容\"><a href=\"#wrapWithConnect-函数-返回内容\" class=\"headerlink\" title=\"wrapWithConnect 函数 返回内容\"></a>wrapWithConnect 函数 返回内容</h4><p>wrapWithConnect 函数接受一个组件(connect这就是个HOC。返回一个connect组件</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ****省略*****</span></span><br><span class=\"line\"><span class=\"comment\">// hoistStatics的作用：常用语高阶组件中，将被包裹元素的静态方法，“同步”到容器元素中。</span></span><br><span class=\"line\"><span class=\"comment\">// 也就是 connect中那些WrappedComponent属性的mix</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> hoistStatics(Connect, WrappedComponent)</span><br></pre></td></tr></table></figure>\n<p>这里，就是HOC常见的增加功能的实现了。  也就是增强与redux的关联，让使用者只需要关注props，而非每次都要自己手动绑定。</p>\n<h4 id=\"connect组件生命周期\"><a href=\"#connect组件生命周期\" class=\"headerlink\" title=\"connect组件生命周期\"></a>connect组件生命周期</h4><p>既然connect存在生命周期，那就顺着生命周期看看</p>\n<h4 id=\"构造函数，就是获取store中的state。\"><a href=\"#构造函数，就是获取store中的state。\" class=\"headerlink\" title=\"构造函数，就是获取store中的state。\"></a>构造函数，就是获取store中的state。</h4><p>this.store 即Provider中挂载的Store</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造函数，获取store中的state</span></span><br><span class=\"line\">      <span class=\"keyword\">constructor</span>(props, context) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(props, context)</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.version = version</span><br><span class=\"line\">        <span class=\"comment\">// props或者context中，这是provider中挂载的store</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.store = props.store || context.store</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">//  获取state</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> storeState = <span class=\"keyword\">this</span>.store.getState()</span><br><span class=\"line\">        <span class=\"comment\">// 初始化state</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.state = &#123; storeState &#125;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.clearCache()</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"shouldComponentUpdate\"><a href=\"#shouldComponentUpdate\" class=\"headerlink\" title=\"shouldComponentUpdate\"></a>shouldComponentUpdate</h4><p>shouldComponentUpdate这里会根据options里面的参数来看是否 pure 选择不同的更新策略</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shouldComponentUpdate() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> !pure || <span class=\"keyword\">this</span>.haveOwnPropsChanged || <span class=\"keyword\">this</span>.hasStoreStateChanged</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"componentDidMount\"><a href=\"#componentDidMount\" class=\"headerlink\" title=\"componentDidMount\"></a>componentDidMount</h4><p> componentDidMount 根据前面的shouldSubscribe标识(mapStateToProps是否为true)决定是否增加监听事件</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentDidMount() &#123;</span><br><span class=\"line\">       <span class=\"keyword\">this</span>.trySubscribe()</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">trySubscribe() &#123;</span><br><span class=\"line\">       <span class=\"comment\">// 存在监听必要 并且没有注册过监听事件</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (shouldSubscribe &amp;&amp; !<span class=\"keyword\">this</span>.unsubscribe) &#123;</span><br><span class=\"line\">         <span class=\"comment\">// 业务组件中没有使用的subscribe 在这里实现，这也是HOC的用法之一，公共方法的抽离</span></span><br><span class=\"line\">         <span class=\"comment\">// 注册完成之后，this.unsubscribe为对一个unsubscribe回调</span></span><br><span class=\"line\">         <span class=\"keyword\">this</span>.unsubscribe = <span class=\"keyword\">this</span>.store.subscribe(<span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>))</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.handleChange()</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">     &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"componentWillReceiveProps\"><a href=\"#componentWillReceiveProps\" class=\"headerlink\" title=\"componentWillReceiveProps\"></a>componentWillReceiveProps</h4><p> componentWillReceiveProps 判断是否更新 ，对于pure 组件 这里就涉及到了shallowEqual。<br> 通过shallowEqual的实现，我们可以得到Immtable的重要性</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillReceiveProps(nextProps) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!pure || !shallowEqual(nextProps, <span class=\"keyword\">this</span>.props)) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">this</span>.haveOwnPropsChanged = <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"shallowEqual浅比较的实现\"><a href=\"#shallowEqual浅比较的实现\" class=\"headerlink\" title=\"shallowEqual浅比较的实现\"></a>shallowEqual浅比较的实现</h4><p>由此可以看到Immutable的重要性。对于引用类型的数据，只是比较了引用地址是否相同。<br>对于嵌套引用数据类型，只比较key的长度和value引用地址，并没有进一步深入比较。导致嵌套结构并不适用。  </p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shallowEqual</span>(<span class=\"params\">objA, objB</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 引用地址是否相同</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (objA === objB) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysA = <span class=\"built_in\">Object</span>.keys(objA)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> keysB = <span class=\"built_in\">Object</span>.keys(objB)</span><br><span class=\"line\">  <span class=\"comment\">// key长度是否相同 </span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 循环比较，vakue思否相同，对于嵌套引用类型，这种比较是不能满足预期的。</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> hasOwn = <span class=\"built_in\">Object</span>.prototype.hasOwnProperty</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!hasOwn.call(objB, keysA[i]) ||</span><br><span class=\"line\">        objA[keysA[i]] !== objB[keysA[i]]) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"render\"><a href=\"#render\" class=\"headerlink\" title=\"render\"></a>render</h4><p> 再下面是render，对于是否更新进行判断，即是否更新传递给子组件的props<br> render的关注点在于 传递给WrappedComponent的props如何获得。</p>\n <figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this.mergedProps 的计算</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (withRef) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.renderedElement = createElement(WrappedComponent, &#123;</span><br><span class=\"line\">           ...this.mergedProps,</span><br><span class=\"line\">           ref: <span class=\"string\">'wrappedInstance'</span></span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">       &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">         <span class=\"keyword\">this</span>.renderedElement = createElement(WrappedComponent,</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.mergedProps</span><br><span class=\"line\">         )</span><br><span class=\"line\">       &#125;</span><br></pre></td></tr></table></figure>\n<p>计算this.mergedProps 最终传递下去的props是经过mapStateToProps，mapDispatchToProps计算之后，最后再由mergeProps计算之后的state。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 简化代码</span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.mergedProps = nextMergedProps = computeMergedProps(<span class=\"keyword\">this</span>.stateProps, <span class=\"keyword\">this</span>.dispatchProps, <span class=\"keyword\">this</span>.props)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获得最终props 即经过参数中的</span></span><br><span class=\"line\"><span class=\"comment\">     * @param &#123;*&#125; stateProps 经过mapStateToProps之后的结果</span></span><br><span class=\"line\"><span class=\"comment\">     * @param &#123;*&#125; dispatchProps mapDispatchToProps之后的结果</span></span><br><span class=\"line\"><span class=\"comment\">     * @param &#123;*&#125; parentProps 此处即为connect组件的props this.props</span></span><br><span class=\"line\"><span class=\"comment\">     * @returns</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">computeMergedProps</span>(<span class=\"params\">stateProps, dispatchProps, parentProps</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">// finalMergeProps 即为参数中的mergeProps 或者 defaultMergeProps。 将前两参数计算结果再进行处理。</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> mergedProps = finalMergeProps(stateProps, dispatchProps, parentProps)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">        checkStateShape(mergedProps, <span class=\"string\">'mergeProps'</span>)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> mergedProps</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>到这里connect的作用也体现出来了： </p>\n<ol>\n<li>根据参数决定监数据的变化</li>\n<li>将store和action作为warpered的props传入，一共组件使用store中的state和action</li>\n<li>对于部分操作进行缓存优化，提升执行效率</li>\n</ol>\n<p>此时再回过头去看上面的例子应该更清晰了。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"http://cn.redux.js.org/docs/react-redux/api.html\" target=\"_blank\" rel=\"noopener\">http://cn.redux.js.org/docs/react-redux/api.html</a>  </p>\n<p>到这里就结束了react-redux的源码解析，更多是自己的学习笔记吧。<br>使用一定程度之后再回头看，可能对自己的理解更有帮助。<br>另外阅读源码不是要盲目去读，而是在应用之后带着问题去读。<br>这样会更清晰如何去优化如何去提升。因为水平有限肯定有错漏指出，欢迎指出。</p>"},{"title":"react-router v4 路由规则解析","date":"2018-11-07T16:00:00.000Z","_content":"  \n\n## 前言  \nreact-router升级到4之后，跟前面版本比有了很大的差别。  \n例如包的拆分，动态路由等[详细的差别就不说了，各位大神的总结也很到位，详细可以点击看看，All About React Router 4这篇文章](https://css-tricks.com/react-router-4/)。  \n此外还有个差别是路由规则的变化。  一直有着上个版本的习惯，所以稍微复杂的路由，配起来的时候简直痛不欲生。  \n痛定思痛，要好好了解下其依赖的匹配规则，即[path-to-regexp](path-to-regexp)。\n\n本文期望读者是对react-router有过使用的同学，不然本文省略了太多东西，可能看起来可能有点太乱。\n<!-- more -->\n## path-to-regexp 是什么   \n其文档一句话介绍很简洁明了:  将路径字符串（如/user/：name）转换为正则表达式。react-router matchPath就是基于其来匹配了。   \n\n### 使用  \n\n```js\nvar pathToRegexp = require('path-to-regexp')\n\n// pathToRegexp(path, keys?, options?)\n// pathToRegexp.parse(path)\n// pathToRegexp.compile(path)\n```\n\n参数：  \n* **path**: 字符串、字符串数组、正则表达式  \n* **keys**  可选  由在path里找到的key组成的数组\n* **options** 可选 由下面几部分组成：  \n   1. 敏感匹配 默认false，当为true时，正则将区分大小写\n   2. 严格模式 默认false 为true，将会匹配可选的紧跟的分隔符\n   3. end 默认true 正则是否匹配至字符串结尾\n   4. start 默认true 是否从字符串开始进行匹配\n   5. 高阶选项（用于非路径名称字符串，例如主机名称hostname）  \n        1. 分隔符 默认每段的分隔符是'/'\n        2. 结尾字符 可选字段或字段列表、用于作为结束字符\n        3. 分隔符列表 解析时要当做分隔符考虑的字段列表 默认‘./’ \n\n还是直接看官方例子吧\n\n```js\n// 匹配的path中关键字，得到由其组成的数组\n// 简而言之，就是匹配的结果，增加该参数，可以更方便的使用和分析\nvar keys = []\nvar re = pathToRegexp('/foo/:bar', keys)\n// 执行结果，转换之后的正则就如下\n// re = /^\\/foo\\/([^\\/]+?)\\/?$/i\n// 得到的路由相关信息\nkeys = [\n    { \n        // 路由path中的参数名称\n        name: 'bar', \n        // 前缀，分隔符等    \n        prefix: '/', \n        delimiter: '/', \n        optional: false, \n        repeat: false, \n        pattern: '[^\\\\/]+?' \n    }\n]\n```\n\n这样看起来应该清楚一下，下面继续看使用规则  \n         \n### 规则  \n\n最简单的例子（结合react-router-config 路由最简单的路由可以如下， 各字段含义就不提了，本文只关注匹配规则）:\n \n```js\nconst routes = [\n  { component: Root,  \n    routes: [\n      { \n        //只匹配/  \n        path: '/',\n        exact: true,\n        component: Home\n      }\n    ]\n  }\n]  \n```\n\n看起来也不过尔尔，简单匹配就完了，但是如果要是有比较复杂的路径的话，例如有这么一个路径:'/a/1/3.html' 其实/1/3都是可以省略的也是可选的，也就是说如下面这样：  \n\n```js\n'/a/1/3.html'\n'/a.html'\n'/a/2.html'\n```\n先不要急着写，这种当然是要有按照相应规则来匹配了，先看下对应规则：\n\n### 参数\n  \n路径参数将会被用来定义参数和匹配关键字列表(即我们的keys)  \n\n#### 命名参数  \n命名参数通过如下形式定义： 在参数前面加上引号，例如：‘：foo’。默认情况下，在path的该区域结束之前的部分都会被匹配到(默认的话也就是两个//之间为一个区域，例如/:foo/，那么:foo 部分就是一个区域(segment))。\n\n```js\nvar re = pathToRegexp('/:foo/:bar')\n// 对应的匹配key数组如下\nkeys = [\n    { name: 'foo', prefix: '/', ... },\n    { name: 'bar', prefix: '/', ... }\n]\n// 对于下面的path，执行结果\nre.exec('/test/route')\n//=> ['/test/route', 'test', 'route']\n```\n\n#### 参数修饰符  \n\n##### 可选\n参数后缀可以加上一个可选标识即'?',表明该参数可选,这样情况下该部分参数如果没有也不正确匹配，只不过在匹配结果里值为undefined  \n\n```js\nvar re = pathToRegexp('/:foo/:bar?')\nkeys = [\n    { name: 'foo', ... }, \n    { \n    name: 'bar', \n    delimiter: '/', \n    // 匹配key数组第二部分就为true，表明该参数可选\n    optional: true, \n    repeat: false }\n]\n// 可省略候选bar对应的部分\nre.exec('/test')\n//=> ['/test', 'test', undefined]\n\nre.exec('/test/route')\n//=> ['/test', 'test', 'route']\n```\n  \n##### 0-n  \n\n当然参数可以以*结尾，标识该部分参数0-n(可以类比正则)。每个匹配都会将前缀(/)考虑进去，即/已经不是默认的区块分割了，这也是跟？的区别。看例子比较清晰  \n\n```js\nvar re = pathToRegexp('/:foo*')\n// keys = [{ name: 'foo', delimiter: '/', optional: true, repeat: true }]\n\nre.exec('/')\n//=> ['/', undefined]\n// 主要看这里，这时候/baz的内容同样被当成 foo的value组成部分了，直接和前面的一起输出\nre.exec('/bar/baz')\n//=> ['/bar/baz', 'bar/baz']\n```\n \n对比下？修饰符，应该比较清楚了。\n\n```js\nvar re = pathToRegexp('/:foo?')\n\n// 直接认为是不匹配的，输出为null\nre.exec('/bar/baz')\n//=> null\n```\n\n##### 1-n \n参数以+结尾时，表明该部分参数至少为1，同样会将分隔符计算进来。可以对比下上面与*的区别\n\n```js\nvar re = pathToRegexp('/:foo+')\n// keys = [{ name: 'foo', delimiter: '/', optional: false, repeat: true }]\n// 此时/ 的路由已经不能匹配了，至少有一个参数\nre.exec('/')\n//=> null\n// 这里倒是跟*一样\nre.exec('/bar/baz')\n//=> ['/bar/baz', 'bar/baz']\n```\n\n##### 自定义匹配参数\n\n所有的参数都可以提供自定义的匹配规则，来覆盖默认规则([^\\/]+)，如下匹配数字的例子：  \n\n```js\n// 这里自定的规则就是我们的数字匹配了(\\d+) \nvar re = pathToRegexp('/icon-:foo(\\\\d+).png')\n// keys = [{ name: 'foo', ... }]\n\nre.exec('/icon-123.png')\n//=> ['/icon-123.png', '123']\n\nre.exec('/icon-abc.png')\n//=> null\n```\n注意：自定义规则中反斜杠(\\)前面需要再加一个反斜杠，例如上线的例子(\\\\d+)(这里跟正则不太一致，记得别混淆)  \n\n#### 未命名参数  \n\n未命名的参数当然也是可行的，即只包含修饰符的群组。和命名参数的功能一样，只不过其name不是对应的key而是数字下标  \n\n```js\n// 第二个区块，匹配的是所有字符.*，显然是未命名的\nvar re = pathToRegexp('/:foo/(.*)')\nkeys = [\n{ name: 'foo', ... }, \n// name就是0了，再有一个则按顺序排列    \n{ name: 0, ... }]\n// 结果没什么差别。\nre.exec('/test/route')\n//=> ['/test/route', 'test', 'route']  \n```  \n注意： react-router v4 不再处理querystring了，大家可以使用各种工具来处理，自己撸个工具也行。  \n\n到这里参数部分已经结束了，回到上面的部分，/a/1/3.html。后面两个参数可选。\n具体规则可以如下配置。  \n\n```js\nconst routes = [\n  { component: Root,  \n    routes: [\n      {  \n        path: '/a(/)?:num1?(/)?:num2?(/)?',\n        exact: true,\n        component: Home\n      }\n    ]\n  }\n]  \n```\n是不是感觉日了那什么，有这么复杂吗，来我们仔细看看有没有这么复杂。\n   \n1. /a是固定的，可以不变，第一部分确定。  \n2. 后面这个1对应num1，且可选  /a/:num1?\n3. 3对应num2,同样可选 /a/:num1?/:num2?.html\n\n看起来应该是这样。那么来试一试吧。\n\n```js\nvar re = pathToRegexp('/a/:num1?/:num2?.html')\n// 第一种情况是满足的，并且正确的得到value了。 3，4\nconsole.log(re.exec('/a/3/4.html')) \n// [ '/a/3/4.html', '3', '4', index: 0, input: '/a/3/4.html' ]\n// 这里看起来没问题，但是我们第一个匹配num1 是 undefined\n// 这样顺序就乱了，这里应该是num1而非num2\nconsole.log(re.exec('/a/4.html'))\n// [ '/a/4.html', undefined, '4', index: 0, input: '/a/4.html' ]\n\n// 直接不能匹配了\nconsole.log(re.exec('/a.html'))\n// null\n```\n\n这里的问题就在于连续两个可选参数的情况下，单纯的使用？就不满足了。  \n\n按照上面的表达式，匹配的应该是第一个参数可选，但只有一个参数时，4.html连着一起，认为是num2的value了。  \n上面的表达式转换为正则之后如下，有兴趣可以研究下：\n这里的4.html命中的是后面的([^\\/]+?)?\\.html(?:\\/)?$\n\n```js\n/^\\/a(?:\\/([^\\/]+?))?\\/([^\\/]+?)?\\.html(?:\\/)?$/i\n```  \n\n对着上面的文档思考下，可以自定义可选参数，那么我们可不可以这样来试试(讲真的，开始真是试的)：    \n\n指明前缀也是可选，表明.html不是跟最后一个区块紧密相连，这样应该可以满足要求  \n\n```js\nvar re = pathToRegexp('/a(/)?:num1?(/)?:num2?.html')\nconsole.log(re.exec('/a/0/4.html'))\n//[ '/a/0/4.html', '/', '0', '/', '4', index: 0, input: '/a/0/4.html' ]\n// 满足需求，这样4其实为num2的value \nconsole.log(re.exec('/a/4.html'))\n//[ '/a/4.html','/','4',undefined,undefined,index: 0,input: '/a/4.html' ]\n// 第三种满足情况\nconsole.log(re.exec('/a.html'))\n// [ '/a.html',undefined,undefined,undefined,undefined,index: 0,input: '/a.html' ]\n```\n\n这样总算满足需求了。  \n\n#### 方法 \n\n有以下这么几个，这里就不详细介绍了。  \n* Parse 返回一个字符串和keys的数组。\n* Compile (\"Reverse\" Path-To-RegExp)  将字符串转换为有效路径。 \n* [其他的参考官网](https://github.com/pillarjs/path-to-regexp)\n\n## 结束语\n到这里关于react-router V4 路由规则部分的解析就结束了。起因也是自己在配置路由时有点懵，不想就那样跟着别人的路由配完就完了。知其然也要知其所以然，应该是我们技术人员一直秉承的一个态度，所以自己总结了一下，抛砖引玉，以供自己记忆和有需要的同学参考。  \n[更多我的博客请移步](https://github.com/xiaoxiangdaiyu/blog)\n### 参考文章  \n* [path-to-regexp文档](https://github.com/pillarjs/path-to-regexp)  \n* [https://css-tricks.com/react-router-4/](https://css-tricks.com/react-router-4/)\n\n\n","source":"_posts/react-router.md","raw":"---\ntitle: react-router v4 路由规则解析\ndate: 2018-11-08\n---\n  \n\n## 前言  \nreact-router升级到4之后，跟前面版本比有了很大的差别。  \n例如包的拆分，动态路由等[详细的差别就不说了，各位大神的总结也很到位，详细可以点击看看，All About React Router 4这篇文章](https://css-tricks.com/react-router-4/)。  \n此外还有个差别是路由规则的变化。  一直有着上个版本的习惯，所以稍微复杂的路由，配起来的时候简直痛不欲生。  \n痛定思痛，要好好了解下其依赖的匹配规则，即[path-to-regexp](path-to-regexp)。\n\n本文期望读者是对react-router有过使用的同学，不然本文省略了太多东西，可能看起来可能有点太乱。\n<!-- more -->\n## path-to-regexp 是什么   \n其文档一句话介绍很简洁明了:  将路径字符串（如/user/：name）转换为正则表达式。react-router matchPath就是基于其来匹配了。   \n\n### 使用  \n\n```js\nvar pathToRegexp = require('path-to-regexp')\n\n// pathToRegexp(path, keys?, options?)\n// pathToRegexp.parse(path)\n// pathToRegexp.compile(path)\n```\n\n参数：  \n* **path**: 字符串、字符串数组、正则表达式  \n* **keys**  可选  由在path里找到的key组成的数组\n* **options** 可选 由下面几部分组成：  \n   1. 敏感匹配 默认false，当为true时，正则将区分大小写\n   2. 严格模式 默认false 为true，将会匹配可选的紧跟的分隔符\n   3. end 默认true 正则是否匹配至字符串结尾\n   4. start 默认true 是否从字符串开始进行匹配\n   5. 高阶选项（用于非路径名称字符串，例如主机名称hostname）  \n        1. 分隔符 默认每段的分隔符是'/'\n        2. 结尾字符 可选字段或字段列表、用于作为结束字符\n        3. 分隔符列表 解析时要当做分隔符考虑的字段列表 默认‘./’ \n\n还是直接看官方例子吧\n\n```js\n// 匹配的path中关键字，得到由其组成的数组\n// 简而言之，就是匹配的结果，增加该参数，可以更方便的使用和分析\nvar keys = []\nvar re = pathToRegexp('/foo/:bar', keys)\n// 执行结果，转换之后的正则就如下\n// re = /^\\/foo\\/([^\\/]+?)\\/?$/i\n// 得到的路由相关信息\nkeys = [\n    { \n        // 路由path中的参数名称\n        name: 'bar', \n        // 前缀，分隔符等    \n        prefix: '/', \n        delimiter: '/', \n        optional: false, \n        repeat: false, \n        pattern: '[^\\\\/]+?' \n    }\n]\n```\n\n这样看起来应该清楚一下，下面继续看使用规则  \n         \n### 规则  \n\n最简单的例子（结合react-router-config 路由最简单的路由可以如下， 各字段含义就不提了，本文只关注匹配规则）:\n \n```js\nconst routes = [\n  { component: Root,  \n    routes: [\n      { \n        //只匹配/  \n        path: '/',\n        exact: true,\n        component: Home\n      }\n    ]\n  }\n]  \n```\n\n看起来也不过尔尔，简单匹配就完了，但是如果要是有比较复杂的路径的话，例如有这么一个路径:'/a/1/3.html' 其实/1/3都是可以省略的也是可选的，也就是说如下面这样：  \n\n```js\n'/a/1/3.html'\n'/a.html'\n'/a/2.html'\n```\n先不要急着写，这种当然是要有按照相应规则来匹配了，先看下对应规则：\n\n### 参数\n  \n路径参数将会被用来定义参数和匹配关键字列表(即我们的keys)  \n\n#### 命名参数  \n命名参数通过如下形式定义： 在参数前面加上引号，例如：‘：foo’。默认情况下，在path的该区域结束之前的部分都会被匹配到(默认的话也就是两个//之间为一个区域，例如/:foo/，那么:foo 部分就是一个区域(segment))。\n\n```js\nvar re = pathToRegexp('/:foo/:bar')\n// 对应的匹配key数组如下\nkeys = [\n    { name: 'foo', prefix: '/', ... },\n    { name: 'bar', prefix: '/', ... }\n]\n// 对于下面的path，执行结果\nre.exec('/test/route')\n//=> ['/test/route', 'test', 'route']\n```\n\n#### 参数修饰符  \n\n##### 可选\n参数后缀可以加上一个可选标识即'?',表明该参数可选,这样情况下该部分参数如果没有也不正确匹配，只不过在匹配结果里值为undefined  \n\n```js\nvar re = pathToRegexp('/:foo/:bar?')\nkeys = [\n    { name: 'foo', ... }, \n    { \n    name: 'bar', \n    delimiter: '/', \n    // 匹配key数组第二部分就为true，表明该参数可选\n    optional: true, \n    repeat: false }\n]\n// 可省略候选bar对应的部分\nre.exec('/test')\n//=> ['/test', 'test', undefined]\n\nre.exec('/test/route')\n//=> ['/test', 'test', 'route']\n```\n  \n##### 0-n  \n\n当然参数可以以*结尾，标识该部分参数0-n(可以类比正则)。每个匹配都会将前缀(/)考虑进去，即/已经不是默认的区块分割了，这也是跟？的区别。看例子比较清晰  \n\n```js\nvar re = pathToRegexp('/:foo*')\n// keys = [{ name: 'foo', delimiter: '/', optional: true, repeat: true }]\n\nre.exec('/')\n//=> ['/', undefined]\n// 主要看这里，这时候/baz的内容同样被当成 foo的value组成部分了，直接和前面的一起输出\nre.exec('/bar/baz')\n//=> ['/bar/baz', 'bar/baz']\n```\n \n对比下？修饰符，应该比较清楚了。\n\n```js\nvar re = pathToRegexp('/:foo?')\n\n// 直接认为是不匹配的，输出为null\nre.exec('/bar/baz')\n//=> null\n```\n\n##### 1-n \n参数以+结尾时，表明该部分参数至少为1，同样会将分隔符计算进来。可以对比下上面与*的区别\n\n```js\nvar re = pathToRegexp('/:foo+')\n// keys = [{ name: 'foo', delimiter: '/', optional: false, repeat: true }]\n// 此时/ 的路由已经不能匹配了，至少有一个参数\nre.exec('/')\n//=> null\n// 这里倒是跟*一样\nre.exec('/bar/baz')\n//=> ['/bar/baz', 'bar/baz']\n```\n\n##### 自定义匹配参数\n\n所有的参数都可以提供自定义的匹配规则，来覆盖默认规则([^\\/]+)，如下匹配数字的例子：  \n\n```js\n// 这里自定的规则就是我们的数字匹配了(\\d+) \nvar re = pathToRegexp('/icon-:foo(\\\\d+).png')\n// keys = [{ name: 'foo', ... }]\n\nre.exec('/icon-123.png')\n//=> ['/icon-123.png', '123']\n\nre.exec('/icon-abc.png')\n//=> null\n```\n注意：自定义规则中反斜杠(\\)前面需要再加一个反斜杠，例如上线的例子(\\\\d+)(这里跟正则不太一致，记得别混淆)  \n\n#### 未命名参数  \n\n未命名的参数当然也是可行的，即只包含修饰符的群组。和命名参数的功能一样，只不过其name不是对应的key而是数字下标  \n\n```js\n// 第二个区块，匹配的是所有字符.*，显然是未命名的\nvar re = pathToRegexp('/:foo/(.*)')\nkeys = [\n{ name: 'foo', ... }, \n// name就是0了，再有一个则按顺序排列    \n{ name: 0, ... }]\n// 结果没什么差别。\nre.exec('/test/route')\n//=> ['/test/route', 'test', 'route']  \n```  \n注意： react-router v4 不再处理querystring了，大家可以使用各种工具来处理，自己撸个工具也行。  \n\n到这里参数部分已经结束了，回到上面的部分，/a/1/3.html。后面两个参数可选。\n具体规则可以如下配置。  \n\n```js\nconst routes = [\n  { component: Root,  \n    routes: [\n      {  \n        path: '/a(/)?:num1?(/)?:num2?(/)?',\n        exact: true,\n        component: Home\n      }\n    ]\n  }\n]  \n```\n是不是感觉日了那什么，有这么复杂吗，来我们仔细看看有没有这么复杂。\n   \n1. /a是固定的，可以不变，第一部分确定。  \n2. 后面这个1对应num1，且可选  /a/:num1?\n3. 3对应num2,同样可选 /a/:num1?/:num2?.html\n\n看起来应该是这样。那么来试一试吧。\n\n```js\nvar re = pathToRegexp('/a/:num1?/:num2?.html')\n// 第一种情况是满足的，并且正确的得到value了。 3，4\nconsole.log(re.exec('/a/3/4.html')) \n// [ '/a/3/4.html', '3', '4', index: 0, input: '/a/3/4.html' ]\n// 这里看起来没问题，但是我们第一个匹配num1 是 undefined\n// 这样顺序就乱了，这里应该是num1而非num2\nconsole.log(re.exec('/a/4.html'))\n// [ '/a/4.html', undefined, '4', index: 0, input: '/a/4.html' ]\n\n// 直接不能匹配了\nconsole.log(re.exec('/a.html'))\n// null\n```\n\n这里的问题就在于连续两个可选参数的情况下，单纯的使用？就不满足了。  \n\n按照上面的表达式，匹配的应该是第一个参数可选，但只有一个参数时，4.html连着一起，认为是num2的value了。  \n上面的表达式转换为正则之后如下，有兴趣可以研究下：\n这里的4.html命中的是后面的([^\\/]+?)?\\.html(?:\\/)?$\n\n```js\n/^\\/a(?:\\/([^\\/]+?))?\\/([^\\/]+?)?\\.html(?:\\/)?$/i\n```  \n\n对着上面的文档思考下，可以自定义可选参数，那么我们可不可以这样来试试(讲真的，开始真是试的)：    \n\n指明前缀也是可选，表明.html不是跟最后一个区块紧密相连，这样应该可以满足要求  \n\n```js\nvar re = pathToRegexp('/a(/)?:num1?(/)?:num2?.html')\nconsole.log(re.exec('/a/0/4.html'))\n//[ '/a/0/4.html', '/', '0', '/', '4', index: 0, input: '/a/0/4.html' ]\n// 满足需求，这样4其实为num2的value \nconsole.log(re.exec('/a/4.html'))\n//[ '/a/4.html','/','4',undefined,undefined,index: 0,input: '/a/4.html' ]\n// 第三种满足情况\nconsole.log(re.exec('/a.html'))\n// [ '/a.html',undefined,undefined,undefined,undefined,index: 0,input: '/a.html' ]\n```\n\n这样总算满足需求了。  \n\n#### 方法 \n\n有以下这么几个，这里就不详细介绍了。  \n* Parse 返回一个字符串和keys的数组。\n* Compile (\"Reverse\" Path-To-RegExp)  将字符串转换为有效路径。 \n* [其他的参考官网](https://github.com/pillarjs/path-to-regexp)\n\n## 结束语\n到这里关于react-router V4 路由规则部分的解析就结束了。起因也是自己在配置路由时有点懵，不想就那样跟着别人的路由配完就完了。知其然也要知其所以然，应该是我们技术人员一直秉承的一个态度，所以自己总结了一下，抛砖引玉，以供自己记忆和有需要的同学参考。  \n[更多我的博客请移步](https://github.com/xiaoxiangdaiyu/blog)\n### 参考文章  \n* [path-to-regexp文档](https://github.com/pillarjs/path-to-regexp)  \n* [https://css-tricks.com/react-router-4/](https://css-tricks.com/react-router-4/)\n\n\n","slug":"react-router","published":1,"updated":"2018-11-09T12:56:43.848Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1x000zgw92jt2x9qyn","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>react-router升级到4之后，跟前面版本比有了很大的差别。<br>例如包的拆分，动态路由等<a href=\"https://css-tricks.com/react-router-4/\" target=\"_blank\" rel=\"noopener\">详细的差别就不说了，各位大神的总结也很到位，详细可以点击看看，All About React Router 4这篇文章</a>。<br>此外还有个差别是路由规则的变化。  一直有着上个版本的习惯，所以稍微复杂的路由，配起来的时候简直痛不欲生。<br>痛定思痛，要好好了解下其依赖的匹配规则，即<a href=\"path-to-regexp\">path-to-regexp</a>。</p>\n<p>本文期望读者是对react-router有过使用的同学，不然本文省略了太多东西，可能看起来可能有点太乱。<br><a id=\"more\"></a></p>\n<h2 id=\"path-to-regexp-是什么\"><a href=\"#path-to-regexp-是什么\" class=\"headerlink\" title=\"path-to-regexp 是什么\"></a>path-to-regexp 是什么</h2><p>其文档一句话介绍很简洁明了:  将路径字符串（如/user/：name）转换为正则表达式。react-router matchPath就是基于其来匹配了。   </p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pathToRegexp = <span class=\"built_in\">require</span>(<span class=\"string\">'path-to-regexp'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pathToRegexp(path, keys?, options?)</span></span><br><span class=\"line\"><span class=\"comment\">// pathToRegexp.parse(path)</span></span><br><span class=\"line\"><span class=\"comment\">// pathToRegexp.compile(path)</span></span><br></pre></td></tr></table></figure>\n<p>参数：  </p>\n<ul>\n<li><strong>path</strong>: 字符串、字符串数组、正则表达式  </li>\n<li><strong>keys</strong>  可选  由在path里找到的key组成的数组</li>\n<li><strong>options</strong> 可选 由下面几部分组成：  <ol>\n<li>敏感匹配 默认false，当为true时，正则将区分大小写</li>\n<li>严格模式 默认false 为true，将会匹配可选的紧跟的分隔符</li>\n<li>end 默认true 正则是否匹配至字符串结尾</li>\n<li>start 默认true 是否从字符串开始进行匹配</li>\n<li>高阶选项（用于非路径名称字符串，例如主机名称hostname）  <ol>\n<li>分隔符 默认每段的分隔符是’/‘</li>\n<li>结尾字符 可选字段或字段列表、用于作为结束字符</li>\n<li>分隔符列表 解析时要当做分隔符考虑的字段列表 默认‘./’ </li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<p>还是直接看官方例子吧</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 匹配的path中关键字，得到由其组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">// 简而言之，就是匹配的结果，增加该参数，可以更方便的使用和分析</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> keys = []</span><br><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/foo/:bar'</span>, keys)</span><br><span class=\"line\"><span class=\"comment\">// 执行结果，转换之后的正则就如下</span></span><br><span class=\"line\"><span class=\"comment\">// re = /^\\/foo\\/([^\\/]+?)\\/?$/i</span></span><br><span class=\"line\"><span class=\"comment\">// 得到的路由相关信息</span></span><br><span class=\"line\">keys = [</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 路由path中的参数名称</span></span><br><span class=\"line\">        name: <span class=\"string\">'bar'</span>, </span><br><span class=\"line\">        <span class=\"comment\">// 前缀，分隔符等    </span></span><br><span class=\"line\">        prefix: <span class=\"string\">'/'</span>, </span><br><span class=\"line\">        delimiter: <span class=\"string\">'/'</span>, </span><br><span class=\"line\">        optional: <span class=\"literal\">false</span>, </span><br><span class=\"line\">        repeat: <span class=\"literal\">false</span>, </span><br><span class=\"line\">        pattern: <span class=\"string\">'[^\\\\/]+?'</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>这样看起来应该清楚一下，下面继续看使用规则  </p>\n<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><p>最简单的例子（结合react-router-config 路由最简单的路由可以如下， 各字段含义就不提了，本文只关注匹配规则）:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> routes = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">component</span>: Root,  </span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">      &#123; </span><br><span class=\"line\">        <span class=\"comment\">//只匹配/  </span></span><br><span class=\"line\">        path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">        exact: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        component: Home</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>看起来也不过尔尔，简单匹配就完了，但是如果要是有比较复杂的路径的话，例如有这么一个路径:’/a/1/3.html’ 其实/1/3都是可以省略的也是可选的，也就是说如下面这样：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'/a/1/3.html'</span></span><br><span class=\"line\"><span class=\"string\">'/a.html'</span></span><br><span class=\"line\"><span class=\"string\">'/a/2.html'</span></span><br></pre></td></tr></table></figure>\n<p>先不要急着写，这种当然是要有按照相应规则来匹配了，先看下对应规则：</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>路径参数将会被用来定义参数和匹配关键字列表(即我们的keys)  </p>\n<h4 id=\"命名参数\"><a href=\"#命名参数\" class=\"headerlink\" title=\"命名参数\"></a>命名参数</h4><p>命名参数通过如下形式定义： 在参数前面加上引号，例如：‘：foo’。默认情况下，在path的该区域结束之前的部分都会被匹配到(默认的话也就是两个//之间为一个区域，例如/:foo/，那么:foo 部分就是一个区域(segment))。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo/:bar'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 对应的匹配key数组如下</span></span><br><span class=\"line\">keys = [</span><br><span class=\"line\">    &#123; <span class=\"attr\">name</span>: <span class=\"string\">'foo'</span>, <span class=\"attr\">prefix</span>: <span class=\"string\">'/'</span>, ... &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">name</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">prefix</span>: <span class=\"string\">'/'</span>, ... &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"comment\">// 对于下面的path，执行结果</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/test/route'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/test/route', 'test', 'route']</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"参数修饰符\"><a href=\"#参数修饰符\" class=\"headerlink\" title=\"参数修饰符\"></a>参数修饰符</h4><h5 id=\"可选\"><a href=\"#可选\" class=\"headerlink\" title=\"可选\"></a>可选</h5><p>参数后缀可以加上一个可选标识即’?’,表明该参数可选,这样情况下该部分参数如果没有也不正确匹配，只不过在匹配结果里值为undefined  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo/:bar?'</span>)</span><br><span class=\"line\">keys = [</span><br><span class=\"line\">    &#123; <span class=\"attr\">name</span>: <span class=\"string\">'foo'</span>, ... &#125;, </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">    name: <span class=\"string\">'bar'</span>, </span><br><span class=\"line\">    delimiter: <span class=\"string\">'/'</span>, </span><br><span class=\"line\">    <span class=\"comment\">// 匹配key数组第二部分就为true，表明该参数可选</span></span><br><span class=\"line\">    optional: <span class=\"literal\">true</span>, </span><br><span class=\"line\">    repeat: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"comment\">// 可省略候选bar对应的部分</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/test'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/test', 'test', undefined]</span></span><br><span class=\"line\"></span><br><span class=\"line\">re.exec(<span class=\"string\">'/test/route'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/test', 'test', 'route']</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"0-n\"><a href=\"#0-n\" class=\"headerlink\" title=\"0-n\"></a>0-n</h5><p>当然参数可以以*结尾，标识该部分参数0-n(可以类比正则)。每个匹配都会将前缀(/)考虑进去，即/已经不是默认的区块分割了，这也是跟？的区别。看例子比较清晰  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo*'</span>)</span><br><span class=\"line\"><span class=\"comment\">// keys = [&#123; name: 'foo', delimiter: '/', optional: true, repeat: true &#125;]</span></span><br><span class=\"line\"></span><br><span class=\"line\">re.exec(<span class=\"string\">'/'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/', undefined]</span></span><br><span class=\"line\"><span class=\"comment\">// 主要看这里，这时候/baz的内容同样被当成 foo的value组成部分了，直接和前面的一起输出</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/bar/baz'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/bar/baz', 'bar/baz']</span></span><br></pre></td></tr></table></figure>\n<p>对比下？修饰符，应该比较清楚了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo?'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接认为是不匹配的，输出为null</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/bar/baz'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; null</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"1-n\"><a href=\"#1-n\" class=\"headerlink\" title=\"1-n\"></a>1-n</h5><p>参数以+结尾时，表明该部分参数至少为1，同样会将分隔符计算进来。可以对比下上面与*的区别</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo+'</span>)</span><br><span class=\"line\"><span class=\"comment\">// keys = [&#123; name: 'foo', delimiter: '/', optional: false, repeat: true &#125;]</span></span><br><span class=\"line\"><span class=\"comment\">// 此时/ 的路由已经不能匹配了，至少有一个参数</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; null</span></span><br><span class=\"line\"><span class=\"comment\">// 这里倒是跟*一样</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/bar/baz'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/bar/baz', 'bar/baz']</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"自定义匹配参数\"><a href=\"#自定义匹配参数\" class=\"headerlink\" title=\"自定义匹配参数\"></a>自定义匹配参数</h5><p>所有的参数都可以提供自定义的匹配规则，来覆盖默认规则([^\\/]+)，如下匹配数字的例子：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里自定的规则就是我们的数字匹配了(\\d+) </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/icon-:foo(\\\\d+).png'</span>)</span><br><span class=\"line\"><span class=\"comment\">// keys = [&#123; name: 'foo', ... &#125;]</span></span><br><span class=\"line\"></span><br><span class=\"line\">re.exec(<span class=\"string\">'/icon-123.png'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/icon-123.png', '123']</span></span><br><span class=\"line\"></span><br><span class=\"line\">re.exec(<span class=\"string\">'/icon-abc.png'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; null</span></span><br></pre></td></tr></table></figure>\n<p>注意：自定义规则中反斜杠()前面需要再加一个反斜杠，例如上线的例子(\\d+)(这里跟正则不太一致，记得别混淆)  </p>\n<h4 id=\"未命名参数\"><a href=\"#未命名参数\" class=\"headerlink\" title=\"未命名参数\"></a>未命名参数</h4><p>未命名的参数当然也是可行的，即只包含修饰符的群组。和命名参数的功能一样，只不过其name不是对应的key而是数字下标  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第二个区块，匹配的是所有字符.*，显然是未命名的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo/(.*)'</span>)</span><br><span class=\"line\">keys = [</span><br><span class=\"line\">&#123; <span class=\"attr\">name</span>: <span class=\"string\">'foo'</span>, ... &#125;, </span><br><span class=\"line\"><span class=\"comment\">// name就是0了，再有一个则按顺序排列    </span></span><br><span class=\"line\">&#123; <span class=\"attr\">name</span>: <span class=\"number\">0</span>, ... &#125;]</span><br><span class=\"line\"><span class=\"comment\">// 结果没什么差别。</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/test/route'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/test/route', 'test', 'route']  </span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">注意： react-router v4 不再处理querystring了，大家可以使用各种工具来处理，自己撸个工具也行。  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">到这里参数部分已经结束了，回到上面的部分，/a/1/3.html。后面两个参数可选。</span></span><br><span class=\"line\"><span class=\"string\">具体规则可以如下配置。  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">const</span> routes = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">component</span>: Root,  </span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">      &#123;  </span><br><span class=\"line\">        path: <span class=\"string\">'/a(/)?:num1?(/)?:num2?(/)?'</span>,</span><br><span class=\"line\">        exact: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        component: Home</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>是不是感觉日了那什么，有这么复杂吗，来我们仔细看看有没有这么复杂。</p>\n<ol>\n<li>/a是固定的，可以不变，第一部分确定。  </li>\n<li>后面这个1对应num1，且可选  /a/:num1?</li>\n<li>3对应num2,同样可选 /a/:num1?/:num2?.html</li>\n</ol>\n<p>看起来应该是这样。那么来试一试吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/a/:num1?/:num2?.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 第一种情况是满足的，并且正确的得到value了。 3，4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a/3/4.html'</span>)) </span><br><span class=\"line\"><span class=\"comment\">// [ '/a/3/4.html', '3', '4', index: 0, input: '/a/3/4.html' ]</span></span><br><span class=\"line\"><span class=\"comment\">// 这里看起来没问题，但是我们第一个匹配num1 是 undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 这样顺序就乱了，这里应该是num1而非num2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a/4.html'</span>))</span><br><span class=\"line\"><span class=\"comment\">// [ '/a/4.html', undefined, '4', index: 0, input: '/a/4.html' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接不能匹配了</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a.html'</span>))</span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>这里的问题就在于连续两个可选参数的情况下，单纯的使用？就不满足了。  </p>\n<p>按照上面的表达式，匹配的应该是第一个参数可选，但只有一个参数时，4.html连着一起，认为是num2的value了。<br>上面的表达式转换为正则之后如下，有兴趣可以研究下：<br>这里的4.html命中的是后面的([^\\/]+?)?.html(?:\\/)?$</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^\\/a(?:\\/([^\\/]+?))?\\/([^\\/]+?)?\\.html(?:\\/)?$/i</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">对着上面的文档思考下，可以自定义可选参数，那么我们可不可以这样来试试(讲真的，开始真是试的)：    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">指明前缀也是可选，表明.html不是跟最后一个区块紧密相连，这样应该可以满足要求  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/a(/)?:num1?(/)?:num2?.html'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a/0/4.html'</span>))</span><br><span class=\"line\"><span class=\"comment\">//[ '/a/0/4.html', '/', '0', '/', '4', index: 0, input: '/a/0/4.html' ]</span></span><br><span class=\"line\"><span class=\"comment\">// 满足需求，这样4其实为num2的value </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a/4.html'</span>))</span><br><span class=\"line\"><span class=\"comment\">//[ '/a/4.html','/','4',undefined,undefined,index: 0,input: '/a/4.html' ]</span></span><br><span class=\"line\"><span class=\"comment\">// 第三种满足情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a.html'</span>))</span><br><span class=\"line\"><span class=\"comment\">// [ '/a.html',undefined,undefined,undefined,undefined,index: 0,input: '/a.html' ]</span></span><br></pre></td></tr></table></figure>\n<p>这样总算满足需求了。  </p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>有以下这么几个，这里就不详细介绍了。  </p>\n<ul>\n<li>Parse 返回一个字符串和keys的数组。</li>\n<li>Compile (“Reverse” Path-To-RegExp)  将字符串转换为有效路径。 </li>\n<li><a href=\"https://github.com/pillarjs/path-to-regexp\" target=\"_blank\" rel=\"noopener\">其他的参考官网</a></li>\n</ul>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>到这里关于react-router V4 路由规则部分的解析就结束了。起因也是自己在配置路由时有点懵，不想就那样跟着别人的路由配完就完了。知其然也要知其所以然，应该是我们技术人员一直秉承的一个态度，所以自己总结了一下，抛砖引玉，以供自己记忆和有需要的同学参考。<br><a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">更多我的博客请移步</a></p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"https://github.com/pillarjs/path-to-regexp\" target=\"_blank\" rel=\"noopener\">path-to-regexp文档</a>  </li>\n<li><a href=\"https://css-tricks.com/react-router-4/\" target=\"_blank\" rel=\"noopener\">https://css-tricks.com/react-router-4/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>react-router升级到4之后，跟前面版本比有了很大的差别。<br>例如包的拆分，动态路由等<a href=\"https://css-tricks.com/react-router-4/\" target=\"_blank\" rel=\"noopener\">详细的差别就不说了，各位大神的总结也很到位，详细可以点击看看，All About React Router 4这篇文章</a>。<br>此外还有个差别是路由规则的变化。  一直有着上个版本的习惯，所以稍微复杂的路由，配起来的时候简直痛不欲生。<br>痛定思痛，要好好了解下其依赖的匹配规则，即<a href=\"path-to-regexp\">path-to-regexp</a>。</p>\n<p>本文期望读者是对react-router有过使用的同学，不然本文省略了太多东西，可能看起来可能有点太乱。<br>","more":"</p>\n<h2 id=\"path-to-regexp-是什么\"><a href=\"#path-to-regexp-是什么\" class=\"headerlink\" title=\"path-to-regexp 是什么\"></a>path-to-regexp 是什么</h2><p>其文档一句话介绍很简洁明了:  将路径字符串（如/user/：name）转换为正则表达式。react-router matchPath就是基于其来匹配了。   </p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> pathToRegexp = <span class=\"built_in\">require</span>(<span class=\"string\">'path-to-regexp'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// pathToRegexp(path, keys?, options?)</span></span><br><span class=\"line\"><span class=\"comment\">// pathToRegexp.parse(path)</span></span><br><span class=\"line\"><span class=\"comment\">// pathToRegexp.compile(path)</span></span><br></pre></td></tr></table></figure>\n<p>参数：  </p>\n<ul>\n<li><strong>path</strong>: 字符串、字符串数组、正则表达式  </li>\n<li><strong>keys</strong>  可选  由在path里找到的key组成的数组</li>\n<li><strong>options</strong> 可选 由下面几部分组成：  <ol>\n<li>敏感匹配 默认false，当为true时，正则将区分大小写</li>\n<li>严格模式 默认false 为true，将会匹配可选的紧跟的分隔符</li>\n<li>end 默认true 正则是否匹配至字符串结尾</li>\n<li>start 默认true 是否从字符串开始进行匹配</li>\n<li>高阶选项（用于非路径名称字符串，例如主机名称hostname）  <ol>\n<li>分隔符 默认每段的分隔符是’/‘</li>\n<li>结尾字符 可选字段或字段列表、用于作为结束字符</li>\n<li>分隔符列表 解析时要当做分隔符考虑的字段列表 默认‘./’ </li>\n</ol>\n</li>\n</ol>\n</li>\n</ul>\n<p>还是直接看官方例子吧</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 匹配的path中关键字，得到由其组成的数组</span></span><br><span class=\"line\"><span class=\"comment\">// 简而言之，就是匹配的结果，增加该参数，可以更方便的使用和分析</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> keys = []</span><br><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/foo/:bar'</span>, keys)</span><br><span class=\"line\"><span class=\"comment\">// 执行结果，转换之后的正则就如下</span></span><br><span class=\"line\"><span class=\"comment\">// re = /^\\/foo\\/([^\\/]+?)\\/?$/i</span></span><br><span class=\"line\"><span class=\"comment\">// 得到的路由相关信息</span></span><br><span class=\"line\">keys = [</span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 路由path中的参数名称</span></span><br><span class=\"line\">        name: <span class=\"string\">'bar'</span>, </span><br><span class=\"line\">        <span class=\"comment\">// 前缀，分隔符等    </span></span><br><span class=\"line\">        prefix: <span class=\"string\">'/'</span>, </span><br><span class=\"line\">        delimiter: <span class=\"string\">'/'</span>, </span><br><span class=\"line\">        optional: <span class=\"literal\">false</span>, </span><br><span class=\"line\">        repeat: <span class=\"literal\">false</span>, </span><br><span class=\"line\">        pattern: <span class=\"string\">'[^\\\\/]+?'</span> </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>这样看起来应该清楚一下，下面继续看使用规则  </p>\n<h3 id=\"规则\"><a href=\"#规则\" class=\"headerlink\" title=\"规则\"></a>规则</h3><p>最简单的例子（结合react-router-config 路由最简单的路由可以如下， 各字段含义就不提了，本文只关注匹配规则）:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> routes = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">component</span>: Root,  </span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">      &#123; </span><br><span class=\"line\">        <span class=\"comment\">//只匹配/  </span></span><br><span class=\"line\">        path: <span class=\"string\">'/'</span>,</span><br><span class=\"line\">        exact: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        component: Home</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>看起来也不过尔尔，简单匹配就完了，但是如果要是有比较复杂的路径的话，例如有这么一个路径:’/a/1/3.html’ 其实/1/3都是可以省略的也是可选的，也就是说如下面这样：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'/a/1/3.html'</span></span><br><span class=\"line\"><span class=\"string\">'/a.html'</span></span><br><span class=\"line\"><span class=\"string\">'/a/2.html'</span></span><br></pre></td></tr></table></figure>\n<p>先不要急着写，这种当然是要有按照相应规则来匹配了，先看下对应规则：</p>\n<h3 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h3><p>路径参数将会被用来定义参数和匹配关键字列表(即我们的keys)  </p>\n<h4 id=\"命名参数\"><a href=\"#命名参数\" class=\"headerlink\" title=\"命名参数\"></a>命名参数</h4><p>命名参数通过如下形式定义： 在参数前面加上引号，例如：‘：foo’。默认情况下，在path的该区域结束之前的部分都会被匹配到(默认的话也就是两个//之间为一个区域，例如/:foo/，那么:foo 部分就是一个区域(segment))。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo/:bar'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 对应的匹配key数组如下</span></span><br><span class=\"line\">keys = [</span><br><span class=\"line\">    &#123; <span class=\"attr\">name</span>: <span class=\"string\">'foo'</span>, <span class=\"attr\">prefix</span>: <span class=\"string\">'/'</span>, ... &#125;,</span><br><span class=\"line\">    &#123; <span class=\"attr\">name</span>: <span class=\"string\">'bar'</span>, <span class=\"attr\">prefix</span>: <span class=\"string\">'/'</span>, ... &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"comment\">// 对于下面的path，执行结果</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/test/route'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/test/route', 'test', 'route']</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"参数修饰符\"><a href=\"#参数修饰符\" class=\"headerlink\" title=\"参数修饰符\"></a>参数修饰符</h4><h5 id=\"可选\"><a href=\"#可选\" class=\"headerlink\" title=\"可选\"></a>可选</h5><p>参数后缀可以加上一个可选标识即’?’,表明该参数可选,这样情况下该部分参数如果没有也不正确匹配，只不过在匹配结果里值为undefined  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo/:bar?'</span>)</span><br><span class=\"line\">keys = [</span><br><span class=\"line\">    &#123; <span class=\"attr\">name</span>: <span class=\"string\">'foo'</span>, ... &#125;, </span><br><span class=\"line\">    &#123; </span><br><span class=\"line\">    name: <span class=\"string\">'bar'</span>, </span><br><span class=\"line\">    delimiter: <span class=\"string\">'/'</span>, </span><br><span class=\"line\">    <span class=\"comment\">// 匹配key数组第二部分就为true，表明该参数可选</span></span><br><span class=\"line\">    optional: <span class=\"literal\">true</span>, </span><br><span class=\"line\">    repeat: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">]</span><br><span class=\"line\"><span class=\"comment\">// 可省略候选bar对应的部分</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/test'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/test', 'test', undefined]</span></span><br><span class=\"line\"></span><br><span class=\"line\">re.exec(<span class=\"string\">'/test/route'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/test', 'test', 'route']</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"0-n\"><a href=\"#0-n\" class=\"headerlink\" title=\"0-n\"></a>0-n</h5><p>当然参数可以以*结尾，标识该部分参数0-n(可以类比正则)。每个匹配都会将前缀(/)考虑进去，即/已经不是默认的区块分割了，这也是跟？的区别。看例子比较清晰  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo*'</span>)</span><br><span class=\"line\"><span class=\"comment\">// keys = [&#123; name: 'foo', delimiter: '/', optional: true, repeat: true &#125;]</span></span><br><span class=\"line\"></span><br><span class=\"line\">re.exec(<span class=\"string\">'/'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/', undefined]</span></span><br><span class=\"line\"><span class=\"comment\">// 主要看这里，这时候/baz的内容同样被当成 foo的value组成部分了，直接和前面的一起输出</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/bar/baz'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/bar/baz', 'bar/baz']</span></span><br></pre></td></tr></table></figure>\n<p>对比下？修饰符，应该比较清楚了。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo?'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接认为是不匹配的，输出为null</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/bar/baz'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; null</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"1-n\"><a href=\"#1-n\" class=\"headerlink\" title=\"1-n\"></a>1-n</h5><p>参数以+结尾时，表明该部分参数至少为1，同样会将分隔符计算进来。可以对比下上面与*的区别</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo+'</span>)</span><br><span class=\"line\"><span class=\"comment\">// keys = [&#123; name: 'foo', delimiter: '/', optional: false, repeat: true &#125;]</span></span><br><span class=\"line\"><span class=\"comment\">// 此时/ 的路由已经不能匹配了，至少有一个参数</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; null</span></span><br><span class=\"line\"><span class=\"comment\">// 这里倒是跟*一样</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/bar/baz'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/bar/baz', 'bar/baz']</span></span><br></pre></td></tr></table></figure>\n<h5 id=\"自定义匹配参数\"><a href=\"#自定义匹配参数\" class=\"headerlink\" title=\"自定义匹配参数\"></a>自定义匹配参数</h5><p>所有的参数都可以提供自定义的匹配规则，来覆盖默认规则([^\\/]+)，如下匹配数字的例子：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这里自定的规则就是我们的数字匹配了(\\d+) </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/icon-:foo(\\\\d+).png'</span>)</span><br><span class=\"line\"><span class=\"comment\">// keys = [&#123; name: 'foo', ... &#125;]</span></span><br><span class=\"line\"></span><br><span class=\"line\">re.exec(<span class=\"string\">'/icon-123.png'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/icon-123.png', '123']</span></span><br><span class=\"line\"></span><br><span class=\"line\">re.exec(<span class=\"string\">'/icon-abc.png'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; null</span></span><br></pre></td></tr></table></figure>\n<p>注意：自定义规则中反斜杠()前面需要再加一个反斜杠，例如上线的例子(\\d+)(这里跟正则不太一致，记得别混淆)  </p>\n<h4 id=\"未命名参数\"><a href=\"#未命名参数\" class=\"headerlink\" title=\"未命名参数\"></a>未命名参数</h4><p>未命名的参数当然也是可行的，即只包含修饰符的群组。和命名参数的功能一样，只不过其name不是对应的key而是数字下标  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 第二个区块，匹配的是所有字符.*，显然是未命名的</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/:foo/(.*)'</span>)</span><br><span class=\"line\">keys = [</span><br><span class=\"line\">&#123; <span class=\"attr\">name</span>: <span class=\"string\">'foo'</span>, ... &#125;, </span><br><span class=\"line\"><span class=\"comment\">// name就是0了，再有一个则按顺序排列    </span></span><br><span class=\"line\">&#123; <span class=\"attr\">name</span>: <span class=\"number\">0</span>, ... &#125;]</span><br><span class=\"line\"><span class=\"comment\">// 结果没什么差别。</span></span><br><span class=\"line\">re.exec(<span class=\"string\">'/test/route'</span>)</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['/test/route', 'test', 'route']  </span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">注意： react-router v4 不再处理querystring了，大家可以使用各种工具来处理，自己撸个工具也行。  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">到这里参数部分已经结束了，回到上面的部分，/a/1/3.html。后面两个参数可选。</span></span><br><span class=\"line\"><span class=\"string\">具体规则可以如下配置。  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">const</span> routes = [</span><br><span class=\"line\">  &#123; <span class=\"attr\">component</span>: Root,  </span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">      &#123;  </span><br><span class=\"line\">        path: <span class=\"string\">'/a(/)?:num1?(/)?:num2?(/)?'</span>,</span><br><span class=\"line\">        exact: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        component: Home</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n<p>是不是感觉日了那什么，有这么复杂吗，来我们仔细看看有没有这么复杂。</p>\n<ol>\n<li>/a是固定的，可以不变，第一部分确定。  </li>\n<li>后面这个1对应num1，且可选  /a/:num1?</li>\n<li>3对应num2,同样可选 /a/:num1?/:num2?.html</li>\n</ol>\n<p>看起来应该是这样。那么来试一试吧。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/a/:num1?/:num2?.html'</span>)</span><br><span class=\"line\"><span class=\"comment\">// 第一种情况是满足的，并且正确的得到value了。 3，4</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a/3/4.html'</span>)) </span><br><span class=\"line\"><span class=\"comment\">// [ '/a/3/4.html', '3', '4', index: 0, input: '/a/3/4.html' ]</span></span><br><span class=\"line\"><span class=\"comment\">// 这里看起来没问题，但是我们第一个匹配num1 是 undefined</span></span><br><span class=\"line\"><span class=\"comment\">// 这样顺序就乱了，这里应该是num1而非num2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a/4.html'</span>))</span><br><span class=\"line\"><span class=\"comment\">// [ '/a/4.html', undefined, '4', index: 0, input: '/a/4.html' ]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接不能匹配了</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a.html'</span>))</span><br><span class=\"line\"><span class=\"comment\">// null</span></span><br></pre></td></tr></table></figure>\n<p>这里的问题就在于连续两个可选参数的情况下，单纯的使用？就不满足了。  </p>\n<p>按照上面的表达式，匹配的应该是第一个参数可选，但只有一个参数时，4.html连着一起，认为是num2的value了。<br>上面的表达式转换为正则之后如下，有兴趣可以研究下：<br>这里的4.html命中的是后面的([^\\/]+?)?.html(?:\\/)?$</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/^\\/a(?:\\/([^\\/]+?))?\\/([^\\/]+?)?\\.html(?:\\/)?$/i</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">对着上面的文档思考下，可以自定义可选参数，那么我们可不可以这样来试试(讲真的，开始真是试的)：    </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">指明前缀也是可选，表明.html不是跟最后一个区块紧密相连，这样应该可以满足要求  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> re = pathToRegexp(<span class=\"string\">'/a(/)?:num1?(/)?:num2?.html'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a/0/4.html'</span>))</span><br><span class=\"line\"><span class=\"comment\">//[ '/a/0/4.html', '/', '0', '/', '4', index: 0, input: '/a/0/4.html' ]</span></span><br><span class=\"line\"><span class=\"comment\">// 满足需求，这样4其实为num2的value </span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a/4.html'</span>))</span><br><span class=\"line\"><span class=\"comment\">//[ '/a/4.html','/','4',undefined,undefined,index: 0,input: '/a/4.html' ]</span></span><br><span class=\"line\"><span class=\"comment\">// 第三种满足情况</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(re.exec(<span class=\"string\">'/a.html'</span>))</span><br><span class=\"line\"><span class=\"comment\">// [ '/a.html',undefined,undefined,undefined,undefined,index: 0,input: '/a.html' ]</span></span><br></pre></td></tr></table></figure>\n<p>这样总算满足需求了。  </p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>有以下这么几个，这里就不详细介绍了。  </p>\n<ul>\n<li>Parse 返回一个字符串和keys的数组。</li>\n<li>Compile (“Reverse” Path-To-RegExp)  将字符串转换为有效路径。 </li>\n<li><a href=\"https://github.com/pillarjs/path-to-regexp\" target=\"_blank\" rel=\"noopener\">其他的参考官网</a></li>\n</ul>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>到这里关于react-router V4 路由规则部分的解析就结束了。起因也是自己在配置路由时有点懵，不想就那样跟着别人的路由配完就完了。知其然也要知其所以然，应该是我们技术人员一直秉承的一个态度，所以自己总结了一下，抛砖引玉，以供自己记忆和有需要的同学参考。<br><a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">更多我的博客请移步</a></p>\n<h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ul>\n<li><a href=\"https://github.com/pillarjs/path-to-regexp\" target=\"_blank\" rel=\"noopener\">path-to-regexp文档</a>  </li>\n<li><a href=\"https://css-tricks.com/react-router-4/\" target=\"_blank\" rel=\"noopener\">https://css-tricks.com/react-router-4/</a></li>\n</ul>"},{"title":"node.js监听文件变化的实现","date":"2019-04-15T16:00:00.000Z","_content":"\n## 前言\n\n随着前端技术的飞速发展，前端开发也从原始的刀耕火种，向着工程化效率化的方向发展。在各种开发框架之外，打包编译等技术也是层出不穷，开发体验也是越来越好。例如HMR，让我们的更新可以即时可见，告别了手动F5的情况。其实现就是监听文件变化自动调用构建过程。下面就关注下如何实现node监听文件变化。\n<!-- more -->\n## 场景\n假定要监听index.js，每当内容更改重新编译。  \n我们就用简单的console来标识执行编译。下面就是实现该功能。\n\n## node原生API\n### fs.watchFile\n翻下node的文档就会看到一个满足我们需求的Api[fs.watchFile](https://nodejs.org/docs/latest-v9.x/api/fs.html#fs_fs_watchfile_filename_options_listener)(毕竟是文件相关的操作，很大可能就在fs模块下面了)。  \n\n```js\nfs.watchFile(filename[, options], listener)\n```\n\n* filename 显然就是文件名\n* options 可选 对象 包含以下两个属性\n        \n   *  persistent  文件被监听时进程是否继续，默认true \n   *  interval 多长时间轮训一次目标文件，默认5007毫秒\n* listener 事件回调 包含两个参数\n   * current  当前文件stat对象\n   * prev 之前文件stat对象  \n\n\n看完参数信息，不知道大家有没有从其参数属性中得到点什么特别的信息。特别是interval选项和listener中的回调参数。\n  \n监控filename对应文件，每当访问文件时会触发回调。  \n\n这里每当访问文件时会触发，实际指的是每次切换之后再次进入文件，然后保存之后，无论是否做了修改都会出发回调。  \n\n另外轮询事件和文件对象，是不是可以猜测，其实现监听的原理，固定时间轮询文件状态，然后将前后的状态返回，将判断交给使用者。  \n所以node也建议，如果要获取文件修改，那么需要根据stat对象的修改时间来进行对比，即比较 curr.mtime 和 prev.mtime。  \n\n这样就有点问题，我们先看下例子，会更清晰一点。\n\n```js\nconst fs = require('fs')\nconst filePath = './index.js'\nconsole.log(`正在监听 ${filePath}`);\nfs.watchFile(filePath, (cur, prv) => {\n    if (filePath) {\n        // 打印出修改时间\n        console.log(`cur.mtime>>${cur.mtime.toLocaleString()}`)\n        console.log(`prv.mtime>>${prv.mtime.toLocaleString()}`)\n        // 根据修改时间判断做下区分，以分辨是否更改\n        if (cur.mtime != prv.mtime){\n            console.log(`${filePath}文件发生更新`)\n        }\n    }\n})\n```\n然后测试结果如下：\n\n```js\n// 运行 \nnode watch1.js\n// 1、访问index.js 不做修改，然后保存\n// 2、切换文件，再次访问，不做修改，只报错\n// 3、编辑内容，并保存\n```\n<img src='/img/watchfile/watchFile.gif'/>\n\n可以看到1、2两步，并没有实际修改内容，然而我们并没有办法区分。只要你是切换之后再保存，修改时间戳mtime就发生变化。  \n另外响应时间真的很慢，毕竟是轮询。\n\n对于这些问题，其实官网也给了一句话：  \n  \n```bash\nUsing fs.watch() is more efficient than fs.watchFile and fs.unwatchFile. fs.watch should be used instead of fs.watchFile and fs.unwatchFile when possible.\n```\n\n**能用fs.watch的情况就不要用watchFile了。一是效率，二是不能准确获知修改状态 三是只能监听单独文件**  \n对于实际开发过程中，显然我们想要关注的是源文件夹的变动。  \n\n### fs.watch\n\n首先用法如下：\n\n```js\nfs.watch(filename[, options][, listener])\n```\n跟fs.watchFile比较类似。 \n\n* filename 显然就是文件名\n* options 可选 对象或者字符串 包含以下三个属性\n        \n   *  persistent  文件被监听时进程是否继续，默认true\n   *  recursive 是否监控所有子目录，默认false 即当前目录，true为所有子目录。 \n   *  encoding 指定传递给回调事件的文件名称，默认utf8\n* listener 事件回调 包含两个参数\n   * eventType  事件类型，rename 或者 change\n   * filename 当前变更文件的文件名\n\noptions如果是字符串，指的是encoding。  \n\n监听filename对应的文件或者文件夹(recursive参数也体现出来这一特性)，返回一个fs.FSWatcher对象。\n\n该功能的实现依赖于底层操作系统的对于文件更改的通知。 所以就存在一个问题，可能不同平台的实现不太相同。\n如下示例1：  \n\n```js\nconst fs = require('fs')\nconst filePath = './'    \nconsole.log(`正在监听 ${filePath}`);\nfs.watch(filePath,(event,filename)=>{\n    if (filename){\n        console.log(`${filename}文件发生更新`)\n    }\n})\n```\n一个比较明显的优势就体现出来了：响应比较及时，相比于轮询，效率肯定更高。  \n\n不过这样修改并保存的时候回发现同样有点问题。\n直接保存，显示两次更新  \n修改文件之后，同样显示两次更新(mac系统上是两次，其他系统可能有所差别)\n<img src='/img/watchfile/watch1.gif'/>\n这样可能是于操作系统对文件修改的事件支持有关，在保存的时候出发了不止一次。  \n下面聚焦于回调事件的参数，event对应事件类型，是否可以判断事件类型为change呢，才执行呢，忽略空保存。  \n\n```js\nconst fs = require('fs')\nconst filePath = './'    \nconsole.log(`正在监听 ${filePath}`);\nfs.watch(filePath,(event,filename)=>{\n    console.log(`event类型${event}`)\n    if (filename && event == 'change') {\n        console.log(`${filename}文件发生更新`)\n    }\n})\n```\n不过实际上，空的保存event也是change，另外不同平台event的实现可能也有所不同。这种方式要pass掉。   \n\n#### 校验变更时间\n显然从上面的例子可以看到，变更时间依然不可控。因为每次保存，node对应stat对象依然会修改。\n\n#### 对比文件内容  \n只能选择这种方式来判断是否是否更新。例如md5:\n\n```js\nconst fs = require('fs'),\n    md5 = require('md5');\nconst filePath = './'    \nlet preveMd5 = null\n\nconsole.log(`正在监听 ${filePath}`);\nfs.watch(filePath,(event,filename)=>{\n    var currentMd5 = md5(fs.readFileSync(filePath + filename))\n    if (currentMd5 == preveMd5) {\n        return\n    }\n    preveMd5 = currentMd5\n    console.log(`${filePath}文件发生更新`)\n})\n```\n先保存当前文件md5值，每次文件变化时(即保存操作响应之后)，每次都获取文件的md5然后进行对比，看是否发生变化。  \n<img src='/img/watchfile/md51.gif'/>\n不过这样可以看到，当初次保存时，都会执行一次，因为初始值为null的缘故。这样可以加个兼容，根据是否第一次保存来判断好了。\n\n#### 优化\n\n对于不同的操作系统，可能保存时触发的回调不止一个(mac上到没出现)。为了避免这种实时响应对应的频繁触发，可以引入debounce函数来保证性能。  \n\n```js\nconst fs = require('fs'),\n    md5 = require('md5');\nlet preveMd5 = null,\n    fsWait = false\nconst filePath = './'    \nconsole.log(`正在监听 ${filePath}`);\nfs.watch(filePath,(event,filename)=>{\n    if (filename){\n        if (fsWait) return;\n        fsWait = setTimeout(() => {\n            fsWait = false;\n        }, 100)\n        var currentMd5 = md5(fs.readFileSync(filePath + filename))\n        if (currentMd5 == preveMd5){\n            return \n        }\n        preveMd5 = currentMd5\n        console.log(`${filePath}文件发生更新`)\n    }\n})\n```\n\n\n## 结束语  \n到这里，node监听文件的实现就结束了。做个学习笔记，来做个参考记录。实现起来并不难，但是要实际应用的话需要考虑的方面就比较多了。还是推荐开源框架node-watch、chokidar等，各方面实现的都比较完善。   \n#### 参考文章\n[node文档](https://nodejs.org/docs/latest-v9.x/api/fs.html#fs_fs_watchfile_filename_options_listener)  \n[How to Watch for Files Changes in Node.js](https://thisdavej.com/how-to-watch-for-files-changes-in-node-js/)  \n[Nodejs Monitor File Changes](https://stackfame.com/nodejs-monitor-file-changes)","source":"_posts/watchfile.md","raw":"---\ntitle: node.js监听文件变化的实现\ndate: 2019-04-16\n---\n\n## 前言\n\n随着前端技术的飞速发展，前端开发也从原始的刀耕火种，向着工程化效率化的方向发展。在各种开发框架之外，打包编译等技术也是层出不穷，开发体验也是越来越好。例如HMR，让我们的更新可以即时可见，告别了手动F5的情况。其实现就是监听文件变化自动调用构建过程。下面就关注下如何实现node监听文件变化。\n<!-- more -->\n## 场景\n假定要监听index.js，每当内容更改重新编译。  \n我们就用简单的console来标识执行编译。下面就是实现该功能。\n\n## node原生API\n### fs.watchFile\n翻下node的文档就会看到一个满足我们需求的Api[fs.watchFile](https://nodejs.org/docs/latest-v9.x/api/fs.html#fs_fs_watchfile_filename_options_listener)(毕竟是文件相关的操作，很大可能就在fs模块下面了)。  \n\n```js\nfs.watchFile(filename[, options], listener)\n```\n\n* filename 显然就是文件名\n* options 可选 对象 包含以下两个属性\n        \n   *  persistent  文件被监听时进程是否继续，默认true \n   *  interval 多长时间轮训一次目标文件，默认5007毫秒\n* listener 事件回调 包含两个参数\n   * current  当前文件stat对象\n   * prev 之前文件stat对象  \n\n\n看完参数信息，不知道大家有没有从其参数属性中得到点什么特别的信息。特别是interval选项和listener中的回调参数。\n  \n监控filename对应文件，每当访问文件时会触发回调。  \n\n这里每当访问文件时会触发，实际指的是每次切换之后再次进入文件，然后保存之后，无论是否做了修改都会出发回调。  \n\n另外轮询事件和文件对象，是不是可以猜测，其实现监听的原理，固定时间轮询文件状态，然后将前后的状态返回，将判断交给使用者。  \n所以node也建议，如果要获取文件修改，那么需要根据stat对象的修改时间来进行对比，即比较 curr.mtime 和 prev.mtime。  \n\n这样就有点问题，我们先看下例子，会更清晰一点。\n\n```js\nconst fs = require('fs')\nconst filePath = './index.js'\nconsole.log(`正在监听 ${filePath}`);\nfs.watchFile(filePath, (cur, prv) => {\n    if (filePath) {\n        // 打印出修改时间\n        console.log(`cur.mtime>>${cur.mtime.toLocaleString()}`)\n        console.log(`prv.mtime>>${prv.mtime.toLocaleString()}`)\n        // 根据修改时间判断做下区分，以分辨是否更改\n        if (cur.mtime != prv.mtime){\n            console.log(`${filePath}文件发生更新`)\n        }\n    }\n})\n```\n然后测试结果如下：\n\n```js\n// 运行 \nnode watch1.js\n// 1、访问index.js 不做修改，然后保存\n// 2、切换文件，再次访问，不做修改，只报错\n// 3、编辑内容，并保存\n```\n<img src='/img/watchfile/watchFile.gif'/>\n\n可以看到1、2两步，并没有实际修改内容，然而我们并没有办法区分。只要你是切换之后再保存，修改时间戳mtime就发生变化。  \n另外响应时间真的很慢，毕竟是轮询。\n\n对于这些问题，其实官网也给了一句话：  \n  \n```bash\nUsing fs.watch() is more efficient than fs.watchFile and fs.unwatchFile. fs.watch should be used instead of fs.watchFile and fs.unwatchFile when possible.\n```\n\n**能用fs.watch的情况就不要用watchFile了。一是效率，二是不能准确获知修改状态 三是只能监听单独文件**  \n对于实际开发过程中，显然我们想要关注的是源文件夹的变动。  \n\n### fs.watch\n\n首先用法如下：\n\n```js\nfs.watch(filename[, options][, listener])\n```\n跟fs.watchFile比较类似。 \n\n* filename 显然就是文件名\n* options 可选 对象或者字符串 包含以下三个属性\n        \n   *  persistent  文件被监听时进程是否继续，默认true\n   *  recursive 是否监控所有子目录，默认false 即当前目录，true为所有子目录。 \n   *  encoding 指定传递给回调事件的文件名称，默认utf8\n* listener 事件回调 包含两个参数\n   * eventType  事件类型，rename 或者 change\n   * filename 当前变更文件的文件名\n\noptions如果是字符串，指的是encoding。  \n\n监听filename对应的文件或者文件夹(recursive参数也体现出来这一特性)，返回一个fs.FSWatcher对象。\n\n该功能的实现依赖于底层操作系统的对于文件更改的通知。 所以就存在一个问题，可能不同平台的实现不太相同。\n如下示例1：  \n\n```js\nconst fs = require('fs')\nconst filePath = './'    \nconsole.log(`正在监听 ${filePath}`);\nfs.watch(filePath,(event,filename)=>{\n    if (filename){\n        console.log(`${filename}文件发生更新`)\n    }\n})\n```\n一个比较明显的优势就体现出来了：响应比较及时，相比于轮询，效率肯定更高。  \n\n不过这样修改并保存的时候回发现同样有点问题。\n直接保存，显示两次更新  \n修改文件之后，同样显示两次更新(mac系统上是两次，其他系统可能有所差别)\n<img src='/img/watchfile/watch1.gif'/>\n这样可能是于操作系统对文件修改的事件支持有关，在保存的时候出发了不止一次。  \n下面聚焦于回调事件的参数，event对应事件类型，是否可以判断事件类型为change呢，才执行呢，忽略空保存。  \n\n```js\nconst fs = require('fs')\nconst filePath = './'    \nconsole.log(`正在监听 ${filePath}`);\nfs.watch(filePath,(event,filename)=>{\n    console.log(`event类型${event}`)\n    if (filename && event == 'change') {\n        console.log(`${filename}文件发生更新`)\n    }\n})\n```\n不过实际上，空的保存event也是change，另外不同平台event的实现可能也有所不同。这种方式要pass掉。   \n\n#### 校验变更时间\n显然从上面的例子可以看到，变更时间依然不可控。因为每次保存，node对应stat对象依然会修改。\n\n#### 对比文件内容  \n只能选择这种方式来判断是否是否更新。例如md5:\n\n```js\nconst fs = require('fs'),\n    md5 = require('md5');\nconst filePath = './'    \nlet preveMd5 = null\n\nconsole.log(`正在监听 ${filePath}`);\nfs.watch(filePath,(event,filename)=>{\n    var currentMd5 = md5(fs.readFileSync(filePath + filename))\n    if (currentMd5 == preveMd5) {\n        return\n    }\n    preveMd5 = currentMd5\n    console.log(`${filePath}文件发生更新`)\n})\n```\n先保存当前文件md5值，每次文件变化时(即保存操作响应之后)，每次都获取文件的md5然后进行对比，看是否发生变化。  \n<img src='/img/watchfile/md51.gif'/>\n不过这样可以看到，当初次保存时，都会执行一次，因为初始值为null的缘故。这样可以加个兼容，根据是否第一次保存来判断好了。\n\n#### 优化\n\n对于不同的操作系统，可能保存时触发的回调不止一个(mac上到没出现)。为了避免这种实时响应对应的频繁触发，可以引入debounce函数来保证性能。  \n\n```js\nconst fs = require('fs'),\n    md5 = require('md5');\nlet preveMd5 = null,\n    fsWait = false\nconst filePath = './'    \nconsole.log(`正在监听 ${filePath}`);\nfs.watch(filePath,(event,filename)=>{\n    if (filename){\n        if (fsWait) return;\n        fsWait = setTimeout(() => {\n            fsWait = false;\n        }, 100)\n        var currentMd5 = md5(fs.readFileSync(filePath + filename))\n        if (currentMd5 == preveMd5){\n            return \n        }\n        preveMd5 = currentMd5\n        console.log(`${filePath}文件发生更新`)\n    }\n})\n```\n\n\n## 结束语  \n到这里，node监听文件的实现就结束了。做个学习笔记，来做个参考记录。实现起来并不难，但是要实际应用的话需要考虑的方面就比较多了。还是推荐开源框架node-watch、chokidar等，各方面实现的都比较完善。   \n#### 参考文章\n[node文档](https://nodejs.org/docs/latest-v9.x/api/fs.html#fs_fs_watchfile_filename_options_listener)  \n[How to Watch for Files Changes in Node.js](https://thisdavej.com/how-to-watch-for-files-changes-in-node-js/)  \n[Nodejs Monitor File Changes](https://stackfame.com/nodejs-monitor-file-changes)","slug":"watchfile","published":1,"updated":"2019-04-16T14:19:11.683Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1x0010gw92w05l5w6g","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>随着前端技术的飞速发展，前端开发也从原始的刀耕火种，向着工程化效率化的方向发展。在各种开发框架之外，打包编译等技术也是层出不穷，开发体验也是越来越好。例如HMR，让我们的更新可以即时可见，告别了手动F5的情况。其实现就是监听文件变化自动调用构建过程。下面就关注下如何实现node监听文件变化。<br><a id=\"more\"></a></p>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>假定要监听index.js，每当内容更改重新编译。<br>我们就用简单的console来标识执行编译。下面就是实现该功能。</p>\n<h2 id=\"node原生API\"><a href=\"#node原生API\" class=\"headerlink\" title=\"node原生API\"></a>node原生API</h2><h3 id=\"fs-watchFile\"><a href=\"#fs-watchFile\" class=\"headerlink\" title=\"fs.watchFile\"></a>fs.watchFile</h3><p>翻下node的文档就会看到一个满足我们需求的Api<a href=\"https://nodejs.org/docs/latest-v9.x/api/fs.html#fs_fs_watchfile_filename_options_listener\" target=\"_blank\" rel=\"noopener\">fs.watchFile</a>(毕竟是文件相关的操作，很大可能就在fs模块下面了)。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.watchFile(filename[, options], listener)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>filename 显然就是文件名</li>\n<li><p>options 可选 对象 包含以下两个属性</p>\n<ul>\n<li>persistent  文件被监听时进程是否继续，默认true </li>\n<li>interval 多长时间轮训一次目标文件，默认5007毫秒</li>\n</ul>\n</li>\n<li>listener 事件回调 包含两个参数<ul>\n<li>current  当前文件stat对象</li>\n<li>prev 之前文件stat对象  </li>\n</ul>\n</li>\n</ul>\n<p>看完参数信息，不知道大家有没有从其参数属性中得到点什么特别的信息。特别是interval选项和listener中的回调参数。</p>\n<p>监控filename对应文件，每当访问文件时会触发回调。  </p>\n<p>这里每当访问文件时会触发，实际指的是每次切换之后再次进入文件，然后保存之后，无论是否做了修改都会出发回调。  </p>\n<p>另外轮询事件和文件对象，是不是可以猜测，其实现监听的原理，固定时间轮询文件状态，然后将前后的状态返回，将判断交给使用者。<br>所以node也建议，如果要获取文件修改，那么需要根据stat对象的修改时间来进行对比，即比较 curr.mtime 和 prev.mtime。  </p>\n<p>这样就有点问题，我们先看下例子，会更清晰一点。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> filePath = <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`正在监听 <span class=\"subst\">$&#123;filePath&#125;</span>`</span>);</span><br><span class=\"line\">fs.watchFile(filePath, (cur, prv) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filePath) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 打印出修改时间</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`cur.mtime&gt;&gt;<span class=\"subst\">$&#123;cur.mtime.toLocaleString()&#125;</span>`</span>)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`prv.mtime&gt;&gt;<span class=\"subst\">$&#123;prv.mtime.toLocaleString()&#125;</span>`</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 根据修改时间判断做下区分，以分辨是否更改</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur.mtime != prv.mtime)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;filePath&#125;</span>文件发生更新`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>然后测试结果如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 运行 </span></span><br><span class=\"line\">node watch1.js</span><br><span class=\"line\"><span class=\"comment\">// 1、访问index.js 不做修改，然后保存</span></span><br><span class=\"line\"><span class=\"comment\">// 2、切换文件，再次访问，不做修改，只报错</span></span><br><span class=\"line\"><span class=\"comment\">// 3、编辑内容，并保存</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/watchfile/watchFile.gif\"></p>\n<p>可以看到1、2两步，并没有实际修改内容，然而我们并没有办法区分。只要你是切换之后再保存，修改时间戳mtime就发生变化。<br>另外响应时间真的很慢，毕竟是轮询。</p>\n<p>对于这些问题，其实官网也给了一句话：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using fs.watch() is more efficient than fs.watchFile and fs.unwatchFile. fs.watch should be used instead of fs.watchFile and fs.unwatchFile when possible.</span><br></pre></td></tr></table></figure>\n<p><strong>能用fs.watch的情况就不要用watchFile了。一是效率，二是不能准确获知修改状态 三是只能监听单独文件</strong><br>对于实际开发过程中，显然我们想要关注的是源文件夹的变动。  </p>\n<h3 id=\"fs-watch\"><a href=\"#fs-watch\" class=\"headerlink\" title=\"fs.watch\"></a>fs.watch</h3><p>首先用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.watch(filename[, options][, listener])</span><br></pre></td></tr></table></figure>\n<p>跟fs.watchFile比较类似。 </p>\n<ul>\n<li>filename 显然就是文件名</li>\n<li><p>options 可选 对象或者字符串 包含以下三个属性</p>\n<ul>\n<li>persistent  文件被监听时进程是否继续，默认true</li>\n<li>recursive 是否监控所有子目录，默认false 即当前目录，true为所有子目录。 </li>\n<li>encoding 指定传递给回调事件的文件名称，默认utf8</li>\n</ul>\n</li>\n<li>listener 事件回调 包含两个参数<ul>\n<li>eventType  事件类型，rename 或者 change</li>\n<li>filename 当前变更文件的文件名</li>\n</ul>\n</li>\n</ul>\n<p>options如果是字符串，指的是encoding。  </p>\n<p>监听filename对应的文件或者文件夹(recursive参数也体现出来这一特性)，返回一个fs.FSWatcher对象。</p>\n<p>该功能的实现依赖于底层操作系统的对于文件更改的通知。 所以就存在一个问题，可能不同平台的实现不太相同。<br>如下示例1：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> filePath = <span class=\"string\">'./'</span>    </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`正在监听 <span class=\"subst\">$&#123;filePath&#125;</span>`</span>);</span><br><span class=\"line\">fs.watch(filePath,(event,filename)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filename)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;filename&#125;</span>文件发生更新`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>一个比较明显的优势就体现出来了：响应比较及时，相比于轮询，效率肯定更高。  </p>\n<p>不过这样修改并保存的时候回发现同样有点问题。<br>直接保存，显示两次更新<br>修改文件之后，同样显示两次更新(mac系统上是两次，其他系统可能有所差别)<br><img src=\"/img/watchfile/watch1.gif\"><br>这样可能是于操作系统对文件修改的事件支持有关，在保存的时候出发了不止一次。<br>下面聚焦于回调事件的参数，event对应事件类型，是否可以判断事件类型为change呢，才执行呢，忽略空保存。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> filePath = <span class=\"string\">'./'</span>    </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`正在监听 <span class=\"subst\">$&#123;filePath&#125;</span>`</span>);</span><br><span class=\"line\">fs.watch(filePath,(event,filename)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`event类型<span class=\"subst\">$&#123;event&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filename &amp;&amp; event == <span class=\"string\">'change'</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;filename&#125;</span>文件发生更新`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>不过实际上，空的保存event也是change，另外不同平台event的实现可能也有所不同。这种方式要pass掉。   </p>\n<h4 id=\"校验变更时间\"><a href=\"#校验变更时间\" class=\"headerlink\" title=\"校验变更时间\"></a>校验变更时间</h4><p>显然从上面的例子可以看到，变更时间依然不可控。因为每次保存，node对应stat对象依然会修改。</p>\n<h4 id=\"对比文件内容\"><a href=\"#对比文件内容\" class=\"headerlink\" title=\"对比文件内容\"></a>对比文件内容</h4><p>只能选择这种方式来判断是否是否更新。例如md5:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>),</span><br><span class=\"line\">    md5 = <span class=\"built_in\">require</span>(<span class=\"string\">'md5'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> filePath = <span class=\"string\">'./'</span>    </span><br><span class=\"line\"><span class=\"keyword\">let</span> preveMd5 = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`正在监听 <span class=\"subst\">$&#123;filePath&#125;</span>`</span>);</span><br><span class=\"line\">fs.watch(filePath,(event,filename)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentMd5 = md5(fs.readFileSync(filePath + filename))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentMd5 == preveMd5) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    preveMd5 = currentMd5</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;filePath&#125;</span>文件发生更新`</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>先保存当前文件md5值，每次文件变化时(即保存操作响应之后)，每次都获取文件的md5然后进行对比，看是否发生变化。<br><img src=\"/img/watchfile/md51.gif\"><br>不过这样可以看到，当初次保存时，都会执行一次，因为初始值为null的缘故。这样可以加个兼容，根据是否第一次保存来判断好了。</p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>对于不同的操作系统，可能保存时触发的回调不止一个(mac上到没出现)。为了避免这种实时响应对应的频繁触发，可以引入debounce函数来保证性能。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>),</span><br><span class=\"line\">    md5 = <span class=\"built_in\">require</span>(<span class=\"string\">'md5'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> preveMd5 = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    fsWait = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> filePath = <span class=\"string\">'./'</span>    </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`正在监听 <span class=\"subst\">$&#123;filePath&#125;</span>`</span>);</span><br><span class=\"line\">fs.watch(filePath,(event,filename)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filename)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fsWait) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        fsWait = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            fsWait = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> currentMd5 = md5(fs.readFileSync(filePath + filename))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentMd5 == preveMd5)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        preveMd5 = currentMd5</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;filePath&#125;</span>文件发生更新`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>到这里，node监听文件的实现就结束了。做个学习笔记，来做个参考记录。实现起来并不难，但是要实际应用的话需要考虑的方面就比较多了。还是推荐开源框架node-watch、chokidar等，各方面实现的都比较完善。   </p>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"https://nodejs.org/docs/latest-v9.x/api/fs.html#fs_fs_watchfile_filename_options_listener\" target=\"_blank\" rel=\"noopener\">node文档</a><br><a href=\"https://thisdavej.com/how-to-watch-for-files-changes-in-node-js/\" target=\"_blank\" rel=\"noopener\">How to Watch for Files Changes in Node.js</a><br><a href=\"https://stackfame.com/nodejs-monitor-file-changes\" target=\"_blank\" rel=\"noopener\">Nodejs Monitor File Changes</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>随着前端技术的飞速发展，前端开发也从原始的刀耕火种，向着工程化效率化的方向发展。在各种开发框架之外，打包编译等技术也是层出不穷，开发体验也是越来越好。例如HMR，让我们的更新可以即时可见，告别了手动F5的情况。其实现就是监听文件变化自动调用构建过程。下面就关注下如何实现node监听文件变化。<br>","more":"</p>\n<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>假定要监听index.js，每当内容更改重新编译。<br>我们就用简单的console来标识执行编译。下面就是实现该功能。</p>\n<h2 id=\"node原生API\"><a href=\"#node原生API\" class=\"headerlink\" title=\"node原生API\"></a>node原生API</h2><h3 id=\"fs-watchFile\"><a href=\"#fs-watchFile\" class=\"headerlink\" title=\"fs.watchFile\"></a>fs.watchFile</h3><p>翻下node的文档就会看到一个满足我们需求的Api<a href=\"https://nodejs.org/docs/latest-v9.x/api/fs.html#fs_fs_watchfile_filename_options_listener\" target=\"_blank\" rel=\"noopener\">fs.watchFile</a>(毕竟是文件相关的操作，很大可能就在fs模块下面了)。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.watchFile(filename[, options], listener)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>filename 显然就是文件名</li>\n<li><p>options 可选 对象 包含以下两个属性</p>\n<ul>\n<li>persistent  文件被监听时进程是否继续，默认true </li>\n<li>interval 多长时间轮训一次目标文件，默认5007毫秒</li>\n</ul>\n</li>\n<li>listener 事件回调 包含两个参数<ul>\n<li>current  当前文件stat对象</li>\n<li>prev 之前文件stat对象  </li>\n</ul>\n</li>\n</ul>\n<p>看完参数信息，不知道大家有没有从其参数属性中得到点什么特别的信息。特别是interval选项和listener中的回调参数。</p>\n<p>监控filename对应文件，每当访问文件时会触发回调。  </p>\n<p>这里每当访问文件时会触发，实际指的是每次切换之后再次进入文件，然后保存之后，无论是否做了修改都会出发回调。  </p>\n<p>另外轮询事件和文件对象，是不是可以猜测，其实现监听的原理，固定时间轮询文件状态，然后将前后的状态返回，将判断交给使用者。<br>所以node也建议，如果要获取文件修改，那么需要根据stat对象的修改时间来进行对比，即比较 curr.mtime 和 prev.mtime。  </p>\n<p>这样就有点问题，我们先看下例子，会更清晰一点。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> filePath = <span class=\"string\">'./index.js'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`正在监听 <span class=\"subst\">$&#123;filePath&#125;</span>`</span>);</span><br><span class=\"line\">fs.watchFile(filePath, (cur, prv) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filePath) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 打印出修改时间</span></span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`cur.mtime&gt;&gt;<span class=\"subst\">$&#123;cur.mtime.toLocaleString()&#125;</span>`</span>)</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`prv.mtime&gt;&gt;<span class=\"subst\">$&#123;prv.mtime.toLocaleString()&#125;</span>`</span>)</span><br><span class=\"line\">        <span class=\"comment\">// 根据修改时间判断做下区分，以分辨是否更改</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur.mtime != prv.mtime)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;filePath&#125;</span>文件发生更新`</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>然后测试结果如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 运行 </span></span><br><span class=\"line\">node watch1.js</span><br><span class=\"line\"><span class=\"comment\">// 1、访问index.js 不做修改，然后保存</span></span><br><span class=\"line\"><span class=\"comment\">// 2、切换文件，再次访问，不做修改，只报错</span></span><br><span class=\"line\"><span class=\"comment\">// 3、编辑内容，并保存</span></span><br></pre></td></tr></table></figure>\n<p><img src=\"/img/watchfile/watchFile.gif\"></p>\n<p>可以看到1、2两步，并没有实际修改内容，然而我们并没有办法区分。只要你是切换之后再保存，修改时间戳mtime就发生变化。<br>另外响应时间真的很慢，毕竟是轮询。</p>\n<p>对于这些问题，其实官网也给了一句话：  </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Using fs.watch() is more efficient than fs.watchFile and fs.unwatchFile. fs.watch should be used instead of fs.watchFile and fs.unwatchFile when possible.</span><br></pre></td></tr></table></figure>\n<p><strong>能用fs.watch的情况就不要用watchFile了。一是效率，二是不能准确获知修改状态 三是只能监听单独文件</strong><br>对于实际开发过程中，显然我们想要关注的是源文件夹的变动。  </p>\n<h3 id=\"fs-watch\"><a href=\"#fs-watch\" class=\"headerlink\" title=\"fs.watch\"></a>fs.watch</h3><p>首先用法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fs.watch(filename[, options][, listener])</span><br></pre></td></tr></table></figure>\n<p>跟fs.watchFile比较类似。 </p>\n<ul>\n<li>filename 显然就是文件名</li>\n<li><p>options 可选 对象或者字符串 包含以下三个属性</p>\n<ul>\n<li>persistent  文件被监听时进程是否继续，默认true</li>\n<li>recursive 是否监控所有子目录，默认false 即当前目录，true为所有子目录。 </li>\n<li>encoding 指定传递给回调事件的文件名称，默认utf8</li>\n</ul>\n</li>\n<li>listener 事件回调 包含两个参数<ul>\n<li>eventType  事件类型，rename 或者 change</li>\n<li>filename 当前变更文件的文件名</li>\n</ul>\n</li>\n</ul>\n<p>options如果是字符串，指的是encoding。  </p>\n<p>监听filename对应的文件或者文件夹(recursive参数也体现出来这一特性)，返回一个fs.FSWatcher对象。</p>\n<p>该功能的实现依赖于底层操作系统的对于文件更改的通知。 所以就存在一个问题，可能不同平台的实现不太相同。<br>如下示例1：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> filePath = <span class=\"string\">'./'</span>    </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`正在监听 <span class=\"subst\">$&#123;filePath&#125;</span>`</span>);</span><br><span class=\"line\">fs.watch(filePath,(event,filename)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filename)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;filename&#125;</span>文件发生更新`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>一个比较明显的优势就体现出来了：响应比较及时，相比于轮询，效率肯定更高。  </p>\n<p>不过这样修改并保存的时候回发现同样有点问题。<br>直接保存，显示两次更新<br>修改文件之后，同样显示两次更新(mac系统上是两次，其他系统可能有所差别)<br><img src=\"/img/watchfile/watch1.gif\"><br>这样可能是于操作系统对文件修改的事件支持有关，在保存的时候出发了不止一次。<br>下面聚焦于回调事件的参数，event对应事件类型，是否可以判断事件类型为change呢，才执行呢，忽略空保存。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> filePath = <span class=\"string\">'./'</span>    </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`正在监听 <span class=\"subst\">$&#123;filePath&#125;</span>`</span>);</span><br><span class=\"line\">fs.watch(filePath,(event,filename)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`event类型<span class=\"subst\">$&#123;event&#125;</span>`</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filename &amp;&amp; event == <span class=\"string\">'change'</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;filename&#125;</span>文件发生更新`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>不过实际上，空的保存event也是change，另外不同平台event的实现可能也有所不同。这种方式要pass掉。   </p>\n<h4 id=\"校验变更时间\"><a href=\"#校验变更时间\" class=\"headerlink\" title=\"校验变更时间\"></a>校验变更时间</h4><p>显然从上面的例子可以看到，变更时间依然不可控。因为每次保存，node对应stat对象依然会修改。</p>\n<h4 id=\"对比文件内容\"><a href=\"#对比文件内容\" class=\"headerlink\" title=\"对比文件内容\"></a>对比文件内容</h4><p>只能选择这种方式来判断是否是否更新。例如md5:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>),</span><br><span class=\"line\">    md5 = <span class=\"built_in\">require</span>(<span class=\"string\">'md5'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> filePath = <span class=\"string\">'./'</span>    </span><br><span class=\"line\"><span class=\"keyword\">let</span> preveMd5 = <span class=\"literal\">null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`正在监听 <span class=\"subst\">$&#123;filePath&#125;</span>`</span>);</span><br><span class=\"line\">fs.watch(filePath,(event,filename)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> currentMd5 = md5(fs.readFileSync(filePath + filename))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (currentMd5 == preveMd5) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    preveMd5 = currentMd5</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;filePath&#125;</span>文件发生更新`</span>)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>先保存当前文件md5值，每次文件变化时(即保存操作响应之后)，每次都获取文件的md5然后进行对比，看是否发生变化。<br><img src=\"/img/watchfile/md51.gif\"><br>不过这样可以看到，当初次保存时，都会执行一次，因为初始值为null的缘故。这样可以加个兼容，根据是否第一次保存来判断好了。</p>\n<h4 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h4><p>对于不同的操作系统，可能保存时触发的回调不止一个(mac上到没出现)。为了避免这种实时响应对应的频繁触发，可以引入debounce函数来保证性能。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">'fs'</span>),</span><br><span class=\"line\">    md5 = <span class=\"built_in\">require</span>(<span class=\"string\">'md5'</span>);</span><br><span class=\"line\"><span class=\"keyword\">let</span> preveMd5 = <span class=\"literal\">null</span>,</span><br><span class=\"line\">    fsWait = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> filePath = <span class=\"string\">'./'</span>    </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">`正在监听 <span class=\"subst\">$&#123;filePath&#125;</span>`</span>);</span><br><span class=\"line\">fs.watch(filePath,(event,filename)=&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (filename)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (fsWait) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        fsWait = setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">            fsWait = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">        <span class=\"keyword\">var</span> currentMd5 = md5(fs.readFileSync(filePath + filename))</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentMd5 == preveMd5)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        preveMd5 = currentMd5</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">`<span class=\"subst\">$&#123;filePath&#125;</span>文件发生更新`</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>到这里，node监听文件的实现就结束了。做个学习笔记，来做个参考记录。实现起来并不难，但是要实际应用的话需要考虑的方面就比较多了。还是推荐开源框架node-watch、chokidar等，各方面实现的都比较完善。   </p>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"https://nodejs.org/docs/latest-v9.x/api/fs.html#fs_fs_watchfile_filename_options_listener\" target=\"_blank\" rel=\"noopener\">node文档</a><br><a href=\"https://thisdavej.com/how-to-watch-for-files-changes-in-node-js/\" target=\"_blank\" rel=\"noopener\">How to Watch for Files Changes in Node.js</a><br><a href=\"https://stackfame.com/nodejs-monitor-file-changes\" target=\"_blank\" rel=\"noopener\">Nodejs Monitor File Changes</a></p>"},{"title":"谈橡皮筋特效的解决方案","date":"2018-08-24T16:00:00.000Z","_content":"### 前言  \n本文翻自[Scroll Bouncing On Your Websites](https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/)，拜读之后收获颇多，结合自己的理解，将该文章翻成中文，一方面加深理解另一方面好文共享。\n  <!--more  -->\n### 导读  \n本文介绍了不同浏览器上弹簧滚动(即scroll bouncing)特效及实现，并回顾了网上几种常见的解决方案,顺便介绍了下近来实现的css属性 overscroll-behavior。希望读过之后能对构建和设计带有fixed元素的页面有所帮助\n\n### Scroll bouncing  \n弹簧特效（同样被叫做滑动橡皮筋特效或弹性滚动），经常发生于下面的场景：  \n1. 当滚动到页面或者html元素的最上或者最下部的时候，在页面或者元素回到顶部/底部之前(即你松开手指或者鼠标之前)，会短暂的看到空白区域的出现。  \n2. 同样的效果也可以在元素之间的CSS滚动捕捉([CSS scroll-snapping](http://www.w3cplus.com/css/practical-css-scroll-snapping.html))中看到。\n本文主要关注于第一种情况，换句话说就是滚动端口到达其滚动边界时的场景  \n对于Scroll bouncing的深入理解，可以帮助我们决定如何构建网页和页面如何滚动。\n\n### 背景\n\n当你不想看到fixed的元素跟着页面移动时，弹簧特效就不那么令人愉快了。例如：我们希望页面上有位置固定的header和footer、或者需要一个fixed的菜单、滚动过程中捕获页面的具体位置、不希望顶部或者底部有额外的滚动。这时候就需要我们去看一下有什么方案去解决这类页面顶/底部的弹簧特效了。   \n\n### 场景回顾   \n\n假如入我们有下面这个页面，底部有一个固定且不能移动的footer，同时页面其他内容可以滚动。看起来如下：\n<img src='https://user-gold-cdn.xitu.io/2018/8/20/16557cd210e6d683?w=800&h=443&f=gif&s=175632'/> \n如果是在非触摸屏和触摸板的Firefox和其他浏览器上，表现是符合预期，但是当我们使用mac上的chrome时，当用触摸板scroll到最下部时，事情就有点不一样了。\n<img src='https://user-gold-cdn.xitu.io/2018/8/20/16557cd22c2b7ef4?w=1280&h=710&f=gif&s=2726862'/>  \n\n虽然设置了footer为fixed=>bottom的css，但是这个橡皮筋特效确实有点猝不及防。  \n让我们看看position:fixed到底几个意思：  \nAccording to the CSS 2.1 Specification, when a “box” (in this case, the dark blue footer) is fixed, it is “fixed with respect to the viewport and does not move when scrolled.”  \n根据CSS 2.1 规范： 当一个box(这里显然是footer)被设置为fixed，它将根据viewport定位并且在滚动过程中不移动。  \n\n显然上面的效果是预期之外的。  \n为了使文章更加完整，把在移动端Edge、移动端Safari和桌面Safari的效果都进行了尝试，确实在firefox和chrome上的表现是不同的。在不同平台上开发相同效果的滑动确实是一件挑战性的事情。  \n\n### 解决方案  \n对于我们来说最先出来的想法肯定是简单快捷的方式，那么针对这种情况，首选当然是css来单独处理。因此选择下面的方式来尝试。测试浏览器包括win10和mac上的chrome、firefox、safari以及Edge和移动端safari，浏览器的版本都是2018最新版本。页面结构如下：   \n\n```html\n<html>\n  <body>\n    <div class=\"body-container\">\n      <div class=\"color-picker-main-container\"> \n      </div>\n    </div>\n    <footer>\n    </footer>\n</body>    \n```\n## 只用css、html来解决   \n\n### 一、绝对定位以及相对定位的方式   \n使用absolute来定位footer，然后html相对定位height100%，以便footer始终在下方固定，content的高度就是100%减去footer的高度。当然也可以设置padding-bottom来代替calc，同时设置body-containe为100%防止footer重复。语言比较苍白，看代码就完了：  \n\n```css\nhtml {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n}\n\nbody {\n  width: 100%;\n  margin: 0;\n  font-family: sans-serif;\n  height: 100%;\n  overflow: hidden;\n}\n\n.body-container {\n  height: calc(100% - 100px);\n  overflow: auto;\n}\n\n.color-picker-main-container {\n  width: 100%;\n  font-size: 22px;\n  padding-bottom: 10px;\n}\n\nfooter {\n  position: absolute;\n  bottom: 0;\n  height: 100px;\n  width: 100%;\n}\n```\n这种方式和原来fixed的方式几乎一样。差别在于该方式滑动的部分不再是整个页面而是content内容，不包括footer。这种方式最大的问题在于移动端的safari上，不仅仅是content，footer也会跟着一起滑动。。。当滑动很快的时候表现简直是灾难。如下图\n<img src='https://user-gold-cdn.xitu.io/2018/8/20/16557cd21927ccd6?w=600&h=1067&f=gif&s=1828247'/>\n\n此外，另一个不想看到的情况也出现了，当滑来滑去的尝试的时候，发现此时的滑动性能有点差。  \n因为我们设置滑动容器的高度为它本身的100%，这样就阻碍了ios上的momentum-based scrolling，  \n这里的momentum-based scrolling，我没有很好的语言来翻译，简称为阻尼滑动吧  \n简单而言就是移动设备上增加的一种旨在提升页面滑动性能的功能，比较明显的体现就是当你的手指轻触触碰设备表面时，页面自身开始滑动，当手指停止滑动之后页面还会顺势滑动一会。[更多了解请转](http://www.hnldesign.nl/work/code/momentum-scrolling-using-jquery/)。我肯定是希望有这种效果的，所以要远离设置滑动元素height100%。  \n\n在继续其他的尝试之前，我们先慢下来想一想当前的状态。原先的fixed定位存在橡皮筋的问题，上面的将其转换为absolute+relative的话没有了阻尼滑动。如果想要阻尼滑动，那么内容部分的height就不能设置为100%。那么是否可以不去显式设置height为100%呢。\n\n```css\nhtml {\n  width: 100%;\n  position: fixed;\n  overflow: hidden;\n}\n\nbody {\n  width: 100%;\n  margin: 0;\n  font-family: sans-serif;\n  position: fixed;\n  overflow: hidden;\n}\n\n.body-container {\n  width: 100vw;\n  height: calc(100vh - 100px);\n  overflow-y: auto;\n  // Use momentum-based scrolling on WebKit-based touch devices\n  -webkit-overflow-scrolling: touch;\n}\n\n.color-picker-main-container {\n  width: 100%;\n  font-size: 22px;\n  padding-bottom: 10px;\n}\n\nfooter {\n  position: fixed;\n  bottom: 0;\n  height: 100px;\n  width: 100%;\n}\n\n```\n这里设置html，body均为fixed、overflow: hidden。footer同样为fixed。  \n在需要滚动的body-container内容区域设置其高度为100vh-footer的高度，  \n同时增加-webkit-overflow-scrolling: touch;开启阻尼滑动支持。   \n效果会怎么样呢。\nmac上的Chrome和Firefox和上一种方式标表现形式是一样的，这种方式的优点就是不再需要100% height,  \n所以 momentum-based scrolling表现的还不错，然而在Safari，footer不见了。。。   \n<img src='https://user-gold-cdn.xitu.io/2018/8/20/16557cd223f6b2a5?w=1280&h=709&f=gif&s=1743190'/> \n在iOS的 Safari上，footer变短，并且底部有了个额外的间隔。同样，当滚到底部的时候，滚动页面的能力消失了。   \n<img src='https://user-gold-cdn.xitu.io/2018/8/20/16557cd21927ccd6?w=600&h=1067&f=gif&s=1828247'/>\n\n\n在上面代码里-webkit-overflow-scrolling: touch;给指定元素增加 momentum-based scrolling 的能力。不过该属性在MDN中标识是非标准的，兼容性有待考虑，所以也只能抛弃它了。  \n\n另一种方案如下：\n\n```css\nhtml {\n  position: fixed;\n  height: 100%;\n  overflow: hidden;\n}\n\nbody {\n  font-family: sans-serif;\n  margin: 0;\n  width: 100vw; \n  height: 100vh;\n  overflow-y: auto;\n  overflow-x: hidden;\n  -webkit-overflow-scrolling: touch;\n}\n\n.color-picker-main-container {\n  width: 100%;\n  font-size: 22px;\n  padding-bottom: 110px;\n}\n\nfooter {\n  position: fixed;\n}\n\n```\n这种方式在不同的桌面浏览器上表现是不错的，阻尼滑动、footer固定并且不跟随移动。但是这种方式的缺点在于在iOS Safari 上可以发现footer有轻微抖动  \n并且当你滑动的时候可以看到content在footer下面。   \n\n## 使用javascript  \n既然上面的方式都有些瑕疵，那么我们还是试试js来解决吧。  \n首先声明我不推荐并且建议尽量避免使用该方式。依据原作者的经验，应该存在更为优雅和简介的html+css方式。\n不过已经花费了很多时间去解决该问题，去看看使用js是否有更好的方式也不会有什么损失。   \n\n一种避免滑动弹簧的方式是阻止window或者document的touchmove或touchstart事件。思路是阻止外层window的tocuch事件，只允许content部分的touch。代码如下：\n  \n```js\n// Prevents window from moving on touch on older browsers.\nwindow.addEventListener('touchmove', function (event) {\n  event.preventDefault()\n}, false)\n\n// Allows content to move on touch.\ndocument.querySelector('.body-container').addEventListener('touchmove', function (event) {\n  event.stopPropagation()\n}, false)\n```\n我尝试了很多方式尽力使滑动表现良好，阻止widow的touchmove和阻止document的没什么区别，我也尝试使用touchstart和touchmove来控制滑动，  \n不过这两种方式也没什么区别。后来发现出于性能的考虑，不应该这种方式来使用event.preventDefault()，应该设置将false作为passive的选项来设置。  \n\n```js\n// Prevents window from moving on touch on newer browsers.\nwindow.addEventListener('touchmove', function (event) {\n  event.preventDefault()\n}, {passive: false})\n```  \n\n## 工具  \n另外可以使用iNoBounce来帮助自己，该库目的就是解决ios上web应用滑动时的弹簧效应。需要提一下的时，使用该库解决上面问题时要加上-webkit-overflow-scrolling。   \n另外我在结尾时提到的简洁方法和其有异曲同工之妙，可以对比一下两者。\n\n## Overscroll Behavior  \n\n尝试那么多方案之后，我发现了css的一个属性overscroll-behavior，该属性CSS属性在2017年12月和2018年3月分别在Chrome 63、Firefox 59中实现。  \n根据mdn的定义：允许你控制浏览器的滑动溢出的行为--当到达滚动区域的边边界时会发生的行为。这就是最后的一种方案。  \n需要做的仅仅是在body设置overscroll-behavior:none,并设置footer为fixed，相比于没有foter，整个页面应用momentum-based scrolling是可以接受的。\n更加客观的是Edge正在开发中，未来可期。  \n\n## 结束语  \n### 参考文章  \n1. [Momentum Scrolling on iOS Overflow Elements](https://css-tricks.com/snippets/css/momentum-scrolling-on-ios-overflow-elements/)\n2. [Scroll Bouncing On Your Websites](https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/)\n3. [MOMENTUM SCROLLING USING JQUERY](http://www.hnldesign.nl/work/code/momentum-scrolling-using-jquery/)   \n\n再次感谢原作者William Lim，提供了比较丰富滑动橡皮筋特效的解决思路。才疏学浅，有些翻译不到位的地方多请指正，[详情异步原文](https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/)\n \n\n\n\n\n\n\n\n \n\n  ","source":"_posts/scroll.md","raw":"---\ntitle: 谈橡皮筋特效的解决方案\ndate: 2018-08-25\n---\n### 前言  \n本文翻自[Scroll Bouncing On Your Websites](https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/)，拜读之后收获颇多，结合自己的理解，将该文章翻成中文，一方面加深理解另一方面好文共享。\n  <!--more  -->\n### 导读  \n本文介绍了不同浏览器上弹簧滚动(即scroll bouncing)特效及实现，并回顾了网上几种常见的解决方案,顺便介绍了下近来实现的css属性 overscroll-behavior。希望读过之后能对构建和设计带有fixed元素的页面有所帮助\n\n### Scroll bouncing  \n弹簧特效（同样被叫做滑动橡皮筋特效或弹性滚动），经常发生于下面的场景：  \n1. 当滚动到页面或者html元素的最上或者最下部的时候，在页面或者元素回到顶部/底部之前(即你松开手指或者鼠标之前)，会短暂的看到空白区域的出现。  \n2. 同样的效果也可以在元素之间的CSS滚动捕捉([CSS scroll-snapping](http://www.w3cplus.com/css/practical-css-scroll-snapping.html))中看到。\n本文主要关注于第一种情况，换句话说就是滚动端口到达其滚动边界时的场景  \n对于Scroll bouncing的深入理解，可以帮助我们决定如何构建网页和页面如何滚动。\n\n### 背景\n\n当你不想看到fixed的元素跟着页面移动时，弹簧特效就不那么令人愉快了。例如：我们希望页面上有位置固定的header和footer、或者需要一个fixed的菜单、滚动过程中捕获页面的具体位置、不希望顶部或者底部有额外的滚动。这时候就需要我们去看一下有什么方案去解决这类页面顶/底部的弹簧特效了。   \n\n### 场景回顾   \n\n假如入我们有下面这个页面，底部有一个固定且不能移动的footer，同时页面其他内容可以滚动。看起来如下：\n<img src='https://user-gold-cdn.xitu.io/2018/8/20/16557cd210e6d683?w=800&h=443&f=gif&s=175632'/> \n如果是在非触摸屏和触摸板的Firefox和其他浏览器上，表现是符合预期，但是当我们使用mac上的chrome时，当用触摸板scroll到最下部时，事情就有点不一样了。\n<img src='https://user-gold-cdn.xitu.io/2018/8/20/16557cd22c2b7ef4?w=1280&h=710&f=gif&s=2726862'/>  \n\n虽然设置了footer为fixed=>bottom的css，但是这个橡皮筋特效确实有点猝不及防。  \n让我们看看position:fixed到底几个意思：  \nAccording to the CSS 2.1 Specification, when a “box” (in this case, the dark blue footer) is fixed, it is “fixed with respect to the viewport and does not move when scrolled.”  \n根据CSS 2.1 规范： 当一个box(这里显然是footer)被设置为fixed，它将根据viewport定位并且在滚动过程中不移动。  \n\n显然上面的效果是预期之外的。  \n为了使文章更加完整，把在移动端Edge、移动端Safari和桌面Safari的效果都进行了尝试，确实在firefox和chrome上的表现是不同的。在不同平台上开发相同效果的滑动确实是一件挑战性的事情。  \n\n### 解决方案  \n对于我们来说最先出来的想法肯定是简单快捷的方式，那么针对这种情况，首选当然是css来单独处理。因此选择下面的方式来尝试。测试浏览器包括win10和mac上的chrome、firefox、safari以及Edge和移动端safari，浏览器的版本都是2018最新版本。页面结构如下：   \n\n```html\n<html>\n  <body>\n    <div class=\"body-container\">\n      <div class=\"color-picker-main-container\"> \n      </div>\n    </div>\n    <footer>\n    </footer>\n</body>    \n```\n## 只用css、html来解决   \n\n### 一、绝对定位以及相对定位的方式   \n使用absolute来定位footer，然后html相对定位height100%，以便footer始终在下方固定，content的高度就是100%减去footer的高度。当然也可以设置padding-bottom来代替calc，同时设置body-containe为100%防止footer重复。语言比较苍白，看代码就完了：  \n\n```css\nhtml {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n}\n\nbody {\n  width: 100%;\n  margin: 0;\n  font-family: sans-serif;\n  height: 100%;\n  overflow: hidden;\n}\n\n.body-container {\n  height: calc(100% - 100px);\n  overflow: auto;\n}\n\n.color-picker-main-container {\n  width: 100%;\n  font-size: 22px;\n  padding-bottom: 10px;\n}\n\nfooter {\n  position: absolute;\n  bottom: 0;\n  height: 100px;\n  width: 100%;\n}\n```\n这种方式和原来fixed的方式几乎一样。差别在于该方式滑动的部分不再是整个页面而是content内容，不包括footer。这种方式最大的问题在于移动端的safari上，不仅仅是content，footer也会跟着一起滑动。。。当滑动很快的时候表现简直是灾难。如下图\n<img src='https://user-gold-cdn.xitu.io/2018/8/20/16557cd21927ccd6?w=600&h=1067&f=gif&s=1828247'/>\n\n此外，另一个不想看到的情况也出现了，当滑来滑去的尝试的时候，发现此时的滑动性能有点差。  \n因为我们设置滑动容器的高度为它本身的100%，这样就阻碍了ios上的momentum-based scrolling，  \n这里的momentum-based scrolling，我没有很好的语言来翻译，简称为阻尼滑动吧  \n简单而言就是移动设备上增加的一种旨在提升页面滑动性能的功能，比较明显的体现就是当你的手指轻触触碰设备表面时，页面自身开始滑动，当手指停止滑动之后页面还会顺势滑动一会。[更多了解请转](http://www.hnldesign.nl/work/code/momentum-scrolling-using-jquery/)。我肯定是希望有这种效果的，所以要远离设置滑动元素height100%。  \n\n在继续其他的尝试之前，我们先慢下来想一想当前的状态。原先的fixed定位存在橡皮筋的问题，上面的将其转换为absolute+relative的话没有了阻尼滑动。如果想要阻尼滑动，那么内容部分的height就不能设置为100%。那么是否可以不去显式设置height为100%呢。\n\n```css\nhtml {\n  width: 100%;\n  position: fixed;\n  overflow: hidden;\n}\n\nbody {\n  width: 100%;\n  margin: 0;\n  font-family: sans-serif;\n  position: fixed;\n  overflow: hidden;\n}\n\n.body-container {\n  width: 100vw;\n  height: calc(100vh - 100px);\n  overflow-y: auto;\n  // Use momentum-based scrolling on WebKit-based touch devices\n  -webkit-overflow-scrolling: touch;\n}\n\n.color-picker-main-container {\n  width: 100%;\n  font-size: 22px;\n  padding-bottom: 10px;\n}\n\nfooter {\n  position: fixed;\n  bottom: 0;\n  height: 100px;\n  width: 100%;\n}\n\n```\n这里设置html，body均为fixed、overflow: hidden。footer同样为fixed。  \n在需要滚动的body-container内容区域设置其高度为100vh-footer的高度，  \n同时增加-webkit-overflow-scrolling: touch;开启阻尼滑动支持。   \n效果会怎么样呢。\nmac上的Chrome和Firefox和上一种方式标表现形式是一样的，这种方式的优点就是不再需要100% height,  \n所以 momentum-based scrolling表现的还不错，然而在Safari，footer不见了。。。   \n<img src='https://user-gold-cdn.xitu.io/2018/8/20/16557cd223f6b2a5?w=1280&h=709&f=gif&s=1743190'/> \n在iOS的 Safari上，footer变短，并且底部有了个额外的间隔。同样，当滚到底部的时候，滚动页面的能力消失了。   \n<img src='https://user-gold-cdn.xitu.io/2018/8/20/16557cd21927ccd6?w=600&h=1067&f=gif&s=1828247'/>\n\n\n在上面代码里-webkit-overflow-scrolling: touch;给指定元素增加 momentum-based scrolling 的能力。不过该属性在MDN中标识是非标准的，兼容性有待考虑，所以也只能抛弃它了。  \n\n另一种方案如下：\n\n```css\nhtml {\n  position: fixed;\n  height: 100%;\n  overflow: hidden;\n}\n\nbody {\n  font-family: sans-serif;\n  margin: 0;\n  width: 100vw; \n  height: 100vh;\n  overflow-y: auto;\n  overflow-x: hidden;\n  -webkit-overflow-scrolling: touch;\n}\n\n.color-picker-main-container {\n  width: 100%;\n  font-size: 22px;\n  padding-bottom: 110px;\n}\n\nfooter {\n  position: fixed;\n}\n\n```\n这种方式在不同的桌面浏览器上表现是不错的，阻尼滑动、footer固定并且不跟随移动。但是这种方式的缺点在于在iOS Safari 上可以发现footer有轻微抖动  \n并且当你滑动的时候可以看到content在footer下面。   \n\n## 使用javascript  \n既然上面的方式都有些瑕疵，那么我们还是试试js来解决吧。  \n首先声明我不推荐并且建议尽量避免使用该方式。依据原作者的经验，应该存在更为优雅和简介的html+css方式。\n不过已经花费了很多时间去解决该问题，去看看使用js是否有更好的方式也不会有什么损失。   \n\n一种避免滑动弹簧的方式是阻止window或者document的touchmove或touchstart事件。思路是阻止外层window的tocuch事件，只允许content部分的touch。代码如下：\n  \n```js\n// Prevents window from moving on touch on older browsers.\nwindow.addEventListener('touchmove', function (event) {\n  event.preventDefault()\n}, false)\n\n// Allows content to move on touch.\ndocument.querySelector('.body-container').addEventListener('touchmove', function (event) {\n  event.stopPropagation()\n}, false)\n```\n我尝试了很多方式尽力使滑动表现良好，阻止widow的touchmove和阻止document的没什么区别，我也尝试使用touchstart和touchmove来控制滑动，  \n不过这两种方式也没什么区别。后来发现出于性能的考虑，不应该这种方式来使用event.preventDefault()，应该设置将false作为passive的选项来设置。  \n\n```js\n// Prevents window from moving on touch on newer browsers.\nwindow.addEventListener('touchmove', function (event) {\n  event.preventDefault()\n}, {passive: false})\n```  \n\n## 工具  \n另外可以使用iNoBounce来帮助自己，该库目的就是解决ios上web应用滑动时的弹簧效应。需要提一下的时，使用该库解决上面问题时要加上-webkit-overflow-scrolling。   \n另外我在结尾时提到的简洁方法和其有异曲同工之妙，可以对比一下两者。\n\n## Overscroll Behavior  \n\n尝试那么多方案之后，我发现了css的一个属性overscroll-behavior，该属性CSS属性在2017年12月和2018年3月分别在Chrome 63、Firefox 59中实现。  \n根据mdn的定义：允许你控制浏览器的滑动溢出的行为--当到达滚动区域的边边界时会发生的行为。这就是最后的一种方案。  \n需要做的仅仅是在body设置overscroll-behavior:none,并设置footer为fixed，相比于没有foter，整个页面应用momentum-based scrolling是可以接受的。\n更加客观的是Edge正在开发中，未来可期。  \n\n## 结束语  \n### 参考文章  \n1. [Momentum Scrolling on iOS Overflow Elements](https://css-tricks.com/snippets/css/momentum-scrolling-on-ios-overflow-elements/)\n2. [Scroll Bouncing On Your Websites](https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/)\n3. [MOMENTUM SCROLLING USING JQUERY](http://www.hnldesign.nl/work/code/momentum-scrolling-using-jquery/)   \n\n再次感谢原作者William Lim，提供了比较丰富滑动橡皮筋特效的解决思路。才疏学浅，有些翻译不到位的地方多请指正，[详情异步原文](https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/)\n \n\n\n\n\n\n\n\n \n\n  ","slug":"scroll","published":1,"updated":"2018-08-24T08:38:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt1y0011gw92xei84ggi","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本文翻自<a href=\"https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/\" target=\"_blank\" rel=\"noopener\">Scroll Bouncing On Your Websites</a>，拜读之后收获颇多，结合自己的理解，将该文章翻成中文，一方面加深理解另一方面好文共享。<br>  <a id=\"more\"></a></p>\n<h3 id=\"导读\"><a href=\"#导读\" class=\"headerlink\" title=\"导读\"></a>导读</h3><p>本文介绍了不同浏览器上弹簧滚动(即scroll bouncing)特效及实现，并回顾了网上几种常见的解决方案,顺便介绍了下近来实现的css属性 overscroll-behavior。希望读过之后能对构建和设计带有fixed元素的页面有所帮助</p>\n<h3 id=\"Scroll-bouncing\"><a href=\"#Scroll-bouncing\" class=\"headerlink\" title=\"Scroll bouncing\"></a>Scroll bouncing</h3><p>弹簧特效（同样被叫做滑动橡皮筋特效或弹性滚动），经常发生于下面的场景：  </p>\n<ol>\n<li>当滚动到页面或者html元素的最上或者最下部的时候，在页面或者元素回到顶部/底部之前(即你松开手指或者鼠标之前)，会短暂的看到空白区域的出现。  </li>\n<li>同样的效果也可以在元素之间的CSS滚动捕捉(<a href=\"http://www.w3cplus.com/css/practical-css-scroll-snapping.html\" target=\"_blank\" rel=\"noopener\">CSS scroll-snapping</a>)中看到。<br>本文主要关注于第一种情况，换句话说就是滚动端口到达其滚动边界时的场景<br>对于Scroll bouncing的深入理解，可以帮助我们决定如何构建网页和页面如何滚动。</li>\n</ol>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>当你不想看到fixed的元素跟着页面移动时，弹簧特效就不那么令人愉快了。例如：我们希望页面上有位置固定的header和footer、或者需要一个fixed的菜单、滚动过程中捕获页面的具体位置、不希望顶部或者底部有额外的滚动。这时候就需要我们去看一下有什么方案去解决这类页面顶/底部的弹簧特效了。   </p>\n<h3 id=\"场景回顾\"><a href=\"#场景回顾\" class=\"headerlink\" title=\"场景回顾\"></a>场景回顾</h3><p>假如入我们有下面这个页面，底部有一个固定且不能移动的footer，同时页面其他内容可以滚动。看起来如下：<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/20/16557cd210e6d683?w=800&h=443&f=gif&s=175632\"><br>如果是在非触摸屏和触摸板的Firefox和其他浏览器上，表现是符合预期，但是当我们使用mac上的chrome时，当用触摸板scroll到最下部时，事情就有点不一样了。<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/20/16557cd22c2b7ef4?w=1280&h=710&f=gif&s=2726862\">  </p>\n<p>虽然设置了footer为fixed=&gt;bottom的css，但是这个橡皮筋特效确实有点猝不及防。<br>让我们看看position:fixed到底几个意思：<br>According to the CSS 2.1 Specification, when a “box” (in this case, the dark blue footer) is fixed, it is “fixed with respect to the viewport and does not move when scrolled.”<br>根据CSS 2.1 规范： 当一个box(这里显然是footer)被设置为fixed，它将根据viewport定位并且在滚动过程中不移动。  </p>\n<p>显然上面的效果是预期之外的。<br>为了使文章更加完整，把在移动端Edge、移动端Safari和桌面Safari的效果都进行了尝试，确实在firefox和chrome上的表现是不同的。在不同平台上开发相同效果的滑动确实是一件挑战性的事情。  </p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>对于我们来说最先出来的想法肯定是简单快捷的方式，那么针对这种情况，首选当然是css来单独处理。因此选择下面的方式来尝试。测试浏览器包括win10和mac上的chrome、firefox、safari以及Edge和移动端safari，浏览器的版本都是2018最新版本。页面结构如下：   </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"body-container\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"color-picker-main-container\"</span>&gt;</span> </span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"只用css、html来解决\"><a href=\"#只用css、html来解决\" class=\"headerlink\" title=\"只用css、html来解决\"></a>只用css、html来解决</h2><h3 id=\"一、绝对定位以及相对定位的方式\"><a href=\"#一、绝对定位以及相对定位的方式\" class=\"headerlink\" title=\"一、绝对定位以及相对定位的方式\"></a>一、绝对定位以及相对定位的方式</h3><p>使用absolute来定位footer，然后html相对定位height100%，以便footer始终在下方固定，content的高度就是100%减去footer的高度。当然也可以设置padding-bottom来代替calc，同时设置body-containe为100%防止footer重复。语言比较苍白，看代码就完了：  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.body-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"built_in\">calc</span>(100% - 100px);</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.color-picker-main-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">22px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式和原来fixed的方式几乎一样。差别在于该方式滑动的部分不再是整个页面而是content内容，不包括footer。这种方式最大的问题在于移动端的safari上，不仅仅是content，footer也会跟着一起滑动。。。当滑动很快的时候表现简直是灾难。如下图<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/20/16557cd21927ccd6?w=600&h=1067&f=gif&s=1828247\"></p>\n<p>此外，另一个不想看到的情况也出现了，当滑来滑去的尝试的时候，发现此时的滑动性能有点差。<br>因为我们设置滑动容器的高度为它本身的100%，这样就阻碍了ios上的momentum-based scrolling，<br>这里的momentum-based scrolling，我没有很好的语言来翻译，简称为阻尼滑动吧<br>简单而言就是移动设备上增加的一种旨在提升页面滑动性能的功能，比较明显的体现就是当你的手指轻触触碰设备表面时，页面自身开始滑动，当手指停止滑动之后页面还会顺势滑动一会。<a href=\"http://www.hnldesign.nl/work/code/momentum-scrolling-using-jquery/\" target=\"_blank\" rel=\"noopener\">更多了解请转</a>。我肯定是希望有这种效果的，所以要远离设置滑动元素height100%。  </p>\n<p>在继续其他的尝试之前，我们先慢下来想一想当前的状态。原先的fixed定位存在橡皮筋的问题，上面的将其转换为absolute+relative的话没有了阻尼滑动。如果想要阻尼滑动，那么内容部分的height就不能设置为100%。那么是否可以不去显式设置height为100%呢。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.body-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100vw</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"built_in\">calc</span>(100vh - 100px);</span><br><span class=\"line\">  <span class=\"attribute\">overflow-y</span>: auto;</span><br><span class=\"line\">  // Use momentum-based scrolling on WebKit-based touch devices</span><br><span class=\"line\">  <span class=\"selector-tag\">-webkit-overflow-scrolling</span>: <span class=\"selector-tag\">touch</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.color-picker-main-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">22px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里设置html，body均为fixed、overflow: hidden。footer同样为fixed。<br>在需要滚动的body-container内容区域设置其高度为100vh-footer的高度，<br>同时增加-webkit-overflow-scrolling: touch;开启阻尼滑动支持。<br>效果会怎么样呢。<br>mac上的Chrome和Firefox和上一种方式标表现形式是一样的，这种方式的优点就是不再需要100% height,<br>所以 momentum-based scrolling表现的还不错，然而在Safari，footer不见了。。。<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/20/16557cd223f6b2a5?w=1280&h=709&f=gif&s=1743190\"><br>在iOS的 Safari上，footer变短，并且底部有了个额外的间隔。同样，当滚到底部的时候，滚动页面的能力消失了。<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/20/16557cd21927ccd6?w=600&h=1067&f=gif&s=1828247\"></p>\n<p>在上面代码里-webkit-overflow-scrolling: touch;给指定元素增加 momentum-based scrolling 的能力。不过该属性在MDN中标识是非标准的，兼容性有待考虑，所以也只能抛弃它了。  </p>\n<p>另一种方案如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100vw</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-y</span>: auto;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-x</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.color-picker-main-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">22px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">110px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式在不同的桌面浏览器上表现是不错的，阻尼滑动、footer固定并且不跟随移动。但是这种方式的缺点在于在iOS Safari 上可以发现footer有轻微抖动<br>并且当你滑动的时候可以看到content在footer下面。   </p>\n<h2 id=\"使用javascript\"><a href=\"#使用javascript\" class=\"headerlink\" title=\"使用javascript\"></a>使用javascript</h2><p>既然上面的方式都有些瑕疵，那么我们还是试试js来解决吧。<br>首先声明我不推荐并且建议尽量避免使用该方式。依据原作者的经验，应该存在更为优雅和简介的html+css方式。<br>不过已经花费了很多时间去解决该问题，去看看使用js是否有更好的方式也不会有什么损失。   </p>\n<p>一种避免滑动弹簧的方式是阻止window或者document的touchmove或touchstart事件。思路是阻止外层window的tocuch事件，只允许content部分的touch。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Prevents window from moving on touch on older browsers.</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  event.preventDefault()</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Allows content to move on touch.</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.body-container'</span>).addEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  event.stopPropagation()</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n<p>我尝试了很多方式尽力使滑动表现良好，阻止widow的touchmove和阻止document的没什么区别，我也尝试使用touchstart和touchmove来控制滑动，<br>不过这两种方式也没什么区别。后来发现出于性能的考虑，不应该这种方式来使用event.preventDefault()，应该设置将false作为passive的选项来设置。  </p>\n<pre><code class=\"js\"><span class=\"comment\">// Prevents window from moving on touch on newer browsers.</span>\n<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>{\n  event.preventDefault()\n}, {<span class=\"attr\">passive</span>: <span class=\"literal\">false</span>})\n</code></pre>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>另外可以使用iNoBounce来帮助自己，该库目的就是解决ios上web应用滑动时的弹簧效应。需要提一下的时，使用该库解决上面问题时要加上-webkit-overflow-scrolling。<br>另外我在结尾时提到的简洁方法和其有异曲同工之妙，可以对比一下两者。</p>\n<h2 id=\"Overscroll-Behavior\"><a href=\"#Overscroll-Behavior\" class=\"headerlink\" title=\"Overscroll Behavior\"></a>Overscroll Behavior</h2><p>尝试那么多方案之后，我发现了css的一个属性overscroll-behavior，该属性CSS属性在2017年12月和2018年3月分别在Chrome 63、Firefox 59中实现。<br>根据mdn的定义：允许你控制浏览器的滑动溢出的行为–当到达滚动区域的边边界时会发生的行为。这就是最后的一种方案。<br>需要做的仅仅是在body设置overscroll-behavior:none,并设置footer为fixed，相比于没有foter，整个页面应用momentum-based scrolling是可以接受的。<br>更加客观的是Edge正在开发中，未来可期。  </p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><a href=\"https://css-tricks.com/snippets/css/momentum-scrolling-on-ios-overflow-elements/\" target=\"_blank\" rel=\"noopener\">Momentum Scrolling on iOS Overflow Elements</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/\" target=\"_blank\" rel=\"noopener\">Scroll Bouncing On Your Websites</a></li>\n<li><a href=\"http://www.hnldesign.nl/work/code/momentum-scrolling-using-jquery/\" target=\"_blank\" rel=\"noopener\">MOMENTUM SCROLLING USING JQUERY</a>   </li>\n</ol>\n<p>再次感谢原作者William Lim，提供了比较丰富滑动橡皮筋特效的解决思路。才疏学浅，有些翻译不到位的地方多请指正，<a href=\"https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/\" target=\"_blank\" rel=\"noopener\">详情异步原文</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本文翻自<a href=\"https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/\" target=\"_blank\" rel=\"noopener\">Scroll Bouncing On Your Websites</a>，拜读之后收获颇多，结合自己的理解，将该文章翻成中文，一方面加深理解另一方面好文共享。<br>","more":"</p>\n<h3 id=\"导读\"><a href=\"#导读\" class=\"headerlink\" title=\"导读\"></a>导读</h3><p>本文介绍了不同浏览器上弹簧滚动(即scroll bouncing)特效及实现，并回顾了网上几种常见的解决方案,顺便介绍了下近来实现的css属性 overscroll-behavior。希望读过之后能对构建和设计带有fixed元素的页面有所帮助</p>\n<h3 id=\"Scroll-bouncing\"><a href=\"#Scroll-bouncing\" class=\"headerlink\" title=\"Scroll bouncing\"></a>Scroll bouncing</h3><p>弹簧特效（同样被叫做滑动橡皮筋特效或弹性滚动），经常发生于下面的场景：  </p>\n<ol>\n<li>当滚动到页面或者html元素的最上或者最下部的时候，在页面或者元素回到顶部/底部之前(即你松开手指或者鼠标之前)，会短暂的看到空白区域的出现。  </li>\n<li>同样的效果也可以在元素之间的CSS滚动捕捉(<a href=\"http://www.w3cplus.com/css/practical-css-scroll-snapping.html\" target=\"_blank\" rel=\"noopener\">CSS scroll-snapping</a>)中看到。<br>本文主要关注于第一种情况，换句话说就是滚动端口到达其滚动边界时的场景<br>对于Scroll bouncing的深入理解，可以帮助我们决定如何构建网页和页面如何滚动。</li>\n</ol>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>当你不想看到fixed的元素跟着页面移动时，弹簧特效就不那么令人愉快了。例如：我们希望页面上有位置固定的header和footer、或者需要一个fixed的菜单、滚动过程中捕获页面的具体位置、不希望顶部或者底部有额外的滚动。这时候就需要我们去看一下有什么方案去解决这类页面顶/底部的弹簧特效了。   </p>\n<h3 id=\"场景回顾\"><a href=\"#场景回顾\" class=\"headerlink\" title=\"场景回顾\"></a>场景回顾</h3><p>假如入我们有下面这个页面，底部有一个固定且不能移动的footer，同时页面其他内容可以滚动。看起来如下：<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/20/16557cd210e6d683?w=800&h=443&f=gif&s=175632\"><br>如果是在非触摸屏和触摸板的Firefox和其他浏览器上，表现是符合预期，但是当我们使用mac上的chrome时，当用触摸板scroll到最下部时，事情就有点不一样了。<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/20/16557cd22c2b7ef4?w=1280&h=710&f=gif&s=2726862\">  </p>\n<p>虽然设置了footer为fixed=&gt;bottom的css，但是这个橡皮筋特效确实有点猝不及防。<br>让我们看看position:fixed到底几个意思：<br>According to the CSS 2.1 Specification, when a “box” (in this case, the dark blue footer) is fixed, it is “fixed with respect to the viewport and does not move when scrolled.”<br>根据CSS 2.1 规范： 当一个box(这里显然是footer)被设置为fixed，它将根据viewport定位并且在滚动过程中不移动。  </p>\n<p>显然上面的效果是预期之外的。<br>为了使文章更加完整，把在移动端Edge、移动端Safari和桌面Safari的效果都进行了尝试，确实在firefox和chrome上的表现是不同的。在不同平台上开发相同效果的滑动确实是一件挑战性的事情。  </p>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>对于我们来说最先出来的想法肯定是简单快捷的方式，那么针对这种情况，首选当然是css来单独处理。因此选择下面的方式来尝试。测试浏览器包括win10和mac上的chrome、firefox、safari以及Edge和移动端safari，浏览器的版本都是2018最新版本。页面结构如下：   </p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"body-container\"</span>&gt;</span></span><br><span class=\"line\">      <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"color-picker-main-container\"</span>&gt;</span> </span><br><span class=\"line\">      <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">footer</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"只用css、html来解决\"><a href=\"#只用css、html来解决\" class=\"headerlink\" title=\"只用css、html来解决\"></a>只用css、html来解决</h2><h3 id=\"一、绝对定位以及相对定位的方式\"><a href=\"#一、绝对定位以及相对定位的方式\" class=\"headerlink\" title=\"一、绝对定位以及相对定位的方式\"></a>一、绝对定位以及相对定位的方式</h3><p>使用absolute来定位footer，然后html相对定位height100%，以便footer始终在下方固定，content的高度就是100%减去footer的高度。当然也可以设置padding-bottom来代替calc，同时设置body-containe为100%防止footer重复。语言比较苍白，看代码就完了：  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: relative;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.body-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"built_in\">calc</span>(100% - 100px);</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: auto;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.color-picker-main-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">22px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: absolute;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式和原来fixed的方式几乎一样。差别在于该方式滑动的部分不再是整个页面而是content内容，不包括footer。这种方式最大的问题在于移动端的safari上，不仅仅是content，footer也会跟着一起滑动。。。当滑动很快的时候表现简直是灾难。如下图<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/20/16557cd21927ccd6?w=600&h=1067&f=gif&s=1828247\"></p>\n<p>此外，另一个不想看到的情况也出现了，当滑来滑去的尝试的时候，发现此时的滑动性能有点差。<br>因为我们设置滑动容器的高度为它本身的100%，这样就阻碍了ios上的momentum-based scrolling，<br>这里的momentum-based scrolling，我没有很好的语言来翻译，简称为阻尼滑动吧<br>简单而言就是移动设备上增加的一种旨在提升页面滑动性能的功能，比较明显的体现就是当你的手指轻触触碰设备表面时，页面自身开始滑动，当手指停止滑动之后页面还会顺势滑动一会。<a href=\"http://www.hnldesign.nl/work/code/momentum-scrolling-using-jquery/\" target=\"_blank\" rel=\"noopener\">更多了解请转</a>。我肯定是希望有这种效果的，所以要远离设置滑动元素height100%。  </p>\n<p>在继续其他的尝试之前，我们先慢下来想一想当前的状态。原先的fixed定位存在橡皮筋的问题，上面的将其转换为absolute+relative的话没有了阻尼滑动。如果想要阻尼滑动，那么内容部分的height就不能设置为100%。那么是否可以不去显式设置height为100%呢。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.body-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100vw</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"built_in\">calc</span>(100vh - 100px);</span><br><span class=\"line\">  <span class=\"attribute\">overflow-y</span>: auto;</span><br><span class=\"line\">  // Use momentum-based scrolling on WebKit-based touch devices</span><br><span class=\"line\">  <span class=\"selector-tag\">-webkit-overflow-scrolling</span>: <span class=\"selector-tag\">touch</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.color-picker-main-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">22px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">bottom</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里设置html，body均为fixed、overflow: hidden。footer同样为fixed。<br>在需要滚动的body-container内容区域设置其高度为100vh-footer的高度，<br>同时增加-webkit-overflow-scrolling: touch;开启阻尼滑动支持。<br>效果会怎么样呢。<br>mac上的Chrome和Firefox和上一种方式标表现形式是一样的，这种方式的优点就是不再需要100% height,<br>所以 momentum-based scrolling表现的还不错，然而在Safari，footer不见了。。。<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/20/16557cd223f6b2a5?w=1280&h=709&f=gif&s=1743190\"><br>在iOS的 Safari上，footer变短，并且底部有了个额外的间隔。同样，当滚到底部的时候，滚动页面的能力消失了。<br><img src=\"https://user-gold-cdn.xitu.io/2018/8/20/16557cd21927ccd6?w=600&h=1067&f=gif&s=1828247\"></p>\n<p>在上面代码里-webkit-overflow-scrolling: touch;给指定元素增加 momentum-based scrolling 的能力。不过该属性在MDN中标识是非标准的，兼容性有待考虑，所以也只能抛弃它了。  </p>\n<p>另一种方案如下：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">html</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow</span>: hidden;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">body</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: sans-serif;</span><br><span class=\"line\">  <span class=\"attribute\">margin</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100vw</span>; </span><br><span class=\"line\">  <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-y</span>: auto;</span><br><span class=\"line\">  <span class=\"attribute\">overflow-x</span>: hidden;</span><br><span class=\"line\">  <span class=\"attribute\">-webkit-overflow-scrolling</span>: touch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.color-picker-main-container</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">22px</span>;</span><br><span class=\"line\">  <span class=\"attribute\">padding-bottom</span>: <span class=\"number\">110px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-tag\">footer</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">position</span>: fixed;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这种方式在不同的桌面浏览器上表现是不错的，阻尼滑动、footer固定并且不跟随移动。但是这种方式的缺点在于在iOS Safari 上可以发现footer有轻微抖动<br>并且当你滑动的时候可以看到content在footer下面。   </p>\n<h2 id=\"使用javascript\"><a href=\"#使用javascript\" class=\"headerlink\" title=\"使用javascript\"></a>使用javascript</h2><p>既然上面的方式都有些瑕疵，那么我们还是试试js来解决吧。<br>首先声明我不推荐并且建议尽量避免使用该方式。依据原作者的经验，应该存在更为优雅和简介的html+css方式。<br>不过已经花费了很多时间去解决该问题，去看看使用js是否有更好的方式也不会有什么损失。   </p>\n<p>一种避免滑动弹簧的方式是阻止window或者document的touchmove或touchstart事件。思路是阻止外层window的tocuch事件，只允许content部分的touch。代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Prevents window from moving on touch on older browsers.</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  event.preventDefault()</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Allows content to move on touch.</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'.body-container'</span>).addEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  event.stopPropagation()</span><br><span class=\"line\">&#125;, <span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n<p>我尝试了很多方式尽力使滑动表现良好，阻止widow的touchmove和阻止document的没什么区别，我也尝试使用touchstart和touchmove来控制滑动，<br>不过这两种方式也没什么区别。后来发现出于性能的考虑，不应该这种方式来使用event.preventDefault()，应该设置将false作为passive的选项来设置。  </p>\n<pre><code class=\"js\"><span class=\"comment\">// Prevents window from moving on touch on newer browsers.</span>\n<span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'touchmove'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">event</span>) </span>{\n  event.preventDefault()\n}, {<span class=\"attr\">passive</span>: <span class=\"literal\">false</span>})\n</code></pre>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><p>另外可以使用iNoBounce来帮助自己，该库目的就是解决ios上web应用滑动时的弹簧效应。需要提一下的时，使用该库解决上面问题时要加上-webkit-overflow-scrolling。<br>另外我在结尾时提到的简洁方法和其有异曲同工之妙，可以对比一下两者。</p>\n<h2 id=\"Overscroll-Behavior\"><a href=\"#Overscroll-Behavior\" class=\"headerlink\" title=\"Overscroll Behavior\"></a>Overscroll Behavior</h2><p>尝试那么多方案之后，我发现了css的一个属性overscroll-behavior，该属性CSS属性在2017年12月和2018年3月分别在Chrome 63、Firefox 59中实现。<br>根据mdn的定义：允许你控制浏览器的滑动溢出的行为–当到达滚动区域的边边界时会发生的行为。这就是最后的一种方案。<br>需要做的仅仅是在body设置overscroll-behavior:none,并设置footer为fixed，相比于没有foter，整个页面应用momentum-based scrolling是可以接受的。<br>更加客观的是Edge正在开发中，未来可期。  </p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><ol>\n<li><a href=\"https://css-tricks.com/snippets/css/momentum-scrolling-on-ios-overflow-elements/\" target=\"_blank\" rel=\"noopener\">Momentum Scrolling on iOS Overflow Elements</a></li>\n<li><a href=\"https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/\" target=\"_blank\" rel=\"noopener\">Scroll Bouncing On Your Websites</a></li>\n<li><a href=\"http://www.hnldesign.nl/work/code/momentum-scrolling-using-jquery/\" target=\"_blank\" rel=\"noopener\">MOMENTUM SCROLLING USING JQUERY</a>   </li>\n</ol>\n<p>再次感谢原作者William Lim，提供了比较丰富滑动橡皮筋特效的解决思路。才疏学浅，有些翻译不到位的地方多请指正，<a href=\"https://www.smashingmagazine.com/2018/08/scroll-bouncing-websites/\" target=\"_blank\" rel=\"noopener\">详情异步原文</a></p>"},{"title":"webpack runtime","date":"2019-10-14T16:00:00.000Z","_content":"\n## webpack runtime代码 比较精悍\n<!-- more -->\n```js\n(function(modules) {\n    function webpackJsonpCallback(data) {\n        var chunkIds = data[0];\n        var moreModules = data[1];\n        var executeModules = data[2];\n        var moduleId, chunkId, i = 0,\n            resolves = [];\n        for (; i < chunkIds.length; i++) {\n            chunkId = chunkIds[i];\n            if (Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n                resolves.push(installedChunks[chunkId][0])\n            }\n            installedChunks[chunkId] = 0\n        }\n        for (moduleId in moreModules) {\n            if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n                modules[moduleId] = moreModules[moduleId]\n            }\n        }\n        if (parentJsonpFunction) parentJsonpFunction(data);\n        while (resolves.length) {\n            resolves.shift()()\n        }\n        deferredModules.push.apply(deferredModules, executeModules || []);\n        return checkDeferredModules()\n    };\n\n    function checkDeferredModules() {\n        var result;\n        for (var i = 0; i < deferredModules.length; i++) {\n            var deferredModule = deferredModules[i];\n            var fulfilled = true;\n            for (var j = 1; j < deferredModule.length; j++) {\n                var depId = deferredModule[j];\n                if (installedChunks[depId] !== 0) fulfilled = false\n            }\n            if (fulfilled) {\n                deferredModules.splice(i--, 1);\n                result = __webpack_require__(__webpack_require__.s = deferredModule[0])\n            }\n        }\n        return result\n    }\n    var installedModules = {};\n    var installedChunks = {\n        \"runtime\": 0\n    };\n    var deferredModules = [];\n\n    function __webpack_require__(moduleId) {\n        if (installedModules[moduleId]) {\n            return installedModules[moduleId].exports\n        }\n        var module = installedModules[moduleId] = {\n            i: moduleId,\n            l: false,\n            exports: {}\n        };\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        module.l = true;\n        return module.exports\n    }\n    __webpack_require__.m = modules;\n    __webpack_require__.c = installedModules;\n    __webpack_require__.d = function(exports, name, getter) {\n        if (!__webpack_require__.o(exports, name)) {\n            Object.defineProperty(exports, name, {\n                enumerable: true,\n                get: getter\n            })\n        }\n    };\n    __webpack_require__.r = function(exports) {\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n            Object.defineProperty(exports, Symbol.toStringTag, {\n                value: 'Module'\n            })\n        }\n        Object.defineProperty(exports, '__esModule', {\n            value: true\n        })\n    };\n    __webpack_require__.t = function(value, mode) {\n        if (mode & 1) value = __webpack_require__(value);\n        if (mode & 8) return value;\n        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n        var ns = Object.create(null);\n        __webpack_require__.r(ns);\n        Object.defineProperty(ns, 'default', {\n            enumerable: true,\n            value: value\n        });\n        if (mode & 2 && typeof value != 'string')\n            for (var key in value) __webpack_require__.d(ns, key, function(key) {\n                return value[key]\n            }.bind(null, key));\n        return ns\n    };\n    __webpack_require__.n = function(module) {\n        var getter = module && module.__esModule ? function getDefault() {\n            return module['default']\n        } : function getModuleExports() {\n            return module\n        };\n        __webpack_require__.d(getter, 'a', getter);\n        return getter\n    };\n    __webpack_require__.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property)\n    };\n    __webpack_require__.p = \"\";\n    var jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n    var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n    jsonpArray.push = webpackJsonpCallback;\n    jsonpArray = jsonpArray.slice();\n    for (var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n    var parentJsonpFunction = oldJsonpFunction;\n    checkDeferredModules()\n})([]);\n```","source":"_posts/webpack.md","raw":"---\ntitle: webpack runtime\ndate: 2019-10-15\n---\n\n## webpack runtime代码 比较精悍\n<!-- more -->\n```js\n(function(modules) {\n    function webpackJsonpCallback(data) {\n        var chunkIds = data[0];\n        var moreModules = data[1];\n        var executeModules = data[2];\n        var moduleId, chunkId, i = 0,\n            resolves = [];\n        for (; i < chunkIds.length; i++) {\n            chunkId = chunkIds[i];\n            if (Object.prototype.hasOwnProperty.call(installedChunks, chunkId) && installedChunks[chunkId]) {\n                resolves.push(installedChunks[chunkId][0])\n            }\n            installedChunks[chunkId] = 0\n        }\n        for (moduleId in moreModules) {\n            if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {\n                modules[moduleId] = moreModules[moduleId]\n            }\n        }\n        if (parentJsonpFunction) parentJsonpFunction(data);\n        while (resolves.length) {\n            resolves.shift()()\n        }\n        deferredModules.push.apply(deferredModules, executeModules || []);\n        return checkDeferredModules()\n    };\n\n    function checkDeferredModules() {\n        var result;\n        for (var i = 0; i < deferredModules.length; i++) {\n            var deferredModule = deferredModules[i];\n            var fulfilled = true;\n            for (var j = 1; j < deferredModule.length; j++) {\n                var depId = deferredModule[j];\n                if (installedChunks[depId] !== 0) fulfilled = false\n            }\n            if (fulfilled) {\n                deferredModules.splice(i--, 1);\n                result = __webpack_require__(__webpack_require__.s = deferredModule[0])\n            }\n        }\n        return result\n    }\n    var installedModules = {};\n    var installedChunks = {\n        \"runtime\": 0\n    };\n    var deferredModules = [];\n\n    function __webpack_require__(moduleId) {\n        if (installedModules[moduleId]) {\n            return installedModules[moduleId].exports\n        }\n        var module = installedModules[moduleId] = {\n            i: moduleId,\n            l: false,\n            exports: {}\n        };\n        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n        module.l = true;\n        return module.exports\n    }\n    __webpack_require__.m = modules;\n    __webpack_require__.c = installedModules;\n    __webpack_require__.d = function(exports, name, getter) {\n        if (!__webpack_require__.o(exports, name)) {\n            Object.defineProperty(exports, name, {\n                enumerable: true,\n                get: getter\n            })\n        }\n    };\n    __webpack_require__.r = function(exports) {\n        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n            Object.defineProperty(exports, Symbol.toStringTag, {\n                value: 'Module'\n            })\n        }\n        Object.defineProperty(exports, '__esModule', {\n            value: true\n        })\n    };\n    __webpack_require__.t = function(value, mode) {\n        if (mode & 1) value = __webpack_require__(value);\n        if (mode & 8) return value;\n        if ((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n        var ns = Object.create(null);\n        __webpack_require__.r(ns);\n        Object.defineProperty(ns, 'default', {\n            enumerable: true,\n            value: value\n        });\n        if (mode & 2 && typeof value != 'string')\n            for (var key in value) __webpack_require__.d(ns, key, function(key) {\n                return value[key]\n            }.bind(null, key));\n        return ns\n    };\n    __webpack_require__.n = function(module) {\n        var getter = module && module.__esModule ? function getDefault() {\n            return module['default']\n        } : function getModuleExports() {\n            return module\n        };\n        __webpack_require__.d(getter, 'a', getter);\n        return getter\n    };\n    __webpack_require__.o = function(object, property) {\n        return Object.prototype.hasOwnProperty.call(object, property)\n    };\n    __webpack_require__.p = \"\";\n    var jsonpArray = window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || [];\n    var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);\n    jsonpArray.push = webpackJsonpCallback;\n    jsonpArray = jsonpArray.slice();\n    for (var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);\n    var parentJsonpFunction = oldJsonpFunction;\n    checkDeferredModules()\n})([]);\n```","slug":"webpack","published":1,"updated":"2019-10-10T12:12:36.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt200012gw925wcyj5c5","content":"<h2 id=\"webpack-runtime代码-比较精悍\"><a href=\"#webpack-runtime代码-比较精悍\" class=\"headerlink\" title=\"webpack runtime代码 比较精悍\"></a>webpack runtime代码 比较精悍</h2><a id=\"more\"></a>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">webpackJsonpCallback</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> chunkIds = data[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> moreModules = data[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> executeModules = data[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> moduleId, chunkId, i = <span class=\"number\">0</span>,</span><br><span class=\"line\">            resolves = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt; chunkIds.length; i++) &#123;</span><br><span class=\"line\">            chunkId = chunkIds[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId]) &#123;</span><br><span class=\"line\">                resolves.push(installedChunks[chunkId][<span class=\"number\">0</span>])</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            installedChunks[chunkId] = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (moduleId <span class=\"keyword\">in</span> moreModules) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class=\"line\">                modules[moduleId] = moreModules[moduleId]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parentJsonpFunction) parentJsonpFunction(data);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (resolves.length) &#123;</span><br><span class=\"line\">            resolves.shift()()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        deferredModules.push.apply(deferredModules, executeModules || []);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> checkDeferredModules()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkDeferredModules</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; deferredModules.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> deferredModule = deferredModules[i];</span><br><span class=\"line\">            <span class=\"keyword\">var</span> fulfilled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">1</span>; j &lt; deferredModule.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> depId = deferredModule[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (installedChunks[depId] !== <span class=\"number\">0</span>) fulfilled = <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fulfilled) &#123;</span><br><span class=\"line\">                deferredModules.splice(i--, <span class=\"number\">1</span>);</span><br><span class=\"line\">                result = __webpack_require__(__webpack_require__.s = deferredModule[<span class=\"number\">0</span>])</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> installedChunks = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"runtime\"</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> deferredModules = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (installedModules[moduleId]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> installedModules[moduleId].exports</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = installedModules[moduleId] = &#123;</span><br><span class=\"line\">            i: moduleId,</span><br><span class=\"line\">            l: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            exports: &#123;&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        modules[moduleId].call(<span class=\"built_in\">module</span>.exports, <span class=\"built_in\">module</span>, <span class=\"built_in\">module</span>.exports, __webpack_require__);</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.l = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __webpack_require__.m = modules;</span><br><span class=\"line\">    __webpack_require__.c = installedModules;</span><br><span class=\"line\">    __webpack_require__.d = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">exports, name, getter</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!__webpack_require__.o(exports, name)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(exports, name, &#123;</span><br><span class=\"line\">                enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                get: getter</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    __webpack_require__.r = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">exports</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">Symbol</span>.toStringTag) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(exports, <span class=\"built_in\">Symbol</span>.toStringTag, &#123;</span><br><span class=\"line\">                value: <span class=\"string\">'Module'</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(exports, <span class=\"string\">'__esModule'</span>, &#123;</span><br><span class=\"line\">            value: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    __webpack_require__.t = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, mode</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">1</span>) value = __webpack_require__(value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">8</span>) <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((mode &amp; <span class=\"number\">4</span>) &amp;&amp; <span class=\"keyword\">typeof</span> value === <span class=\"string\">'object'</span> &amp;&amp; value &amp;&amp; value.__esModule) <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ns = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        __webpack_require__.r(ns);</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(ns, <span class=\"string\">'default'</span>, &#123;</span><br><span class=\"line\">            enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            value: value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">2</span> &amp;&amp; <span class=\"keyword\">typeof</span> value != <span class=\"string\">'string'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> value) __webpack_require__.d(ns, key, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> value[key]</span><br><span class=\"line\">            &#125;.bind(<span class=\"literal\">null</span>, key));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ns</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    __webpack_require__.n = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> getter = <span class=\"built_in\">module</span> &amp;&amp; <span class=\"built_in\">module</span>.__esModule ? <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDefault</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>[<span class=\"string\">'default'</span>]</span><br><span class=\"line\">        &#125; : <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getModuleExports</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        __webpack_require__.d(getter, <span class=\"string\">'a'</span>, getter);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getter</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    __webpack_require__.o = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">object, property</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(object, property)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    __webpack_require__.p = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> jsonpArray = <span class=\"built_in\">window</span>[<span class=\"string\">\"webpackJsonp\"</span>] = <span class=\"built_in\">window</span>[<span class=\"string\">\"webpackJsonp\"</span>] || [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldJsonpFunction = jsonpArray.push.bind(jsonpArray);</span><br><span class=\"line\">    jsonpArray.push = webpackJsonpCallback;</span><br><span class=\"line\">    jsonpArray = jsonpArray.slice();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> parentJsonpFunction = oldJsonpFunction;</span><br><span class=\"line\">    checkDeferredModules()</span><br><span class=\"line\">&#125;)([]);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"webpack-runtime代码-比较精悍\"><a href=\"#webpack-runtime代码-比较精悍\" class=\"headerlink\" title=\"webpack runtime代码 比较精悍\"></a>webpack runtime代码 比较精悍</h2>","more":"<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">modules</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">webpackJsonpCallback</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> chunkIds = data[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> moreModules = data[<span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> executeModules = data[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> moduleId, chunkId, i = <span class=\"number\">0</span>,</span><br><span class=\"line\">            resolves = [];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (; i &lt; chunkIds.length; i++) &#123;</span><br><span class=\"line\">            chunkId = chunkIds[i];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId]) &#123;</span><br><span class=\"line\">                resolves.push(installedChunks[chunkId][<span class=\"number\">0</span>])</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            installedChunks[chunkId] = <span class=\"number\">0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (moduleId <span class=\"keyword\">in</span> moreModules) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(moreModules, moduleId)) &#123;</span><br><span class=\"line\">                modules[moduleId] = moreModules[moduleId]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parentJsonpFunction) parentJsonpFunction(data);</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (resolves.length) &#123;</span><br><span class=\"line\">            resolves.shift()()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        deferredModules.push.apply(deferredModules, executeModules || []);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> checkDeferredModules()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkDeferredModules</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; deferredModules.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> deferredModule = deferredModules[i];</span><br><span class=\"line\">            <span class=\"keyword\">var</span> fulfilled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> j = <span class=\"number\">1</span>; j &lt; deferredModule.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> depId = deferredModule[j];</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (installedChunks[depId] !== <span class=\"number\">0</span>) fulfilled = <span class=\"literal\">false</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fulfilled) &#123;</span><br><span class=\"line\">                deferredModules.splice(i--, <span class=\"number\">1</span>);</span><br><span class=\"line\">                result = __webpack_require__(__webpack_require__.s = deferredModule[<span class=\"number\">0</span>])</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> installedModules = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> installedChunks = &#123;</span><br><span class=\"line\">        <span class=\"string\">\"runtime\"</span>: <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> deferredModules = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__webpack_require__</span>(<span class=\"params\">moduleId</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (installedModules[moduleId]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> installedModules[moduleId].exports</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> <span class=\"built_in\">module</span> = installedModules[moduleId] = &#123;</span><br><span class=\"line\">            i: moduleId,</span><br><span class=\"line\">            l: <span class=\"literal\">false</span>,</span><br><span class=\"line\">            exports: &#123;&#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        modules[moduleId].call(<span class=\"built_in\">module</span>.exports, <span class=\"built_in\">module</span>, <span class=\"built_in\">module</span>.exports, __webpack_require__);</span><br><span class=\"line\">        <span class=\"built_in\">module</span>.l = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>.exports</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    __webpack_require__.m = modules;</span><br><span class=\"line\">    __webpack_require__.c = installedModules;</span><br><span class=\"line\">    __webpack_require__.d = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">exports, name, getter</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!__webpack_require__.o(exports, name)) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(exports, name, &#123;</span><br><span class=\"line\">                enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">                get: getter</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    __webpack_require__.r = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">exports</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span> !== <span class=\"string\">'undefined'</span> &amp;&amp; <span class=\"built_in\">Symbol</span>.toStringTag) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">Object</span>.defineProperty(exports, <span class=\"built_in\">Symbol</span>.toStringTag, &#123;</span><br><span class=\"line\">                value: <span class=\"string\">'Module'</span></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(exports, <span class=\"string\">'__esModule'</span>, &#123;</span><br><span class=\"line\">            value: <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    __webpack_require__.t = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, mode</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">1</span>) value = __webpack_require__(value);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">8</span>) <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((mode &amp; <span class=\"number\">4</span>) &amp;&amp; <span class=\"keyword\">typeof</span> value === <span class=\"string\">'object'</span> &amp;&amp; value &amp;&amp; value.__esModule) <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> ns = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>);</span><br><span class=\"line\">        __webpack_require__.r(ns);</span><br><span class=\"line\">        <span class=\"built_in\">Object</span>.defineProperty(ns, <span class=\"string\">'default'</span>, &#123;</span><br><span class=\"line\">            enumerable: <span class=\"literal\">true</span>,</span><br><span class=\"line\">            value: value</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mode &amp; <span class=\"number\">2</span> &amp;&amp; <span class=\"keyword\">typeof</span> value != <span class=\"string\">'string'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> value) __webpack_require__.d(ns, key, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">key</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> value[key]</span><br><span class=\"line\">            &#125;.bind(<span class=\"literal\">null</span>, key));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ns</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    __webpack_require__.n = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> getter = <span class=\"built_in\">module</span> &amp;&amp; <span class=\"built_in\">module</span>.__esModule ? <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getDefault</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span>[<span class=\"string\">'default'</span>]</span><br><span class=\"line\">        &#125; : <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getModuleExports</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">module</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        __webpack_require__.d(getter, <span class=\"string\">'a'</span>, getter);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getter</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    __webpack_require__.o = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">object, property</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.hasOwnProperty.call(object, property)</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    __webpack_require__.p = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> jsonpArray = <span class=\"built_in\">window</span>[<span class=\"string\">\"webpackJsonp\"</span>] = <span class=\"built_in\">window</span>[<span class=\"string\">\"webpackJsonp\"</span>] || [];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> oldJsonpFunction = jsonpArray.push.bind(jsonpArray);</span><br><span class=\"line\">    jsonpArray.push = webpackJsonpCallback;</span><br><span class=\"line\">    jsonpArray = jsonpArray.slice();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> parentJsonpFunction = oldJsonpFunction;</span><br><span class=\"line\">    checkDeferredModules()</span><br><span class=\"line\">&#125;)([]);</span><br></pre></td></tr></table></figure>"},{"title":"更便捷的css处理方式-PostCSS","date":"2017-12-21T16:00:00.000Z","_content":"一般来说介绍一个东西都是要从是什么，怎么用的顺序来讲。我感觉这样很容易让大家失去兴趣，先看一下postcss能做点什么，有兴趣的话再往下看，否则可能没有耐心看下去。让我们开始吧\n<!-- more -->\n## postcss能做什么  \n### 补全css属性浏览器前缀 \n手写的代码可以是这样的:  \n\n```css\n.div{\n    display: flex;\n}\n```\n   \npostcss可以转换之后成了这样:\n\n```css\n.div{\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n``` \n  \n### 检查css语法   \n \n```css\n    body{\n    color: #f0;\n    }\n```\n\n会有以下提示:    \n\n```\nsrc/er.css\n 2:12  ✖  Unexpected invalid hex color \"#f0\"   color-no-invalid-hex\n\n\n\n[18:27:28] 'css-lint' errored after 98 ms\n[18:27:28] Error in plugin 'gulp-stylelint'\nMessage:\n    Failed with 1 error\n```\n### 拥抱下个版本规范的css 即css4\n对于下个规范的css而言，变量，方法等功能的都会增加上去，你可以这样来定义一个变量：    \n```css\n:root { \n    --red: #d33;\n  }\n  a { \n      color: var(--red);\n  }\n```\n当然直接在现有浏览器上是跑不通的，就正如es2015刚开始一样，我们需要一个转化器来将其转成当前可用规范。postcss的插件就可以做到。  \n\n```css\na{\n    color:#d33\n}\n```\n除了上面之外还有其他很多功能，postcss及其插件都能提供。\n\n## 什么是postcss  \n\n现在让我们回到最基本的问题，postcss是什么。  \n援引官网的定义，一种使用js来转化css的工具(A tool for transforming CSS with JavaScript)。其实我们更多的时候提到postcss是有两个含义的：\n1. postcss本身，也就是我们npm install时的安装部分  \n2. 基于postCss的丰富插件系统。   \n   上文那些功能，都是基于postcss的插件提供的功能。  \n   \npostcss本身并不直接用于处理样式，只有配合它的插件，才能完成相关的编译工作。\n \n#### postcss不是预编译语言的替代品   \n  \n我想你脑海里一直在复现两个名词，less/sass，开始的时候我也一样，认为postcss跟二者一样是一种css预编译语言或者起到类似作用的一种语言。postcss不是要取代哪一个，更多的是提供的一种补充，完全可以是互补的概念。  \n作为一个是使用js将css转化为AST然后进行处理的工具，完全不是预处理语言的替代品，postcss处理的必须是css文件，所以完全可以和预编译语言结合，使用预编译语言转化为css之后然后进行处理。  \n我一直认为两者不是互斥的关系，完全可以互补使用。   \n\n## 为什么需要postcss    \n\n大家可能有这么个疑问既然两者不互相冲突，目前我使用less/sass 也很容易满足我的需求，为什么要使用新的东西呢。我认为主要原因是其提供的丰富的插件功能，可以工作更加的简单化，便捷化，一句话，你只需要编写基本的css，其他的功能交给postcss就好。做了简单的对比可能更加清晰明了。  \n\n#### 实现给css属性加上浏览器前缀的功能  \n\n对比一下less和postcss的实现： \n\n1、 对于less而言，肯定是写一个方法  \n\n```css\n.flex-block() {\n    display: -ms-flexbox;\n    display: -webkit-flex;\n    display: flex;\n}\n.test{\n    .flex-block()\n}\n```\n2、使用postcss\n\n```css\n.test{\n    display: flex;\n}\n```\n只需要编译的时候使用autoprefixer处理就好。  \n可能一个属性的效果不是特别明显，要是有很多个属性需要处理呢?  \n\n```css\n.flex-block() {\n    display: -ms-flexbox;\n    display: -webkit-flex;\n    display: flex;\n}\n.transform(){\n    //仅仅是举例子\n}\n.ccc(){\n}\n.test{\n    .flex-block()\n    .transform()\n    .ccc()\n}\n```\n这时候postcss还是只需要如下:  \n\n```css\n.test{\n    display: flex;\n    transform:rotate(7deg);\n}\n```\n这时候就能看出来postcss的便捷性了，我一直认为可以抽象公共化的东西完全没有必要去重复的去手动开发。  \n\n## postcss工作原理   \n\npostcss本身是一个node模块，可以将css文件解析为抽象语法树(AST)，将该树在多个插件方法传递，然后将AST转换为字符串返回，该字符串可以输出到目标文件中。传递过程中的插件可以选择是否改变该语法树，上诉改变可以通过sourcemap来记录。如下面的流程所示(借用w3cplus的一张图)：\n<img src='https://www.w3cplus.com/sites/default/files/blogs/2017/1707/figure-18.png'/>\n\n其实这里我们更应该关联起来的是babel，看一下功能：  \n* 将未来规范的转化为当前规范的转义器\n* 实现相同，都是将源文件解析为AST然后经由插件处理。\n* 丰富的插件，满足不同的需求\n* 支持自定义插件的开发   \n\n#### 当前工作流中引入postcss  \n  \n大家可能会有这种想法，又是一种新的工具，我当前的开发框架中岂不是要大动。其实这种担心是没必要的。postcss是很容易引入当前的工作流中的。无论是webpack还是gulp，都有比较方便的方式。[官方有详细的介绍文档](https://github.com/postcss/postcss#usage)  \n\n## 结束语  \n\n原先很早就看到postCss，当时太年轻认为是less的一种替代品罢了，所以一直没有去关注。了解之后感觉真的不错，至于如何使用这里就不去演示了，有兴趣的可以查看下[我的简单示例](https://github.com/xiaoxiangdaiyu/postcss/tree/master/)希望更多的人使用。\n\n#### 参考文章  \n[http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/](http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/)\n[http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/](http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/)\n","source":"_posts/css/postcss.md","raw":"---\ntitle: 更便捷的css处理方式-PostCSS\ndate: 2017-12-22\n---\n一般来说介绍一个东西都是要从是什么，怎么用的顺序来讲。我感觉这样很容易让大家失去兴趣，先看一下postcss能做点什么，有兴趣的话再往下看，否则可能没有耐心看下去。让我们开始吧\n<!-- more -->\n## postcss能做什么  \n### 补全css属性浏览器前缀 \n手写的代码可以是这样的:  \n\n```css\n.div{\n    display: flex;\n}\n```\n   \npostcss可以转换之后成了这样:\n\n```css\n.div{\n    display: -webkit-box;\n    display: -ms-flexbox;\n    display: flex;\n}\n``` \n  \n### 检查css语法   \n \n```css\n    body{\n    color: #f0;\n    }\n```\n\n会有以下提示:    \n\n```\nsrc/er.css\n 2:12  ✖  Unexpected invalid hex color \"#f0\"   color-no-invalid-hex\n\n\n\n[18:27:28] 'css-lint' errored after 98 ms\n[18:27:28] Error in plugin 'gulp-stylelint'\nMessage:\n    Failed with 1 error\n```\n### 拥抱下个版本规范的css 即css4\n对于下个规范的css而言，变量，方法等功能的都会增加上去，你可以这样来定义一个变量：    \n```css\n:root { \n    --red: #d33;\n  }\n  a { \n      color: var(--red);\n  }\n```\n当然直接在现有浏览器上是跑不通的，就正如es2015刚开始一样，我们需要一个转化器来将其转成当前可用规范。postcss的插件就可以做到。  \n\n```css\na{\n    color:#d33\n}\n```\n除了上面之外还有其他很多功能，postcss及其插件都能提供。\n\n## 什么是postcss  \n\n现在让我们回到最基本的问题，postcss是什么。  \n援引官网的定义，一种使用js来转化css的工具(A tool for transforming CSS with JavaScript)。其实我们更多的时候提到postcss是有两个含义的：\n1. postcss本身，也就是我们npm install时的安装部分  \n2. 基于postCss的丰富插件系统。   \n   上文那些功能，都是基于postcss的插件提供的功能。  \n   \npostcss本身并不直接用于处理样式，只有配合它的插件，才能完成相关的编译工作。\n \n#### postcss不是预编译语言的替代品   \n  \n我想你脑海里一直在复现两个名词，less/sass，开始的时候我也一样，认为postcss跟二者一样是一种css预编译语言或者起到类似作用的一种语言。postcss不是要取代哪一个，更多的是提供的一种补充，完全可以是互补的概念。  \n作为一个是使用js将css转化为AST然后进行处理的工具，完全不是预处理语言的替代品，postcss处理的必须是css文件，所以完全可以和预编译语言结合，使用预编译语言转化为css之后然后进行处理。  \n我一直认为两者不是互斥的关系，完全可以互补使用。   \n\n## 为什么需要postcss    \n\n大家可能有这么个疑问既然两者不互相冲突，目前我使用less/sass 也很容易满足我的需求，为什么要使用新的东西呢。我认为主要原因是其提供的丰富的插件功能，可以工作更加的简单化，便捷化，一句话，你只需要编写基本的css，其他的功能交给postcss就好。做了简单的对比可能更加清晰明了。  \n\n#### 实现给css属性加上浏览器前缀的功能  \n\n对比一下less和postcss的实现： \n\n1、 对于less而言，肯定是写一个方法  \n\n```css\n.flex-block() {\n    display: -ms-flexbox;\n    display: -webkit-flex;\n    display: flex;\n}\n.test{\n    .flex-block()\n}\n```\n2、使用postcss\n\n```css\n.test{\n    display: flex;\n}\n```\n只需要编译的时候使用autoprefixer处理就好。  \n可能一个属性的效果不是特别明显，要是有很多个属性需要处理呢?  \n\n```css\n.flex-block() {\n    display: -ms-flexbox;\n    display: -webkit-flex;\n    display: flex;\n}\n.transform(){\n    //仅仅是举例子\n}\n.ccc(){\n}\n.test{\n    .flex-block()\n    .transform()\n    .ccc()\n}\n```\n这时候postcss还是只需要如下:  \n\n```css\n.test{\n    display: flex;\n    transform:rotate(7deg);\n}\n```\n这时候就能看出来postcss的便捷性了，我一直认为可以抽象公共化的东西完全没有必要去重复的去手动开发。  \n\n## postcss工作原理   \n\npostcss本身是一个node模块，可以将css文件解析为抽象语法树(AST)，将该树在多个插件方法传递，然后将AST转换为字符串返回，该字符串可以输出到目标文件中。传递过程中的插件可以选择是否改变该语法树，上诉改变可以通过sourcemap来记录。如下面的流程所示(借用w3cplus的一张图)：\n<img src='https://www.w3cplus.com/sites/default/files/blogs/2017/1707/figure-18.png'/>\n\n其实这里我们更应该关联起来的是babel，看一下功能：  \n* 将未来规范的转化为当前规范的转义器\n* 实现相同，都是将源文件解析为AST然后经由插件处理。\n* 丰富的插件，满足不同的需求\n* 支持自定义插件的开发   \n\n#### 当前工作流中引入postcss  \n  \n大家可能会有这种想法，又是一种新的工具，我当前的开发框架中岂不是要大动。其实这种担心是没必要的。postcss是很容易引入当前的工作流中的。无论是webpack还是gulp，都有比较方便的方式。[官方有详细的介绍文档](https://github.com/postcss/postcss#usage)  \n\n## 结束语  \n\n原先很早就看到postCss，当时太年轻认为是less的一种替代品罢了，所以一直没有去关注。了解之后感觉真的不错，至于如何使用这里就不去演示了，有兴趣的可以查看下[我的简单示例](https://github.com/xiaoxiangdaiyu/postcss/tree/master/)希望更多的人使用。\n\n#### 参考文章  \n[http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/](http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/)\n[http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/](http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/)\n","slug":"css/postcss","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt7t0019gw928t87n70z","content":"<p>一般来说介绍一个东西都是要从是什么，怎么用的顺序来讲。我感觉这样很容易让大家失去兴趣，先看一下postcss能做点什么，有兴趣的话再往下看，否则可能没有耐心看下去。让我们开始吧<br><a id=\"more\"></a></p>\n<h2 id=\"postcss能做什么\"><a href=\"#postcss能做什么\" class=\"headerlink\" title=\"postcss能做什么\"></a>postcss能做什么</h2><h3 id=\"补全css属性浏览器前缀\"><a href=\"#补全css属性浏览器前缀\" class=\"headerlink\" title=\"补全css属性浏览器前缀\"></a>补全css属性浏览器前缀</h3><p>手写的代码可以是这样的:  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>postcss可以转换之后成了这样:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-box;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -ms-flexbox;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">  </span><br><span class=\"line\">### 检查<span class=\"selector-tag\">css</span>语法   </span><br><span class=\"line\"> </span><br><span class=\"line\">```<span class=\"selector-tag\">css</span></span><br><span class=\"line\">    <span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#f0</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>会有以下提示:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src/er.css</span><br><span class=\"line\"> 2:12  ✖  Unexpected invalid hex color &quot;#f0&quot;   color-no-invalid-hex</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[18:27:28] &apos;css-lint&apos; errored after 98 ms</span><br><span class=\"line\">[18:27:28] Error in plugin &apos;gulp-stylelint&apos;</span><br><span class=\"line\">Message:</span><br><span class=\"line\">    Failed with 1 error</span><br></pre></td></tr></table></figure>\n<h3 id=\"拥抱下个版本规范的css-即css4\"><a href=\"#拥抱下个版本规范的css-即css4\" class=\"headerlink\" title=\"拥抱下个版本规范的css 即css4\"></a>拥抱下个版本规范的css 即css4</h3><p>对于下个规范的css而言，变量，方法等功能的都会增加上去，你可以这样来定义一个变量：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">--red</span>: <span class=\"number\">#d33</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">a</span> &#123; </span><br><span class=\"line\">      <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--red);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然直接在现有浏览器上是跑不通的，就正如es2015刚开始一样，我们需要一个转化器来将其转成当前可用规范。postcss的插件就可以做到。  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#d33</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了上面之外还有其他很多功能，postcss及其插件都能提供。</p>\n<h2 id=\"什么是postcss\"><a href=\"#什么是postcss\" class=\"headerlink\" title=\"什么是postcss\"></a>什么是postcss</h2><p>现在让我们回到最基本的问题，postcss是什么。<br>援引官网的定义，一种使用js来转化css的工具(A tool for transforming CSS with JavaScript)。其实我们更多的时候提到postcss是有两个含义的：</p>\n<ol>\n<li>postcss本身，也就是我们npm install时的安装部分  </li>\n<li>基于postCss的丰富插件系统。<br>上文那些功能，都是基于postcss的插件提供的功能。  </li>\n</ol>\n<p>postcss本身并不直接用于处理样式，只有配合它的插件，才能完成相关的编译工作。</p>\n<h4 id=\"postcss不是预编译语言的替代品\"><a href=\"#postcss不是预编译语言的替代品\" class=\"headerlink\" title=\"postcss不是预编译语言的替代品\"></a>postcss不是预编译语言的替代品</h4><p>我想你脑海里一直在复现两个名词，less/sass，开始的时候我也一样，认为postcss跟二者一样是一种css预编译语言或者起到类似作用的一种语言。postcss不是要取代哪一个，更多的是提供的一种补充，完全可以是互补的概念。<br>作为一个是使用js将css转化为AST然后进行处理的工具，完全不是预处理语言的替代品，postcss处理的必须是css文件，所以完全可以和预编译语言结合，使用预编译语言转化为css之后然后进行处理。<br>我一直认为两者不是互斥的关系，完全可以互补使用。   </p>\n<h2 id=\"为什么需要postcss\"><a href=\"#为什么需要postcss\" class=\"headerlink\" title=\"为什么需要postcss\"></a>为什么需要postcss</h2><p>大家可能有这么个疑问既然两者不互相冲突，目前我使用less/sass 也很容易满足我的需求，为什么要使用新的东西呢。我认为主要原因是其提供的丰富的插件功能，可以工作更加的简单化，便捷化，一句话，你只需要编写基本的css，其他的功能交给postcss就好。做了简单的对比可能更加清晰明了。  </p>\n<h4 id=\"实现给css属性加上浏览器前缀的功能\"><a href=\"#实现给css属性加上浏览器前缀的功能\" class=\"headerlink\" title=\"实现给css属性加上浏览器前缀的功能\"></a>实现给css属性加上浏览器前缀的功能</h4><p>对比一下less和postcss的实现： </p>\n<p>1、 对于less而言，肯定是写一个方法  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.flex-block</span>() &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -ms-flexbox;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-flex;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.test</span>&#123;</span><br><span class=\"line\">    .flex-block()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、使用postcss</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.test</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只需要编译的时候使用autoprefixer处理就好。<br>可能一个属性的效果不是特别明显，要是有很多个属性需要处理呢?  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.flex-block</span>() &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -ms-flexbox;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-flex;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.transform</span>()&#123;</span><br><span class=\"line\">    //仅仅是举例子</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.ccc</span>()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.test</span>&#123;</span><br><span class=\"line\">    .flex-block()</span><br><span class=\"line\">    <span class=\"selector-class\">.transform</span>()</span><br><span class=\"line\">    <span class=\"selector-class\">.ccc</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候postcss还是只需要如下:  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.test</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>:<span class=\"built_in\">rotate</span>(7deg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候就能看出来postcss的便捷性了，我一直认为可以抽象公共化的东西完全没有必要去重复的去手动开发。  </p>\n<h2 id=\"postcss工作原理\"><a href=\"#postcss工作原理\" class=\"headerlink\" title=\"postcss工作原理\"></a>postcss工作原理</h2><p>postcss本身是一个node模块，可以将css文件解析为抽象语法树(AST)，将该树在多个插件方法传递，然后将AST转换为字符串返回，该字符串可以输出到目标文件中。传递过程中的插件可以选择是否改变该语法树，上诉改变可以通过sourcemap来记录。如下面的流程所示(借用w3cplus的一张图)：<br><img src=\"https://www.w3cplus.com/sites/default/files/blogs/2017/1707/figure-18.png\"></p>\n<p>其实这里我们更应该关联起来的是babel，看一下功能：  </p>\n<ul>\n<li>将未来规范的转化为当前规范的转义器</li>\n<li>实现相同，都是将源文件解析为AST然后经由插件处理。</li>\n<li>丰富的插件，满足不同的需求</li>\n<li>支持自定义插件的开发   </li>\n</ul>\n<h4 id=\"当前工作流中引入postcss\"><a href=\"#当前工作流中引入postcss\" class=\"headerlink\" title=\"当前工作流中引入postcss\"></a>当前工作流中引入postcss</h4><p>大家可能会有这种想法，又是一种新的工具，我当前的开发框架中岂不是要大动。其实这种担心是没必要的。postcss是很容易引入当前的工作流中的。无论是webpack还是gulp，都有比较方便的方式。<a href=\"https://github.com/postcss/postcss#usage\" target=\"_blank\" rel=\"noopener\">官方有详细的介绍文档</a>  </p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>原先很早就看到postCss，当时太年轻认为是less的一种替代品罢了，所以一直没有去关注。了解之后感觉真的不错，至于如何使用这里就不去演示了，有兴趣的可以查看下<a href=\"https://github.com/xiaoxiangdaiyu/postcss/tree/master/\" target=\"_blank\" rel=\"noopener\">我的简单示例</a>希望更多的人使用。</p>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/\" target=\"_blank\" rel=\"noopener\">http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/</a><br><a href=\"http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/\" target=\"_blank\" rel=\"noopener\">http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/</a></p>\n","site":{"data":{}},"excerpt":"<p>一般来说介绍一个东西都是要从是什么，怎么用的顺序来讲。我感觉这样很容易让大家失去兴趣，先看一下postcss能做点什么，有兴趣的话再往下看，否则可能没有耐心看下去。让我们开始吧<br>","more":"</p>\n<h2 id=\"postcss能做什么\"><a href=\"#postcss能做什么\" class=\"headerlink\" title=\"postcss能做什么\"></a>postcss能做什么</h2><h3 id=\"补全css属性浏览器前缀\"><a href=\"#补全css属性浏览器前缀\" class=\"headerlink\" title=\"补全css属性浏览器前缀\"></a>补全css属性浏览器前缀</h3><p>手写的代码可以是这样的:  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>postcss可以转换之后成了这样:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.div</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-box;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -ms-flexbox;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">  </span><br><span class=\"line\">### 检查<span class=\"selector-tag\">css</span>语法   </span><br><span class=\"line\"> </span><br><span class=\"line\">```<span class=\"selector-tag\">css</span></span><br><span class=\"line\">    <span class=\"selector-tag\">body</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#f0</span>;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>会有以下提示:    </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">src/er.css</span><br><span class=\"line\"> 2:12  ✖  Unexpected invalid hex color &quot;#f0&quot;   color-no-invalid-hex</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">[18:27:28] &apos;css-lint&apos; errored after 98 ms</span><br><span class=\"line\">[18:27:28] Error in plugin &apos;gulp-stylelint&apos;</span><br><span class=\"line\">Message:</span><br><span class=\"line\">    Failed with 1 error</span><br></pre></td></tr></table></figure>\n<h3 id=\"拥抱下个版本规范的css-即css4\"><a href=\"#拥抱下个版本规范的css-即css4\" class=\"headerlink\" title=\"拥抱下个版本规范的css 即css4\"></a>拥抱下个版本规范的css 即css4</h3><p>对于下个规范的css而言，变量，方法等功能的都会增加上去，你可以这样来定义一个变量：<br><figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-pseudo\">:root</span> &#123; </span><br><span class=\"line\">    <span class=\"attribute\">--red</span>: <span class=\"number\">#d33</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"selector-tag\">a</span> &#123; </span><br><span class=\"line\">      <span class=\"attribute\">color</span>: <span class=\"built_in\">var</span>(--red);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure></p>\n<p>当然直接在现有浏览器上是跑不通的，就正如es2015刚开始一样，我们需要一个转化器来将其转成当前可用规范。postcss的插件就可以做到。  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>:<span class=\"number\">#d33</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除了上面之外还有其他很多功能，postcss及其插件都能提供。</p>\n<h2 id=\"什么是postcss\"><a href=\"#什么是postcss\" class=\"headerlink\" title=\"什么是postcss\"></a>什么是postcss</h2><p>现在让我们回到最基本的问题，postcss是什么。<br>援引官网的定义，一种使用js来转化css的工具(A tool for transforming CSS with JavaScript)。其实我们更多的时候提到postcss是有两个含义的：</p>\n<ol>\n<li>postcss本身，也就是我们npm install时的安装部分  </li>\n<li>基于postCss的丰富插件系统。<br>上文那些功能，都是基于postcss的插件提供的功能。  </li>\n</ol>\n<p>postcss本身并不直接用于处理样式，只有配合它的插件，才能完成相关的编译工作。</p>\n<h4 id=\"postcss不是预编译语言的替代品\"><a href=\"#postcss不是预编译语言的替代品\" class=\"headerlink\" title=\"postcss不是预编译语言的替代品\"></a>postcss不是预编译语言的替代品</h4><p>我想你脑海里一直在复现两个名词，less/sass，开始的时候我也一样，认为postcss跟二者一样是一种css预编译语言或者起到类似作用的一种语言。postcss不是要取代哪一个，更多的是提供的一种补充，完全可以是互补的概念。<br>作为一个是使用js将css转化为AST然后进行处理的工具，完全不是预处理语言的替代品，postcss处理的必须是css文件，所以完全可以和预编译语言结合，使用预编译语言转化为css之后然后进行处理。<br>我一直认为两者不是互斥的关系，完全可以互补使用。   </p>\n<h2 id=\"为什么需要postcss\"><a href=\"#为什么需要postcss\" class=\"headerlink\" title=\"为什么需要postcss\"></a>为什么需要postcss</h2><p>大家可能有这么个疑问既然两者不互相冲突，目前我使用less/sass 也很容易满足我的需求，为什么要使用新的东西呢。我认为主要原因是其提供的丰富的插件功能，可以工作更加的简单化，便捷化，一句话，你只需要编写基本的css，其他的功能交给postcss就好。做了简单的对比可能更加清晰明了。  </p>\n<h4 id=\"实现给css属性加上浏览器前缀的功能\"><a href=\"#实现给css属性加上浏览器前缀的功能\" class=\"headerlink\" title=\"实现给css属性加上浏览器前缀的功能\"></a>实现给css属性加上浏览器前缀的功能</h4><p>对比一下less和postcss的实现： </p>\n<p>1、 对于less而言，肯定是写一个方法  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.flex-block</span>() &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -ms-flexbox;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-flex;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.test</span>&#123;</span><br><span class=\"line\">    .flex-block()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、使用postcss</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.test</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>只需要编译的时候使用autoprefixer处理就好。<br>可能一个属性的效果不是特别明显，要是有很多个属性需要处理呢?  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.flex-block</span>() &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -ms-flexbox;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: -webkit-flex;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.transform</span>()&#123;</span><br><span class=\"line\">    //仅仅是举例子</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.ccc</span>()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.test</span>&#123;</span><br><span class=\"line\">    .flex-block()</span><br><span class=\"line\">    <span class=\"selector-class\">.transform</span>()</span><br><span class=\"line\">    <span class=\"selector-class\">.ccc</span>()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候postcss还是只需要如下:  </p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.test</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: flex;</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>:<span class=\"built_in\">rotate</span>(7deg);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这时候就能看出来postcss的便捷性了，我一直认为可以抽象公共化的东西完全没有必要去重复的去手动开发。  </p>\n<h2 id=\"postcss工作原理\"><a href=\"#postcss工作原理\" class=\"headerlink\" title=\"postcss工作原理\"></a>postcss工作原理</h2><p>postcss本身是一个node模块，可以将css文件解析为抽象语法树(AST)，将该树在多个插件方法传递，然后将AST转换为字符串返回，该字符串可以输出到目标文件中。传递过程中的插件可以选择是否改变该语法树，上诉改变可以通过sourcemap来记录。如下面的流程所示(借用w3cplus的一张图)：<br><img src=\"https://www.w3cplus.com/sites/default/files/blogs/2017/1707/figure-18.png\"></p>\n<p>其实这里我们更应该关联起来的是babel，看一下功能：  </p>\n<ul>\n<li>将未来规范的转化为当前规范的转义器</li>\n<li>实现相同，都是将源文件解析为AST然后经由插件处理。</li>\n<li>丰富的插件，满足不同的需求</li>\n<li>支持自定义插件的开发   </li>\n</ul>\n<h4 id=\"当前工作流中引入postcss\"><a href=\"#当前工作流中引入postcss\" class=\"headerlink\" title=\"当前工作流中引入postcss\"></a>当前工作流中引入postcss</h4><p>大家可能会有这种想法，又是一种新的工具，我当前的开发框架中岂不是要大动。其实这种担心是没必要的。postcss是很容易引入当前的工作流中的。无论是webpack还是gulp，都有比较方便的方式。<a href=\"https://github.com/postcss/postcss#usage\" target=\"_blank\" rel=\"noopener\">官方有详细的介绍文档</a>  </p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>原先很早就看到postCss，当时太年轻认为是less的一种替代品罢了，所以一直没有去关注。了解之后感觉真的不错，至于如何使用这里就不去演示了，有兴趣的可以查看下<a href=\"https://github.com/xiaoxiangdaiyu/postcss/tree/master/\" target=\"_blank\" rel=\"noopener\">我的简单示例</a>希望更多的人使用。</p>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/\" target=\"_blank\" rel=\"noopener\">http://davidtheclark.com/its-time-for-everyone-to-learn-about-postcss/</a><br><a href=\"http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/\" target=\"_blank\" rel=\"noopener\">http://julian.io/some-things-you-may-think-about-postcss-and-you-might-be-wrong/</a></p>"},{"title":"重读redux(一)","date":"2018-06-12T16:00:00.000Z","_content":"\n## 前言  \n对于react技术栈的前端同学来说，redux应该是相对熟悉的。其代码之精简和设计之巧妙，一直为大家所推崇。此外redux的注释简直完美，阅读起来比较省事。原本也是强行读了通源码，现在也忘得差不多了。因为最近打算对redux进行些操作，所以又开始重读了redux，收益匪浅。\n<!--more-->\n关于redux的基本概念，这里就不再详细描述了。可以参考[Redux 中文文档](http://www.redux.org.cn/)。\n## 阅读源码感受  \n有很多大牛已经提供了很多阅读经验。   \n个人感觉一开始就强行读源码是不可取的，就像我当初读的第一遍redux，只能说食之无味，现在全忘了。   \n \n应该是对其基础用法比较熟练之后，有问题或者有兴趣时再读比较好，结合文档或者实例，完整的流程走一走。   \n  \n此外直接源码仓库clone下来，本地跑一跑，实在看不懂的断点跟进去。  \n   \n对于不理解的地方，可能是某些方法不太熟悉，这时候多去找找其具体用法和目的   \n \n实在不明白的可以结合网上已有的源码实例，和别人的思路对比一下，看自己哪里理解有偏差。     \n\n一句话，希望读过之后对自己有启发，更深入的理解和学习，而非只是说起来读过而已。\n\nredux 提供了如下方法：  \n\n```js  \nexport {\n  createStore,\n  combineReducers,\n  bindActionCreators,\n  applyMiddleware,\n  compose\n}\n```\n下面的文章就是按照Redux 中文文档例子的顺序，来分别看下各方法的实现。  \n\n## action和actionCreater  \n### 定义和概念\naction 本质上是 JavaScript 普通对象 \n在 Redux 中的 actionCreater就是生成 action 的方法\n```js  \n//addTodo 就是actionCreater\nfunction addTodo(text) {\n  //return的对象即为action\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\n```\n在 传统的 Flux 实现中，当调用 action 创建函数时  \n一般会触发一个 dispatch  \nRedux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。\n```js\ndispatch(addTodo(text))\n//或者 \nconst boundAddTodo = text => dispatch(addTodo(text))\n```\n当然实际使用的时候，一般情况下（这里指的是简单的同步actionCreater）我们不需要每次都手动dispatch，  \nreact-redux 提供的 connect() 会帮我们来做这个事情。  \n  \n里面通过bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。    \n\n这里先不涉及connect，我们一起看看bindActionCreators如何实现的。  \n\n在看之前，我们可以大胆的猜一下，如果是我们要提供一个warper，将两个方法绑定在一起会怎么做：  \n \n```js  \nfunction a (){\n   /*.....*/  \n};\nfunction b(f){\n  /*.....*/ \n  return f()\n}\n```    \nb里面调用a（先不考虑其他），通过一个c来绑定一下\n\n```js\nfunction c(){\n    return ()=> b(a)\n}\n```\n应该就是这么个样子，那么看一下具体实现\n## bindActionCreators()    \n先看源码：  \n\n```js\n// 绑定单个actionCreator\nfunction bindActionCreator(actionCreator, dispatch) {\n  //将方法dispatch中，避免了action创建手动调用。\n  return (...args) => dispatch(actionCreator(...args))\n}\nexport default function bindActionCreators(actionCreators, dispatch) {\n   // function 说明是单个的actionCreator 直接调用bindActionCreator\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n   // 校验，否则抛错\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(`错误提示`)\n  }\n  //获取keys数组，以便遍历\n  var keys = Object.keys(actionCreators)\n  var boundActionCreators = {}\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    var actionCreator = actionCreators[key]\n    //依次进行校验绑定操作\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  //返回\n  return boundActionCreators\n}\n```\n该方法分为两部分\n#### 首先是 bindActionCreator   \n对单个ActionCreator方法封装  \n\n```js\n   function bindActionCreator(actionCreator, dispatch) {\n  //将方法dispatch中，避免了action创建手动调用。\n  return (...args) => dispatch(actionCreator(...args))\n  } \n```\nbindActionCreators的actionCreators期望是个对象,即actionCreator，  \n 可以想到下面肯定是对该对象进行属性遍历，依次调用bindActionCreator    \n \n#### 下面bindActionCreators的动作就是处理该对象  \n\n* typeof actionCreators === 'function'  \n  单独的方法，直接调用 bindActionCreator结束  \n* 如果不是对象或者为null，那么抛错\n* 对于对象，根据key进行遍历，获取包装之后的 boundActionCreators 然后返回   \n\n```js  \n  // function 说明是单个的actionCreator 直接调用bindActionCreator\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n   // 校验，否则抛错\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(`错误提示`)\n  }\n  //获取keys数组，以便遍历\n  var keys = Object.keys(actionCreators)\n  var boundActionCreators = {}\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    var actionCreator = actionCreators[key]\n    //依次进行校验绑定操作\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }  \n```\n这样我们获得了绑定之后的 actionCreators，无需手动调用dispatch（同步的简单情况下）    \n\n\n   \n## reducer  \naction 只是描述了有事发生及提供源数据，具体如何做就需要reducer来处理（详细介绍就略过了）。  \n在 Redux 应用中，所有的 state 都被保存在一个单一对象中  \n\n当reducer处理多个atcion时，显得比较冗长，需要拆分，如下这样：  \n  \n```js  \nfunction todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    case ADD_TODO:\n      return Object.assign({}, state, {\n        todos: [\n          ...state.todos,\n          {\n            text: action.text,\n            completed: false\n          }\n        ]\n      })\n    case TOGGLE_TODO:\n      return Object.assign({}, state, {\n        todos: state.todos.map((todo, index) => {\n          if (index === action.index) {\n            return Object.assign({}, todo, {\n              completed: !todo.completed\n            })\n          }\n          return todo\n        })\n      })\n    default:\n      return state\n  }\n}  \n```\n需要拆分的时候，每个reducer只处理相关部分的state相比于全部state应该更好，\n例如:\n\n```js\n//reducer1 中 \n function reducer1(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return state.reducer1.a \n      //相比较state只是state.reducer1，显然好一点\n      return state.a\n }\n```\n\n每个 reducer 只负责管理全局 state 中它负责的一部分。  \n每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据  \n\n这样需要在主函数里，分别对子reducer的入参进行管理，可以如下面这样：  \n\n```js\nfunction todoApp(state = {}, action) {\n  return {\n    visibilityFilter: visibilityFilter(state.visibilityFilter, action),\n    todos: todos(state.todos, action)\n  }\n}\n```\n当然redux提供了combineReducers()方法\n\n```js\nimport { combineReducers } from 'redux'\n\nconst todoApp = combineReducers({\n  visibilityFilter,\n  todos\n})\n```\n那么我们来看下combineReducers是如何来实现的 \n\n## combineReducers    \n  \n还是把完整的代码放上来  \n\n```js \nexport default function combineReducers(reducers) {\n  // 获取reducer的key 不作处理的话是子reducer的方法名\n  var reducerKeys = Object.keys(reducers)\n\n  var finalReducers = {}\n  // 遍历 构造finalReducers即总的reducer\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i]\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers)\n\n  var sanityError\n  try {\n    // 规范校验\n    assertReducerSanity(finalReducers)\n  } catch (e) {\n    sanityError = e\n  }\n\n  return function combination(state = {}, action) {\n    if (sanityError) {\n      throw sanityError\n    }\n    // 警报信息 \n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action)\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n    /**\n     * 当有action改变时，\n     * 遍历finalReducers，执行reducer并赋值给nextState，\n     * 通过对应key的state是否改变决定返回当前或者nextState\n     * */\n    // state改变与否的flag \n    var hasChanged = false\n    var nextState = {}\n    // 依次处理\n    for (var i = 0; i < finalReducerKeys.length; i++) {\n      var key = finalReducerKeys[i]\n      var reducer = finalReducers[key]\n      // 获取对应key的state属性\n      var previousStateForKey = state[key]\n      // 目的之一，只处理对应key数据\n      var nextStateForKey = reducer(previousStateForKey, action)\n      // 不能返回undefined，否则抛错\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      // 新状态赋给 nextState对象\n      nextState[key] = nextStateForKey\n      // 是否改变处理 \n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    // 视情况返回state\n    return hasChanged ? nextState : state\n  }\n}\n```\n#### 入参  \n首先看一下入参：reducers    \n \n* 即需要合并处理的子reducer对象集合。\n* 可以通过import * as reducers来获取 \n* tips：  \nreducer应该对default情况也进行处理， 当state是undefined或者未定义的action时，也不能返回undefined。\n返回的是一个总reducer，可以调用每个传入方法，并且分别传入相应的state属性。  \n#### 遍历reducers \n既然是个对象集合，肯定要遍历对象，所以前几步就是这么个操作。\n  \n```js\n// 获取reducer key  目的在于每个子方法处理对应key的state\n  var reducerKeys = Object.keys(reducers)\n\n  var finalReducers = {}\n  // 遍历 构造finalReducers即总的reducer\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i]\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n//获取finalReducers 供下面遍历调用  \nvar finalReducerKeys = Object.keys(finalReducers)\n```\n然后是规范校验，作为一个框架这是必须的，可以略过  \n#### combination  \n返回一个function  \n* 当action被dispatch进来时，该方法主要是分发不同state到对应reducer处理，并返回最新state  \n  \n* 先是标识变量：\n```js  \n    // state改变与否的flag \n    var hasChanged = false\n    var nextState = {}  \n```\n* 进行遍历finalReducers\n   保存原来的previousStateForKey  \n   \n* 然后分发对应属性给相应reducer进行处理获取nextStateForKey  \n   \n  先对nextStateForKey 做个校验，因为reducer要求做兼容的，所以不允许undefined的出现，出现就抛错。    \n  \n  正常的话就nextStateForKey把赋给nextState对应的key  \n\n* 前后两个state做个比较看是否相等，相等的话hasChanged置为true \n遍历结束之后就获得了一个新的state即nextState\n\n```js  \nfor (var i = 0; i < finalReducerKeys.length; i++) {\n      var key = finalReducerKeys[i]\n      var reducer = finalReducers[key]\n      // 获取对应key的state属性\n      var previousStateForKey = state[key]\n      // 目的之一，只处理对应key数据\n      var nextStateForKey = reducer(previousStateForKey, action)\n      // 不能返回undefined，否则抛错\n      if (typeof nextStateForKey === 'undefined') {\n         //.....\n      }\n      // 新状态赋给 nextState对象\n      nextState[key] = nextStateForKey\n      // 是否改变处理 \n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n```\n根据hasChanged来决定返回新旧state。 \n \n```js\n// 视情况返回state\n    return hasChanged ? nextState : state\n```    \n到这里combineReducers就结束了。\n## 结束语  \n这次先分享一半，还是有点多的，剩下的下次再记录一下。抛砖引玉，提升自己，共同学习吧。[更多请移步博客](https://github.com/xiaoxiangdaiyu/blog)\n#### 参考文章  \n[Redux 中文文档](http://www.redux.org.cn/)\n\n\n\n\n\n","source":"_posts/redux/redux1.md","raw":"---\ntitle: 重读redux(一)\ndate: 2018-06-13\n---\n\n## 前言  \n对于react技术栈的前端同学来说，redux应该是相对熟悉的。其代码之精简和设计之巧妙，一直为大家所推崇。此外redux的注释简直完美，阅读起来比较省事。原本也是强行读了通源码，现在也忘得差不多了。因为最近打算对redux进行些操作，所以又开始重读了redux，收益匪浅。\n<!--more-->\n关于redux的基本概念，这里就不再详细描述了。可以参考[Redux 中文文档](http://www.redux.org.cn/)。\n## 阅读源码感受  \n有很多大牛已经提供了很多阅读经验。   \n个人感觉一开始就强行读源码是不可取的，就像我当初读的第一遍redux，只能说食之无味，现在全忘了。   \n \n应该是对其基础用法比较熟练之后，有问题或者有兴趣时再读比较好，结合文档或者实例，完整的流程走一走。   \n  \n此外直接源码仓库clone下来，本地跑一跑，实在看不懂的断点跟进去。  \n   \n对于不理解的地方，可能是某些方法不太熟悉，这时候多去找找其具体用法和目的   \n \n实在不明白的可以结合网上已有的源码实例，和别人的思路对比一下，看自己哪里理解有偏差。     \n\n一句话，希望读过之后对自己有启发，更深入的理解和学习，而非只是说起来读过而已。\n\nredux 提供了如下方法：  \n\n```js  \nexport {\n  createStore,\n  combineReducers,\n  bindActionCreators,\n  applyMiddleware,\n  compose\n}\n```\n下面的文章就是按照Redux 中文文档例子的顺序，来分别看下各方法的实现。  \n\n## action和actionCreater  \n### 定义和概念\naction 本质上是 JavaScript 普通对象 \n在 Redux 中的 actionCreater就是生成 action 的方法\n```js  \n//addTodo 就是actionCreater\nfunction addTodo(text) {\n  //return的对象即为action\n  return {\n    type: ADD_TODO,\n    text\n  }\n}\n```\n在 传统的 Flux 实现中，当调用 action 创建函数时  \n一般会触发一个 dispatch  \nRedux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。\n```js\ndispatch(addTodo(text))\n//或者 \nconst boundAddTodo = text => dispatch(addTodo(text))\n```\n当然实际使用的时候，一般情况下（这里指的是简单的同步actionCreater）我们不需要每次都手动dispatch，  \nreact-redux 提供的 connect() 会帮我们来做这个事情。  \n  \n里面通过bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。    \n\n这里先不涉及connect，我们一起看看bindActionCreators如何实现的。  \n\n在看之前，我们可以大胆的猜一下，如果是我们要提供一个warper，将两个方法绑定在一起会怎么做：  \n \n```js  \nfunction a (){\n   /*.....*/  \n};\nfunction b(f){\n  /*.....*/ \n  return f()\n}\n```    \nb里面调用a（先不考虑其他），通过一个c来绑定一下\n\n```js\nfunction c(){\n    return ()=> b(a)\n}\n```\n应该就是这么个样子，那么看一下具体实现\n## bindActionCreators()    \n先看源码：  \n\n```js\n// 绑定单个actionCreator\nfunction bindActionCreator(actionCreator, dispatch) {\n  //将方法dispatch中，避免了action创建手动调用。\n  return (...args) => dispatch(actionCreator(...args))\n}\nexport default function bindActionCreators(actionCreators, dispatch) {\n   // function 说明是单个的actionCreator 直接调用bindActionCreator\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n   // 校验，否则抛错\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(`错误提示`)\n  }\n  //获取keys数组，以便遍历\n  var keys = Object.keys(actionCreators)\n  var boundActionCreators = {}\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    var actionCreator = actionCreators[key]\n    //依次进行校验绑定操作\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }\n  //返回\n  return boundActionCreators\n}\n```\n该方法分为两部分\n#### 首先是 bindActionCreator   \n对单个ActionCreator方法封装  \n\n```js\n   function bindActionCreator(actionCreator, dispatch) {\n  //将方法dispatch中，避免了action创建手动调用。\n  return (...args) => dispatch(actionCreator(...args))\n  } \n```\nbindActionCreators的actionCreators期望是个对象,即actionCreator，  \n 可以想到下面肯定是对该对象进行属性遍历，依次调用bindActionCreator    \n \n#### 下面bindActionCreators的动作就是处理该对象  \n\n* typeof actionCreators === 'function'  \n  单独的方法，直接调用 bindActionCreator结束  \n* 如果不是对象或者为null，那么抛错\n* 对于对象，根据key进行遍历，获取包装之后的 boundActionCreators 然后返回   \n\n```js  \n  // function 说明是单个的actionCreator 直接调用bindActionCreator\n  if (typeof actionCreators === 'function') {\n    return bindActionCreator(actionCreators, dispatch)\n  }\n   // 校验，否则抛错\n  if (typeof actionCreators !== 'object' || actionCreators === null) {\n    throw new Error(`错误提示`)\n  }\n  //获取keys数组，以便遍历\n  var keys = Object.keys(actionCreators)\n  var boundActionCreators = {}\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i]\n    var actionCreator = actionCreators[key]\n    //依次进行校验绑定操作\n    if (typeof actionCreator === 'function') {\n      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)\n    }\n  }  \n```\n这样我们获得了绑定之后的 actionCreators，无需手动调用dispatch（同步的简单情况下）    \n\n\n   \n## reducer  \naction 只是描述了有事发生及提供源数据，具体如何做就需要reducer来处理（详细介绍就略过了）。  \n在 Redux 应用中，所有的 state 都被保存在一个单一对象中  \n\n当reducer处理多个atcion时，显得比较冗长，需要拆分，如下这样：  \n  \n```js  \nfunction todoApp(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    case ADD_TODO:\n      return Object.assign({}, state, {\n        todos: [\n          ...state.todos,\n          {\n            text: action.text,\n            completed: false\n          }\n        ]\n      })\n    case TOGGLE_TODO:\n      return Object.assign({}, state, {\n        todos: state.todos.map((todo, index) => {\n          if (index === action.index) {\n            return Object.assign({}, todo, {\n              completed: !todo.completed\n            })\n          }\n          return todo\n        })\n      })\n    default:\n      return state\n  }\n}  \n```\n需要拆分的时候，每个reducer只处理相关部分的state相比于全部state应该更好，\n例如:\n\n```js\n//reducer1 中 \n function reducer1(state = initialState, action) {\n  switch (action.type) {\n    case SET_VISIBILITY_FILTER:\n      return state.reducer1.a \n      //相比较state只是state.reducer1，显然好一点\n      return state.a\n }\n```\n\n每个 reducer 只负责管理全局 state 中它负责的一部分。  \n每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据  \n\n这样需要在主函数里，分别对子reducer的入参进行管理，可以如下面这样：  \n\n```js\nfunction todoApp(state = {}, action) {\n  return {\n    visibilityFilter: visibilityFilter(state.visibilityFilter, action),\n    todos: todos(state.todos, action)\n  }\n}\n```\n当然redux提供了combineReducers()方法\n\n```js\nimport { combineReducers } from 'redux'\n\nconst todoApp = combineReducers({\n  visibilityFilter,\n  todos\n})\n```\n那么我们来看下combineReducers是如何来实现的 \n\n## combineReducers    \n  \n还是把完整的代码放上来  \n\n```js \nexport default function combineReducers(reducers) {\n  // 获取reducer的key 不作处理的话是子reducer的方法名\n  var reducerKeys = Object.keys(reducers)\n\n  var finalReducers = {}\n  // 遍历 构造finalReducers即总的reducer\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i]\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n  var finalReducerKeys = Object.keys(finalReducers)\n\n  var sanityError\n  try {\n    // 规范校验\n    assertReducerSanity(finalReducers)\n  } catch (e) {\n    sanityError = e\n  }\n\n  return function combination(state = {}, action) {\n    if (sanityError) {\n      throw sanityError\n    }\n    // 警报信息 \n    if (process.env.NODE_ENV !== 'production') {\n      var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action)\n      if (warningMessage) {\n        warning(warningMessage)\n      }\n    }\n    /**\n     * 当有action改变时，\n     * 遍历finalReducers，执行reducer并赋值给nextState，\n     * 通过对应key的state是否改变决定返回当前或者nextState\n     * */\n    // state改变与否的flag \n    var hasChanged = false\n    var nextState = {}\n    // 依次处理\n    for (var i = 0; i < finalReducerKeys.length; i++) {\n      var key = finalReducerKeys[i]\n      var reducer = finalReducers[key]\n      // 获取对应key的state属性\n      var previousStateForKey = state[key]\n      // 目的之一，只处理对应key数据\n      var nextStateForKey = reducer(previousStateForKey, action)\n      // 不能返回undefined，否则抛错\n      if (typeof nextStateForKey === 'undefined') {\n        var errorMessage = getUndefinedStateErrorMessage(key, action)\n        throw new Error(errorMessage)\n      }\n      // 新状态赋给 nextState对象\n      nextState[key] = nextStateForKey\n      // 是否改变处理 \n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n    // 视情况返回state\n    return hasChanged ? nextState : state\n  }\n}\n```\n#### 入参  \n首先看一下入参：reducers    \n \n* 即需要合并处理的子reducer对象集合。\n* 可以通过import * as reducers来获取 \n* tips：  \nreducer应该对default情况也进行处理， 当state是undefined或者未定义的action时，也不能返回undefined。\n返回的是一个总reducer，可以调用每个传入方法，并且分别传入相应的state属性。  \n#### 遍历reducers \n既然是个对象集合，肯定要遍历对象，所以前几步就是这么个操作。\n  \n```js\n// 获取reducer key  目的在于每个子方法处理对应key的state\n  var reducerKeys = Object.keys(reducers)\n\n  var finalReducers = {}\n  // 遍历 构造finalReducers即总的reducer\n  for (var i = 0; i < reducerKeys.length; i++) {\n    var key = reducerKeys[i]\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key]\n    }\n  }\n//获取finalReducers 供下面遍历调用  \nvar finalReducerKeys = Object.keys(finalReducers)\n```\n然后是规范校验，作为一个框架这是必须的，可以略过  \n#### combination  \n返回一个function  \n* 当action被dispatch进来时，该方法主要是分发不同state到对应reducer处理，并返回最新state  \n  \n* 先是标识变量：\n```js  \n    // state改变与否的flag \n    var hasChanged = false\n    var nextState = {}  \n```\n* 进行遍历finalReducers\n   保存原来的previousStateForKey  \n   \n* 然后分发对应属性给相应reducer进行处理获取nextStateForKey  \n   \n  先对nextStateForKey 做个校验，因为reducer要求做兼容的，所以不允许undefined的出现，出现就抛错。    \n  \n  正常的话就nextStateForKey把赋给nextState对应的key  \n\n* 前后两个state做个比较看是否相等，相等的话hasChanged置为true \n遍历结束之后就获得了一个新的state即nextState\n\n```js  \nfor (var i = 0; i < finalReducerKeys.length; i++) {\n      var key = finalReducerKeys[i]\n      var reducer = finalReducers[key]\n      // 获取对应key的state属性\n      var previousStateForKey = state[key]\n      // 目的之一，只处理对应key数据\n      var nextStateForKey = reducer(previousStateForKey, action)\n      // 不能返回undefined，否则抛错\n      if (typeof nextStateForKey === 'undefined') {\n         //.....\n      }\n      // 新状态赋给 nextState对象\n      nextState[key] = nextStateForKey\n      // 是否改变处理 \n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey\n    }\n```\n根据hasChanged来决定返回新旧state。 \n \n```js\n// 视情况返回state\n    return hasChanged ? nextState : state\n```    \n到这里combineReducers就结束了。\n## 结束语  \n这次先分享一半，还是有点多的，剩下的下次再记录一下。抛砖引玉，提升自己，共同学习吧。[更多请移步博客](https://github.com/xiaoxiangdaiyu/blog)\n#### 参考文章  \n[Redux 中文文档](http://www.redux.org.cn/)\n\n\n\n\n\n","slug":"redux/redux1","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt7u001bgw923qu9amii","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于react技术栈的前端同学来说，redux应该是相对熟悉的。其代码之精简和设计之巧妙，一直为大家所推崇。此外redux的注释简直完美，阅读起来比较省事。原本也是强行读了通源码，现在也忘得差不多了。因为最近打算对redux进行些操作，所以又开始重读了redux，收益匪浅。<br><a id=\"more\"></a><br>关于redux的基本概念，这里就不再详细描述了。可以参考<a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">Redux 中文文档</a>。</p>\n<h2 id=\"阅读源码感受\"><a href=\"#阅读源码感受\" class=\"headerlink\" title=\"阅读源码感受\"></a>阅读源码感受</h2><p>有很多大牛已经提供了很多阅读经验。<br>个人感觉一开始就强行读源码是不可取的，就像我当初读的第一遍redux，只能说食之无味，现在全忘了。   </p>\n<p>应该是对其基础用法比较熟练之后，有问题或者有兴趣时再读比较好，结合文档或者实例，完整的流程走一走。   </p>\n<p>此外直接源码仓库clone下来，本地跑一跑，实在看不懂的断点跟进去。  </p>\n<p>对于不理解的地方，可能是某些方法不太熟悉，这时候多去找找其具体用法和目的   </p>\n<p>实在不明白的可以结合网上已有的源码实例，和别人的思路对比一下，看自己哪里理解有偏差。     </p>\n<p>一句话，希望读过之后对自己有启发，更深入的理解和学习，而非只是说起来读过而已。</p>\n<p>redux 提供了如下方法：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> &#123;</span><br><span class=\"line\">  createStore,</span><br><span class=\"line\">  combineReducers,</span><br><span class=\"line\">  bindActionCreators,</span><br><span class=\"line\">  applyMiddleware,</span><br><span class=\"line\">  compose</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的文章就是按照Redux 中文文档例子的顺序，来分别看下各方法的实现。  </p>\n<h2 id=\"action和actionCreater\"><a href=\"#action和actionCreater\" class=\"headerlink\" title=\"action和actionCreater\"></a>action和actionCreater</h2><h3 id=\"定义和概念\"><a href=\"#定义和概念\" class=\"headerlink\" title=\"定义和概念\"></a>定义和概念</h3><p>action 本质上是 JavaScript 普通对象<br>在 Redux 中的 actionCreater就是生成 action 的方法<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//addTodo 就是actionCreater</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//return的对象即为action</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 传统的 Flux 实现中，当调用 action 创建函数时<br>一般会触发一个 dispatch<br>Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch(addTodo(text))</span><br><span class=\"line\"><span class=\"comment\">//或者 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> boundAddTodo = <span class=\"function\"><span class=\"params\">text</span> =&gt;</span> dispatch(addTodo(text))</span><br></pre></td></tr></table></figure></p>\n<p>当然实际使用的时候，一般情况下（这里指的是简单的同步actionCreater）我们不需要每次都手动dispatch，<br>react-redux 提供的 connect() 会帮我们来做这个事情。  </p>\n<p>里面通过bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。    </p>\n<p>这里先不涉及connect，我们一起看看bindActionCreators如何实现的。  </p>\n<p>在看之前，我们可以大胆的猜一下，如果是我们要提供一个warper，将两个方法绑定在一起会怎么做：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/*.....*/</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/*.....*/</span> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> f()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\">b里面调用a（先不考虑其他），通过一个c来绑定一下</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> b(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>应该就是这么个样子，那么看一下具体实现</p>\n<h2 id=\"bindActionCreators\"><a href=\"#bindActionCreators\" class=\"headerlink\" title=\"bindActionCreators()\"></a>bindActionCreators()</h2><p>先看源码：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 绑定单个actionCreator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreator</span>(<span class=\"params\">actionCreator, dispatch</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将方法dispatch中，避免了action创建手动调用。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(actionCreator(...args))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreators</span>(<span class=\"params\">actionCreators, dispatch</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// function 说明是单个的actionCreator 直接调用bindActionCreator</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 校验，否则抛错</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators !== <span class=\"string\">'object'</span> || actionCreators === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`错误提示`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//获取keys数组，以便遍历</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(actionCreators)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> boundActionCreators = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = keys[i]</span><br><span class=\"line\">    <span class=\"keyword\">var</span> actionCreator = actionCreators[key]</span><br><span class=\"line\">    <span class=\"comment\">//依次进行校验绑定操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreator === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//返回</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> boundActionCreators</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法分为两部分</p>\n<h4 id=\"首先是-bindActionCreator\"><a href=\"#首先是-bindActionCreator\" class=\"headerlink\" title=\"首先是 bindActionCreator\"></a>首先是 bindActionCreator</h4><p>对单个ActionCreator方法封装  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreator</span>(<span class=\"params\">actionCreator, dispatch</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//将方法dispatch中，避免了action创建手动调用。</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(actionCreator(...args))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bindActionCreators的actionCreators期望是个对象,即actionCreator，<br> 可以想到下面肯定是对该对象进行属性遍历，依次调用bindActionCreator    </p>\n<h4 id=\"下面bindActionCreators的动作就是处理该对象\"><a href=\"#下面bindActionCreators的动作就是处理该对象\" class=\"headerlink\" title=\"下面bindActionCreators的动作就是处理该对象\"></a>下面bindActionCreators的动作就是处理该对象</h4><ul>\n<li>typeof actionCreators === ‘function’<br>单独的方法，直接调用 bindActionCreator结束  </li>\n<li>如果不是对象或者为null，那么抛错</li>\n<li>对于对象，根据key进行遍历，获取包装之后的 boundActionCreators 然后返回   </li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// function 说明是单个的actionCreator 直接调用bindActionCreator</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"comment\">// 校验，否则抛错</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators !== <span class=\"string\">'object'</span> || actionCreators === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`错误提示`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取keys数组，以便遍历</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(actionCreators)</span><br><span class=\"line\"><span class=\"keyword\">var</span> boundActionCreators = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> key = keys[i]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> actionCreator = actionCreators[key]</span><br><span class=\"line\">  <span class=\"comment\">//依次进行校验绑定操作</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreator === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们获得了绑定之后的 actionCreators，无需手动调用dispatch（同步的简单情况下）    </p>\n<h2 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a>reducer</h2><p>action 只是描述了有事发生及提供源数据，具体如何做就需要reducer来处理（详细介绍就略过了）。<br>在 Redux 应用中，所有的 state 都被保存在一个单一对象中  </p>\n<p>当reducer处理多个atcion时，显得比较冗长，需要拆分，如下这样：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todoApp</span>(<span class=\"params\">state = initialState, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SET_VISIBILITY_FILTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        visibilityFilter: action.filter</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_TODO:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        todos: [</span><br><span class=\"line\">          ...state.todos,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            text: action.text,</span><br><span class=\"line\">            completed: <span class=\"literal\">false</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> TOGGLE_TODO:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        todos: state.todos.map(<span class=\"function\">(<span class=\"params\">todo, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (index === action.index) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, todo, &#123;</span><br><span class=\"line\">              completed: !todo.completed</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> todo</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要拆分的时候，每个reducer只处理相关部分的state相比于全部state应该更好，<br>例如:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//reducer1 中 </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer1</span>(<span class=\"params\">state = initialState, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SET_VISIBILITY_FILTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.reducer1.a </span><br><span class=\"line\">      <span class=\"comment\">//相比较state只是state.reducer1，显然好一点</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.a</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>每个 reducer 只负责管理全局 state 中它负责的一部分。<br>每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据  </p>\n<p>这样需要在主函数里，分别对子reducer的入参进行管理，可以如下面这样：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todoApp</span>(<span class=\"params\">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    visibilityFilter: visibilityFilter(state.visibilityFilter, action),</span><br><span class=\"line\">    todos: todos(state.todos, action)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然redux提供了combineReducers()方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoApp = combineReducers(&#123;</span><br><span class=\"line\">  visibilityFilter,</span><br><span class=\"line\">  todos</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>那么我们来看下combineReducers是如何来实现的 </p>\n<h2 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h2><p>还是把完整的代码放上来  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combineReducers</span>(<span class=\"params\">reducers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取reducer的key 不作处理的话是子reducer的方法名</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> reducerKeys = <span class=\"built_in\">Object</span>.keys(reducers)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> finalReducers = &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 遍历 构造finalReducers即总的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = reducerKeys[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      finalReducers[key] = reducers[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> finalReducerKeys = <span class=\"built_in\">Object</span>.keys(finalReducers)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> sanityError</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 规范校验</span></span><br><span class=\"line\">    assertReducerSanity(finalReducers)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    sanityError = e</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combination</span>(<span class=\"params\">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sanityError) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> sanityError</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 警报信息 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (warningMessage) &#123;</span><br><span class=\"line\">        warning(warningMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当有action改变时，</span></span><br><span class=\"line\"><span class=\"comment\">     * 遍历finalReducers，执行reducer并赋值给nextState，</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过对应key的state是否改变决定返回当前或者nextState</span></span><br><span class=\"line\"><span class=\"comment\">     * */</span></span><br><span class=\"line\">    <span class=\"comment\">// state改变与否的flag </span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextState = &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 依次处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> key = finalReducerKeys[i]</span><br><span class=\"line\">      <span class=\"keyword\">var</span> reducer = finalReducers[key]</span><br><span class=\"line\">      <span class=\"comment\">// 获取对应key的state属性</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> previousStateForKey = state[key]</span><br><span class=\"line\">      <span class=\"comment\">// 目的之一，只处理对应key数据</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">      <span class=\"comment\">// 不能返回undefined，否则抛错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(errorMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 新状态赋给 nextState对象</span></span><br><span class=\"line\">      nextState[key] = nextStateForKey</span><br><span class=\"line\">      <span class=\"comment\">// 是否改变处理 </span></span><br><span class=\"line\">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 视情况返回state</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"入参\"><a href=\"#入参\" class=\"headerlink\" title=\"入参\"></a>入参</h4><p>首先看一下入参：reducers    </p>\n<ul>\n<li>即需要合并处理的子reducer对象集合。</li>\n<li>可以通过import * as reducers来获取 </li>\n<li>tips：<br>reducer应该对default情况也进行处理， 当state是undefined或者未定义的action时，也不能返回undefined。<br>返回的是一个总reducer，可以调用每个传入方法，并且分别传入相应的state属性。  <h4 id=\"遍历reducers\"><a href=\"#遍历reducers\" class=\"headerlink\" title=\"遍历reducers\"></a>遍历reducers</h4>既然是个对象集合，肯定要遍历对象，所以前几步就是这么个操作。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取reducer key  目的在于每个子方法处理对应key的state</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> reducerKeys = <span class=\"built_in\">Object</span>.keys(reducers)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> finalReducers = &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 遍历 构造finalReducers即总的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = reducerKeys[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      finalReducers[key] = reducers[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">//获取finalReducers 供下面遍历调用  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> finalReducerKeys = <span class=\"built_in\">Object</span>.keys(finalReducers)</span><br></pre></td></tr></table></figure>\n<p>然后是规范校验，作为一个框架这是必须的，可以略过  </p>\n<h4 id=\"combination\"><a href=\"#combination\" class=\"headerlink\" title=\"combination\"></a>combination</h4><p>返回一个function  </p>\n<ul>\n<li><p>当action被dispatch进来时，该方法主要是分发不同state到对应reducer处理，并返回最新state  </p>\n</li>\n<li><p>先是标识变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// state改变与否的flag </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nextState = &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进行遍历finalReducers<br> 保存原来的previousStateForKey  </p>\n</li>\n<li><p>然后分发对应属性给相应reducer进行处理获取nextStateForKey  </p>\n<p>先对nextStateForKey 做个校验，因为reducer要求做兼容的，所以不允许undefined的出现，出现就抛错。    </p>\n<p>正常的话就nextStateForKey把赋给nextState对应的key  </p>\n</li>\n<li><p>前后两个state做个比较看是否相等，相等的话hasChanged置为true<br>遍历结束之后就获得了一个新的state即nextState</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> key = finalReducerKeys[i]</span><br><span class=\"line\">      <span class=\"keyword\">var</span> reducer = finalReducers[key]</span><br><span class=\"line\">      <span class=\"comment\">// 获取对应key的state属性</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> previousStateForKey = state[key]</span><br><span class=\"line\">      <span class=\"comment\">// 目的之一，只处理对应key数据</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">      <span class=\"comment\">// 不能返回undefined，否则抛错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">//.....</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 新状态赋给 nextState对象</span></span><br><span class=\"line\">      nextState[key] = nextStateForKey</span><br><span class=\"line\">      <span class=\"comment\">// 是否改变处理 </span></span><br><span class=\"line\">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>根据hasChanged来决定返回新旧state。 </p>\n<pre><code class=\"js\"><span class=\"comment\">// 视情况返回state</span>\n    <span class=\"keyword\">return</span> hasChanged ? nextState : state\n</code></pre>\n<p>到这里combineReducers就结束了。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>这次先分享一半，还是有点多的，剩下的下次再记录一下。抛砖引玉，提升自己，共同学习吧。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">更多请移步博客</a></p>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">Redux 中文文档</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>对于react技术栈的前端同学来说，redux应该是相对熟悉的。其代码之精简和设计之巧妙，一直为大家所推崇。此外redux的注释简直完美，阅读起来比较省事。原本也是强行读了通源码，现在也忘得差不多了。因为最近打算对redux进行些操作，所以又开始重读了redux，收益匪浅。<br>","more":"<br>关于redux的基本概念，这里就不再详细描述了。可以参考<a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">Redux 中文文档</a>。</p>\n<h2 id=\"阅读源码感受\"><a href=\"#阅读源码感受\" class=\"headerlink\" title=\"阅读源码感受\"></a>阅读源码感受</h2><p>有很多大牛已经提供了很多阅读经验。<br>个人感觉一开始就强行读源码是不可取的，就像我当初读的第一遍redux，只能说食之无味，现在全忘了。   </p>\n<p>应该是对其基础用法比较熟练之后，有问题或者有兴趣时再读比较好，结合文档或者实例，完整的流程走一走。   </p>\n<p>此外直接源码仓库clone下来，本地跑一跑，实在看不懂的断点跟进去。  </p>\n<p>对于不理解的地方，可能是某些方法不太熟悉，这时候多去找找其具体用法和目的   </p>\n<p>实在不明白的可以结合网上已有的源码实例，和别人的思路对比一下，看自己哪里理解有偏差。     </p>\n<p>一句话，希望读过之后对自己有启发，更深入的理解和学习，而非只是说起来读过而已。</p>\n<p>redux 提供了如下方法：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> &#123;</span><br><span class=\"line\">  createStore,</span><br><span class=\"line\">  combineReducers,</span><br><span class=\"line\">  bindActionCreators,</span><br><span class=\"line\">  applyMiddleware,</span><br><span class=\"line\">  compose</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面的文章就是按照Redux 中文文档例子的顺序，来分别看下各方法的实现。  </p>\n<h2 id=\"action和actionCreater\"><a href=\"#action和actionCreater\" class=\"headerlink\" title=\"action和actionCreater\"></a>action和actionCreater</h2><h3 id=\"定义和概念\"><a href=\"#定义和概念\" class=\"headerlink\" title=\"定义和概念\"></a>定义和概念</h3><p>action 本质上是 JavaScript 普通对象<br>在 Redux 中的 actionCreater就是生成 action 的方法<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//addTodo 就是actionCreater</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addTodo</span>(<span class=\"params\">text</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//return的对象即为action</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    type: ADD_TODO,</span><br><span class=\"line\">    text</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在 传统的 Flux 实现中，当调用 action 创建函数时<br>一般会触发一个 dispatch<br>Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次 dispatch 过程。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dispatch(addTodo(text))</span><br><span class=\"line\"><span class=\"comment\">//或者 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> boundAddTodo = <span class=\"function\"><span class=\"params\">text</span> =&gt;</span> dispatch(addTodo(text))</span><br></pre></td></tr></table></figure></p>\n<p>当然实际使用的时候，一般情况下（这里指的是简单的同步actionCreater）我们不需要每次都手动dispatch，<br>react-redux 提供的 connect() 会帮我们来做这个事情。  </p>\n<p>里面通过bindActionCreators() 可以自动把多个 action 创建函数 绑定到 dispatch() 方法上。    </p>\n<p>这里先不涉及connect，我们一起看看bindActionCreators如何实现的。  </p>\n<p>在看之前，我们可以大胆的猜一下，如果是我们要提供一个warper，将两个方法绑定在一起会怎么做：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span> (<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">/*.....*/</span>  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/*.....*/</span> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> f()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`    </span></span><br><span class=\"line\"><span class=\"string\">b里面调用a（先不考虑其他），通过一个c来绑定一下</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">c</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span>=&gt;</span> b(a)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>应该就是这么个样子，那么看一下具体实现</p>\n<h2 id=\"bindActionCreators\"><a href=\"#bindActionCreators\" class=\"headerlink\" title=\"bindActionCreators()\"></a>bindActionCreators()</h2><p>先看源码：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 绑定单个actionCreator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreator</span>(<span class=\"params\">actionCreator, dispatch</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将方法dispatch中，避免了action创建手动调用。</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(actionCreator(...args))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreators</span>(<span class=\"params\">actionCreators, dispatch</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// function 说明是单个的actionCreator 直接调用bindActionCreator</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 校验，否则抛错</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators !== <span class=\"string\">'object'</span> || actionCreators === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`错误提示`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//获取keys数组，以便遍历</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(actionCreators)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> boundActionCreators = &#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = keys[i]</span><br><span class=\"line\">    <span class=\"keyword\">var</span> actionCreator = actionCreators[key]</span><br><span class=\"line\">    <span class=\"comment\">//依次进行校验绑定操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreator === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//返回</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> boundActionCreators</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>该方法分为两部分</p>\n<h4 id=\"首先是-bindActionCreator\"><a href=\"#首先是-bindActionCreator\" class=\"headerlink\" title=\"首先是 bindActionCreator\"></a>首先是 bindActionCreator</h4><p>对单个ActionCreator方法封装  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bindActionCreator</span>(<span class=\"params\">actionCreator, dispatch</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//将方法dispatch中，避免了action创建手动调用。</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(actionCreator(...args))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>bindActionCreators的actionCreators期望是个对象,即actionCreator，<br> 可以想到下面肯定是对该对象进行属性遍历，依次调用bindActionCreator    </p>\n<h4 id=\"下面bindActionCreators的动作就是处理该对象\"><a href=\"#下面bindActionCreators的动作就是处理该对象\" class=\"headerlink\" title=\"下面bindActionCreators的动作就是处理该对象\"></a>下面bindActionCreators的动作就是处理该对象</h4><ul>\n<li>typeof actionCreators === ‘function’<br>单独的方法，直接调用 bindActionCreator结束  </li>\n<li>如果不是对象或者为null，那么抛错</li>\n<li>对于对象，根据key进行遍历，获取包装之后的 boundActionCreators 然后返回   </li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// function 说明是单个的actionCreator 直接调用bindActionCreator</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bindActionCreator(actionCreators, dispatch)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> <span class=\"comment\">// 校验，否则抛错</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreators !== <span class=\"string\">'object'</span> || actionCreators === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">`错误提示`</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//获取keys数组，以便遍历</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> keys = <span class=\"built_in\">Object</span>.keys(actionCreators)</span><br><span class=\"line\"><span class=\"keyword\">var</span> boundActionCreators = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> key = keys[i]</span><br><span class=\"line\">  <span class=\"keyword\">var</span> actionCreator = actionCreators[key]</span><br><span class=\"line\">  <span class=\"comment\">//依次进行校验绑定操作</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> actionCreator === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    boundActionCreators[key] = bindActionCreator(actionCreator, dispatch)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们获得了绑定之后的 actionCreators，无需手动调用dispatch（同步的简单情况下）    </p>\n<h2 id=\"reducer\"><a href=\"#reducer\" class=\"headerlink\" title=\"reducer\"></a>reducer</h2><p>action 只是描述了有事发生及提供源数据，具体如何做就需要reducer来处理（详细介绍就略过了）。<br>在 Redux 应用中，所有的 state 都被保存在一个单一对象中  </p>\n<p>当reducer处理多个atcion时，显得比较冗长，需要拆分，如下这样：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todoApp</span>(<span class=\"params\">state = initialState, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SET_VISIBILITY_FILTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        visibilityFilter: action.filter</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ADD_TODO:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        todos: [</span><br><span class=\"line\">          ...state.todos,</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            text: action.text,</span><br><span class=\"line\">            completed: <span class=\"literal\">false</span></span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">case</span> TOGGLE_TODO:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class=\"line\">        todos: state.todos.map(<span class=\"function\">(<span class=\"params\">todo, index</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (index === action.index) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.assign(&#123;&#125;, todo, &#123;</span><br><span class=\"line\">              completed: !todo.completed</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> todo</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>需要拆分的时候，每个reducer只处理相关部分的state相比于全部state应该更好，<br>例如:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//reducer1 中 </span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reducer1</span>(<span class=\"params\">state = initialState, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> SET_VISIBILITY_FILTER:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.reducer1.a </span><br><span class=\"line\">      <span class=\"comment\">//相比较state只是state.reducer1，显然好一点</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> state.a</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>每个 reducer 只负责管理全局 state 中它负责的一部分。<br>每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据  </p>\n<p>这样需要在主函数里，分别对子reducer的入参进行管理，可以如下面这样：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">todoApp</span>(<span class=\"params\">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    visibilityFilter: visibilityFilter(state.visibilityFilter, action),</span><br><span class=\"line\">    todos: todos(state.todos, action)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当然redux提供了combineReducers()方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; combineReducers &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> todoApp = combineReducers(&#123;</span><br><span class=\"line\">  visibilityFilter,</span><br><span class=\"line\">  todos</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>那么我们来看下combineReducers是如何来实现的 </p>\n<h2 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h2><p>还是把完整的代码放上来  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combineReducers</span>(<span class=\"params\">reducers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 获取reducer的key 不作处理的话是子reducer的方法名</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> reducerKeys = <span class=\"built_in\">Object</span>.keys(reducers)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> finalReducers = &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 遍历 构造finalReducers即总的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = reducerKeys[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      finalReducers[key] = reducers[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> finalReducerKeys = <span class=\"built_in\">Object</span>.keys(finalReducers)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> sanityError</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 规范校验</span></span><br><span class=\"line\">    assertReducerSanity(finalReducers)</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">    sanityError = e</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">combination</span>(<span class=\"params\">state = &#123;&#125;, action</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (sanityError) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> sanityError</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 警报信息 </span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (process.env.NODE_ENV !== <span class=\"string\">'production'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action)</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (warningMessage) &#123;</span><br><span class=\"line\">        warning(warningMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当有action改变时，</span></span><br><span class=\"line\"><span class=\"comment\">     * 遍历finalReducers，执行reducer并赋值给nextState，</span></span><br><span class=\"line\"><span class=\"comment\">     * 通过对应key的state是否改变决定返回当前或者nextState</span></span><br><span class=\"line\"><span class=\"comment\">     * */</span></span><br><span class=\"line\">    <span class=\"comment\">// state改变与否的flag </span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> nextState = &#123;&#125;</span><br><span class=\"line\">    <span class=\"comment\">// 依次处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> key = finalReducerKeys[i]</span><br><span class=\"line\">      <span class=\"keyword\">var</span> reducer = finalReducers[key]</span><br><span class=\"line\">      <span class=\"comment\">// 获取对应key的state属性</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> previousStateForKey = state[key]</span><br><span class=\"line\">      <span class=\"comment\">// 目的之一，只处理对应key数据</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">      <span class=\"comment\">// 不能返回undefined，否则抛错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(errorMessage)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 新状态赋给 nextState对象</span></span><br><span class=\"line\">      nextState[key] = nextStateForKey</span><br><span class=\"line\">      <span class=\"comment\">// 是否改变处理 </span></span><br><span class=\"line\">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 视情况返回state</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> hasChanged ? nextState : state</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"入参\"><a href=\"#入参\" class=\"headerlink\" title=\"入参\"></a>入参</h4><p>首先看一下入参：reducers    </p>\n<ul>\n<li>即需要合并处理的子reducer对象集合。</li>\n<li>可以通过import * as reducers来获取 </li>\n<li>tips：<br>reducer应该对default情况也进行处理， 当state是undefined或者未定义的action时，也不能返回undefined。<br>返回的是一个总reducer，可以调用每个传入方法，并且分别传入相应的state属性。  <h4 id=\"遍历reducers\"><a href=\"#遍历reducers\" class=\"headerlink\" title=\"遍历reducers\"></a>遍历reducers</h4>既然是个对象集合，肯定要遍历对象，所以前几步就是这么个操作。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取reducer key  目的在于每个子方法处理对应key的state</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> reducerKeys = <span class=\"built_in\">Object</span>.keys(reducers)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> finalReducers = &#123;&#125;</span><br><span class=\"line\">  <span class=\"comment\">// 遍历 构造finalReducers即总的reducer</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; reducerKeys.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> key = reducerKeys[i]</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducers[key] === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      finalReducers[key] = reducers[key]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"comment\">//获取finalReducers 供下面遍历调用  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> finalReducerKeys = <span class=\"built_in\">Object</span>.keys(finalReducers)</span><br></pre></td></tr></table></figure>\n<p>然后是规范校验，作为一个框架这是必须的，可以略过  </p>\n<h4 id=\"combination\"><a href=\"#combination\" class=\"headerlink\" title=\"combination\"></a>combination</h4><p>返回一个function  </p>\n<ul>\n<li><p>当action被dispatch进来时，该方法主要是分发不同state到对应reducer处理，并返回最新state  </p>\n</li>\n<li><p>先是标识变量：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// state改变与否的flag </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> hasChanged = <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> nextState = &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>进行遍历finalReducers<br> 保存原来的previousStateForKey  </p>\n</li>\n<li><p>然后分发对应属性给相应reducer进行处理获取nextStateForKey  </p>\n<p>先对nextStateForKey 做个校验，因为reducer要求做兼容的，所以不允许undefined的出现，出现就抛错。    </p>\n<p>正常的话就nextStateForKey把赋给nextState对应的key  </p>\n</li>\n<li><p>前后两个state做个比较看是否相等，相等的话hasChanged置为true<br>遍历结束之后就获得了一个新的state即nextState</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">var</span> key = finalReducerKeys[i]</span><br><span class=\"line\">      <span class=\"keyword\">var</span> reducer = finalReducers[key]</span><br><span class=\"line\">      <span class=\"comment\">// 获取对应key的state属性</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> previousStateForKey = state[key]</span><br><span class=\"line\">      <span class=\"comment\">// 目的之一，只处理对应key数据</span></span><br><span class=\"line\">      <span class=\"keyword\">var</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class=\"line\">      <span class=\"comment\">// 不能返回undefined，否则抛错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextStateForKey === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">         <span class=\"comment\">//.....</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 新状态赋给 nextState对象</span></span><br><span class=\"line\">      nextState[key] = nextStateForKey</span><br><span class=\"line\">      <span class=\"comment\">// 是否改变处理 </span></span><br><span class=\"line\">      hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>根据hasChanged来决定返回新旧state。 </p>\n<pre><code class=\"js\"><span class=\"comment\">// 视情况返回state</span>\n    <span class=\"keyword\">return</span> hasChanged ? nextState : state\n</code></pre>\n<p>到这里combineReducers就结束了。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>这次先分享一半，还是有点多的，剩下的下次再记录一下。抛砖引玉，提升自己，共同学习吧。<a href=\"https://github.com/xiaoxiangdaiyu/blog\" target=\"_blank\" rel=\"noopener\">更多请移步博客</a></p>\n<h4 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h4><p><a href=\"http://www.redux.org.cn/\" target=\"_blank\" rel=\"noopener\">Redux 中文文档</a></p>"},{"title":"webpack优化之code splitting","date":"2018-01-26T02:55:57.000Z","_content":"作为当前风头正盛的打包工具，webpack风靡前端界。确实作为引领了一个时代的打包工具，很多方面都带来了颠覆性的改进，让我们更加的感受到自动化的快感。不过最为大家诟病的一点就是用起来太难了。  \n<!-- more -->\n要想愉快的使用，要使用n多的配置项，究其原因在于文档的不够详细、本身默认集成的不足。  \n也不能说这是缺点吧，更多的主动权放给用户就意味着配置工作量的增加，这里就不过多探讨了。  \n当历尽千辛万苦，你的项目跑起来之后，可能会发现有一些不太美好的问题的出现，编译慢、打包文件大等。那么，我们还要花些时间来看看怎么优化相关配置了。 下面一起看下code splitting \n## code splitting出现的背景 \n对于前端资源来说，文件体积过大是很影响性能的一项。特别是对于移动端的设备而言简直是灾难。   \n此外对于某些只要特定环境下才需要的代码，一开始就加载进来显然也不那么合理，这就引出了按需加载的概念了。\n   \n   为了解决这些情况，代码拆分就应运而生了。代码拆分故名思意就是将大的文件按不同粒度拆分，以满足解决生成文件体积过大、按需加载等需求。  \n   具体到webpack而言有下面几种方式来达到我们的目的。\n## webpack实现代码拆分的方式   \nwebpack通过下面三种方式来达到以上目的\n1. Entry Points: 多入口分开打包\n2. Prevent Duplication:去重，抽离公共模块和第三方库\n3. Dynamic Imports:动态加载 \n这里不去扒文档上的定义了，我们从一个例子中来逐步体会他们不同的作用。\n\n假设我们有这么个项目，有下面几个文件\n![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd777da3adc1?w=738&h=254&f=jpeg&s=19970)  \n\n代码很简单(示例而已，直接用commonjs的语法来写了):  \n\n```js\n//a.js\nvar react = require('react')\nvar tool = require('./tool')\nvar b = require('./b')\nfunction load(){\n    b()\n    tool()\n    console.log('全部文件都从一个入口打包')\n}\nload()\n//b.js\nvar react = require('react')\nvar tool = require('./tool')\nfunction b(){\n    tool()\n    console.log('这是bjs文件')\n}\nmodule.exports = b;\n//tool.js\nvar react = require('react')\nfunction tool(){\n    console.log('这是tooljs文件')\n}\nmodule.exports = tool;\n```  \n\n配置很简单:\n\n```js\nvar webpack = require('webpack');module.exports = {\n    entry: './codesplitting/c1/a.js',\n    output: {\n        path: __dirname,\n        filename: '/dist/index.js'\n    }\n    //*****\n}\n```\n直接打包：可以看到文件大小有2047行,体积也变大了\n![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd777e941ac1?w=1280&h=402&f=png&s=119875)  \n\n目前只引入了react，并且业务代码几乎没有的情况下。大家可以猜到实际项目中的情况了。来让我们进行第一优化  \n### Entry Points\n\n如果业务中的项目不是单页面应用，这一步可以忽略了，直接是多入口打包。这里是为了演示效果，强行分一个模块出来打包，假设我们的文件也很大，需要将b.js单独打个包出来:\n\n```js\n    entry: {\n        index:'./codesplitting/c1/a.js',\n        other:'./codesplitting/c1/b.js'\n    },\n    output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: '[name].js'\n    }，\n    //***\n```\n这里a.js也需要修改,去掉对b的引用。入口文件之间不能相互引用的。不然，问题就大了，到底以谁为主呢，这样就陷入了循环引用的问题。\n此时的生成文件如下:\n![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd77812b0d89?w=1170&h=342&f=png&s=129329)  \n看来文件竟然只小了那么一点了吧？第一步的优化这里就完成了，显然你会认为我在开玩笑。  \n当然这只是万里长征第一步，看一下dist下的文件不难发现两个文件中都把react这个第三方库和tool.js这个可复用模块打进去了，显然这样重复打包有点没必要。  \n是不是可以把这些复用性强的模块拿出来单独打包呢？  \n这样浏览器第一次请求之后就会将该文件缓存起来，从服务端请求的只有体积缩小之后的业务文件了，这样的话加载速度显然会有所提升。  \n如果你也是这么想的，来一起继续看下去。\n\n### Prevent Duplication  \nwebpack去除重复引用是通过[CommonsChunkPlugin](https://webpack.js.org/plugins/commons-chunk-plugin/)插件来实现的。该插件的配置项如下：\n\n```js\n{\n    //被抽离为公共文件的chunk名，例如common,可以是string或者数组\n    //显然如果是单个的模块，就是name多个就是names\n    name:string,\n    names:[],\n    //打包之后公共模块的名称模板\n    //例如'[name].js'\n    //如果省略，则和name名称一致\n    filename:string,\n     //模块被引的最小次数，也就是说至少有几个组件引用了该模块。\n    //如果是Infinity，则表明单纯的创建，并不做任何事情\n    minChunks:2  \n}\n```\n具体在webpack中去重对于第三方库显示声明vendor，公共模块声明common的方式来处理\n\n```js\nentry: {\n        index:'./codesplitting/c1/a.js',\n        other:'./codesplitting/c1/b.js',\n        //第三方库显示声明\n        vendor:['react'],\n        //公共组件声明为common\n        common:['./codesplitting/c1/tool']\n    },\n    //***\n    plugins: [\n        new webpack.optimize.CommonsChunkPlugin({\n            names:[\"common\", \"vendor\"],\n            filename: \"[name].js\"\n        })  \n    ]\n```  \n\n打包结果如下：\n![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd7786a1c7a1?w=958&h=266&f=png&s=95165)\n\n可以看到index和other两个业务包已经很小了，react被抽离到单独的包中。  \n这样还有一个问题，对于某些代码可能只有在特定条件下才执行，或者可能就不执行。  \n我不希望在首屏就去加载它，也就是我们常说的按需加载是要怎么做呢。一起看下去。  \n### Dynamic Imports  \nwebpack建议如下两种方式使用动态加载。   \n\n1)、ECMAScript中出于提案状态的import()   \n\n2)、webpack 特定的 require.ensure   \n\n我们这里就是用第二种来看下效果(毕竟偷懒没用babel...),在ajs中动态引入di.js  \n\n```js\n    //虽然始终会加载,大家能明白就行\n    if(true){\n        require.ensure([],function(require){\n            var di = require('./di')\n        })\n    }\n    //新增动态加载的js\n    function di(){\n        tool()\n        console.log('这是动态引入的文件')\n    }\n    module.exports = di;\n```\n运行之后可以发现多了个2.2.js,打开可以发现就是我们新建的动态引入的di.js\n![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd77c0c64a7d?w=1086&h=266&f=png&s=94861)\n\n大家可能会问怎么确定就是动态引入的呢，虽然本示例只能看打包之后的例子(就不引入dev server了，毕竟是懒。。。)我们依然可以从代码里看到结果。\n首先、查看index.js文件，可以看到下面的代码：\n\n```js\n      var react = __webpack_require__(2)\n\t   var tool = __webpack_require__(1)  \n\t   /****省略8*****/\n      //虽然始终会加载\n\t    if(true){\n\t        __webpack_require__.e/* nsure */(2, function(require){\n\t            var di = __webpack_require__(13)\n\t        })\n\t    }\n```\n\n与直接require的模块不同,require.ensure被转化为了 __webpack_require__.e方法，来继续看一下该方法有什么用。\n\n```js  \n   \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n\t\t// \"0\" is the signal for \"already loaded\"\n\t\tif(installedChunks[chunkId] === 0)\n\t\t\treturn callback.call(null, __webpack_require__);\n\n\t\t// an array means \"currently loading\".\n\t\tif(installedChunks[chunkId] !== undefined) {\n\t\t\tinstalledChunks[chunkId].push(callback);\n\t\t} else {\n\t\t\t// start chunk loading\n\t\t\tinstalledChunks[chunkId] = [callback];\n\t\t\tvar head = document.getElementsByTagName('head')[0];\n\t\t\tvar script = document.createElement('script');\n\t\t\tscript.type = 'text/javascript';\n\t\t\tscript.charset = 'utf-8';\n\t\t\tscript.async = true;\n\n\t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + ({\"0\":\"common\",\"1\":\"index\",\"3\":\"other\"}[chunkId]||chunkId) + \".js\";\n\t\t\thead.appendChild(script);\n\t\t}\n\t};\n```  \n结合注释直接从源码中可以看出来，最后面的条件语句来创建script标签进而实现动态加载的。所谓动态加载本质还是要创建script标签来实现的。\n#### 结束语\n至此代码分割部分的优化已经完成了，以上是个人关于代码分割的简单理解，抛砖引玉，共同学习进步。更多请移步[github查看](https://github.com/xiaoxiangdaiyu/webpack_demo/tree/master/codesplitting)","source":"_posts/webpack/code-splitting.md","raw":"---\ntitle: webpack优化之code splitting\ndate: 2018-01-26 10:55:57\ntags: webpack\n---\n作为当前风头正盛的打包工具，webpack风靡前端界。确实作为引领了一个时代的打包工具，很多方面都带来了颠覆性的改进，让我们更加的感受到自动化的快感。不过最为大家诟病的一点就是用起来太难了。  \n<!-- more -->\n要想愉快的使用，要使用n多的配置项，究其原因在于文档的不够详细、本身默认集成的不足。  \n也不能说这是缺点吧，更多的主动权放给用户就意味着配置工作量的增加，这里就不过多探讨了。  \n当历尽千辛万苦，你的项目跑起来之后，可能会发现有一些不太美好的问题的出现，编译慢、打包文件大等。那么，我们还要花些时间来看看怎么优化相关配置了。 下面一起看下code splitting \n## code splitting出现的背景 \n对于前端资源来说，文件体积过大是很影响性能的一项。特别是对于移动端的设备而言简直是灾难。   \n此外对于某些只要特定环境下才需要的代码，一开始就加载进来显然也不那么合理，这就引出了按需加载的概念了。\n   \n   为了解决这些情况，代码拆分就应运而生了。代码拆分故名思意就是将大的文件按不同粒度拆分，以满足解决生成文件体积过大、按需加载等需求。  \n   具体到webpack而言有下面几种方式来达到我们的目的。\n## webpack实现代码拆分的方式   \nwebpack通过下面三种方式来达到以上目的\n1. Entry Points: 多入口分开打包\n2. Prevent Duplication:去重，抽离公共模块和第三方库\n3. Dynamic Imports:动态加载 \n这里不去扒文档上的定义了，我们从一个例子中来逐步体会他们不同的作用。\n\n假设我们有这么个项目，有下面几个文件\n![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd777da3adc1?w=738&h=254&f=jpeg&s=19970)  \n\n代码很简单(示例而已，直接用commonjs的语法来写了):  \n\n```js\n//a.js\nvar react = require('react')\nvar tool = require('./tool')\nvar b = require('./b')\nfunction load(){\n    b()\n    tool()\n    console.log('全部文件都从一个入口打包')\n}\nload()\n//b.js\nvar react = require('react')\nvar tool = require('./tool')\nfunction b(){\n    tool()\n    console.log('这是bjs文件')\n}\nmodule.exports = b;\n//tool.js\nvar react = require('react')\nfunction tool(){\n    console.log('这是tooljs文件')\n}\nmodule.exports = tool;\n```  \n\n配置很简单:\n\n```js\nvar webpack = require('webpack');module.exports = {\n    entry: './codesplitting/c1/a.js',\n    output: {\n        path: __dirname,\n        filename: '/dist/index.js'\n    }\n    //*****\n}\n```\n直接打包：可以看到文件大小有2047行,体积也变大了\n![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd777e941ac1?w=1280&h=402&f=png&s=119875)  \n\n目前只引入了react，并且业务代码几乎没有的情况下。大家可以猜到实际项目中的情况了。来让我们进行第一优化  \n### Entry Points\n\n如果业务中的项目不是单页面应用，这一步可以忽略了，直接是多入口打包。这里是为了演示效果，强行分一个模块出来打包，假设我们的文件也很大，需要将b.js单独打个包出来:\n\n```js\n    entry: {\n        index:'./codesplitting/c1/a.js',\n        other:'./codesplitting/c1/b.js'\n    },\n    output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: '[name].js'\n    }，\n    //***\n```\n这里a.js也需要修改,去掉对b的引用。入口文件之间不能相互引用的。不然，问题就大了，到底以谁为主呢，这样就陷入了循环引用的问题。\n此时的生成文件如下:\n![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd77812b0d89?w=1170&h=342&f=png&s=129329)  \n看来文件竟然只小了那么一点了吧？第一步的优化这里就完成了，显然你会认为我在开玩笑。  \n当然这只是万里长征第一步，看一下dist下的文件不难发现两个文件中都把react这个第三方库和tool.js这个可复用模块打进去了，显然这样重复打包有点没必要。  \n是不是可以把这些复用性强的模块拿出来单独打包呢？  \n这样浏览器第一次请求之后就会将该文件缓存起来，从服务端请求的只有体积缩小之后的业务文件了，这样的话加载速度显然会有所提升。  \n如果你也是这么想的，来一起继续看下去。\n\n### Prevent Duplication  \nwebpack去除重复引用是通过[CommonsChunkPlugin](https://webpack.js.org/plugins/commons-chunk-plugin/)插件来实现的。该插件的配置项如下：\n\n```js\n{\n    //被抽离为公共文件的chunk名，例如common,可以是string或者数组\n    //显然如果是单个的模块，就是name多个就是names\n    name:string,\n    names:[],\n    //打包之后公共模块的名称模板\n    //例如'[name].js'\n    //如果省略，则和name名称一致\n    filename:string,\n     //模块被引的最小次数，也就是说至少有几个组件引用了该模块。\n    //如果是Infinity，则表明单纯的创建，并不做任何事情\n    minChunks:2  \n}\n```\n具体在webpack中去重对于第三方库显示声明vendor，公共模块声明common的方式来处理\n\n```js\nentry: {\n        index:'./codesplitting/c1/a.js',\n        other:'./codesplitting/c1/b.js',\n        //第三方库显示声明\n        vendor:['react'],\n        //公共组件声明为common\n        common:['./codesplitting/c1/tool']\n    },\n    //***\n    plugins: [\n        new webpack.optimize.CommonsChunkPlugin({\n            names:[\"common\", \"vendor\"],\n            filename: \"[name].js\"\n        })  \n    ]\n```  \n\n打包结果如下：\n![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd7786a1c7a1?w=958&h=266&f=png&s=95165)\n\n可以看到index和other两个业务包已经很小了，react被抽离到单独的包中。  \n这样还有一个问题，对于某些代码可能只有在特定条件下才执行，或者可能就不执行。  \n我不希望在首屏就去加载它，也就是我们常说的按需加载是要怎么做呢。一起看下去。  \n### Dynamic Imports  \nwebpack建议如下两种方式使用动态加载。   \n\n1)、ECMAScript中出于提案状态的import()   \n\n2)、webpack 特定的 require.ensure   \n\n我们这里就是用第二种来看下效果(毕竟偷懒没用babel...),在ajs中动态引入di.js  \n\n```js\n    //虽然始终会加载,大家能明白就行\n    if(true){\n        require.ensure([],function(require){\n            var di = require('./di')\n        })\n    }\n    //新增动态加载的js\n    function di(){\n        tool()\n        console.log('这是动态引入的文件')\n    }\n    module.exports = di;\n```\n运行之后可以发现多了个2.2.js,打开可以发现就是我们新建的动态引入的di.js\n![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd77c0c64a7d?w=1086&h=266&f=png&s=94861)\n\n大家可能会问怎么确定就是动态引入的呢，虽然本示例只能看打包之后的例子(就不引入dev server了，毕竟是懒。。。)我们依然可以从代码里看到结果。\n首先、查看index.js文件，可以看到下面的代码：\n\n```js\n      var react = __webpack_require__(2)\n\t   var tool = __webpack_require__(1)  \n\t   /****省略8*****/\n      //虽然始终会加载\n\t    if(true){\n\t        __webpack_require__.e/* nsure */(2, function(require){\n\t            var di = __webpack_require__(13)\n\t        })\n\t    }\n```\n\n与直接require的模块不同,require.ensure被转化为了 __webpack_require__.e方法，来继续看一下该方法有什么用。\n\n```js  \n   \t__webpack_require__.e = function requireEnsure(chunkId, callback) {\n\t\t// \"0\" is the signal for \"already loaded\"\n\t\tif(installedChunks[chunkId] === 0)\n\t\t\treturn callback.call(null, __webpack_require__);\n\n\t\t// an array means \"currently loading\".\n\t\tif(installedChunks[chunkId] !== undefined) {\n\t\t\tinstalledChunks[chunkId].push(callback);\n\t\t} else {\n\t\t\t// start chunk loading\n\t\t\tinstalledChunks[chunkId] = [callback];\n\t\t\tvar head = document.getElementsByTagName('head')[0];\n\t\t\tvar script = document.createElement('script');\n\t\t\tscript.type = 'text/javascript';\n\t\t\tscript.charset = 'utf-8';\n\t\t\tscript.async = true;\n\n\t\t\tscript.src = __webpack_require__.p + \"\" + chunkId + \".\" + ({\"0\":\"common\",\"1\":\"index\",\"3\":\"other\"}[chunkId]||chunkId) + \".js\";\n\t\t\thead.appendChild(script);\n\t\t}\n\t};\n```  \n结合注释直接从源码中可以看出来，最后面的条件语句来创建script标签进而实现动态加载的。所谓动态加载本质还是要创建script标签来实现的。\n#### 结束语\n至此代码分割部分的优化已经完成了，以上是个人关于代码分割的简单理解，抛砖引玉，共同学习进步。更多请移步[github查看](https://github.com/xiaoxiangdaiyu/webpack_demo/tree/master/codesplitting)","slug":"webpack/code-splitting","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt7v001dgw929xvckk02","content":"<p>作为当前风头正盛的打包工具，webpack风靡前端界。确实作为引领了一个时代的打包工具，很多方面都带来了颠覆性的改进，让我们更加的感受到自动化的快感。不过最为大家诟病的一点就是用起来太难了。<br><a id=\"more\"></a><br>要想愉快的使用，要使用n多的配置项，究其原因在于文档的不够详细、本身默认集成的不足。<br>也不能说这是缺点吧，更多的主动权放给用户就意味着配置工作量的增加，这里就不过多探讨了。<br>当历尽千辛万苦，你的项目跑起来之后，可能会发现有一些不太美好的问题的出现，编译慢、打包文件大等。那么，我们还要花些时间来看看怎么优化相关配置了。 下面一起看下code splitting </p>\n<h2 id=\"code-splitting出现的背景\"><a href=\"#code-splitting出现的背景\" class=\"headerlink\" title=\"code splitting出现的背景\"></a>code splitting出现的背景</h2><p>对于前端资源来说，文件体积过大是很影响性能的一项。特别是对于移动端的设备而言简直是灾难。<br>此外对于某些只要特定环境下才需要的代码，一开始就加载进来显然也不那么合理，这就引出了按需加载的概念了。</p>\n<p>   为了解决这些情况，代码拆分就应运而生了。代码拆分故名思意就是将大的文件按不同粒度拆分，以满足解决生成文件体积过大、按需加载等需求。<br>   具体到webpack而言有下面几种方式来达到我们的目的。</p>\n<h2 id=\"webpack实现代码拆分的方式\"><a href=\"#webpack实现代码拆分的方式\" class=\"headerlink\" title=\"webpack实现代码拆分的方式\"></a>webpack实现代码拆分的方式</h2><p>webpack通过下面三种方式来达到以上目的</p>\n<ol>\n<li>Entry Points: 多入口分开打包</li>\n<li>Prevent Duplication:去重，抽离公共模块和第三方库</li>\n<li>Dynamic Imports:动态加载<br>这里不去扒文档上的定义了，我们从一个例子中来逐步体会他们不同的作用。</li>\n</ol>\n<p>假设我们有这么个项目，有下面几个文件<br><img src=\"https://user-gold-cdn.xitu.io/2018/1/25/1612dd777da3adc1?w=738&amp;h=254&amp;f=jpeg&amp;s=19970\" alt=\"\">  </p>\n<p>代码很简单(示例而已，直接用commonjs的语法来写了):  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//a.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> react = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> tool = <span class=\"built_in\">require</span>(<span class=\"string\">'./tool'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    b()</span><br><span class=\"line\">    tool()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'全部文件都从一个入口打包'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">load()</span><br><span class=\"line\"><span class=\"comment\">//b.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> react = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> tool = <span class=\"built_in\">require</span>(<span class=\"string\">'./tool'</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    tool()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这是bjs文件'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = b;</span><br><span class=\"line\"><span class=\"comment\">//tool.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> react = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tool</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这是tooljs文件'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = tool;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">配置很简单:</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);<span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: <span class=\"string\">'./codesplitting/c1/a.js'</span>,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: __dirname,</span><br><span class=\"line\">        filename: <span class=\"string\">'/dist/index.js'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//*****</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接打包：可以看到文件大小有2047行,体积也变大了<br><img src=\"https://user-gold-cdn.xitu.io/2018/1/25/1612dd777e941ac1?w=1280&amp;h=402&amp;f=png&amp;s=119875\" alt=\"\">  </p>\n<p>目前只引入了react，并且业务代码几乎没有的情况下。大家可以猜到实际项目中的情况了。来让我们进行第一优化  </p>\n<h3 id=\"Entry-Points\"><a href=\"#Entry-Points\" class=\"headerlink\" title=\"Entry Points\"></a>Entry Points</h3><p>如果业务中的项目不是单页面应用，这一步可以忽略了，直接是多入口打包。这里是为了演示效果，强行分一个模块出来打包，假设我们的文件也很大，需要将b.js单独打个包出来:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    index:<span class=\"string\">'./codesplitting/c1/a.js'</span>,</span><br><span class=\"line\">    other:<span class=\"string\">'./codesplitting/c1/b.js'</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'./dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"><span class=\"comment\">//***</span></span><br></pre></td></tr></table></figure>\n<p>这里a.js也需要修改,去掉对b的引用。入口文件之间不能相互引用的。不然，问题就大了，到底以谁为主呢，这样就陷入了循环引用的问题。<br>此时的生成文件如下:<br><img src=\"https://user-gold-cdn.xitu.io/2018/1/25/1612dd77812b0d89?w=1170&amp;h=342&amp;f=png&amp;s=129329\" alt=\"\"><br>看来文件竟然只小了那么一点了吧？第一步的优化这里就完成了，显然你会认为我在开玩笑。<br>当然这只是万里长征第一步，看一下dist下的文件不难发现两个文件中都把react这个第三方库和tool.js这个可复用模块打进去了，显然这样重复打包有点没必要。<br>是不是可以把这些复用性强的模块拿出来单独打包呢？<br>这样浏览器第一次请求之后就会将该文件缓存起来，从服务端请求的只有体积缩小之后的业务文件了，这样的话加载速度显然会有所提升。<br>如果你也是这么想的，来一起继续看下去。</p>\n<h3 id=\"Prevent-Duplication\"><a href=\"#Prevent-Duplication\" class=\"headerlink\" title=\"Prevent Duplication\"></a>Prevent Duplication</h3><p>webpack去除重复引用是通过<a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"noopener\">CommonsChunkPlugin</a>插件来实现的。该插件的配置项如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//被抽离为公共文件的chunk名，例如common,可以是string或者数组</span></span><br><span class=\"line\">    <span class=\"comment\">//显然如果是单个的模块，就是name多个就是names</span></span><br><span class=\"line\">    name:string,</span><br><span class=\"line\">    names:[],</span><br><span class=\"line\">    <span class=\"comment\">//打包之后公共模块的名称模板</span></span><br><span class=\"line\">    <span class=\"comment\">//例如'[name].js'</span></span><br><span class=\"line\">    <span class=\"comment\">//如果省略，则和name名称一致</span></span><br><span class=\"line\">    filename:string,</span><br><span class=\"line\">     <span class=\"comment\">//模块被引的最小次数，也就是说至少有几个组件引用了该模块。</span></span><br><span class=\"line\">    <span class=\"comment\">//如果是Infinity，则表明单纯的创建，并不做任何事情</span></span><br><span class=\"line\">    minChunks:<span class=\"number\">2</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体在webpack中去重对于第三方库显示声明vendor，公共模块声明common的方式来处理</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">        index:<span class=\"string\">'./codesplitting/c1/a.js'</span>,</span><br><span class=\"line\">        other:<span class=\"string\">'./codesplitting/c1/b.js'</span>,</span><br><span class=\"line\">        <span class=\"comment\">//第三方库显示声明</span></span><br><span class=\"line\">        vendor:[<span class=\"string\">'react'</span>],</span><br><span class=\"line\">        <span class=\"comment\">//公共组件声明为common</span></span><br><span class=\"line\">        common:[<span class=\"string\">'./codesplitting/c1/tool'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//***</span></span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">            names:[<span class=\"string\">\"common\"</span>, <span class=\"string\">\"vendor\"</span>],</span><br><span class=\"line\">            filename: <span class=\"string\">\"[name].js\"</span></span><br><span class=\"line\">        &#125;)  </span><br><span class=\"line\">    ]</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">打包结果如下：</span></span><br><span class=\"line\"><span class=\"string\">![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd7786a1c7a1?w=958&amp;h=266&amp;f=png&amp;s=95165)</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">可以看到index和other两个业务包已经很小了，react被抽离到单独的包中。  </span></span><br><span class=\"line\"><span class=\"string\">这样还有一个问题，对于某些代码可能只有在特定条件下才执行，或者可能就不执行。  </span></span><br><span class=\"line\"><span class=\"string\">我不希望在首屏就去加载它，也就是我们常说的按需加载是要怎么做呢。一起看下去。  </span></span><br><span class=\"line\"><span class=\"string\">### Dynamic Imports  </span></span><br><span class=\"line\"><span class=\"string\">webpack建议如下两种方式使用动态加载。   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1)、ECMAScript中出于提案状态的import()   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2)、webpack 特定的 require.ensure   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">我们这里就是用第二种来看下效果(毕竟偷懒没用babel...),在ajs中动态引入di.js  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">    <span class=\"comment\">//虽然始终会加载,大家能明白就行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">require</span>.ensure([],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> di = <span class=\"built_in\">require</span>(<span class=\"string\">'./di'</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//新增动态加载的js</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">di</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        tool()</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'这是动态引入的文件'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = di;</span><br></pre></td></tr></table></figure>\n<p>运行之后可以发现多了个2.2.js,打开可以发现就是我们新建的动态引入的di.js<br><img src=\"https://user-gold-cdn.xitu.io/2018/1/25/1612dd77c0c64a7d?w=1086&amp;h=266&amp;f=png&amp;s=94861\" alt=\"\"></p>\n<p>大家可能会问怎么确定就是动态引入的呢，虽然本示例只能看打包之后的例子(就不引入dev server了，毕竟是懒。。。)我们依然可以从代码里看到结果。<br>首先、查看index.js文件，可以看到下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">var</span> react = __webpack_require__(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> tool = __webpack_require__(<span class=\"number\">1</span>)  </span><br><span class=\"line\"><span class=\"comment\">/****省略8*****/</span></span><br><span class=\"line\">  <span class=\"comment\">//虽然始终会加载</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">     __webpack_require__.e<span class=\"comment\">/* nsure */</span>(<span class=\"number\">2</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> di = __webpack_require__(<span class=\"number\">13</span>)</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>与直接require的模块不同,require.ensure被转化为了 <strong>webpack_require</strong>.e方法，来继续看一下该方法有什么用。</p>\n<pre><code class=\"js\">   __webpack_require__.e = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">requireEnsure</span>(<span class=\"params\">chunkId, callback</span>) </span>{\n    <span class=\"comment\">// \"0\" is the signal for \"already loaded\"</span>\n    <span class=\"keyword\">if</span>(installedChunks[chunkId] === <span class=\"number\">0</span>)\n        <span class=\"keyword\">return</span> callback.call(<span class=\"literal\">null</span>, __webpack_require__);\n\n    <span class=\"comment\">// an array means \"currently loading\".</span>\n    <span class=\"keyword\">if</span>(installedChunks[chunkId] !== <span class=\"literal\">undefined</span>) {\n        installedChunks[chunkId].push(callback);\n    } <span class=\"keyword\">else</span> {\n        <span class=\"comment\">// start chunk loading</span>\n        installedChunks[chunkId] = [callback];\n        <span class=\"keyword\">var</span> head = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>];\n        <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);\n        script.type = <span class=\"string\">'text/javascript'</span>;\n        script.charset = <span class=\"string\">'utf-8'</span>;\n        script.async = <span class=\"literal\">true</span>;\n\n        script.src = __webpack_require__.p + <span class=\"string\">\"\"</span> + chunkId + <span class=\"string\">\".\"</span> + ({<span class=\"string\">\"0\"</span>:<span class=\"string\">\"common\"</span>,<span class=\"string\">\"1\"</span>:<span class=\"string\">\"index\"</span>,<span class=\"string\">\"3\"</span>:<span class=\"string\">\"other\"</span>}[chunkId]||chunkId) + <span class=\"string\">\".js\"</span>;\n        head.appendChild(script);\n    }\n};\n</code></pre>\n<p>结合注释直接从源码中可以看出来，最后面的条件语句来创建script标签进而实现动态加载的。所谓动态加载本质还是要创建script标签来实现的。</p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>至此代码分割部分的优化已经完成了，以上是个人关于代码分割的简单理解，抛砖引玉，共同学习进步。更多请移步<a href=\"https://github.com/xiaoxiangdaiyu/webpack_demo/tree/master/codesplitting\" target=\"_blank\" rel=\"noopener\">github查看</a></p>\n","site":{"data":{}},"excerpt":"<p>作为当前风头正盛的打包工具，webpack风靡前端界。确实作为引领了一个时代的打包工具，很多方面都带来了颠覆性的改进，让我们更加的感受到自动化的快感。不过最为大家诟病的一点就是用起来太难了。<br>","more":"<br>要想愉快的使用，要使用n多的配置项，究其原因在于文档的不够详细、本身默认集成的不足。<br>也不能说这是缺点吧，更多的主动权放给用户就意味着配置工作量的增加，这里就不过多探讨了。<br>当历尽千辛万苦，你的项目跑起来之后，可能会发现有一些不太美好的问题的出现，编译慢、打包文件大等。那么，我们还要花些时间来看看怎么优化相关配置了。 下面一起看下code splitting </p>\n<h2 id=\"code-splitting出现的背景\"><a href=\"#code-splitting出现的背景\" class=\"headerlink\" title=\"code splitting出现的背景\"></a>code splitting出现的背景</h2><p>对于前端资源来说，文件体积过大是很影响性能的一项。特别是对于移动端的设备而言简直是灾难。<br>此外对于某些只要特定环境下才需要的代码，一开始就加载进来显然也不那么合理，这就引出了按需加载的概念了。</p>\n<p>   为了解决这些情况，代码拆分就应运而生了。代码拆分故名思意就是将大的文件按不同粒度拆分，以满足解决生成文件体积过大、按需加载等需求。<br>   具体到webpack而言有下面几种方式来达到我们的目的。</p>\n<h2 id=\"webpack实现代码拆分的方式\"><a href=\"#webpack实现代码拆分的方式\" class=\"headerlink\" title=\"webpack实现代码拆分的方式\"></a>webpack实现代码拆分的方式</h2><p>webpack通过下面三种方式来达到以上目的</p>\n<ol>\n<li>Entry Points: 多入口分开打包</li>\n<li>Prevent Duplication:去重，抽离公共模块和第三方库</li>\n<li>Dynamic Imports:动态加载<br>这里不去扒文档上的定义了，我们从一个例子中来逐步体会他们不同的作用。</li>\n</ol>\n<p>假设我们有这么个项目，有下面几个文件<br><img src=\"https://user-gold-cdn.xitu.io/2018/1/25/1612dd777da3adc1?w=738&amp;h=254&amp;f=jpeg&amp;s=19970\" alt=\"\">  </p>\n<p>代码很简单(示例而已，直接用commonjs的语法来写了):  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//a.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> react = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> tool = <span class=\"built_in\">require</span>(<span class=\"string\">'./tool'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">require</span>(<span class=\"string\">'./b'</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">load</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    b()</span><br><span class=\"line\">    tool()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'全部文件都从一个入口打包'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">load()</span><br><span class=\"line\"><span class=\"comment\">//b.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> react = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> tool = <span class=\"built_in\">require</span>(<span class=\"string\">'./tool'</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    tool()</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这是bjs文件'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = b;</span><br><span class=\"line\"><span class=\"comment\">//tool.js</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> react = <span class=\"built_in\">require</span>(<span class=\"string\">'react'</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tool</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'这是tooljs文件'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = tool;</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">配置很简单:</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">var</span> webpack = <span class=\"built_in\">require</span>(<span class=\"string\">'webpack'</span>);<span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">    entry: <span class=\"string\">'./codesplitting/c1/a.js'</span>,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">        path: __dirname,</span><br><span class=\"line\">        filename: <span class=\"string\">'/dist/index.js'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//*****</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>直接打包：可以看到文件大小有2047行,体积也变大了<br><img src=\"https://user-gold-cdn.xitu.io/2018/1/25/1612dd777e941ac1?w=1280&amp;h=402&amp;f=png&amp;s=119875\" alt=\"\">  </p>\n<p>目前只引入了react，并且业务代码几乎没有的情况下。大家可以猜到实际项目中的情况了。来让我们进行第一优化  </p>\n<h3 id=\"Entry-Points\"><a href=\"#Entry-Points\" class=\"headerlink\" title=\"Entry Points\"></a>Entry Points</h3><p>如果业务中的项目不是单页面应用，这一步可以忽略了，直接是多入口打包。这里是为了演示效果，强行分一个模块出来打包，假设我们的文件也很大，需要将b.js单独打个包出来:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">    index:<span class=\"string\">'./codesplitting/c1/a.js'</span>,</span><br><span class=\"line\">    other:<span class=\"string\">'./codesplitting/c1/b.js'</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">output: &#123;</span><br><span class=\"line\">    path: path.resolve(__dirname, <span class=\"string\">'./dist'</span>),</span><br><span class=\"line\">    filename: <span class=\"string\">'[name].js'</span></span><br><span class=\"line\">&#125;，</span><br><span class=\"line\"><span class=\"comment\">//***</span></span><br></pre></td></tr></table></figure>\n<p>这里a.js也需要修改,去掉对b的引用。入口文件之间不能相互引用的。不然，问题就大了，到底以谁为主呢，这样就陷入了循环引用的问题。<br>此时的生成文件如下:<br><img src=\"https://user-gold-cdn.xitu.io/2018/1/25/1612dd77812b0d89?w=1170&amp;h=342&amp;f=png&amp;s=129329\" alt=\"\"><br>看来文件竟然只小了那么一点了吧？第一步的优化这里就完成了，显然你会认为我在开玩笑。<br>当然这只是万里长征第一步，看一下dist下的文件不难发现两个文件中都把react这个第三方库和tool.js这个可复用模块打进去了，显然这样重复打包有点没必要。<br>是不是可以把这些复用性强的模块拿出来单独打包呢？<br>这样浏览器第一次请求之后就会将该文件缓存起来，从服务端请求的只有体积缩小之后的业务文件了，这样的话加载速度显然会有所提升。<br>如果你也是这么想的，来一起继续看下去。</p>\n<h3 id=\"Prevent-Duplication\"><a href=\"#Prevent-Duplication\" class=\"headerlink\" title=\"Prevent Duplication\"></a>Prevent Duplication</h3><p>webpack去除重复引用是通过<a href=\"https://webpack.js.org/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"noopener\">CommonsChunkPlugin</a>插件来实现的。该插件的配置项如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//被抽离为公共文件的chunk名，例如common,可以是string或者数组</span></span><br><span class=\"line\">    <span class=\"comment\">//显然如果是单个的模块，就是name多个就是names</span></span><br><span class=\"line\">    name:string,</span><br><span class=\"line\">    names:[],</span><br><span class=\"line\">    <span class=\"comment\">//打包之后公共模块的名称模板</span></span><br><span class=\"line\">    <span class=\"comment\">//例如'[name].js'</span></span><br><span class=\"line\">    <span class=\"comment\">//如果省略，则和name名称一致</span></span><br><span class=\"line\">    filename:string,</span><br><span class=\"line\">     <span class=\"comment\">//模块被引的最小次数，也就是说至少有几个组件引用了该模块。</span></span><br><span class=\"line\">    <span class=\"comment\">//如果是Infinity，则表明单纯的创建，并不做任何事情</span></span><br><span class=\"line\">    minChunks:<span class=\"number\">2</span>  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>具体在webpack中去重对于第三方库显示声明vendor，公共模块声明common的方式来处理</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">entry: &#123;</span><br><span class=\"line\">        index:<span class=\"string\">'./codesplitting/c1/a.js'</span>,</span><br><span class=\"line\">        other:<span class=\"string\">'./codesplitting/c1/b.js'</span>,</span><br><span class=\"line\">        <span class=\"comment\">//第三方库显示声明</span></span><br><span class=\"line\">        vendor:[<span class=\"string\">'react'</span>],</span><br><span class=\"line\">        <span class=\"comment\">//公共组件声明为common</span></span><br><span class=\"line\">        common:[<span class=\"string\">'./codesplitting/c1/tool'</span>]</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">//***</span></span><br><span class=\"line\">    plugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">            names:[<span class=\"string\">\"common\"</span>, <span class=\"string\">\"vendor\"</span>],</span><br><span class=\"line\">            filename: <span class=\"string\">\"[name].js\"</span></span><br><span class=\"line\">        &#125;)  </span><br><span class=\"line\">    ]</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">打包结果如下：</span></span><br><span class=\"line\"><span class=\"string\">![](https://user-gold-cdn.xitu.io/2018/1/25/1612dd7786a1c7a1?w=958&amp;h=266&amp;f=png&amp;s=95165)</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">可以看到index和other两个业务包已经很小了，react被抽离到单独的包中。  </span></span><br><span class=\"line\"><span class=\"string\">这样还有一个问题，对于某些代码可能只有在特定条件下才执行，或者可能就不执行。  </span></span><br><span class=\"line\"><span class=\"string\">我不希望在首屏就去加载它，也就是我们常说的按需加载是要怎么做呢。一起看下去。  </span></span><br><span class=\"line\"><span class=\"string\">### Dynamic Imports  </span></span><br><span class=\"line\"><span class=\"string\">webpack建议如下两种方式使用动态加载。   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">1)、ECMAScript中出于提案状态的import()   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">2)、webpack 特定的 require.ensure   </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">我们这里就是用第二种来看下效果(毕竟偷懒没用babel...),在ajs中动态引入di.js  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\">    <span class=\"comment\">//虽然始终会加载,大家能明白就行</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">require</span>.ensure([],<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>)</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> di = <span class=\"built_in\">require</span>(<span class=\"string\">'./di'</span>)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//新增动态加载的js</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">di</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        tool()</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'这是动态引入的文件'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = di;</span><br></pre></td></tr></table></figure>\n<p>运行之后可以发现多了个2.2.js,打开可以发现就是我们新建的动态引入的di.js<br><img src=\"https://user-gold-cdn.xitu.io/2018/1/25/1612dd77c0c64a7d?w=1086&amp;h=266&amp;f=png&amp;s=94861\" alt=\"\"></p>\n<p>大家可能会问怎么确定就是动态引入的呢，虽然本示例只能看打包之后的例子(就不引入dev server了，毕竟是懒。。。)我们依然可以从代码里看到结果。<br>首先、查看index.js文件，可以看到下面的代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">var</span> react = __webpack_require__(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> tool = __webpack_require__(<span class=\"number\">1</span>)  </span><br><span class=\"line\"><span class=\"comment\">/****省略8*****/</span></span><br><span class=\"line\">  <span class=\"comment\">//虽然始终会加载</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span>(<span class=\"literal\">true</span>)&#123;</span><br><span class=\"line\">     __webpack_require__.e<span class=\"comment\">/* nsure */</span>(<span class=\"number\">2</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require</span>)</span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">var</span> di = __webpack_require__(<span class=\"number\">13</span>)</span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>与直接require的模块不同,require.ensure被转化为了 <strong>webpack_require</strong>.e方法，来继续看一下该方法有什么用。</p>\n<pre><code class=\"js\">   __webpack_require__.e = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">requireEnsure</span>(<span class=\"params\">chunkId, callback</span>) </span>{\n    <span class=\"comment\">// \"0\" is the signal for \"already loaded\"</span>\n    <span class=\"keyword\">if</span>(installedChunks[chunkId] === <span class=\"number\">0</span>)\n        <span class=\"keyword\">return</span> callback.call(<span class=\"literal\">null</span>, __webpack_require__);\n\n    <span class=\"comment\">// an array means \"currently loading\".</span>\n    <span class=\"keyword\">if</span>(installedChunks[chunkId] !== <span class=\"literal\">undefined</span>) {\n        installedChunks[chunkId].push(callback);\n    } <span class=\"keyword\">else</span> {\n        <span class=\"comment\">// start chunk loading</span>\n        installedChunks[chunkId] = [callback];\n        <span class=\"keyword\">var</span> head = <span class=\"built_in\">document</span>.getElementsByTagName(<span class=\"string\">'head'</span>)[<span class=\"number\">0</span>];\n        <span class=\"keyword\">var</span> script = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'script'</span>);\n        script.type = <span class=\"string\">'text/javascript'</span>;\n        script.charset = <span class=\"string\">'utf-8'</span>;\n        script.async = <span class=\"literal\">true</span>;\n\n        script.src = __webpack_require__.p + <span class=\"string\">\"\"</span> + chunkId + <span class=\"string\">\".\"</span> + ({<span class=\"string\">\"0\"</span>:<span class=\"string\">\"common\"</span>,<span class=\"string\">\"1\"</span>:<span class=\"string\">\"index\"</span>,<span class=\"string\">\"3\"</span>:<span class=\"string\">\"other\"</span>}[chunkId]||chunkId) + <span class=\"string\">\".js\"</span>;\n        head.appendChild(script);\n    }\n};\n</code></pre>\n<p>结合注释直接从源码中可以看出来，最后面的条件语句来创建script标签进而实现动态加载的。所谓动态加载本质还是要创建script标签来实现的。</p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>至此代码分割部分的优化已经完成了，以上是个人关于代码分割的简单理解，抛砖引玉，共同学习进步。更多请移步<a href=\"https://github.com/xiaoxiangdaiyu/webpack_demo/tree/master/codesplitting\" target=\"_blank\" rel=\"noopener\">github查看</a></p>"},{"title":"如何开发webpack loader","date":"2017-10-13T16:00:00.000Z","_content":"## 关于webpack  \n作为近段时间风头正盛的打包工具，webpack基本占领了前端圈。相信你都不好意思说不知道webpack。  \n有兴趣的同学可以参考下我很早之前的[webpack简介](http://www.cnblogs.com/pqjwyn/p/5380689.html) .  \n确实webpack万事万物皆模块的思路真是极大的方便了我们的开发，将css，图片等文件都能打包的功能离不开形形色色的loader。  \n对于一个事情要知其然更要知其所以然，抱着这个心态我们一起来看下loader的相关知识及如何开发。   \n<!-- more -->\n#### 学习方法  \n对于一个新事物最好的学习方法，我认为是其官方文档。对于loader，将其官方文档看一遍，就知道如何开发最简单的loader了。  \n只是其[官方文档](https://webpack.js.org/contribute/writing-a-loader/)是英文的，我就顺手翻译了一下，一方面加深自己理解。另一方面为其他同学提供个参考。    \n我相信看完文档你就知道如何开发一个loader了。  \n\n## 什么是loader  \n  \nloader是一个对面暴露一个方法的node包.当遇到某些资源需要被转换时调用该方法。  \n#### 简单情况   \n\n只有一个loader来处理某个文件时，该loader被调用时只有一个参数，这个参数是该文件的内容转化之后的字符串。  \n\nloader在function执行时可以通过this context来访问laoder API 以便更高效的开发。  \n\n一个仅仅需要一个值的同步loader可以简单的return 自己。其他情况下，loader可以通过this.callback(err, values...)返回一系列的值。error同样传递给this.callback或者在loader中抛出。  \n\nloader期望返回1-2个值，第一个是处理之后作为string或者buffer返回的js代码。第二个是SourceMap或者js 对象   \n\n#### 复杂情况:    \n\n当多个loader被链式调用时，只有最后一个loader获得资源文件。  \n同时只有第一个loader被期望返回1-2个值(即上面提到的JavaScript和SourceMap)。  \n其他loader接收值由上一个loader传递。  \n\n换句话说，链式loader执行顺序从右至左或者自下而上。  \n举个栗子：下面这段代码的执行顺序就是自下而上  foo-loader==>bar-loader  \n```js\nmodule: {\n  loaders: [\n    {\n      test: /\\.js/,\n      loaders: [\n        'bar-loader',\n        'foo-loader'\n      ]\n    }\n  ]\n}\n```\n#### 注意：当前weboack只会在nodemodules文件夹下面搜索你指定的loader   \n\n如果你的文件夹不在该目录下需要在config下面增加一项配置:  \n即默认访问node_modules，你的文件夹不在的话就需要手动在配置文件里加上了。\n```js  \n    resolveLoader: {\n        modules: ['node_modules', path.resolve(__dirname, 'loaders')]\n    }\n```\n#### 温馨提示\nps：经过自身实践发现这样写是错的，不需要通过path去解析，直接将文件目录写入即可。    \n一般来说loader都会发布到npm上进行管理，这种状况不用担心，但是开发阶段如果要自行测试，就面对这种情况了。   \n例如，我手写的myloader在loaders下面，例子如下。  \n```js   \n     resolveLoader:{\n        modules: ['node_modules','loader']\n    }\n```\n## Examples     \n\n就这么简单就是个普通的loader\n```js  \n    module.exports = function(source,map){\n    this.cacheable && this.cacheable()\n    this.value = source\n    return '/*copy@ xiaoxiangdaiyu*/'+JSON.stringify(source)\n    }\n```\n## 开发指南  \n\nloader需要遵循以下事项。   \n以下事项按优先级排列，第一条具有最高优先级。   \n\n#### 一、单一任务    \n\nloaders可以被链式调用，为每一步创建一个loader而非一个loader做所有事情  \n也就是说，在非必要的状况下没有必要将他们转换为js。  \n\n例如：通过查询字符串将一个字符串模板转化为html。   \n如果你写了个loader做了所有事情那么你违背了loader的第一条要求。   \n你应该为每一个task创建一个loader并且通过管道来使用它们  \n* jade-loader: 转换模板为一个module   \n* apply-loader: 创建一个module并通过查询参数来返回结果  \n* html-loade: 创建一个处理html并返回一个string的模块   \n \n#### 二、创建moulde话的模块，即正常的模块   \n\nloader产出的module应该和遵循和普通的module一样的设计原则。  \n举个例子，下面这样设计是不好的，没有模块化，依赖全局状态  \n```js\n    require(\"any-template-language-loader!./xyz.atl\");\n    var html = anyTemplateLanguage.render(\"xyz\");\n```\n#### 三、尽量表明该loader是否可以缓存  \n\n大部分loaders是cacheable，所以应该标明是否cacheable。   \n只需要在loader里面调用即可  \n```js  \n    // Cacheable identity loader\nmodule.exports = function(source) {\n\tthis.cacheable();\n\treturn source;\n};\n```\n#### 四、不要在运行和模块之间保存状态     \n\n* 一个loader相对于其他编译后的模块应该是独立的。 除非其可以自己处理这些状态  \n* 一个loader相对于同一模块之前的编译过程应该是独立的。\n\n#### 五、标明依赖   \n\n如果该loader引用了其他资源（例如文件系统）， 必须声明它们。这些信息用来是缓存的loader失效并且重新编译它们  \n\n```js  \n    var path = require(\"path\");\n    module.exports = function(source) {\n\tthis.cacheable();\n\tvar callback = this.async();\n\tvar headerPath = path.resolve(\"header.js\");\n\tthis.addDependency(headerPath);\n\tfs.readFile(headerPath, \"utf-8\", function(err, header) {\n\t\tif(err) return callback(err);\n\t\tcallback(null, header + \"\\n\" + source);\n\t});\n};\n```\n#### 六、解析依赖  \n\n很多语言都提供了一些规范来声明依赖，例如css中的 @import 和 url(...)。这些依赖应该被模块系统所解析。  \n##### 下面是两种解决方式：\n* 1、将它们转化成require   \n* 2、 用this.resolve方法来解析路径  \n\n##### 下面是两个示例   \n\n* 1、css-loader: 将依赖转化成require，即用require来替换@import和 url(...)，解析对其他样式文件的依赖  \n* 2、less-loader: 不能像css-loader那样做，因为所有的less文件需要一起编译来解析变量和mixins。因此其通过一个公共的路径逻辑来扩展less编译过程。这个公共的逻辑使用this.resolve来解析带有module系统配置项的文件。例如aliasing, custom module directories等。  \n\n如果语言仅仅接受相对urls（如css中url(file) 总是代表./file），使用~来说明成模块依赖.  \n```js  \n    url(file) -> require(\"./file\")\n    url(~module) -> require(\"module\")\n```\n#### 七、抽离公共代码  \n\nextract common code  我感觉还是翻译成上面的标题比较好。其实所有语言都遵循该思想，即封装  \n不要写出来很多每个模块都在使用的代码，在loader中创建一个runtime文件，将公共代码放在其中\n\n#### 八、避免写入绝对路径  \n\n不要把绝对路径写入到模块代码中。它们将会破坏hash的过程当项目的根目录发生改变的时候。应该使用loader-utils的 stringifyRequest方法来绝对路径转化为相对路径。   \n例子：  \n```js  \n    var loaderUtils = require(\"loader-utils\");\n    return \"var runtime = require(\" +\n    loaderUtils.stringifyRequest(this, \"!\" + require.resolve(\"module/runtime\")) +\n  \");\";\n```\n#### 九、使用peerDependencies来指明依赖的库 \n\n使用peerDependency允许应用开发者去在package.json里说明依赖的具体版本。这些依赖应该是相对开放的允许工具库升级而不需要重新发布loader版本。简而言之，对于peerDependency依赖的库应该是松耦合的，当工具库版本变化的时候不需要重新变更loader版本。  \n\n#### 十、可编程对象作为查询项  \n\n有些情况下，loader需要某些可编程的对象但是不能作为序列化的query参数被方法解析。例如less-loader通过具体的less-plugin提供了这种可能。这种情况下，loader应该允许扩展webpack的options对象去获得具体的option。为了避免名字冲突，基于loader的命名空间来命名是很必要的。\n\n```js  \n     // webpack.config.js\n    module.exports = {\n        ...\n    lessLoader: {\n        lessPlugins: [\n        new LessPluginCleanCSS({advanced: true})\n        ]\n    }\n};\n```\n#### 结束语   \n至此，如何开发一个webpack loader 我相信大家已经知道了，如果还不太清楚的话，可以移步[w-loader](https://github.com/xiaoxiangdaiyu/w-loader)查看。   \n另外，对于我这种英语渣渣来说，翻译起来确实难度蛮大的。此处抛砖引玉，希望大家共同探讨学习。   \n","source":"_posts/webpack/loader.md","raw":"---\ntitle: 如何开发webpack loader\ndate: 2017-10-14\n---\n## 关于webpack  \n作为近段时间风头正盛的打包工具，webpack基本占领了前端圈。相信你都不好意思说不知道webpack。  \n有兴趣的同学可以参考下我很早之前的[webpack简介](http://www.cnblogs.com/pqjwyn/p/5380689.html) .  \n确实webpack万事万物皆模块的思路真是极大的方便了我们的开发，将css，图片等文件都能打包的功能离不开形形色色的loader。  \n对于一个事情要知其然更要知其所以然，抱着这个心态我们一起来看下loader的相关知识及如何开发。   \n<!-- more -->\n#### 学习方法  \n对于一个新事物最好的学习方法，我认为是其官方文档。对于loader，将其官方文档看一遍，就知道如何开发最简单的loader了。  \n只是其[官方文档](https://webpack.js.org/contribute/writing-a-loader/)是英文的，我就顺手翻译了一下，一方面加深自己理解。另一方面为其他同学提供个参考。    \n我相信看完文档你就知道如何开发一个loader了。  \n\n## 什么是loader  \n  \nloader是一个对面暴露一个方法的node包.当遇到某些资源需要被转换时调用该方法。  \n#### 简单情况   \n\n只有一个loader来处理某个文件时，该loader被调用时只有一个参数，这个参数是该文件的内容转化之后的字符串。  \n\nloader在function执行时可以通过this context来访问laoder API 以便更高效的开发。  \n\n一个仅仅需要一个值的同步loader可以简单的return 自己。其他情况下，loader可以通过this.callback(err, values...)返回一系列的值。error同样传递给this.callback或者在loader中抛出。  \n\nloader期望返回1-2个值，第一个是处理之后作为string或者buffer返回的js代码。第二个是SourceMap或者js 对象   \n\n#### 复杂情况:    \n\n当多个loader被链式调用时，只有最后一个loader获得资源文件。  \n同时只有第一个loader被期望返回1-2个值(即上面提到的JavaScript和SourceMap)。  \n其他loader接收值由上一个loader传递。  \n\n换句话说，链式loader执行顺序从右至左或者自下而上。  \n举个栗子：下面这段代码的执行顺序就是自下而上  foo-loader==>bar-loader  \n```js\nmodule: {\n  loaders: [\n    {\n      test: /\\.js/,\n      loaders: [\n        'bar-loader',\n        'foo-loader'\n      ]\n    }\n  ]\n}\n```\n#### 注意：当前weboack只会在nodemodules文件夹下面搜索你指定的loader   \n\n如果你的文件夹不在该目录下需要在config下面增加一项配置:  \n即默认访问node_modules，你的文件夹不在的话就需要手动在配置文件里加上了。\n```js  \n    resolveLoader: {\n        modules: ['node_modules', path.resolve(__dirname, 'loaders')]\n    }\n```\n#### 温馨提示\nps：经过自身实践发现这样写是错的，不需要通过path去解析，直接将文件目录写入即可。    \n一般来说loader都会发布到npm上进行管理，这种状况不用担心，但是开发阶段如果要自行测试，就面对这种情况了。   \n例如，我手写的myloader在loaders下面，例子如下。  \n```js   \n     resolveLoader:{\n        modules: ['node_modules','loader']\n    }\n```\n## Examples     \n\n就这么简单就是个普通的loader\n```js  \n    module.exports = function(source,map){\n    this.cacheable && this.cacheable()\n    this.value = source\n    return '/*copy@ xiaoxiangdaiyu*/'+JSON.stringify(source)\n    }\n```\n## 开发指南  \n\nloader需要遵循以下事项。   \n以下事项按优先级排列，第一条具有最高优先级。   \n\n#### 一、单一任务    \n\nloaders可以被链式调用，为每一步创建一个loader而非一个loader做所有事情  \n也就是说，在非必要的状况下没有必要将他们转换为js。  \n\n例如：通过查询字符串将一个字符串模板转化为html。   \n如果你写了个loader做了所有事情那么你违背了loader的第一条要求。   \n你应该为每一个task创建一个loader并且通过管道来使用它们  \n* jade-loader: 转换模板为一个module   \n* apply-loader: 创建一个module并通过查询参数来返回结果  \n* html-loade: 创建一个处理html并返回一个string的模块   \n \n#### 二、创建moulde话的模块，即正常的模块   \n\nloader产出的module应该和遵循和普通的module一样的设计原则。  \n举个例子，下面这样设计是不好的，没有模块化，依赖全局状态  \n```js\n    require(\"any-template-language-loader!./xyz.atl\");\n    var html = anyTemplateLanguage.render(\"xyz\");\n```\n#### 三、尽量表明该loader是否可以缓存  \n\n大部分loaders是cacheable，所以应该标明是否cacheable。   \n只需要在loader里面调用即可  \n```js  \n    // Cacheable identity loader\nmodule.exports = function(source) {\n\tthis.cacheable();\n\treturn source;\n};\n```\n#### 四、不要在运行和模块之间保存状态     \n\n* 一个loader相对于其他编译后的模块应该是独立的。 除非其可以自己处理这些状态  \n* 一个loader相对于同一模块之前的编译过程应该是独立的。\n\n#### 五、标明依赖   \n\n如果该loader引用了其他资源（例如文件系统）， 必须声明它们。这些信息用来是缓存的loader失效并且重新编译它们  \n\n```js  \n    var path = require(\"path\");\n    module.exports = function(source) {\n\tthis.cacheable();\n\tvar callback = this.async();\n\tvar headerPath = path.resolve(\"header.js\");\n\tthis.addDependency(headerPath);\n\tfs.readFile(headerPath, \"utf-8\", function(err, header) {\n\t\tif(err) return callback(err);\n\t\tcallback(null, header + \"\\n\" + source);\n\t});\n};\n```\n#### 六、解析依赖  \n\n很多语言都提供了一些规范来声明依赖，例如css中的 @import 和 url(...)。这些依赖应该被模块系统所解析。  \n##### 下面是两种解决方式：\n* 1、将它们转化成require   \n* 2、 用this.resolve方法来解析路径  \n\n##### 下面是两个示例   \n\n* 1、css-loader: 将依赖转化成require，即用require来替换@import和 url(...)，解析对其他样式文件的依赖  \n* 2、less-loader: 不能像css-loader那样做，因为所有的less文件需要一起编译来解析变量和mixins。因此其通过一个公共的路径逻辑来扩展less编译过程。这个公共的逻辑使用this.resolve来解析带有module系统配置项的文件。例如aliasing, custom module directories等。  \n\n如果语言仅仅接受相对urls（如css中url(file) 总是代表./file），使用~来说明成模块依赖.  \n```js  \n    url(file) -> require(\"./file\")\n    url(~module) -> require(\"module\")\n```\n#### 七、抽离公共代码  \n\nextract common code  我感觉还是翻译成上面的标题比较好。其实所有语言都遵循该思想，即封装  \n不要写出来很多每个模块都在使用的代码，在loader中创建一个runtime文件，将公共代码放在其中\n\n#### 八、避免写入绝对路径  \n\n不要把绝对路径写入到模块代码中。它们将会破坏hash的过程当项目的根目录发生改变的时候。应该使用loader-utils的 stringifyRequest方法来绝对路径转化为相对路径。   \n例子：  \n```js  \n    var loaderUtils = require(\"loader-utils\");\n    return \"var runtime = require(\" +\n    loaderUtils.stringifyRequest(this, \"!\" + require.resolve(\"module/runtime\")) +\n  \");\";\n```\n#### 九、使用peerDependencies来指明依赖的库 \n\n使用peerDependency允许应用开发者去在package.json里说明依赖的具体版本。这些依赖应该是相对开放的允许工具库升级而不需要重新发布loader版本。简而言之，对于peerDependency依赖的库应该是松耦合的，当工具库版本变化的时候不需要重新变更loader版本。  \n\n#### 十、可编程对象作为查询项  \n\n有些情况下，loader需要某些可编程的对象但是不能作为序列化的query参数被方法解析。例如less-loader通过具体的less-plugin提供了这种可能。这种情况下，loader应该允许扩展webpack的options对象去获得具体的option。为了避免名字冲突，基于loader的命名空间来命名是很必要的。\n\n```js  \n     // webpack.config.js\n    module.exports = {\n        ...\n    lessLoader: {\n        lessPlugins: [\n        new LessPluginCleanCSS({advanced: true})\n        ]\n    }\n};\n```\n#### 结束语   \n至此，如何开发一个webpack loader 我相信大家已经知道了，如果还不太清楚的话，可以移步[w-loader](https://github.com/xiaoxiangdaiyu/w-loader)查看。   \n另外，对于我这种英语渣渣来说，翻译起来确实难度蛮大的。此处抛砖引玉，希望大家共同探讨学习。   \n","slug":"webpack/loader","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt7w001egw92nwofhsyz","content":"<h2 id=\"关于webpack\"><a href=\"#关于webpack\" class=\"headerlink\" title=\"关于webpack\"></a>关于webpack</h2><p>作为近段时间风头正盛的打包工具，webpack基本占领了前端圈。相信你都不好意思说不知道webpack。<br>有兴趣的同学可以参考下我很早之前的<a href=\"http://www.cnblogs.com/pqjwyn/p/5380689.html\" target=\"_blank\" rel=\"noopener\">webpack简介</a> .<br>确实webpack万事万物皆模块的思路真是极大的方便了我们的开发，将css，图片等文件都能打包的功能离不开形形色色的loader。<br>对于一个事情要知其然更要知其所以然，抱着这个心态我们一起来看下loader的相关知识及如何开发。<br><a id=\"more\"></a></p>\n<h4 id=\"学习方法\"><a href=\"#学习方法\" class=\"headerlink\" title=\"学习方法\"></a>学习方法</h4><p>对于一个新事物最好的学习方法，我认为是其官方文档。对于loader，将其官方文档看一遍，就知道如何开发最简单的loader了。<br>只是其<a href=\"https://webpack.js.org/contribute/writing-a-loader/\" target=\"_blank\" rel=\"noopener\">官方文档</a>是英文的，我就顺手翻译了一下，一方面加深自己理解。另一方面为其他同学提供个参考。<br>我相信看完文档你就知道如何开发一个loader了。  </p>\n<h2 id=\"什么是loader\"><a href=\"#什么是loader\" class=\"headerlink\" title=\"什么是loader\"></a>什么是loader</h2><p>loader是一个对面暴露一个方法的node包.当遇到某些资源需要被转换时调用该方法。  </p>\n<h4 id=\"简单情况\"><a href=\"#简单情况\" class=\"headerlink\" title=\"简单情况\"></a>简单情况</h4><p>只有一个loader来处理某个文件时，该loader被调用时只有一个参数，这个参数是该文件的内容转化之后的字符串。  </p>\n<p>loader在function执行时可以通过this context来访问laoder API 以便更高效的开发。  </p>\n<p>一个仅仅需要一个值的同步loader可以简单的return 自己。其他情况下，loader可以通过this.callback(err, values…)返回一系列的值。error同样传递给this.callback或者在loader中抛出。  </p>\n<p>loader期望返回1-2个值，第一个是处理之后作为string或者buffer返回的js代码。第二个是SourceMap或者js 对象   </p>\n<h4 id=\"复杂情况\"><a href=\"#复杂情况\" class=\"headerlink\" title=\"复杂情况:\"></a>复杂情况:</h4><p>当多个loader被链式调用时，只有最后一个loader获得资源文件。<br>同时只有第一个loader被期望返回1-2个值(即上面提到的JavaScript和SourceMap)。<br>其他loader接收值由上一个loader传递。  </p>\n<p>换句话说，链式loader执行顺序从右至左或者自下而上。<br>举个栗子：下面这段代码的执行顺序就是自下而上  foo-loader==&gt;bar-loader<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  loaders: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.js/</span>,</span><br><span class=\"line\">      loaders: [</span><br><span class=\"line\">        <span class=\"string\">'bar-loader'</span>,</span><br><span class=\"line\">        <span class=\"string\">'foo-loader'</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"注意：当前weboack只会在nodemodules文件夹下面搜索你指定的loader\"><a href=\"#注意：当前weboack只会在nodemodules文件夹下面搜索你指定的loader\" class=\"headerlink\" title=\"注意：当前weboack只会在nodemodules文件夹下面搜索你指定的loader\"></a>注意：当前weboack只会在nodemodules文件夹下面搜索你指定的loader</h4><p>如果你的文件夹不在该目录下需要在config下面增加一项配置:<br>即默认访问node_modules，你的文件夹不在的话就需要手动在配置文件里加上了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolveLoader: &#123;</span><br><span class=\"line\">    modules: [<span class=\"string\">'node_modules'</span>, path.resolve(__dirname, <span class=\"string\">'loaders'</span>)]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"温馨提示\"><a href=\"#温馨提示\" class=\"headerlink\" title=\"温馨提示\"></a>温馨提示</h4><p>ps：经过自身实践发现这样写是错的，不需要通过path去解析，直接将文件目录写入即可。<br>一般来说loader都会发布到npm上进行管理，这种状况不用担心，但是开发阶段如果要自行测试，就面对这种情况了。<br>例如，我手写的myloader在loaders下面，例子如下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> resolveLoader:&#123;</span><br><span class=\"line\">    modules: [<span class=\"string\">'node_modules'</span>,<span class=\"string\">'loader'</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><p>就这么简单就是个普通的loader<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source,map</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">this</span>.cacheable &amp;&amp; <span class=\"keyword\">this</span>.cacheable()</span><br><span class=\"line\"><span class=\"keyword\">this</span>.value = source</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">'/*copy@ xiaoxiangdaiyu*/'</span>+<span class=\"built_in\">JSON</span>.stringify(source)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"开发指南\"><a href=\"#开发指南\" class=\"headerlink\" title=\"开发指南\"></a>开发指南</h2><p>loader需要遵循以下事项。<br>以下事项按优先级排列，第一条具有最高优先级。   </p>\n<h4 id=\"一、单一任务\"><a href=\"#一、单一任务\" class=\"headerlink\" title=\"一、单一任务\"></a>一、单一任务</h4><p>loaders可以被链式调用，为每一步创建一个loader而非一个loader做所有事情<br>也就是说，在非必要的状况下没有必要将他们转换为js。  </p>\n<p>例如：通过查询字符串将一个字符串模板转化为html。<br>如果你写了个loader做了所有事情那么你违背了loader的第一条要求。<br>你应该为每一个task创建一个loader并且通过管道来使用它们  </p>\n<ul>\n<li>jade-loader: 转换模板为一个module   </li>\n<li>apply-loader: 创建一个module并通过查询参数来返回结果  </li>\n<li>html-loade: 创建一个处理html并返回一个string的模块   </li>\n</ul>\n<h4 id=\"二、创建moulde话的模块，即正常的模块\"><a href=\"#二、创建moulde话的模块，即正常的模块\" class=\"headerlink\" title=\"二、创建moulde话的模块，即正常的模块\"></a>二、创建moulde话的模块，即正常的模块</h4><p>loader产出的module应该和遵循和普通的module一样的设计原则。<br>举个例子，下面这样设计是不好的，没有模块化，依赖全局状态<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"any-template-language-loader!./xyz.atl\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> html = anyTemplateLanguage.render(<span class=\"string\">\"xyz\"</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"三、尽量表明该loader是否可以缓存\"><a href=\"#三、尽量表明该loader是否可以缓存\" class=\"headerlink\" title=\"三、尽量表明该loader是否可以缓存\"></a>三、尽量表明该loader是否可以缓存</h4><p>大部分loaders是cacheable，所以应该标明是否cacheable。<br>只需要在loader里面调用即可<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">// Cacheable identity loader</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.cacheable();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> source;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"四、不要在运行和模块之间保存状态\"><a href=\"#四、不要在运行和模块之间保存状态\" class=\"headerlink\" title=\"四、不要在运行和模块之间保存状态\"></a>四、不要在运行和模块之间保存状态</h4><ul>\n<li>一个loader相对于其他编译后的模块应该是独立的。 除非其可以自己处理这些状态  </li>\n<li>一个loader相对于同一模块之前的编译过程应该是独立的。</li>\n</ul>\n<h4 id=\"五、标明依赖\"><a href=\"#五、标明依赖\" class=\"headerlink\" title=\"五、标明依赖\"></a>五、标明依赖</h4><p>如果该loader引用了其他资源（例如文件系统）， 必须声明它们。这些信息用来是缓存的loader失效并且重新编译它们  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">\"path\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.cacheable();</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> callback = <span class=\"keyword\">this</span>.async();</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> headerPath = path.resolve(<span class=\"string\">\"header.js\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.addDependency(headerPath);</span><br><span class=\"line\">\tfs.readFile(headerPath, <span class=\"string\">\"utf-8\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, header</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">\t\tcallback(<span class=\"literal\">null</span>, header + <span class=\"string\">\"\\n\"</span> + source);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"六、解析依赖\"><a href=\"#六、解析依赖\" class=\"headerlink\" title=\"六、解析依赖\"></a>六、解析依赖</h4><p>很多语言都提供了一些规范来声明依赖，例如css中的 @import 和 url(…)。这些依赖应该被模块系统所解析。  </p>\n<h5 id=\"下面是两种解决方式：\"><a href=\"#下面是两种解决方式：\" class=\"headerlink\" title=\"下面是两种解决方式：\"></a>下面是两种解决方式：</h5><ul>\n<li>1、将它们转化成require   </li>\n<li>2、 用this.resolve方法来解析路径  </li>\n</ul>\n<h5 id=\"下面是两个示例\"><a href=\"#下面是两个示例\" class=\"headerlink\" title=\"下面是两个示例\"></a>下面是两个示例</h5><ul>\n<li>1、css-loader: 将依赖转化成require，即用require来替换@import和 url(…)，解析对其他样式文件的依赖  </li>\n<li>2、less-loader: 不能像css-loader那样做，因为所有的less文件需要一起编译来解析变量和mixins。因此其通过一个公共的路径逻辑来扩展less编译过程。这个公共的逻辑使用this.resolve来解析带有module系统配置项的文件。例如aliasing, custom module directories等。  </li>\n</ul>\n<p>如果语言仅仅接受相对urls（如css中url(file) 总是代表./file），使用~来说明成模块依赖.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url(file) -&gt; <span class=\"built_in\">require</span>(<span class=\"string\">\"./file\"</span>)</span><br><span class=\"line\">url(~<span class=\"built_in\">module</span>) -&gt; <span class=\"built_in\">require</span>(<span class=\"string\">\"module\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"七、抽离公共代码\"><a href=\"#七、抽离公共代码\" class=\"headerlink\" title=\"七、抽离公共代码\"></a>七、抽离公共代码</h4><p>extract common code  我感觉还是翻译成上面的标题比较好。其实所有语言都遵循该思想，即封装<br>不要写出来很多每个模块都在使用的代码，在loader中创建一个runtime文件，将公共代码放在其中</p>\n<h4 id=\"八、避免写入绝对路径\"><a href=\"#八、避免写入绝对路径\" class=\"headerlink\" title=\"八、避免写入绝对路径\"></a>八、避免写入绝对路径</h4><p>不要把绝对路径写入到模块代码中。它们将会破坏hash的过程当项目的根目录发生改变的时候。应该使用loader-utils的 stringifyRequest方法来绝对路径转化为相对路径。<br>例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">var</span> loaderUtils = <span class=\"built_in\">require</span>(<span class=\"string\">\"loader-utils\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"var runtime = require(\"</span> +</span><br><span class=\"line\">  loaderUtils.stringifyRequest(<span class=\"keyword\">this</span>, <span class=\"string\">\"!\"</span> + <span class=\"built_in\">require</span>.resolve(<span class=\"string\">\"module/runtime\"</span>)) +</span><br><span class=\"line\"><span class=\"string\">\");\"</span>;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"九、使用peerDependencies来指明依赖的库\"><a href=\"#九、使用peerDependencies来指明依赖的库\" class=\"headerlink\" title=\"九、使用peerDependencies来指明依赖的库\"></a>九、使用peerDependencies来指明依赖的库</h4><p>使用peerDependency允许应用开发者去在package.json里说明依赖的具体版本。这些依赖应该是相对开放的允许工具库升级而不需要重新发布loader版本。简而言之，对于peerDependency依赖的库应该是松耦合的，当工具库版本变化的时候不需要重新变更loader版本。  </p>\n<h4 id=\"十、可编程对象作为查询项\"><a href=\"#十、可编程对象作为查询项\" class=\"headerlink\" title=\"十、可编程对象作为查询项\"></a>十、可编程对象作为查询项</h4><p>有些情况下，loader需要某些可编程的对象但是不能作为序列化的query参数被方法解析。例如less-loader通过具体的less-plugin提供了这种可能。这种情况下，loader应该允许扩展webpack的options对象去获得具体的option。为了避免名字冲突，基于loader的命名空间来命名是很必要的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    lessLoader: &#123;</span><br><span class=\"line\">        lessPlugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> LessPluginCleanCSS(&#123;<span class=\"attr\">advanced</span>: <span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>至此，如何开发一个webpack loader 我相信大家已经知道了，如果还不太清楚的话，可以移步<a href=\"https://github.com/xiaoxiangdaiyu/w-loader\" target=\"_blank\" rel=\"noopener\">w-loader</a>查看。<br>另外，对于我这种英语渣渣来说，翻译起来确实难度蛮大的。此处抛砖引玉，希望大家共同探讨学习。   </p>\n","site":{"data":{}},"excerpt":"<h2 id=\"关于webpack\"><a href=\"#关于webpack\" class=\"headerlink\" title=\"关于webpack\"></a>关于webpack</h2><p>作为近段时间风头正盛的打包工具，webpack基本占领了前端圈。相信你都不好意思说不知道webpack。<br>有兴趣的同学可以参考下我很早之前的<a href=\"http://www.cnblogs.com/pqjwyn/p/5380689.html\" target=\"_blank\" rel=\"noopener\">webpack简介</a> .<br>确实webpack万事万物皆模块的思路真是极大的方便了我们的开发，将css，图片等文件都能打包的功能离不开形形色色的loader。<br>对于一个事情要知其然更要知其所以然，抱着这个心态我们一起来看下loader的相关知识及如何开发。<br>","more":"</p>\n<h4 id=\"学习方法\"><a href=\"#学习方法\" class=\"headerlink\" title=\"学习方法\"></a>学习方法</h4><p>对于一个新事物最好的学习方法，我认为是其官方文档。对于loader，将其官方文档看一遍，就知道如何开发最简单的loader了。<br>只是其<a href=\"https://webpack.js.org/contribute/writing-a-loader/\" target=\"_blank\" rel=\"noopener\">官方文档</a>是英文的，我就顺手翻译了一下，一方面加深自己理解。另一方面为其他同学提供个参考。<br>我相信看完文档你就知道如何开发一个loader了。  </p>\n<h2 id=\"什么是loader\"><a href=\"#什么是loader\" class=\"headerlink\" title=\"什么是loader\"></a>什么是loader</h2><p>loader是一个对面暴露一个方法的node包.当遇到某些资源需要被转换时调用该方法。  </p>\n<h4 id=\"简单情况\"><a href=\"#简单情况\" class=\"headerlink\" title=\"简单情况\"></a>简单情况</h4><p>只有一个loader来处理某个文件时，该loader被调用时只有一个参数，这个参数是该文件的内容转化之后的字符串。  </p>\n<p>loader在function执行时可以通过this context来访问laoder API 以便更高效的开发。  </p>\n<p>一个仅仅需要一个值的同步loader可以简单的return 自己。其他情况下，loader可以通过this.callback(err, values…)返回一系列的值。error同样传递给this.callback或者在loader中抛出。  </p>\n<p>loader期望返回1-2个值，第一个是处理之后作为string或者buffer返回的js代码。第二个是SourceMap或者js 对象   </p>\n<h4 id=\"复杂情况\"><a href=\"#复杂情况\" class=\"headerlink\" title=\"复杂情况:\"></a>复杂情况:</h4><p>当多个loader被链式调用时，只有最后一个loader获得资源文件。<br>同时只有第一个loader被期望返回1-2个值(即上面提到的JavaScript和SourceMap)。<br>其他loader接收值由上一个loader传递。  </p>\n<p>换句话说，链式loader执行顺序从右至左或者自下而上。<br>举个栗子：下面这段代码的执行顺序就是自下而上  foo-loader==&gt;bar-loader<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">  loaders: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      test: <span class=\"regexp\">/\\.js/</span>,</span><br><span class=\"line\">      loaders: [</span><br><span class=\"line\">        <span class=\"string\">'bar-loader'</span>,</span><br><span class=\"line\">        <span class=\"string\">'foo-loader'</span></span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"注意：当前weboack只会在nodemodules文件夹下面搜索你指定的loader\"><a href=\"#注意：当前weboack只会在nodemodules文件夹下面搜索你指定的loader\" class=\"headerlink\" title=\"注意：当前weboack只会在nodemodules文件夹下面搜索你指定的loader\"></a>注意：当前weboack只会在nodemodules文件夹下面搜索你指定的loader</h4><p>如果你的文件夹不在该目录下需要在config下面增加一项配置:<br>即默认访问node_modules，你的文件夹不在的话就需要手动在配置文件里加上了。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolveLoader: &#123;</span><br><span class=\"line\">    modules: [<span class=\"string\">'node_modules'</span>, path.resolve(__dirname, <span class=\"string\">'loaders'</span>)]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"温馨提示\"><a href=\"#温馨提示\" class=\"headerlink\" title=\"温馨提示\"></a>温馨提示</h4><p>ps：经过自身实践发现这样写是错的，不需要通过path去解析，直接将文件目录写入即可。<br>一般来说loader都会发布到npm上进行管理，这种状况不用担心，但是开发阶段如果要自行测试，就面对这种情况了。<br>例如，我手写的myloader在loaders下面，例子如下。<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> resolveLoader:&#123;</span><br><span class=\"line\">    modules: [<span class=\"string\">'node_modules'</span>,<span class=\"string\">'loader'</span>]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Examples\"><a href=\"#Examples\" class=\"headerlink\" title=\"Examples\"></a>Examples</h2><p>就这么简单就是个普通的loader<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source,map</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">this</span>.cacheable &amp;&amp; <span class=\"keyword\">this</span>.cacheable()</span><br><span class=\"line\"><span class=\"keyword\">this</span>.value = source</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"string\">'/*copy@ xiaoxiangdaiyu*/'</span>+<span class=\"built_in\">JSON</span>.stringify(source)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"开发指南\"><a href=\"#开发指南\" class=\"headerlink\" title=\"开发指南\"></a>开发指南</h2><p>loader需要遵循以下事项。<br>以下事项按优先级排列，第一条具有最高优先级。   </p>\n<h4 id=\"一、单一任务\"><a href=\"#一、单一任务\" class=\"headerlink\" title=\"一、单一任务\"></a>一、单一任务</h4><p>loaders可以被链式调用，为每一步创建一个loader而非一个loader做所有事情<br>也就是说，在非必要的状况下没有必要将他们转换为js。  </p>\n<p>例如：通过查询字符串将一个字符串模板转化为html。<br>如果你写了个loader做了所有事情那么你违背了loader的第一条要求。<br>你应该为每一个task创建一个loader并且通过管道来使用它们  </p>\n<ul>\n<li>jade-loader: 转换模板为一个module   </li>\n<li>apply-loader: 创建一个module并通过查询参数来返回结果  </li>\n<li>html-loade: 创建一个处理html并返回一个string的模块   </li>\n</ul>\n<h4 id=\"二、创建moulde话的模块，即正常的模块\"><a href=\"#二、创建moulde话的模块，即正常的模块\" class=\"headerlink\" title=\"二、创建moulde话的模块，即正常的模块\"></a>二、创建moulde话的模块，即正常的模块</h4><p>loader产出的module应该和遵循和普通的module一样的设计原则。<br>举个例子，下面这样设计是不好的，没有模块化，依赖全局状态<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">\"any-template-language-loader!./xyz.atl\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> html = anyTemplateLanguage.render(<span class=\"string\">\"xyz\"</span>);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"三、尽量表明该loader是否可以缓存\"><a href=\"#三、尽量表明该loader是否可以缓存\" class=\"headerlink\" title=\"三、尽量表明该loader是否可以缓存\"></a>三、尽量表明该loader是否可以缓存</h4><p>大部分loaders是cacheable，所以应该标明是否cacheable。<br>只需要在loader里面调用即可<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">// Cacheable identity loader</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.cacheable();</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> source;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"四、不要在运行和模块之间保存状态\"><a href=\"#四、不要在运行和模块之间保存状态\" class=\"headerlink\" title=\"四、不要在运行和模块之间保存状态\"></a>四、不要在运行和模块之间保存状态</h4><ul>\n<li>一个loader相对于其他编译后的模块应该是独立的。 除非其可以自己处理这些状态  </li>\n<li>一个loader相对于同一模块之前的编译过程应该是独立的。</li>\n</ul>\n<h4 id=\"五、标明依赖\"><a href=\"#五、标明依赖\" class=\"headerlink\" title=\"五、标明依赖\"></a>五、标明依赖</h4><p>如果该loader引用了其他资源（例如文件系统）， 必须声明它们。这些信息用来是缓存的loader失效并且重新编译它们  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"keyword\">var</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">\"path\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">source</span>) </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.cacheable();</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> callback = <span class=\"keyword\">this</span>.async();</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> headerPath = path.resolve(<span class=\"string\">\"header.js\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">this</span>.addDependency(headerPath);</span><br><span class=\"line\">\tfs.readFile(headerPath, <span class=\"string\">\"utf-8\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, header</span>) </span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(err) <span class=\"keyword\">return</span> callback(err);</span><br><span class=\"line\">\t\tcallback(<span class=\"literal\">null</span>, header + <span class=\"string\">\"\\n\"</span> + source);</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"六、解析依赖\"><a href=\"#六、解析依赖\" class=\"headerlink\" title=\"六、解析依赖\"></a>六、解析依赖</h4><p>很多语言都提供了一些规范来声明依赖，例如css中的 @import 和 url(…)。这些依赖应该被模块系统所解析。  </p>\n<h5 id=\"下面是两种解决方式：\"><a href=\"#下面是两种解决方式：\" class=\"headerlink\" title=\"下面是两种解决方式：\"></a>下面是两种解决方式：</h5><ul>\n<li>1、将它们转化成require   </li>\n<li>2、 用this.resolve方法来解析路径  </li>\n</ul>\n<h5 id=\"下面是两个示例\"><a href=\"#下面是两个示例\" class=\"headerlink\" title=\"下面是两个示例\"></a>下面是两个示例</h5><ul>\n<li>1、css-loader: 将依赖转化成require，即用require来替换@import和 url(…)，解析对其他样式文件的依赖  </li>\n<li>2、less-loader: 不能像css-loader那样做，因为所有的less文件需要一起编译来解析变量和mixins。因此其通过一个公共的路径逻辑来扩展less编译过程。这个公共的逻辑使用this.resolve来解析带有module系统配置项的文件。例如aliasing, custom module directories等。  </li>\n</ul>\n<p>如果语言仅仅接受相对urls（如css中url(file) 总是代表./file），使用~来说明成模块依赖.<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">url(file) -&gt; <span class=\"built_in\">require</span>(<span class=\"string\">\"./file\"</span>)</span><br><span class=\"line\">url(~<span class=\"built_in\">module</span>) -&gt; <span class=\"built_in\">require</span>(<span class=\"string\">\"module\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"七、抽离公共代码\"><a href=\"#七、抽离公共代码\" class=\"headerlink\" title=\"七、抽离公共代码\"></a>七、抽离公共代码</h4><p>extract common code  我感觉还是翻译成上面的标题比较好。其实所有语言都遵循该思想，即封装<br>不要写出来很多每个模块都在使用的代码，在loader中创建一个runtime文件，将公共代码放在其中</p>\n<h4 id=\"八、避免写入绝对路径\"><a href=\"#八、避免写入绝对路径\" class=\"headerlink\" title=\"八、避免写入绝对路径\"></a>八、避免写入绝对路径</h4><p>不要把绝对路径写入到模块代码中。它们将会破坏hash的过程当项目的根目录发生改变的时候。应该使用loader-utils的 stringifyRequest方法来绝对路径转化为相对路径。<br>例子：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">var</span> loaderUtils = <span class=\"built_in\">require</span>(<span class=\"string\">\"loader-utils\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"string\">\"var runtime = require(\"</span> +</span><br><span class=\"line\">  loaderUtils.stringifyRequest(<span class=\"keyword\">this</span>, <span class=\"string\">\"!\"</span> + <span class=\"built_in\">require</span>.resolve(<span class=\"string\">\"module/runtime\"</span>)) +</span><br><span class=\"line\"><span class=\"string\">\");\"</span>;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"九、使用peerDependencies来指明依赖的库\"><a href=\"#九、使用peerDependencies来指明依赖的库\" class=\"headerlink\" title=\"九、使用peerDependencies来指明依赖的库\"></a>九、使用peerDependencies来指明依赖的库</h4><p>使用peerDependency允许应用开发者去在package.json里说明依赖的具体版本。这些依赖应该是相对开放的允许工具库升级而不需要重新发布loader版本。简而言之，对于peerDependency依赖的库应该是松耦合的，当工具库版本变化的时候不需要重新变更loader版本。  </p>\n<h4 id=\"十、可编程对象作为查询项\"><a href=\"#十、可编程对象作为查询项\" class=\"headerlink\" title=\"十、可编程对象作为查询项\"></a>十、可编程对象作为查询项</h4><p>有些情况下，loader需要某些可编程的对象但是不能作为序列化的query参数被方法解析。例如less-loader通过具体的less-plugin提供了这种可能。这种情况下，loader应该允许扩展webpack的options对象去获得具体的option。为了避免名字冲突，基于loader的命名空间来命名是很必要的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"comment\">// webpack.config.js</span></span><br><span class=\"line\">    <span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    lessLoader: &#123;</span><br><span class=\"line\">        lessPlugins: [</span><br><span class=\"line\">        <span class=\"keyword\">new</span> LessPluginCleanCSS(&#123;<span class=\"attr\">advanced</span>: <span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>至此，如何开发一个webpack loader 我相信大家已经知道了，如果还不太清楚的话，可以移步<a href=\"https://github.com/xiaoxiangdaiyu/w-loader\" target=\"_blank\" rel=\"noopener\">w-loader</a>查看。<br>另外，对于我这种英语渣渣来说，翻译起来确实难度蛮大的。此处抛砖引玉，希望大家共同探讨学习。   </p>"},{"title":"如何开发webpack plugin","date":"2017-10-22T16:00:00.000Z","_content":"继上回介绍了[如何开发webpack loader](https://github.com/xiaoxiangdaiyu/w-loader/blob/master/loader/DOC.md) 之后。趁热打铁，来继续看下webpack另一个核心组成：plugin。  \n下面也和loader一样，让我们一起从基本的[官方文档](https://webpack.js.org/contribute/writing-a-plugin/)着手看起。  \n<!-- more -->\n## loader和plugin的差别   \n\n*  loader : 顾名思义，某种类型资源文件的加载器，作用于某种类型的文件上。webpack本身也是不能直接打包这些非js文件的，需要一个转化器即loader。 loader本身是单一，简单的，不能将多个功能放在一个loader里。   \n*  plugin比loaders更加先进一点，你可以扩展webpack的功能来满足自己的需要，换句话说，loader不能满足的时候，就需要plugin了。\n   \n\n## 如何开发一个plugin  \n\n插件将webpack引擎所有的能力暴露给第三方开发者。通过阶梯式的build回调，开发者可以在webpack编译过程中加入自己的行为。开发插件比loaders更加先进一点，因为你需要理解webpack一些底层构成来添加钩子回调。准备好读一些源码吧。       \n\n## 开发一个插件   \n\n一个webpack的插件由以下几方面组成：  \n* 一个非匿名的js函数   \n* 在它的原型对象上定义apply方法  \n* 指明挂载自身的webpack钩子事件  \n* 操作webpack内部情况的特定数据  \n* 方法完成时唤起webpack提供的回调\n```js\n// A named JavaScript function.\nfunction MyExampleWebpackPlugin() {\n   //\n};\n// Defines `apply` method in it's prototype.\nMyExampleWebpackPlugin.prototype.apply = function(compiler) {\n  // Specifies webpack's event hook to attach itself.\n  compiler.plugin('webpacksEventHook', function(compilation /* Manipulates webpack internal instance specific data. */, callback) {\n    console.log(\"This is an example plugin!!!\");\n    // Invokes webpack provided callback after functionality is complete.\n    callback();\n  });\n};    \n```\n## 编译器和编译     \n\n开发插件过程中最重要的两个对象就是compiler 和compilation。理解他们的职责是扩展webpack功能最重要的第一步   \n\n编译器对象就是webpack完整的配置环境。该对象一经webpack开始执行就创建，并且通过所有可操作的设置项来设置，例如options，loaders，和plugins。当在webpack环境中应用一个插件时，该插件将会接受到一个指向该编译器的引用。使用该编译器来访问主要的webpack环境。\n\ncompilation对象是一个单独的关于版本资源的创建。当执行webpack 开发中间件时，当一个文件的更改被检测到就会创建一个新的compilation对象，因此产生了一些可被编译的资源。一个compilation展现了一些信息关于当前模块资源状态、编译资源、改变的文件、监视的依赖等信息。同样提供了很多关键的回调，当插件扩展自定义行为时   \n\n这两个组件是webpack 插件必需的组成部分(特别是compilation)，所以开发者如果熟悉下面这些源文件将会获益不小。   \n* [Compiler Source](https://github.com/webpack/webpack/blob/master/lib/Compiler.js)  \n* [Compilation Source](https://github.com/webpack/webpack/blob/master/lib/Compilation.js)   \n\n## 插件的基本结构   \n\n插件是在原型中带有一个apply方法的实例化对象，当安装插件的时候，这个apply方法就会被webpack调用一次。apply方法提供一个指向当前活动的webpack compiler的引用，该引用允许访问compiler的回调。一个简单的插件结构如下：  \n \n```js\nfunction HelloWorldPlugin(options) {\n  // Setup the plugin instance with options...\n}\n\nHelloWorldPlugin.prototype.apply = function(compiler) {\n  compiler.plugin('done', function() {\n    console.log('Hello World!');\n  });\n};\n\nmodule.exports = HelloWorldPlugin;   \n```\n然后安装一个插件，仅仅需要在你的 webpack config 中plugins对应的数组中，增加一个插件的实例即可   \n\n```js\nvar HelloWorldPlugin = require('hello-world');\n\nvar webpackConfig = {\n  // ... config settings here ...\n  plugins: [\n    new HelloWorldPlugin({options: true})\n  ]\n};\n```\n## 访问编译    \n\n通过使用编译器对象，你可能会绑定提供指向每个新的compilation应用的回调。这些compilations提供了编译过程中很多步骤的回调函数。   \n\n```js\nfunction HelloCompilationPlugin(options) {}\n\nHelloCompilationPlugin.prototype.apply = function(compiler) {\n\n  // Setup callback for accessing a compilation:\n  compiler.plugin(\"compilation\", function(compilation) {\n\n    // Now setup callbacks for accessing compilation steps:\n    compilation.plugin(\"optimize\", function() {\n      console.log(\"Assets are being optimized.\");\n    });\n  });\n};\n\nmodule.exports = HelloCompilationPlugin;\n```\n如果想了解更多关于在编译器、编译中哪些回调是可用的和其他一些更重要的对象，轻戳[plugin文档](https://doc.webpack-china.org/api/plugins/) \n\n## 异步插件    \n\n一些编译插件步骤是异步的并且提供了一个当你的插件结束编译时必须调用的回调方法\n\n```js\nfunction HelloAsyncPlugin(options) {}\n\nHelloAsyncPlugin.prototype.apply = function(compiler) {\n  compiler.plugin(\"emit\", function(compilation, callback) {\n\n    // Do something async...\n    setTimeout(function() {\n      console.log(\"Done with async work...\");\n      callback();\n    }, 1000);\n\n  });\n};\n\nmodule.exports = HelloAsyncPlugin;\n```\n## 示例  \n\n一旦我们打开了webpack编译器和每个单独编译的大门，我们可以使用引擎做的事情是无限可能的。我们可以重新格式化存在的文件、创建派生文件、完全伪造一个新文件  \n\n让我们写个简单的示例插件，目的是生成一个新的名字为filelist.md的文件。内容如下：列出构建过程中所有的生成文件。这个插件大概如下：\n \n```js\nfunction FileListPlugin(options) {}\n\nFileListPlugin.prototype.apply = function(compiler) {\n  compiler.plugin('emit', function(compilation, callback) {\n    // Create a header string for the generated file:\n    var filelist = 'In this build:\\n\\n';\n\n    // Loop through all compiled assets,\n    // adding a new line item for each filename.\n    for (var filename in compilation.assets) {\n      filelist += ('- '+ filename +'\\n');\n    }\n\n    // Insert this list into the webpack build as a new file asset:\n    compilation.assets['filelist.md'] = {\n      source: function() {\n        return filelist;\n      },\n      size: function() {\n        return filelist.length;\n      }\n    };\n\n    callback();\n  });\n};\n\nmodule.exports = FileListPlugin;\n```\n## 不同类型的插件   \n\n插件可以依据其注册的事件来分成不同的类型，每个事件钩子决定了在触发时如何调用该插件。  \n\n#### 同步类型 \n\n这种类型的实例使用如下方式来调用插件  \n```js\napplyPlugins(name: string, args: any...)\n\napplyPluginsBailResult(name: string, args: any...)  \n```\n这意味着每一个插件的回调将伴随特定参数args依次被调用。对插件而言这是最简单的格式。很多有用的事件例如\"compile\", \"this-compilation\"，是期望插件同步执行的。  \n\n#### 流式类型 \n\nwaterfall Plugins 通过下面的方式调用  \n```js\napplyPluginsWaterfall(name: string, init: any, args: any...)\n```\n#### 异步类型   \n\n当所有的插件被使用下面的方法异步调用的时候，即为异步插件\n```js\napplyPluginsAsync(name: string, args: any..., callback: (err?: Error) -> void)\n```\n插件控制方法被调用，参数是所有的args和带有这种标志(err?: Error) -> void的回调。handler方法按照注册回调在所有handlers被调用之后的顺序来调用。对于\"emit\", \"run\"事件来说这是很常用的模式。\n\n#### 异步流    \n\n这种插件将按照流失方式来被异步使用  \n\n```js\napplyPluginsAsyncWaterfall(name: string, init: any, callback: (err: Error, result: any) -> void)\n```\n这种插件的handler被调用时，参数是当前value和带有这种标志(err?: Error) -> void的回调。当被调用时，nextValue是下一个handler的当前值。第一个handler的当前值是init。所有的handler被调用之后，最后一个值将会被赋给回调。如果有的handler传递了一个err的值，回调将会接受err，并且不会有其他handler被第阿勇。这种插件模式使用与于\"before-resolve\" and \"after-resolve\"之类的事件。   \n\n#### 异步系列  \n\n这种和异步插件很相似，不同在于如果有点插件注册失败，将不会调用任何插件   \n```js\napplyPluginsAsyncSeries(name: string, args: any..., callback: (err: Error, result: any) -> void)\n```\n#### 结束语   \n至此，如何开发一个基本的webpack plugin 我相信大家已经知道了，如果还不太清楚的话，可以移步[w-loader](https://github.com/xiaoxiangdaiyu/w-loader)查看。   \n另外，对于我这种英语渣渣来说，翻译起来确实难度蛮大的。此处抛砖引玉，希望大家共同探讨学习。   ","source":"_posts/webpack/plugin.md","raw":"---\ntitle: 如何开发webpack plugin\ndate: 2017-10-23\n---\n继上回介绍了[如何开发webpack loader](https://github.com/xiaoxiangdaiyu/w-loader/blob/master/loader/DOC.md) 之后。趁热打铁，来继续看下webpack另一个核心组成：plugin。  \n下面也和loader一样，让我们一起从基本的[官方文档](https://webpack.js.org/contribute/writing-a-plugin/)着手看起。  \n<!-- more -->\n## loader和plugin的差别   \n\n*  loader : 顾名思义，某种类型资源文件的加载器，作用于某种类型的文件上。webpack本身也是不能直接打包这些非js文件的，需要一个转化器即loader。 loader本身是单一，简单的，不能将多个功能放在一个loader里。   \n*  plugin比loaders更加先进一点，你可以扩展webpack的功能来满足自己的需要，换句话说，loader不能满足的时候，就需要plugin了。\n   \n\n## 如何开发一个plugin  \n\n插件将webpack引擎所有的能力暴露给第三方开发者。通过阶梯式的build回调，开发者可以在webpack编译过程中加入自己的行为。开发插件比loaders更加先进一点，因为你需要理解webpack一些底层构成来添加钩子回调。准备好读一些源码吧。       \n\n## 开发一个插件   \n\n一个webpack的插件由以下几方面组成：  \n* 一个非匿名的js函数   \n* 在它的原型对象上定义apply方法  \n* 指明挂载自身的webpack钩子事件  \n* 操作webpack内部情况的特定数据  \n* 方法完成时唤起webpack提供的回调\n```js\n// A named JavaScript function.\nfunction MyExampleWebpackPlugin() {\n   //\n};\n// Defines `apply` method in it's prototype.\nMyExampleWebpackPlugin.prototype.apply = function(compiler) {\n  // Specifies webpack's event hook to attach itself.\n  compiler.plugin('webpacksEventHook', function(compilation /* Manipulates webpack internal instance specific data. */, callback) {\n    console.log(\"This is an example plugin!!!\");\n    // Invokes webpack provided callback after functionality is complete.\n    callback();\n  });\n};    \n```\n## 编译器和编译     \n\n开发插件过程中最重要的两个对象就是compiler 和compilation。理解他们的职责是扩展webpack功能最重要的第一步   \n\n编译器对象就是webpack完整的配置环境。该对象一经webpack开始执行就创建，并且通过所有可操作的设置项来设置，例如options，loaders，和plugins。当在webpack环境中应用一个插件时，该插件将会接受到一个指向该编译器的引用。使用该编译器来访问主要的webpack环境。\n\ncompilation对象是一个单独的关于版本资源的创建。当执行webpack 开发中间件时，当一个文件的更改被检测到就会创建一个新的compilation对象，因此产生了一些可被编译的资源。一个compilation展现了一些信息关于当前模块资源状态、编译资源、改变的文件、监视的依赖等信息。同样提供了很多关键的回调，当插件扩展自定义行为时   \n\n这两个组件是webpack 插件必需的组成部分(特别是compilation)，所以开发者如果熟悉下面这些源文件将会获益不小。   \n* [Compiler Source](https://github.com/webpack/webpack/blob/master/lib/Compiler.js)  \n* [Compilation Source](https://github.com/webpack/webpack/blob/master/lib/Compilation.js)   \n\n## 插件的基本结构   \n\n插件是在原型中带有一个apply方法的实例化对象，当安装插件的时候，这个apply方法就会被webpack调用一次。apply方法提供一个指向当前活动的webpack compiler的引用，该引用允许访问compiler的回调。一个简单的插件结构如下：  \n \n```js\nfunction HelloWorldPlugin(options) {\n  // Setup the plugin instance with options...\n}\n\nHelloWorldPlugin.prototype.apply = function(compiler) {\n  compiler.plugin('done', function() {\n    console.log('Hello World!');\n  });\n};\n\nmodule.exports = HelloWorldPlugin;   \n```\n然后安装一个插件，仅仅需要在你的 webpack config 中plugins对应的数组中，增加一个插件的实例即可   \n\n```js\nvar HelloWorldPlugin = require('hello-world');\n\nvar webpackConfig = {\n  // ... config settings here ...\n  plugins: [\n    new HelloWorldPlugin({options: true})\n  ]\n};\n```\n## 访问编译    \n\n通过使用编译器对象，你可能会绑定提供指向每个新的compilation应用的回调。这些compilations提供了编译过程中很多步骤的回调函数。   \n\n```js\nfunction HelloCompilationPlugin(options) {}\n\nHelloCompilationPlugin.prototype.apply = function(compiler) {\n\n  // Setup callback for accessing a compilation:\n  compiler.plugin(\"compilation\", function(compilation) {\n\n    // Now setup callbacks for accessing compilation steps:\n    compilation.plugin(\"optimize\", function() {\n      console.log(\"Assets are being optimized.\");\n    });\n  });\n};\n\nmodule.exports = HelloCompilationPlugin;\n```\n如果想了解更多关于在编译器、编译中哪些回调是可用的和其他一些更重要的对象，轻戳[plugin文档](https://doc.webpack-china.org/api/plugins/) \n\n## 异步插件    \n\n一些编译插件步骤是异步的并且提供了一个当你的插件结束编译时必须调用的回调方法\n\n```js\nfunction HelloAsyncPlugin(options) {}\n\nHelloAsyncPlugin.prototype.apply = function(compiler) {\n  compiler.plugin(\"emit\", function(compilation, callback) {\n\n    // Do something async...\n    setTimeout(function() {\n      console.log(\"Done with async work...\");\n      callback();\n    }, 1000);\n\n  });\n};\n\nmodule.exports = HelloAsyncPlugin;\n```\n## 示例  \n\n一旦我们打开了webpack编译器和每个单独编译的大门，我们可以使用引擎做的事情是无限可能的。我们可以重新格式化存在的文件、创建派生文件、完全伪造一个新文件  \n\n让我们写个简单的示例插件，目的是生成一个新的名字为filelist.md的文件。内容如下：列出构建过程中所有的生成文件。这个插件大概如下：\n \n```js\nfunction FileListPlugin(options) {}\n\nFileListPlugin.prototype.apply = function(compiler) {\n  compiler.plugin('emit', function(compilation, callback) {\n    // Create a header string for the generated file:\n    var filelist = 'In this build:\\n\\n';\n\n    // Loop through all compiled assets,\n    // adding a new line item for each filename.\n    for (var filename in compilation.assets) {\n      filelist += ('- '+ filename +'\\n');\n    }\n\n    // Insert this list into the webpack build as a new file asset:\n    compilation.assets['filelist.md'] = {\n      source: function() {\n        return filelist;\n      },\n      size: function() {\n        return filelist.length;\n      }\n    };\n\n    callback();\n  });\n};\n\nmodule.exports = FileListPlugin;\n```\n## 不同类型的插件   \n\n插件可以依据其注册的事件来分成不同的类型，每个事件钩子决定了在触发时如何调用该插件。  \n\n#### 同步类型 \n\n这种类型的实例使用如下方式来调用插件  \n```js\napplyPlugins(name: string, args: any...)\n\napplyPluginsBailResult(name: string, args: any...)  \n```\n这意味着每一个插件的回调将伴随特定参数args依次被调用。对插件而言这是最简单的格式。很多有用的事件例如\"compile\", \"this-compilation\"，是期望插件同步执行的。  \n\n#### 流式类型 \n\nwaterfall Plugins 通过下面的方式调用  \n```js\napplyPluginsWaterfall(name: string, init: any, args: any...)\n```\n#### 异步类型   \n\n当所有的插件被使用下面的方法异步调用的时候，即为异步插件\n```js\napplyPluginsAsync(name: string, args: any..., callback: (err?: Error) -> void)\n```\n插件控制方法被调用，参数是所有的args和带有这种标志(err?: Error) -> void的回调。handler方法按照注册回调在所有handlers被调用之后的顺序来调用。对于\"emit\", \"run\"事件来说这是很常用的模式。\n\n#### 异步流    \n\n这种插件将按照流失方式来被异步使用  \n\n```js\napplyPluginsAsyncWaterfall(name: string, init: any, callback: (err: Error, result: any) -> void)\n```\n这种插件的handler被调用时，参数是当前value和带有这种标志(err?: Error) -> void的回调。当被调用时，nextValue是下一个handler的当前值。第一个handler的当前值是init。所有的handler被调用之后，最后一个值将会被赋给回调。如果有的handler传递了一个err的值，回调将会接受err，并且不会有其他handler被第阿勇。这种插件模式使用与于\"before-resolve\" and \"after-resolve\"之类的事件。   \n\n#### 异步系列  \n\n这种和异步插件很相似，不同在于如果有点插件注册失败，将不会调用任何插件   \n```js\napplyPluginsAsyncSeries(name: string, args: any..., callback: (err: Error, result: any) -> void)\n```\n#### 结束语   \n至此，如何开发一个基本的webpack plugin 我相信大家已经知道了，如果还不太清楚的话，可以移步[w-loader](https://github.com/xiaoxiangdaiyu/w-loader)查看。   \n另外，对于我这种英语渣渣来说，翻译起来确实难度蛮大的。此处抛砖引玉，希望大家共同探讨学习。   ","slug":"webpack/plugin","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt7x001ggw92wer23v29","content":"<p>继上回介绍了<a href=\"https://github.com/xiaoxiangdaiyu/w-loader/blob/master/loader/DOC.md\" target=\"_blank\" rel=\"noopener\">如何开发webpack loader</a> 之后。趁热打铁，来继续看下webpack另一个核心组成：plugin。<br>下面也和loader一样，让我们一起从基本的<a href=\"https://webpack.js.org/contribute/writing-a-plugin/\" target=\"_blank\" rel=\"noopener\">官方文档</a>着手看起。<br><a id=\"more\"></a></p>\n<h2 id=\"loader和plugin的差别\"><a href=\"#loader和plugin的差别\" class=\"headerlink\" title=\"loader和plugin的差别\"></a>loader和plugin的差别</h2><ul>\n<li>loader : 顾名思义，某种类型资源文件的加载器，作用于某种类型的文件上。webpack本身也是不能直接打包这些非js文件的，需要一个转化器即loader。 loader本身是单一，简单的，不能将多个功能放在一个loader里。   </li>\n<li>plugin比loaders更加先进一点，你可以扩展webpack的功能来满足自己的需要，换句话说，loader不能满足的时候，就需要plugin了。</li>\n</ul>\n<h2 id=\"如何开发一个plugin\"><a href=\"#如何开发一个plugin\" class=\"headerlink\" title=\"如何开发一个plugin\"></a>如何开发一个plugin</h2><p>插件将webpack引擎所有的能力暴露给第三方开发者。通过阶梯式的build回调，开发者可以在webpack编译过程中加入自己的行为。开发插件比loaders更加先进一点，因为你需要理解webpack一些底层构成来添加钩子回调。准备好读一些源码吧。       </p>\n<h2 id=\"开发一个插件\"><a href=\"#开发一个插件\" class=\"headerlink\" title=\"开发一个插件\"></a>开发一个插件</h2><p>一个webpack的插件由以下几方面组成：  </p>\n<ul>\n<li>一个非匿名的js函数   </li>\n<li>在它的原型对象上定义apply方法  </li>\n<li>指明挂载自身的webpack钩子事件  </li>\n<li>操作webpack内部情况的特定数据  </li>\n<li>方法完成时唤起webpack提供的回调<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A named JavaScript function.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyExampleWebpackPlugin</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// Defines `apply` method in it's prototype.</span></span><br><span class=\"line\">MyExampleWebpackPlugin.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compiler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Specifies webpack's event hook to attach itself.</span></span><br><span class=\"line\">  compiler.plugin(<span class=\"string\">'webpacksEventHook'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compilation <span class=\"regexp\">/* Manipulates webpack internal instance specific data. */</span>, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"This is an example plugin!!!\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Invokes webpack provided callback after functionality is complete.</span></span><br><span class=\"line\">    callback();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"编译器和编译\"><a href=\"#编译器和编译\" class=\"headerlink\" title=\"编译器和编译\"></a>编译器和编译</h2><p>开发插件过程中最重要的两个对象就是compiler 和compilation。理解他们的职责是扩展webpack功能最重要的第一步   </p>\n<p>编译器对象就是webpack完整的配置环境。该对象一经webpack开始执行就创建，并且通过所有可操作的设置项来设置，例如options，loaders，和plugins。当在webpack环境中应用一个插件时，该插件将会接受到一个指向该编译器的引用。使用该编译器来访问主要的webpack环境。</p>\n<p>compilation对象是一个单独的关于版本资源的创建。当执行webpack 开发中间件时，当一个文件的更改被检测到就会创建一个新的compilation对象，因此产生了一些可被编译的资源。一个compilation展现了一些信息关于当前模块资源状态、编译资源、改变的文件、监视的依赖等信息。同样提供了很多关键的回调，当插件扩展自定义行为时   </p>\n<p>这两个组件是webpack 插件必需的组成部分(特别是compilation)，所以开发者如果熟悉下面这些源文件将会获益不小。   </p>\n<ul>\n<li><a href=\"https://github.com/webpack/webpack/blob/master/lib/Compiler.js\" target=\"_blank\" rel=\"noopener\">Compiler Source</a>  </li>\n<li><a href=\"https://github.com/webpack/webpack/blob/master/lib/Compilation.js\" target=\"_blank\" rel=\"noopener\">Compilation Source</a>   </li>\n</ul>\n<h2 id=\"插件的基本结构\"><a href=\"#插件的基本结构\" class=\"headerlink\" title=\"插件的基本结构\"></a>插件的基本结构</h2><p>插件是在原型中带有一个apply方法的实例化对象，当安装插件的时候，这个apply方法就会被webpack调用一次。apply方法提供一个指向当前活动的webpack compiler的引用，该引用允许访问compiler的回调。一个简单的插件结构如下：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloWorldPlugin</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Setup the plugin instance with options...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">HelloWorldPlugin.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compiler</span>) </span>&#123;</span><br><span class=\"line\">  compiler.plugin(<span class=\"string\">'done'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World!'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = HelloWorldPlugin;</span><br></pre></td></tr></table></figure>\n<p>然后安装一个插件，仅仅需要在你的 webpack config 中plugins对应的数组中，增加一个插件的实例即可   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloWorldPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'hello-world'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackConfig = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... config settings here ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HelloWorldPlugin(&#123;<span class=\"attr\">options</span>: <span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"访问编译\"><a href=\"#访问编译\" class=\"headerlink\" title=\"访问编译\"></a>访问编译</h2><p>通过使用编译器对象，你可能会绑定提供指向每个新的compilation应用的回调。这些compilations提供了编译过程中很多步骤的回调函数。   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloCompilationPlugin</span>(<span class=\"params\">options</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">HelloCompilationPlugin.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compiler</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Setup callback for accessing a compilation:</span></span><br><span class=\"line\">  compiler.plugin(<span class=\"string\">\"compilation\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compilation</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Now setup callbacks for accessing compilation steps:</span></span><br><span class=\"line\">    compilation.plugin(<span class=\"string\">\"optimize\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Assets are being optimized.\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = HelloCompilationPlugin;</span><br></pre></td></tr></table></figure>\n<p>如果想了解更多关于在编译器、编译中哪些回调是可用的和其他一些更重要的对象，轻戳<a href=\"https://doc.webpack-china.org/api/plugins/\" target=\"_blank\" rel=\"noopener\">plugin文档</a> </p>\n<h2 id=\"异步插件\"><a href=\"#异步插件\" class=\"headerlink\" title=\"异步插件\"></a>异步插件</h2><p>一些编译插件步骤是异步的并且提供了一个当你的插件结束编译时必须调用的回调方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloAsyncPlugin</span>(<span class=\"params\">options</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">HelloAsyncPlugin.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compiler</span>) </span>&#123;</span><br><span class=\"line\">  compiler.plugin(<span class=\"string\">\"emit\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compilation, callback</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do something async...</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Done with async work...\"</span>);</span><br><span class=\"line\">      callback();</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = HelloAsyncPlugin;</span><br></pre></td></tr></table></figure>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>一旦我们打开了webpack编译器和每个单独编译的大门，我们可以使用引擎做的事情是无限可能的。我们可以重新格式化存在的文件、创建派生文件、完全伪造一个新文件  </p>\n<p>让我们写个简单的示例插件，目的是生成一个新的名字为filelist.md的文件。内容如下：列出构建过程中所有的生成文件。这个插件大概如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FileListPlugin</span>(<span class=\"params\">options</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FileListPlugin.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compiler</span>) </span>&#123;</span><br><span class=\"line\">  compiler.plugin(<span class=\"string\">'emit'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compilation, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a header string for the generated file:</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> filelist = <span class=\"string\">'In this build:\\n\\n'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Loop through all compiled assets,</span></span><br><span class=\"line\">    <span class=\"comment\">// adding a new line item for each filename.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> filename <span class=\"keyword\">in</span> compilation.assets) &#123;</span><br><span class=\"line\">      filelist += (<span class=\"string\">'- '</span>+ filename +<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Insert this list into the webpack build as a new file asset:</span></span><br><span class=\"line\">    compilation.assets[<span class=\"string\">'filelist.md'</span>] = &#123;</span><br><span class=\"line\">      source: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> filelist;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      size: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> filelist.length;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    callback();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = FileListPlugin;</span><br></pre></td></tr></table></figure>\n<h2 id=\"不同类型的插件\"><a href=\"#不同类型的插件\" class=\"headerlink\" title=\"不同类型的插件\"></a>不同类型的插件</h2><p>插件可以依据其注册的事件来分成不同的类型，每个事件钩子决定了在触发时如何调用该插件。  </p>\n<h4 id=\"同步类型\"><a href=\"#同步类型\" class=\"headerlink\" title=\"同步类型\"></a>同步类型</h4><p>这种类型的实例使用如下方式来调用插件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyPlugins(name: string, <span class=\"attr\">args</span>: any...)</span><br><span class=\"line\"></span><br><span class=\"line\">applyPluginsBailResult(name: string, <span class=\"attr\">args</span>: any...)</span><br></pre></td></tr></table></figure></p>\n<p>这意味着每一个插件的回调将伴随特定参数args依次被调用。对插件而言这是最简单的格式。很多有用的事件例如”compile”, “this-compilation”，是期望插件同步执行的。  </p>\n<h4 id=\"流式类型\"><a href=\"#流式类型\" class=\"headerlink\" title=\"流式类型\"></a>流式类型</h4><p>waterfall Plugins 通过下面的方式调用<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyPluginsWaterfall(name: string, <span class=\"attr\">init</span>: any, <span class=\"attr\">args</span>: any...)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"异步类型\"><a href=\"#异步类型\" class=\"headerlink\" title=\"异步类型\"></a>异步类型</h4><p>当所有的插件被使用下面的方法异步调用的时候，即为异步插件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyPluginsAsync(name: string, <span class=\"attr\">args</span>: any..., <span class=\"attr\">callback</span>: (err?: <span class=\"built_in\">Error</span>) -&gt; <span class=\"keyword\">void</span>)</span><br></pre></td></tr></table></figure></p>\n<p>插件控制方法被调用，参数是所有的args和带有这种标志(err?: Error) -&gt; void的回调。handler方法按照注册回调在所有handlers被调用之后的顺序来调用。对于”emit”, “run”事件来说这是很常用的模式。</p>\n<h4 id=\"异步流\"><a href=\"#异步流\" class=\"headerlink\" title=\"异步流\"></a>异步流</h4><p>这种插件将按照流失方式来被异步使用  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyPluginsAsyncWaterfall(name: string, <span class=\"attr\">init</span>: any, <span class=\"attr\">callback</span>: (err: <span class=\"built_in\">Error</span>, <span class=\"attr\">result</span>: any) -&gt; <span class=\"keyword\">void</span>)</span><br></pre></td></tr></table></figure>\n<p>这种插件的handler被调用时，参数是当前value和带有这种标志(err?: Error) -&gt; void的回调。当被调用时，nextValue是下一个handler的当前值。第一个handler的当前值是init。所有的handler被调用之后，最后一个值将会被赋给回调。如果有的handler传递了一个err的值，回调将会接受err，并且不会有其他handler被第阿勇。这种插件模式使用与于”before-resolve” and “after-resolve”之类的事件。   </p>\n<h4 id=\"异步系列\"><a href=\"#异步系列\" class=\"headerlink\" title=\"异步系列\"></a>异步系列</h4><p>这种和异步插件很相似，不同在于如果有点插件注册失败，将不会调用任何插件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyPluginsAsyncSeries(name: string, <span class=\"attr\">args</span>: any..., <span class=\"attr\">callback</span>: (err: <span class=\"built_in\">Error</span>, <span class=\"attr\">result</span>: any) -&gt; <span class=\"keyword\">void</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>至此，如何开发一个基本的webpack plugin 我相信大家已经知道了，如果还不太清楚的话，可以移步<a href=\"https://github.com/xiaoxiangdaiyu/w-loader\" target=\"_blank\" rel=\"noopener\">w-loader</a>查看。<br>另外，对于我这种英语渣渣来说，翻译起来确实难度蛮大的。此处抛砖引玉，希望大家共同探讨学习。   </p>\n","site":{"data":{}},"excerpt":"<p>继上回介绍了<a href=\"https://github.com/xiaoxiangdaiyu/w-loader/blob/master/loader/DOC.md\" target=\"_blank\" rel=\"noopener\">如何开发webpack loader</a> 之后。趁热打铁，来继续看下webpack另一个核心组成：plugin。<br>下面也和loader一样，让我们一起从基本的<a href=\"https://webpack.js.org/contribute/writing-a-plugin/\" target=\"_blank\" rel=\"noopener\">官方文档</a>着手看起。<br>","more":"</p>\n<h2 id=\"loader和plugin的差别\"><a href=\"#loader和plugin的差别\" class=\"headerlink\" title=\"loader和plugin的差别\"></a>loader和plugin的差别</h2><ul>\n<li>loader : 顾名思义，某种类型资源文件的加载器，作用于某种类型的文件上。webpack本身也是不能直接打包这些非js文件的，需要一个转化器即loader。 loader本身是单一，简单的，不能将多个功能放在一个loader里。   </li>\n<li>plugin比loaders更加先进一点，你可以扩展webpack的功能来满足自己的需要，换句话说，loader不能满足的时候，就需要plugin了。</li>\n</ul>\n<h2 id=\"如何开发一个plugin\"><a href=\"#如何开发一个plugin\" class=\"headerlink\" title=\"如何开发一个plugin\"></a>如何开发一个plugin</h2><p>插件将webpack引擎所有的能力暴露给第三方开发者。通过阶梯式的build回调，开发者可以在webpack编译过程中加入自己的行为。开发插件比loaders更加先进一点，因为你需要理解webpack一些底层构成来添加钩子回调。准备好读一些源码吧。       </p>\n<h2 id=\"开发一个插件\"><a href=\"#开发一个插件\" class=\"headerlink\" title=\"开发一个插件\"></a>开发一个插件</h2><p>一个webpack的插件由以下几方面组成：  </p>\n<ul>\n<li>一个非匿名的js函数   </li>\n<li>在它的原型对象上定义apply方法  </li>\n<li>指明挂载自身的webpack钩子事件  </li>\n<li>操作webpack内部情况的特定数据  </li>\n<li>方法完成时唤起webpack提供的回调<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A named JavaScript function.</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">MyExampleWebpackPlugin</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"comment\">// Defines `apply` method in it's prototype.</span></span><br><span class=\"line\">MyExampleWebpackPlugin.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compiler</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Specifies webpack's event hook to attach itself.</span></span><br><span class=\"line\">  compiler.plugin(<span class=\"string\">'webpacksEventHook'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compilation <span class=\"regexp\">/* Manipulates webpack internal instance specific data. */</span>, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"This is an example plugin!!!\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">// Invokes webpack provided callback after functionality is complete.</span></span><br><span class=\"line\">    callback();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"编译器和编译\"><a href=\"#编译器和编译\" class=\"headerlink\" title=\"编译器和编译\"></a>编译器和编译</h2><p>开发插件过程中最重要的两个对象就是compiler 和compilation。理解他们的职责是扩展webpack功能最重要的第一步   </p>\n<p>编译器对象就是webpack完整的配置环境。该对象一经webpack开始执行就创建，并且通过所有可操作的设置项来设置，例如options，loaders，和plugins。当在webpack环境中应用一个插件时，该插件将会接受到一个指向该编译器的引用。使用该编译器来访问主要的webpack环境。</p>\n<p>compilation对象是一个单独的关于版本资源的创建。当执行webpack 开发中间件时，当一个文件的更改被检测到就会创建一个新的compilation对象，因此产生了一些可被编译的资源。一个compilation展现了一些信息关于当前模块资源状态、编译资源、改变的文件、监视的依赖等信息。同样提供了很多关键的回调，当插件扩展自定义行为时   </p>\n<p>这两个组件是webpack 插件必需的组成部分(特别是compilation)，所以开发者如果熟悉下面这些源文件将会获益不小。   </p>\n<ul>\n<li><a href=\"https://github.com/webpack/webpack/blob/master/lib/Compiler.js\" target=\"_blank\" rel=\"noopener\">Compiler Source</a>  </li>\n<li><a href=\"https://github.com/webpack/webpack/blob/master/lib/Compilation.js\" target=\"_blank\" rel=\"noopener\">Compilation Source</a>   </li>\n</ul>\n<h2 id=\"插件的基本结构\"><a href=\"#插件的基本结构\" class=\"headerlink\" title=\"插件的基本结构\"></a>插件的基本结构</h2><p>插件是在原型中带有一个apply方法的实例化对象，当安装插件的时候，这个apply方法就会被webpack调用一次。apply方法提供一个指向当前活动的webpack compiler的引用，该引用允许访问compiler的回调。一个简单的插件结构如下：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloWorldPlugin</span>(<span class=\"params\">options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// Setup the plugin instance with options...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">HelloWorldPlugin.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compiler</span>) </span>&#123;</span><br><span class=\"line\">  compiler.plugin(<span class=\"string\">'done'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hello World!'</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = HelloWorldPlugin;</span><br></pre></td></tr></table></figure>\n<p>然后安装一个插件，仅仅需要在你的 webpack config 中plugins对应的数组中，增加一个插件的实例即可   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> HelloWorldPlugin = <span class=\"built_in\">require</span>(<span class=\"string\">'hello-world'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> webpackConfig = &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ... config settings here ...</span></span><br><span class=\"line\">  plugins: [</span><br><span class=\"line\">    <span class=\"keyword\">new</span> HelloWorldPlugin(&#123;<span class=\"attr\">options</span>: <span class=\"literal\">true</span>&#125;)</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h2 id=\"访问编译\"><a href=\"#访问编译\" class=\"headerlink\" title=\"访问编译\"></a>访问编译</h2><p>通过使用编译器对象，你可能会绑定提供指向每个新的compilation应用的回调。这些compilations提供了编译过程中很多步骤的回调函数。   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloCompilationPlugin</span>(<span class=\"params\">options</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">HelloCompilationPlugin.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compiler</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Setup callback for accessing a compilation:</span></span><br><span class=\"line\">  compiler.plugin(<span class=\"string\">\"compilation\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compilation</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Now setup callbacks for accessing compilation steps:</span></span><br><span class=\"line\">    compilation.plugin(<span class=\"string\">\"optimize\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Assets are being optimized.\"</span>);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = HelloCompilationPlugin;</span><br></pre></td></tr></table></figure>\n<p>如果想了解更多关于在编译器、编译中哪些回调是可用的和其他一些更重要的对象，轻戳<a href=\"https://doc.webpack-china.org/api/plugins/\" target=\"_blank\" rel=\"noopener\">plugin文档</a> </p>\n<h2 id=\"异步插件\"><a href=\"#异步插件\" class=\"headerlink\" title=\"异步插件\"></a>异步插件</h2><p>一些编译插件步骤是异步的并且提供了一个当你的插件结束编译时必须调用的回调方法</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">HelloAsyncPlugin</span>(<span class=\"params\">options</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">HelloAsyncPlugin.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compiler</span>) </span>&#123;</span><br><span class=\"line\">  compiler.plugin(<span class=\"string\">\"emit\"</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compilation, callback</span>) </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Do something async...</span></span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">\"Done with async work...\"</span>);</span><br><span class=\"line\">      callback();</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = HelloAsyncPlugin;</span><br></pre></td></tr></table></figure>\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><p>一旦我们打开了webpack编译器和每个单独编译的大门，我们可以使用引擎做的事情是无限可能的。我们可以重新格式化存在的文件、创建派生文件、完全伪造一个新文件  </p>\n<p>让我们写个简单的示例插件，目的是生成一个新的名字为filelist.md的文件。内容如下：列出构建过程中所有的生成文件。这个插件大概如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">FileListPlugin</span>(<span class=\"params\">options</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">FileListPlugin.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compiler</span>) </span>&#123;</span><br><span class=\"line\">  compiler.plugin(<span class=\"string\">'emit'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">compilation, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Create a header string for the generated file:</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> filelist = <span class=\"string\">'In this build:\\n\\n'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Loop through all compiled assets,</span></span><br><span class=\"line\">    <span class=\"comment\">// adding a new line item for each filename.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> filename <span class=\"keyword\">in</span> compilation.assets) &#123;</span><br><span class=\"line\">      filelist += (<span class=\"string\">'- '</span>+ filename +<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Insert this list into the webpack build as a new file asset:</span></span><br><span class=\"line\">    compilation.assets[<span class=\"string\">'filelist.md'</span>] = &#123;</span><br><span class=\"line\">      source: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> filelist;</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      size: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> filelist.length;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    callback();</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = FileListPlugin;</span><br></pre></td></tr></table></figure>\n<h2 id=\"不同类型的插件\"><a href=\"#不同类型的插件\" class=\"headerlink\" title=\"不同类型的插件\"></a>不同类型的插件</h2><p>插件可以依据其注册的事件来分成不同的类型，每个事件钩子决定了在触发时如何调用该插件。  </p>\n<h4 id=\"同步类型\"><a href=\"#同步类型\" class=\"headerlink\" title=\"同步类型\"></a>同步类型</h4><p>这种类型的实例使用如下方式来调用插件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyPlugins(name: string, <span class=\"attr\">args</span>: any...)</span><br><span class=\"line\"></span><br><span class=\"line\">applyPluginsBailResult(name: string, <span class=\"attr\">args</span>: any...)</span><br></pre></td></tr></table></figure></p>\n<p>这意味着每一个插件的回调将伴随特定参数args依次被调用。对插件而言这是最简单的格式。很多有用的事件例如”compile”, “this-compilation”，是期望插件同步执行的。  </p>\n<h4 id=\"流式类型\"><a href=\"#流式类型\" class=\"headerlink\" title=\"流式类型\"></a>流式类型</h4><p>waterfall Plugins 通过下面的方式调用<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyPluginsWaterfall(name: string, <span class=\"attr\">init</span>: any, <span class=\"attr\">args</span>: any...)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"异步类型\"><a href=\"#异步类型\" class=\"headerlink\" title=\"异步类型\"></a>异步类型</h4><p>当所有的插件被使用下面的方法异步调用的时候，即为异步插件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyPluginsAsync(name: string, <span class=\"attr\">args</span>: any..., <span class=\"attr\">callback</span>: (err?: <span class=\"built_in\">Error</span>) -&gt; <span class=\"keyword\">void</span>)</span><br></pre></td></tr></table></figure></p>\n<p>插件控制方法被调用，参数是所有的args和带有这种标志(err?: Error) -&gt; void的回调。handler方法按照注册回调在所有handlers被调用之后的顺序来调用。对于”emit”, “run”事件来说这是很常用的模式。</p>\n<h4 id=\"异步流\"><a href=\"#异步流\" class=\"headerlink\" title=\"异步流\"></a>异步流</h4><p>这种插件将按照流失方式来被异步使用  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyPluginsAsyncWaterfall(name: string, <span class=\"attr\">init</span>: any, <span class=\"attr\">callback</span>: (err: <span class=\"built_in\">Error</span>, <span class=\"attr\">result</span>: any) -&gt; <span class=\"keyword\">void</span>)</span><br></pre></td></tr></table></figure>\n<p>这种插件的handler被调用时，参数是当前value和带有这种标志(err?: Error) -&gt; void的回调。当被调用时，nextValue是下一个handler的当前值。第一个handler的当前值是init。所有的handler被调用之后，最后一个值将会被赋给回调。如果有的handler传递了一个err的值，回调将会接受err，并且不会有其他handler被第阿勇。这种插件模式使用与于”before-resolve” and “after-resolve”之类的事件。   </p>\n<h4 id=\"异步系列\"><a href=\"#异步系列\" class=\"headerlink\" title=\"异步系列\"></a>异步系列</h4><p>这种和异步插件很相似，不同在于如果有点插件注册失败，将不会调用任何插件<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">applyPluginsAsyncSeries(name: string, <span class=\"attr\">args</span>: any..., <span class=\"attr\">callback</span>: (err: <span class=\"built_in\">Error</span>, <span class=\"attr\">result</span>: any) -&gt; <span class=\"keyword\">void</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h4><p>至此，如何开发一个基本的webpack plugin 我相信大家已经知道了，如果还不太清楚的话，可以移步<a href=\"https://github.com/xiaoxiangdaiyu/w-loader\" target=\"_blank\" rel=\"noopener\">w-loader</a>查看。<br>另外，对于我这种英语渣渣来说，翻译起来确实难度蛮大的。此处抛砖引玉，希望大家共同探讨学习。   </p>"},{"title":"带着问题看redux源码","date":"2019-05-20T16:00:00.000Z","_content":"\n## 前言\n作为前端状态管理器，这个比较跨时代的工具库redux有很多实现和思想值得我们思考。在深入源码之前，我们可以相关注下一些常见问题，这样带着问题去看实现，也能更加清晰的了解。  \n<!-- more -->\n### 常见问题\n大概看了下主要有这么几个：  \n\n1. redux三大原则  \n   这个可以直接参考[官方文档](http://cn.redux.js.org/docs/introduction/ThreePrinciples.html)\n2. redux 的优缺点。 关于优缺点，太主观了大家见仁见智。\n3. redux中间件相关，洋葱模型是什么，常见中间件。\n\n\n### 背景\n有关acton，reducer相关的部分可以看[我前面的文章](https://juejin.im/post/5b208ef06fb9a01e615ed8cb)。我们主要关注针对store和中间件相关的部分来解读。\n\n## store的创建\n作为维护和管理数据的部分，store在redux中的作用十分重要。在action发出指令，reduxer进行数据更新之后，监听数据变化和同步数据更新的操作都要借助store来实现。  \n\n### createStore 输入和输出\n首先看下createStore的使用,即常见的就是接受经过[combineReducers处理之后的reducer](https://juejin.im/post/5b208ef06fb9a01e615ed8cb#heading-8)和初始的state\n\n```js\nimport reducer from './reducers'\nconst store = createStore(reducer,initialState)\n```\n此外还可以接受第三个参数enhancer(增强器,一般就是applyMiddleware)\n\n```js\n\n/**\n * 创建管理state 树的Redux store\n * 应用中只能存在一个store，为了区分不同action对应的reducer，\n * 可以通过combineReducers来关联不同的reducer\n * @param {Function} reducer   combineReducers关联之后的reducer\n * @param {Object} preloadedState 初始state\n * @param {Function} enhancer 可以增强store功能的函数，例如中间件等。唯一适合\n * @returns 返回一个Store 以维护state和监听变化  \n */\nexport default function createStore(reducer, preloadedState, enhancer) {\n  // 如果第二个参数为func，redux认为忽略了初始state，而是\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    // enhancer增强剂，即利用中间件等来增强redux能力\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n  // 返回具有dispatch等属性的对象 即store\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  }\n } \n```\n按照一般的执行顺序，我们先看下对于参数的处理(平时大家也是一样，一个函数，执行之前尽量判断入参是否符合预期，避免直接处理造成的错误)\n### 入参处理\n对于三个参数，后两个是非必填的，但如果第二个参数是function，reduxe认为其实encher，不然初始状态是个函数不符合redux的预期，只能这样处理了。   \n\n```js\n// 如果第二个参数为func，redux认为忽略了初始state，而是\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    // enhancer增强剂，即利用中间件等来增强redux能力\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n    // 对于存在的enhancer,高阶函数函数的用法，\n    // 接受createStore返回一个增加功能之后的函数，然后再传入相关reducer得到store。\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.')\n  }\n  // 一切符合预期，没有 enhancer，那么初始赋值\n  let currentReducer = reducer\n  let currentState = preloadedState\n  let currentListeners = []\n  // 监听队列\n  let nextListeners = currentListeners\n  // dispatch标识\n  let isDispatching = false\n  \n  // 初始状态更新之后，声明init状态完成。\n  dispatch({ type: ActionTypes.INIT })\n\n```\n\n\n### dispatch的实现\ndispatch的作用就是根据action，执行对应reducer以更新state。并执行监听队列。  \n下面就来看dispatch的用法和实现。\n常见使用：\n```js\n// redux要求 参数必须为纯对象\ndispatch({ type: ActionTypes.INIT })\n```\n那么对于纯对象，redux做了些什么呢  \n\n```js\n /**\n   * 通知方法，参数为纯的js对象，标明更新内容\n   * @param {Object} action \n   */\n  function dispatch(action) {\n    // 是否满足纯净对象\n    if (!isPlainObject(action)) {\n      throw new Error(\n        '省略'\n      )\n    }\n    // 必须的type是否存在 \n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        '省略'\n      )\n    }\n    // 判断是否处于某个action的dispatch中，大家一起dispatch可能死循环\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.')\n    }\n\n    try {\n      // 开始dispatch，加锁，标明状态\n      isDispatching = true\n      // 将当前状态和更新action，传给当前reducer处理\n      // 这里可以回想下我们reducer中的两个参数，state和action 对应的是什么\n      /**\n       * const todos = (state = [], action) => {\n       */\n      currentState = currentReducer(currentState, action)\n    } finally {\n      // 有异常，锁置为false，不影响别的dispatch\n      isDispatching = false\n    }\n    // 执行dispatch，并且更新当前监听队列为 最新队列\n    const listeners = (currentListeners = nextListeners)\n    // 依次执行，监听器\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    return action\n  }\n```\n\ncreateStore初始化完成之后会执行dispatch({ type: ActionTypes.INIT })，此时执行初始化操作。\n\n我们要关注下currentState的计算，  \n将currentState，action传给reducer处理，然后更新currentState。\n\n针对初始化来说currentState其实就是initState：  \n\n```js\n// 初始化状态\nlet currentState = preloadedState\n/****省略***/\n// 这里可以回想下我们reducer中的两个参数，state和action对应的值\ncurrentState = currentReducer(currentState, action)\n``` \n\nreducer示例：\n\n```js\nconst todos = (state = [], action) => {\nswitch (action.type) {\n    case 'ADD_TODO':\n      return [\n        ...state,\n        {\n          id: action.id,\n          text: action.text,\n          completed: false\n        }\n      ]\n    }\n```\n\n### getSate实现  \ngetState就是获得store的state。这个比较简单。当结合react-redux使用时，其会帮我们进行操作。我们就不用自行调用这个方法了，所以不要疑惑从哪里获取的state。  \n\n```js\n/**\n   * 返回应用当前状态\n   * 不过需要看下当前是否有更新正在进行，是的话则提示\n   */\n  function getState() {\n    // 判断是否isDispatching 中\n    if (isDispatching) {\n      throw new Error('省略')\n    }\n    return currentState\n  }\n```\n\n### subscribe\nsubscribe是比较重要的一个方法，用来供我们监听状态的变化，以执行相关操作。  \n例如react-redux中的handleChange 会对是否pure组件及state进行对比，以提升渲染效率。   \n\n**示例：**\n\n```js\n this.unsubscribe = this.store.subscribe(this.handleChange.bind(this))\n```\n\n**实现：**\n返回的是一个函数，可以进行unsubscribe操作。\n\n```js\n/** \n   * 订阅通知\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.')\n    }\n\n    if (isDispatching) {\n      throw new Error(\n        '省略'\n      )\n    }\n    // 是否已经监听过\n    let isSubscribed = true\n    // 监听队列是否相同，区分开，操作nextListeners\n    ensureCanMutateNextListeners()\n    // 新增监听事件\n    nextListeners.push(listener)\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return\n      }\n\n      if (isDispatching) {\n        throw new Error(\n          '省略'\n        )\n      }\n      // 注册完成，可以进行取消操作\n      isSubscribed = false\n      // 保持事件队列 同步\n      ensureCanMutateNextListeners()\n      const index = nextListeners.indexOf(listener)\n      // 删除监听事件\n      nextListeners.splice(index, 1)\n    }\n  }\n\n```\n\n### replaceReducer\n这个开发比较少用，用于热更新\n\n```js\n// 用于reducer的热替换，开发中一般不会直接使用\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.')\n    }\n\n    currentReducer = nextReducer\n    // 更新值之后，进行dispatch。\n    dispatch({ type: ActionTypes.REPLACE })\n  }\n```\n 到这里createStore已经解析完成了，大家应该了解该方法到底做了些什么操作吧。  \n 简单概括一下就是：接收reducer和initState，返回一个store 对象。该对象提供了监听、分发等功能，以实现数据的更新。\n\n## 实际使用中的问题\n经过上面的解读之后,对于redux的常规应用应该有所了解了。不过实际使用中可能会遇到些问题。  \n例如action要求是纯对象，而我们获取数据一般是异步的，这就需要借助redux-thunk这个中间件了。  \nactionCreater返回一个函数。如下：  \n\n```js\nexport function func1() {\n  return dispatch => {\n      dispatch({\n      type:'test',\n      data:'a'\n      })\n  }\n}\n```\n\n在了解如何实现之前，需要先看下redux中间件的原理。\n因为reducer更多的关注的是数据的操作，对于一些公共的方法，需要抽离出来，不过这些方法在何时使用呢，redux为我们提供了中间件来满足需求。\n  \n\n## redux中间件原理\nredux 借鉴了 Koa里 middleware 的思想，即鼎鼎大名的洋葱模型。\n<img src='/img/redux/middleware.jpg'/>\n\n不过这里请求对应的是dispatch的过程。  \n\n每次dispatch的过程中，都要依次将中间件执行一遍。  \n遇到阻塞或者操作完成，执行下个中间件，直到执行完成，以便我们事先日志，监控、异常上报等功能。  \n那么redux 又是如何支持中间件的呢。这就离不开applyMiddleware了。  \n这里前面的\n \n### applyMiddleware实现思路\n\n实现思想比较简单,通过科里化和compose，为符合规范的中间件分配访问dispatch和store的途径，以便在不同阶段来自定义数据更新。  \n例如异步操作，返回的不是对象，那么就执行返回的函数，然后调用下一个中间件。等异步请求结束，再次dispatch 对应的action。   \n\n```js\nexport default function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    const store = createStore(...args)\n    let dispatch = () => {\n      throw new Error(\n        `Dispatching while constructing your middleware is not allowed. ` +\n          `Other middleware would not be applied to this dispatch.`\n      )\n    }\n    // 赋予每个中间件访问store的能力。\n    const middlewareAPI = {\n      getState: store.getState,\n      // 箭头函数保存dispatch，保证其的同步更新\n      dispatch: (...args) => dispatch(...args)\n    }\n    // 串联中间件，并赋予每个中间件访问dispatch的能力。\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    // 关联dispatch与中间件，组合调用之后得到类似下面的新对象\n    // dispatch = f1(f2(f3(store.dispatch))));\n    dispatch = compose(...chain)(store.dispatch)\n    \n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\n这样执行之后返回的，对象就是增强之后的store了。\n### compose的实现\nredux中compose是柯里化函数的一个示例，目的是将函数串联起来。 \n \n```js\n/**\n * 函数组合，科里化的串联\n */\nexport default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n```\n\n\n### 结合redux-thunk示例  \nredux-thunk源码，实现也很优雅，对于返回的function，将dispatch等参数传递进去，然后执行，等待回调异步完成再dispatch。对于正常对象则进行下一步。\n\n```js\nfunction createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) => next => action => {\n    // 每次dispatch的时候都会进行判断，如果是个函数，那就执行函数，不再进行下一步吧，这样就避免了，函数不满足action要求的问题\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n```\n那么实际使用时,在createStore时加入该中间件即可：  \n\n```js\nimport { createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk';\nconst store = createStore(\n  reducer,\n  applyMiddleware({\n  ...middleware,\n  thunk})\n)\n```\n\n那么到这里对于redux的中间件 也就是问题2，我想大家也比较清楚了。  \n对于常见中间件可以参考\n\n## 结束语\n### 参考文章  \n[redux中文文档](http://cn.redux.js.org/docs/recipes/ServerRendering.html)   \n[深入React技术栈](http://product.dangdang.com/24135483.html)  \n\n加上[重读redux源码一](https://juejin.im/post/5b208ef06fb9a01e615ed8cb#heading-8)和[带着问题看 react-redux 源码实现](https://juejin.im/post/5ce25a76e51d4510835e01f3)总算将redux及react-redux重读了一遍。可能有人会说道这些源码，看完也会忘，有这个必要吗。我感觉分情况来看，如果我们只是使用，那么看官方文档就可以了，当遇到某些疑问好像找不到贴切解释的时候，不放一看。  \n此外也是学习大佬们的设计思路和实现方式，有的放矢才能开卷有益。  \n\n\n\n\n\n\n\n\n\n","source":"_posts/redux/redux2.md","raw":"---\ntitle: 带着问题看redux源码\ndate: 2019-05-21\n---\n\n## 前言\n作为前端状态管理器，这个比较跨时代的工具库redux有很多实现和思想值得我们思考。在深入源码之前，我们可以相关注下一些常见问题，这样带着问题去看实现，也能更加清晰的了解。  \n<!-- more -->\n### 常见问题\n大概看了下主要有这么几个：  \n\n1. redux三大原则  \n   这个可以直接参考[官方文档](http://cn.redux.js.org/docs/introduction/ThreePrinciples.html)\n2. redux 的优缺点。 关于优缺点，太主观了大家见仁见智。\n3. redux中间件相关，洋葱模型是什么，常见中间件。\n\n\n### 背景\n有关acton，reducer相关的部分可以看[我前面的文章](https://juejin.im/post/5b208ef06fb9a01e615ed8cb)。我们主要关注针对store和中间件相关的部分来解读。\n\n## store的创建\n作为维护和管理数据的部分，store在redux中的作用十分重要。在action发出指令，reduxer进行数据更新之后，监听数据变化和同步数据更新的操作都要借助store来实现。  \n\n### createStore 输入和输出\n首先看下createStore的使用,即常见的就是接受经过[combineReducers处理之后的reducer](https://juejin.im/post/5b208ef06fb9a01e615ed8cb#heading-8)和初始的state\n\n```js\nimport reducer from './reducers'\nconst store = createStore(reducer,initialState)\n```\n此外还可以接受第三个参数enhancer(增强器,一般就是applyMiddleware)\n\n```js\n\n/**\n * 创建管理state 树的Redux store\n * 应用中只能存在一个store，为了区分不同action对应的reducer，\n * 可以通过combineReducers来关联不同的reducer\n * @param {Function} reducer   combineReducers关联之后的reducer\n * @param {Object} preloadedState 初始state\n * @param {Function} enhancer 可以增强store功能的函数，例如中间件等。唯一适合\n * @returns 返回一个Store 以维护state和监听变化  \n */\nexport default function createStore(reducer, preloadedState, enhancer) {\n  // 如果第二个参数为func，redux认为忽略了初始state，而是\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    // enhancer增强剂，即利用中间件等来增强redux能力\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n  // 返回具有dispatch等属性的对象 即store\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable\n  }\n } \n```\n按照一般的执行顺序，我们先看下对于参数的处理(平时大家也是一样，一个函数，执行之前尽量判断入参是否符合预期，避免直接处理造成的错误)\n### 入参处理\n对于三个参数，后两个是非必填的，但如果第二个参数是function，reduxe认为其实encher，不然初始状态是个函数不符合redux的预期，只能这样处理了。   \n\n```js\n// 如果第二个参数为func，redux认为忽略了初始state，而是\n  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n    // enhancer增强剂，即利用中间件等来增强redux能力\n    enhancer = preloadedState\n    preloadedState = undefined\n  }\n\n  if (typeof enhancer !== 'undefined') {\n    if (typeof enhancer !== 'function') {\n      throw new Error('Expected the enhancer to be a function.')\n    }\n    // 对于存在的enhancer,高阶函数函数的用法，\n    // 接受createStore返回一个增加功能之后的函数，然后再传入相关reducer得到store。\n    return enhancer(createStore)(reducer, preloadedState)\n  }\n\n  if (typeof reducer !== 'function') {\n    throw new Error('Expected the reducer to be a function.')\n  }\n  // 一切符合预期，没有 enhancer，那么初始赋值\n  let currentReducer = reducer\n  let currentState = preloadedState\n  let currentListeners = []\n  // 监听队列\n  let nextListeners = currentListeners\n  // dispatch标识\n  let isDispatching = false\n  \n  // 初始状态更新之后，声明init状态完成。\n  dispatch({ type: ActionTypes.INIT })\n\n```\n\n\n### dispatch的实现\ndispatch的作用就是根据action，执行对应reducer以更新state。并执行监听队列。  \n下面就来看dispatch的用法和实现。\n常见使用：\n```js\n// redux要求 参数必须为纯对象\ndispatch({ type: ActionTypes.INIT })\n```\n那么对于纯对象，redux做了些什么呢  \n\n```js\n /**\n   * 通知方法，参数为纯的js对象，标明更新内容\n   * @param {Object} action \n   */\n  function dispatch(action) {\n    // 是否满足纯净对象\n    if (!isPlainObject(action)) {\n      throw new Error(\n        '省略'\n      )\n    }\n    // 必须的type是否存在 \n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        '省略'\n      )\n    }\n    // 判断是否处于某个action的dispatch中，大家一起dispatch可能死循环\n    if (isDispatching) {\n      throw new Error('Reducers may not dispatch actions.')\n    }\n\n    try {\n      // 开始dispatch，加锁，标明状态\n      isDispatching = true\n      // 将当前状态和更新action，传给当前reducer处理\n      // 这里可以回想下我们reducer中的两个参数，state和action 对应的是什么\n      /**\n       * const todos = (state = [], action) => {\n       */\n      currentState = currentReducer(currentState, action)\n    } finally {\n      // 有异常，锁置为false，不影响别的dispatch\n      isDispatching = false\n    }\n    // 执行dispatch，并且更新当前监听队列为 最新队列\n    const listeners = (currentListeners = nextListeners)\n    // 依次执行，监听器\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i]\n      listener()\n    }\n\n    return action\n  }\n```\n\ncreateStore初始化完成之后会执行dispatch({ type: ActionTypes.INIT })，此时执行初始化操作。\n\n我们要关注下currentState的计算，  \n将currentState，action传给reducer处理，然后更新currentState。\n\n针对初始化来说currentState其实就是initState：  \n\n```js\n// 初始化状态\nlet currentState = preloadedState\n/****省略***/\n// 这里可以回想下我们reducer中的两个参数，state和action对应的值\ncurrentState = currentReducer(currentState, action)\n``` \n\nreducer示例：\n\n```js\nconst todos = (state = [], action) => {\nswitch (action.type) {\n    case 'ADD_TODO':\n      return [\n        ...state,\n        {\n          id: action.id,\n          text: action.text,\n          completed: false\n        }\n      ]\n    }\n```\n\n### getSate实现  \ngetState就是获得store的state。这个比较简单。当结合react-redux使用时，其会帮我们进行操作。我们就不用自行调用这个方法了，所以不要疑惑从哪里获取的state。  \n\n```js\n/**\n   * 返回应用当前状态\n   * 不过需要看下当前是否有更新正在进行，是的话则提示\n   */\n  function getState() {\n    // 判断是否isDispatching 中\n    if (isDispatching) {\n      throw new Error('省略')\n    }\n    return currentState\n  }\n```\n\n### subscribe\nsubscribe是比较重要的一个方法，用来供我们监听状态的变化，以执行相关操作。  \n例如react-redux中的handleChange 会对是否pure组件及state进行对比，以提升渲染效率。   \n\n**示例：**\n\n```js\n this.unsubscribe = this.store.subscribe(this.handleChange.bind(this))\n```\n\n**实现：**\n返回的是一个函数，可以进行unsubscribe操作。\n\n```js\n/** \n   * 订阅通知\n   */\n  function subscribe(listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('Expected the listener to be a function.')\n    }\n\n    if (isDispatching) {\n      throw new Error(\n        '省略'\n      )\n    }\n    // 是否已经监听过\n    let isSubscribed = true\n    // 监听队列是否相同，区分开，操作nextListeners\n    ensureCanMutateNextListeners()\n    // 新增监听事件\n    nextListeners.push(listener)\n\n    return function unsubscribe() {\n      if (!isSubscribed) {\n        return\n      }\n\n      if (isDispatching) {\n        throw new Error(\n          '省略'\n        )\n      }\n      // 注册完成，可以进行取消操作\n      isSubscribed = false\n      // 保持事件队列 同步\n      ensureCanMutateNextListeners()\n      const index = nextListeners.indexOf(listener)\n      // 删除监听事件\n      nextListeners.splice(index, 1)\n    }\n  }\n\n```\n\n### replaceReducer\n这个开发比较少用，用于热更新\n\n```js\n// 用于reducer的热替换，开发中一般不会直接使用\n  function replaceReducer(nextReducer) {\n    if (typeof nextReducer !== 'function') {\n      throw new Error('Expected the nextReducer to be a function.')\n    }\n\n    currentReducer = nextReducer\n    // 更新值之后，进行dispatch。\n    dispatch({ type: ActionTypes.REPLACE })\n  }\n```\n 到这里createStore已经解析完成了，大家应该了解该方法到底做了些什么操作吧。  \n 简单概括一下就是：接收reducer和initState，返回一个store 对象。该对象提供了监听、分发等功能，以实现数据的更新。\n\n## 实际使用中的问题\n经过上面的解读之后,对于redux的常规应用应该有所了解了。不过实际使用中可能会遇到些问题。  \n例如action要求是纯对象，而我们获取数据一般是异步的，这就需要借助redux-thunk这个中间件了。  \nactionCreater返回一个函数。如下：  \n\n```js\nexport function func1() {\n  return dispatch => {\n      dispatch({\n      type:'test',\n      data:'a'\n      })\n  }\n}\n```\n\n在了解如何实现之前，需要先看下redux中间件的原理。\n因为reducer更多的关注的是数据的操作，对于一些公共的方法，需要抽离出来，不过这些方法在何时使用呢，redux为我们提供了中间件来满足需求。\n  \n\n## redux中间件原理\nredux 借鉴了 Koa里 middleware 的思想，即鼎鼎大名的洋葱模型。\n<img src='/img/redux/middleware.jpg'/>\n\n不过这里请求对应的是dispatch的过程。  \n\n每次dispatch的过程中，都要依次将中间件执行一遍。  \n遇到阻塞或者操作完成，执行下个中间件，直到执行完成，以便我们事先日志，监控、异常上报等功能。  \n那么redux 又是如何支持中间件的呢。这就离不开applyMiddleware了。  \n这里前面的\n \n### applyMiddleware实现思路\n\n实现思想比较简单,通过科里化和compose，为符合规范的中间件分配访问dispatch和store的途径，以便在不同阶段来自定义数据更新。  \n例如异步操作，返回的不是对象，那么就执行返回的函数，然后调用下一个中间件。等异步请求结束，再次dispatch 对应的action。   \n\n```js\nexport default function applyMiddleware(...middlewares) {\n  return createStore => (...args) => {\n    const store = createStore(...args)\n    let dispatch = () => {\n      throw new Error(\n        `Dispatching while constructing your middleware is not allowed. ` +\n          `Other middleware would not be applied to this dispatch.`\n      )\n    }\n    // 赋予每个中间件访问store的能力。\n    const middlewareAPI = {\n      getState: store.getState,\n      // 箭头函数保存dispatch，保证其的同步更新\n      dispatch: (...args) => dispatch(...args)\n    }\n    // 串联中间件，并赋予每个中间件访问dispatch的能力。\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    // 关联dispatch与中间件，组合调用之后得到类似下面的新对象\n    // dispatch = f1(f2(f3(store.dispatch))));\n    dispatch = compose(...chain)(store.dispatch)\n    \n\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\n这样执行之后返回的，对象就是增强之后的store了。\n### compose的实现\nredux中compose是柯里化函数的一个示例，目的是将函数串联起来。 \n \n```js\n/**\n * 函数组合，科里化的串联\n */\nexport default function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n```\n\n\n### 结合redux-thunk示例  \nredux-thunk源码，实现也很优雅，对于返回的function，将dispatch等参数传递进去，然后执行，等待回调异步完成再dispatch。对于正常对象则进行下一步。\n\n```js\nfunction createThunkMiddleware(extraArgument) {\n  return ({ dispatch, getState }) => next => action => {\n    // 每次dispatch的时候都会进行判断，如果是个函数，那就执行函数，不再进行下一步吧，这样就避免了，函数不满足action要求的问题\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n\n    return next(action);\n  };\n}\n\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\n\nexport default thunk;\n```\n那么实际使用时,在createStore时加入该中间件即可：  \n\n```js\nimport { createStore, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk';\nconst store = createStore(\n  reducer,\n  applyMiddleware({\n  ...middleware,\n  thunk})\n)\n```\n\n那么到这里对于redux的中间件 也就是问题2，我想大家也比较清楚了。  \n对于常见中间件可以参考\n\n## 结束语\n### 参考文章  \n[redux中文文档](http://cn.redux.js.org/docs/recipes/ServerRendering.html)   \n[深入React技术栈](http://product.dangdang.com/24135483.html)  \n\n加上[重读redux源码一](https://juejin.im/post/5b208ef06fb9a01e615ed8cb#heading-8)和[带着问题看 react-redux 源码实现](https://juejin.im/post/5ce25a76e51d4510835e01f3)总算将redux及react-redux重读了一遍。可能有人会说道这些源码，看完也会忘，有这个必要吗。我感觉分情况来看，如果我们只是使用，那么看官方文档就可以了，当遇到某些疑问好像找不到贴切解释的时候，不放一看。  \n此外也是学习大佬们的设计思路和实现方式，有的放矢才能开卷有益。  \n\n\n\n\n\n\n\n\n\n","slug":"redux/redux2","published":1,"updated":"2019-05-21T07:54:39.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt7y001hgw92e308010r","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为前端状态管理器，这个比较跨时代的工具库redux有很多实现和思想值得我们思考。在深入源码之前，我们可以相关注下一些常见问题，这样带着问题去看实现，也能更加清晰的了解。<br><a id=\"more\"></a></p>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3><p>大概看了下主要有这么几个：  </p>\n<ol>\n<li>redux三大原则<br>这个可以直接参考<a href=\"http://cn.redux.js.org/docs/introduction/ThreePrinciples.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>redux 的优缺点。 关于优缺点，太主观了大家见仁见智。</li>\n<li>redux中间件相关，洋葱模型是什么，常见中间件。</li>\n</ol>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>有关acton，reducer相关的部分可以看<a href=\"https://juejin.im/post/5b208ef06fb9a01e615ed8cb\" target=\"_blank\" rel=\"noopener\">我前面的文章</a>。我们主要关注针对store和中间件相关的部分来解读。</p>\n<h2 id=\"store的创建\"><a href=\"#store的创建\" class=\"headerlink\" title=\"store的创建\"></a>store的创建</h2><p>作为维护和管理数据的部分，store在redux中的作用十分重要。在action发出指令，reduxer进行数据更新之后，监听数据变化和同步数据更新的操作都要借助store来实现。  </p>\n<h3 id=\"createStore-输入和输出\"><a href=\"#createStore-输入和输出\" class=\"headerlink\" title=\"createStore 输入和输出\"></a>createStore 输入和输出</h3><p>首先看下createStore的使用,即常见的就是接受经过<a href=\"https://juejin.im/post/5b208ef06fb9a01e615ed8cb#heading-8\" target=\"_blank\" rel=\"noopener\">combineReducers处理之后的reducer</a>和初始的state</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer,initialState)</span><br></pre></td></tr></table></figure>\n<p>此外还可以接受第三个参数enhancer(增强器,一般就是applyMiddleware)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建管理state 树的Redux store</span></span><br><span class=\"line\"><span class=\"comment\"> * 应用中只能存在一个store，为了区分不同action对应的reducer，</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以通过combineReducers来关联不同的reducer</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Function&#125; reducer   combineReducers关联之后的reducer</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Object&#125; preloadedState 初始state</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Function&#125; enhancer 可以增强store功能的函数，例如中间件等。唯一适合</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns 返回一个Store 以维护state和监听变化  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果第二个参数为func，redux认为忽略了初始state，而是</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// enhancer增强剂，即利用中间件等来增强redux能力</span></span><br><span class=\"line\">    enhancer = preloadedState</span><br><span class=\"line\">    preloadedState = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回具有dispatch等属性的对象 即store</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    dispatch,</span><br><span class=\"line\">    subscribe,</span><br><span class=\"line\">    getState,</span><br><span class=\"line\">    replaceReducer,</span><br><span class=\"line\">    [$$observable]: observable</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>按照一般的执行顺序，我们先看下对于参数的处理(平时大家也是一样，一个函数，执行之前尽量判断入参是否符合预期，避免直接处理造成的错误)</p>\n<h3 id=\"入参处理\"><a href=\"#入参处理\" class=\"headerlink\" title=\"入参处理\"></a>入参处理</h3><p>对于三个参数，后两个是非必填的，但如果第二个参数是function，reduxe认为其实encher，不然初始状态是个函数不符合redux的预期，只能这样处理了。   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果第二个参数为func，redux认为忽略了初始state，而是</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// enhancer增强剂，即利用中间件等来增强redux能力</span></span><br><span class=\"line\">    enhancer = preloadedState</span><br><span class=\"line\">    preloadedState = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the enhancer to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 对于存在的enhancer,高阶函数函数的用法，</span></span><br><span class=\"line\">    <span class=\"comment\">// 接受createStore返回一个增加功能之后的函数，然后再传入相关reducer得到store。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the reducer to be a function.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 一切符合预期，没有 enhancer，那么初始赋值</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentReducer = reducer</span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState = preloadedState</span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentListeners = []</span><br><span class=\"line\">  <span class=\"comment\">// 监听队列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextListeners = currentListeners</span><br><span class=\"line\">  <span class=\"comment\">// dispatch标识</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isDispatching = <span class=\"literal\">false</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 初始状态更新之后，声明init状态完成。</span></span><br><span class=\"line\">  dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"dispatch的实现\"><a href=\"#dispatch的实现\" class=\"headerlink\" title=\"dispatch的实现\"></a>dispatch的实现</h3><p>dispatch的作用就是根据action，执行对应reducer以更新state。并执行监听队列。<br>下面就来看dispatch的用法和实现。<br>常见使用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// redux要求 参数必须为纯对象</span></span><br><span class=\"line\">dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>那么对于纯对象，redux做了些什么呢  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 通知方法，参数为纯的js对象，标明更新内容</span></span><br><span class=\"line\"><span class=\"comment\">  * @param &#123;Object&#125; action </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 是否满足纯净对象</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!isPlainObject(action)) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">       <span class=\"string\">'省略'</span></span><br><span class=\"line\">     )</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 必须的type是否存在 </span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action.type === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">       <span class=\"string\">'省略'</span></span><br><span class=\"line\">     )</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 判断是否处于某个action的dispatch中，大家一起dispatch可能死循环</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Reducers may not dispatch actions.'</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 开始dispatch，加锁，标明状态</span></span><br><span class=\"line\">     isDispatching = <span class=\"literal\">true</span></span><br><span class=\"line\">     <span class=\"comment\">// 将当前状态和更新action，传给当前reducer处理</span></span><br><span class=\"line\">     <span class=\"comment\">// 这里可以回想下我们reducer中的两个参数，state和action 对应的是什么</span></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * const todos = (state = [], action) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     currentState = currentReducer(currentState, action)</span><br><span class=\"line\">   &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 有异常，锁置为false，不影响别的dispatch</span></span><br><span class=\"line\">     isDispatching = <span class=\"literal\">false</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 执行dispatch，并且更新当前监听队列为 最新队列</span></span><br><span class=\"line\">   <span class=\"keyword\">const</span> listeners = (currentListeners = nextListeners)</span><br><span class=\"line\">   <span class=\"comment\">// 依次执行，监听器</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> listener = listeners[i]</span><br><span class=\"line\">     listener()</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> action</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>createStore初始化完成之后会执行dispatch({ type: ActionTypes.INIT })，此时执行初始化操作。</p>\n<p>我们要关注下currentState的计算，<br>将currentState，action传给reducer处理，然后更新currentState。</p>\n<p>针对初始化来说currentState其实就是initState：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化状态</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> currentState = preloadedState</span><br><span class=\"line\"><span class=\"comment\">/****省略***/</span></span><br><span class=\"line\"><span class=\"comment\">// 这里可以回想下我们reducer中的两个参数，state和action对应的值</span></span><br><span class=\"line\">currentState = currentReducer(currentState, action)</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">reducer示例：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">const</span> todos = <span class=\"function\">(<span class=\"params\">state = [], action</span>) =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          id: action.id,</span><br><span class=\"line\">          text: action.text,</span><br><span class=\"line\">          completed: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"getSate实现\"><a href=\"#getSate实现\" class=\"headerlink\" title=\"getSate实现\"></a>getSate实现</h3><p>getState就是获得store的state。这个比较简单。当结合react-redux使用时，其会帮我们进行操作。我们就不用自行调用这个方法了，所以不要疑惑从哪里获取的state。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 返回应用当前状态</span></span><br><span class=\"line\"><span class=\"comment\">   * 不过需要看下当前是否有更新正在进行，是的话则提示</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否isDispatching 中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'省略'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"subscribe\"><a href=\"#subscribe\" class=\"headerlink\" title=\"subscribe\"></a>subscribe</h3><p>subscribe是比较重要的一个方法，用来供我们监听状态的变化，以执行相关操作。<br>例如react-redux中的handleChange 会对是否pure组件及state进行对比，以提升渲染效率。   </p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.unsubscribe = <span class=\"keyword\">this</span>.store.subscribe(<span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>))</span><br></pre></td></tr></table></figure>\n<p><strong>实现：</strong><br>返回的是一个函数，可以进行unsubscribe操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">   * 订阅通知</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> listener !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the listener to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'省略'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 是否已经监听过</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isSubscribed = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\">// 监听队列是否相同，区分开，操作nextListeners</span></span><br><span class=\"line\">    ensureCanMutateNextListeners()</span><br><span class=\"line\">    <span class=\"comment\">// 新增监听事件</span></span><br><span class=\"line\">    nextListeners.push(listener)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unsubscribe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isSubscribed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">          <span class=\"string\">'省略'</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 注册完成，可以进行取消操作</span></span><br><span class=\"line\">      isSubscribed = <span class=\"literal\">false</span></span><br><span class=\"line\">      <span class=\"comment\">// 保持事件队列 同步</span></span><br><span class=\"line\">      ensureCanMutateNextListeners()</span><br><span class=\"line\">      <span class=\"keyword\">const</span> index = nextListeners.indexOf(listener)</span><br><span class=\"line\">      <span class=\"comment\">// 删除监听事件</span></span><br><span class=\"line\">      nextListeners.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"replaceReducer\"><a href=\"#replaceReducer\" class=\"headerlink\" title=\"replaceReducer\"></a>replaceReducer</h3><p>这个开发比较少用，用于热更新</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于reducer的热替换，开发中一般不会直接使用</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replaceReducer</span>(<span class=\"params\">nextReducer</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextReducer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the nextReducer to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentReducer = nextReducer</span><br><span class=\"line\">    <span class=\"comment\">// 更新值之后，进行dispatch。</span></span><br><span class=\"line\">    dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.REPLACE &#125;)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p> 到这里createStore已经解析完成了，大家应该了解该方法到底做了些什么操作吧。<br> 简单概括一下就是：接收reducer和initState，返回一个store 对象。该对象提供了监听、分发等功能，以实现数据的更新。</p>\n<h2 id=\"实际使用中的问题\"><a href=\"#实际使用中的问题\" class=\"headerlink\" title=\"实际使用中的问题\"></a>实际使用中的问题</h2><p>经过上面的解读之后,对于redux的常规应用应该有所了解了。不过实际使用中可能会遇到些问题。<br>例如action要求是纯对象，而我们获取数据一般是异步的，这就需要借助redux-thunk这个中间件了。<br>actionCreater返回一个函数。如下：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">      type:<span class=\"string\">'test'</span>,</span><br><span class=\"line\">      data:<span class=\"string\">'a'</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在了解如何实现之前，需要先看下redux中间件的原理。<br>因为reducer更多的关注的是数据的操作，对于一些公共的方法，需要抽离出来，不过这些方法在何时使用呢，redux为我们提供了中间件来满足需求。</p>\n<h2 id=\"redux中间件原理\"><a href=\"#redux中间件原理\" class=\"headerlink\" title=\"redux中间件原理\"></a>redux中间件原理</h2><p>redux 借鉴了 Koa里 middleware 的思想，即鼎鼎大名的洋葱模型。<br><img src=\"/img/redux/middleware.jpg\"></p>\n<p>不过这里请求对应的是dispatch的过程。  </p>\n<p>每次dispatch的过程中，都要依次将中间件执行一遍。<br>遇到阻塞或者操作完成，执行下个中间件，直到执行完成，以便我们事先日志，监控、异常上报等功能。<br>那么redux 又是如何支持中间件的呢。这就离不开applyMiddleware了。<br>这里前面的</p>\n<h3 id=\"applyMiddleware实现思路\"><a href=\"#applyMiddleware实现思路\" class=\"headerlink\" title=\"applyMiddleware实现思路\"></a>applyMiddleware实现思路</h3><p>实现思想比较简单,通过科里化和compose，为符合规范的中间件分配访问dispatch和store的途径，以便在不同阶段来自定义数据更新。<br>例如异步操作，返回的不是对象，那么就执行返回的函数，然后调用下一个中间件。等异步请求结束，再次dispatch 对应的action。   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">createStore</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = createStore(...args)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dispatch = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">`Dispatching while constructing your middleware is not allowed. `</span> +</span><br><span class=\"line\">          <span class=\"string\">`Other middleware would not be applied to this dispatch.`</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 赋予每个中间件访问store的能力。</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> middlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      <span class=\"comment\">// 箭头函数保存dispatch，保证其的同步更新</span></span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 串联中间件，并赋予每个中间件访问dispatch的能力。</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\">    <span class=\"comment\">// 关联dispatch与中间件，组合调用之后得到类似下面的新对象</span></span><br><span class=\"line\">    <span class=\"comment\">// dispatch = f1(f2(f3(store.dispatch))));</span></span><br><span class=\"line\">    dispatch = compose(...chain)(store.dispatch)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样执行之后返回的，对象就是增强之后的store了。</p>\n<h3 id=\"compose的实现\"><a href=\"#compose的实现\" class=\"headerlink\" title=\"compose的实现\"></a>compose的实现</h3><p>redux中compose是柯里化函数的一个示例，目的是将函数串联起来。 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 函数组合，科里化的串联</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">arg</span> =&gt;</span> arg</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"结合redux-thunk示例\"><a href=\"#结合redux-thunk示例\" class=\"headerlink\" title=\"结合redux-thunk示例\"></a>结合redux-thunk示例</h3><p>redux-thunk源码，实现也很优雅，对于返回的function，将dispatch等参数传递进去，然后执行，等待回调异步完成再dispatch。对于正常对象则进行下一步。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createThunkMiddleware</span>(<span class=\"params\">extraArgument</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">&#123; dispatch, getState &#125;</span>) =&gt;</span> next =&gt; <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 每次dispatch的时候都会进行判断，如果是个函数，那就执行函数，不再进行下一步吧，这样就避免了，函数不满足action要求的问题</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action(dispatch, getState, extraArgument);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> thunk = createThunkMiddleware();</span><br><span class=\"line\">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> thunk;</span><br></pre></td></tr></table></figure>\n<p>那么实际使用时,在createStore时加入该中间件即可：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(</span><br><span class=\"line\">  reducer,</span><br><span class=\"line\">  applyMiddleware(&#123;</span><br><span class=\"line\">  ...middleware,</span><br><span class=\"line\">  thunk&#125;)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>那么到这里对于redux的中间件 也就是问题2，我想大家也比较清楚了。<br>对于常见中间件可以参考</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"http://cn.redux.js.org/docs/recipes/ServerRendering.html\" target=\"_blank\" rel=\"noopener\">redux中文文档</a><br><a href=\"http://product.dangdang.com/24135483.html\" target=\"_blank\" rel=\"noopener\">深入React技术栈</a>  </p>\n<p>加上<a href=\"https://juejin.im/post/5b208ef06fb9a01e615ed8cb#heading-8\" target=\"_blank\" rel=\"noopener\">重读redux源码一</a>和<a href=\"https://juejin.im/post/5ce25a76e51d4510835e01f3\" target=\"_blank\" rel=\"noopener\">带着问题看 react-redux 源码实现</a>总算将redux及react-redux重读了一遍。可能有人会说道这些源码，看完也会忘，有这个必要吗。我感觉分情况来看，如果我们只是使用，那么看官方文档就可以了，当遇到某些疑问好像找不到贴切解释的时候，不放一看。<br>此外也是学习大佬们的设计思路和实现方式，有的放矢才能开卷有益。  </p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>作为前端状态管理器，这个比较跨时代的工具库redux有很多实现和思想值得我们思考。在深入源码之前，我们可以相关注下一些常见问题，这样带着问题去看实现，也能更加清晰的了解。<br>","more":"</p>\n<h3 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h3><p>大概看了下主要有这么几个：  </p>\n<ol>\n<li>redux三大原则<br>这个可以直接参考<a href=\"http://cn.redux.js.org/docs/introduction/ThreePrinciples.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></li>\n<li>redux 的优缺点。 关于优缺点，太主观了大家见仁见智。</li>\n<li>redux中间件相关，洋葱模型是什么，常见中间件。</li>\n</ol>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><p>有关acton，reducer相关的部分可以看<a href=\"https://juejin.im/post/5b208ef06fb9a01e615ed8cb\" target=\"_blank\" rel=\"noopener\">我前面的文章</a>。我们主要关注针对store和中间件相关的部分来解读。</p>\n<h2 id=\"store的创建\"><a href=\"#store的创建\" class=\"headerlink\" title=\"store的创建\"></a>store的创建</h2><p>作为维护和管理数据的部分，store在redux中的作用十分重要。在action发出指令，reduxer进行数据更新之后，监听数据变化和同步数据更新的操作都要借助store来实现。  </p>\n<h3 id=\"createStore-输入和输出\"><a href=\"#createStore-输入和输出\" class=\"headerlink\" title=\"createStore 输入和输出\"></a>createStore 输入和输出</h3><p>首先看下createStore的使用,即常见的就是接受经过<a href=\"https://juejin.im/post/5b208ef06fb9a01e615ed8cb#heading-8\" target=\"_blank\" rel=\"noopener\">combineReducers处理之后的reducer</a>和初始的state</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> reducer <span class=\"keyword\">from</span> <span class=\"string\">'./reducers'</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(reducer,initialState)</span><br></pre></td></tr></table></figure>\n<p>此外还可以接受第三个参数enhancer(增强器,一般就是applyMiddleware)</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 创建管理state 树的Redux store</span></span><br><span class=\"line\"><span class=\"comment\"> * 应用中只能存在一个store，为了区分不同action对应的reducer，</span></span><br><span class=\"line\"><span class=\"comment\"> * 可以通过combineReducers来关联不同的reducer</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Function&#125; reducer   combineReducers关联之后的reducer</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Object&#125; preloadedState 初始state</span></span><br><span class=\"line\"><span class=\"comment\"> * @param &#123;Function&#125; enhancer 可以增强store功能的函数，例如中间件等。唯一适合</span></span><br><span class=\"line\"><span class=\"comment\"> * @returns 返回一个Store 以维护state和监听变化  </span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 如果第二个参数为func，redux认为忽略了初始state，而是</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// enhancer增强剂，即利用中间件等来增强redux能力</span></span><br><span class=\"line\">    enhancer = preloadedState</span><br><span class=\"line\">    preloadedState = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 返回具有dispatch等属性的对象 即store</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    dispatch,</span><br><span class=\"line\">    subscribe,</span><br><span class=\"line\">    getState,</span><br><span class=\"line\">    replaceReducer,</span><br><span class=\"line\">    [$$observable]: observable</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>按照一般的执行顺序，我们先看下对于参数的处理(平时大家也是一样，一个函数，执行之前尽量判断入参是否符合预期，避免直接处理造成的错误)</p>\n<h3 id=\"入参处理\"><a href=\"#入参处理\" class=\"headerlink\" title=\"入参处理\"></a>入参处理</h3><p>对于三个参数，后两个是非必填的，但如果第二个参数是function，reduxe认为其实encher，不然初始状态是个函数不符合redux的预期，只能这样处理了。   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果第二个参数为func，redux认为忽略了初始state，而是</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">'function'</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// enhancer增强剂，即利用中间件等来增强redux能力</span></span><br><span class=\"line\">    enhancer = preloadedState</span><br><span class=\"line\">    preloadedState = <span class=\"literal\">undefined</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the enhancer to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 对于存在的enhancer,高阶函数函数的用法，</span></span><br><span class=\"line\">    <span class=\"comment\">// 接受createStore返回一个增加功能之后的函数，然后再传入相关reducer得到store。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(reducer, preloadedState)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> reducer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the reducer to be a function.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 一切符合预期，没有 enhancer，那么初始赋值</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentReducer = reducer</span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState = preloadedState</span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentListeners = []</span><br><span class=\"line\">  <span class=\"comment\">// 监听队列</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextListeners = currentListeners</span><br><span class=\"line\">  <span class=\"comment\">// dispatch标识</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isDispatching = <span class=\"literal\">false</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"comment\">// 初始状态更新之后，声明init状态完成。</span></span><br><span class=\"line\">  dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"dispatch的实现\"><a href=\"#dispatch的实现\" class=\"headerlink\" title=\"dispatch的实现\"></a>dispatch的实现</h3><p>dispatch的作用就是根据action，执行对应reducer以更新state。并执行监听队列。<br>下面就来看dispatch的用法和实现。<br>常见使用：<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// redux要求 参数必须为纯对象</span></span><br><span class=\"line\">dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>那么对于纯对象，redux做了些什么呢  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 通知方法，参数为纯的js对象，标明更新内容</span></span><br><span class=\"line\"><span class=\"comment\">  * @param &#123;Object&#125; action </span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">action</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// 是否满足纯净对象</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (!isPlainObject(action)) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">       <span class=\"string\">'省略'</span></span><br><span class=\"line\">     )</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 必须的type是否存在 </span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action.type === <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">       <span class=\"string\">'省略'</span></span><br><span class=\"line\">     )</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 判断是否处于某个action的dispatch中，大家一起dispatch可能死循环</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Reducers may not dispatch actions.'</span>)</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 开始dispatch，加锁，标明状态</span></span><br><span class=\"line\">     isDispatching = <span class=\"literal\">true</span></span><br><span class=\"line\">     <span class=\"comment\">// 将当前状态和更新action，传给当前reducer处理</span></span><br><span class=\"line\">     <span class=\"comment\">// 这里可以回想下我们reducer中的两个参数，state和action 对应的是什么</span></span><br><span class=\"line\">     <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">      * const todos = (state = [], action) =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">      */</span></span><br><span class=\"line\">     currentState = currentReducer(currentState, action)</span><br><span class=\"line\">   &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 有异常，锁置为false，不影响别的dispatch</span></span><br><span class=\"line\">     isDispatching = <span class=\"literal\">false</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"comment\">// 执行dispatch，并且更新当前监听队列为 最新队列</span></span><br><span class=\"line\">   <span class=\"keyword\">const</span> listeners = (currentListeners = nextListeners)</span><br><span class=\"line\">   <span class=\"comment\">// 依次执行，监听器</span></span><br><span class=\"line\">   <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">const</span> listener = listeners[i]</span><br><span class=\"line\">     listener()</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> action</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>createStore初始化完成之后会执行dispatch({ type: ActionTypes.INIT })，此时执行初始化操作。</p>\n<p>我们要关注下currentState的计算，<br>将currentState，action传给reducer处理，然后更新currentState。</p>\n<p>针对初始化来说currentState其实就是initState：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化状态</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> currentState = preloadedState</span><br><span class=\"line\"><span class=\"comment\">/****省略***/</span></span><br><span class=\"line\"><span class=\"comment\">// 这里可以回想下我们reducer中的两个参数，state和action对应的值</span></span><br><span class=\"line\">currentState = currentReducer(currentState, action)</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">` </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">reducer示例：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>js</span><br><span class=\"line\"><span class=\"keyword\">const</span> todos = <span class=\"function\">(<span class=\"params\">state = [], action</span>) =&gt;</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">switch</span> (action.type) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'ADD_TODO'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> [</span><br><span class=\"line\">        ...state,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          id: action.id,</span><br><span class=\"line\">          text: action.text,</span><br><span class=\"line\">          completed: <span class=\"literal\">false</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"getSate实现\"><a href=\"#getSate实现\" class=\"headerlink\" title=\"getSate实现\"></a>getSate实现</h3><p>getState就是获得store的state。这个比较简单。当结合react-redux使用时，其会帮我们进行操作。我们就不用自行调用这个方法了，所以不要疑惑从哪里获取的state。  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 返回应用当前状态</span></span><br><span class=\"line\"><span class=\"comment\">   * 不过需要看下当前是否有更新正在进行，是的话则提示</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否isDispatching 中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'省略'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"subscribe\"><a href=\"#subscribe\" class=\"headerlink\" title=\"subscribe\"></a>subscribe</h3><p>subscribe是比较重要的一个方法，用来供我们监听状态的变化，以执行相关操作。<br>例如react-redux中的handleChange 会对是否pure组件及state进行对比，以提升渲染效率。   </p>\n<p><strong>示例：</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span>.unsubscribe = <span class=\"keyword\">this</span>.store.subscribe(<span class=\"keyword\">this</span>.handleChange.bind(<span class=\"keyword\">this</span>))</span><br></pre></td></tr></table></figure>\n<p><strong>实现：</strong><br>返回的是一个函数，可以进行unsubscribe操作。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">   * 订阅通知</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> listener !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the listener to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">'省略'</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 是否已经监听过</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isSubscribed = <span class=\"literal\">true</span></span><br><span class=\"line\">    <span class=\"comment\">// 监听队列是否相同，区分开，操作nextListeners</span></span><br><span class=\"line\">    ensureCanMutateNextListeners()</span><br><span class=\"line\">    <span class=\"comment\">// 新增监听事件</span></span><br><span class=\"line\">    nextListeners.push(listener)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unsubscribe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isSubscribed) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">          <span class=\"string\">'省略'</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 注册完成，可以进行取消操作</span></span><br><span class=\"line\">      isSubscribed = <span class=\"literal\">false</span></span><br><span class=\"line\">      <span class=\"comment\">// 保持事件队列 同步</span></span><br><span class=\"line\">      ensureCanMutateNextListeners()</span><br><span class=\"line\">      <span class=\"keyword\">const</span> index = nextListeners.indexOf(listener)</span><br><span class=\"line\">      <span class=\"comment\">// 删除监听事件</span></span><br><span class=\"line\">      nextListeners.splice(index, <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"replaceReducer\"><a href=\"#replaceReducer\" class=\"headerlink\" title=\"replaceReducer\"></a>replaceReducer</h3><p>这个开发比较少用，用于热更新</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 用于reducer的热替换，开发中一般不会直接使用</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replaceReducer</span>(<span class=\"params\">nextReducer</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> nextReducer !== <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'Expected the nextReducer to be a function.'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    currentReducer = nextReducer</span><br><span class=\"line\">    <span class=\"comment\">// 更新值之后，进行dispatch。</span></span><br><span class=\"line\">    dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.REPLACE &#125;)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p> 到这里createStore已经解析完成了，大家应该了解该方法到底做了些什么操作吧。<br> 简单概括一下就是：接收reducer和initState，返回一个store 对象。该对象提供了监听、分发等功能，以实现数据的更新。</p>\n<h2 id=\"实际使用中的问题\"><a href=\"#实际使用中的问题\" class=\"headerlink\" title=\"实际使用中的问题\"></a>实际使用中的问题</h2><p>经过上面的解读之后,对于redux的常规应用应该有所了解了。不过实际使用中可能会遇到些问题。<br>例如action要求是纯对象，而我们获取数据一般是异步的，这就需要借助redux-thunk这个中间件了。<br>actionCreater返回一个函数。如下：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">func1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">dispatch</span> =&gt;</span> &#123;</span><br><span class=\"line\">      dispatch(&#123;</span><br><span class=\"line\">      type:<span class=\"string\">'test'</span>,</span><br><span class=\"line\">      data:<span class=\"string\">'a'</span></span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在了解如何实现之前，需要先看下redux中间件的原理。<br>因为reducer更多的关注的是数据的操作，对于一些公共的方法，需要抽离出来，不过这些方法在何时使用呢，redux为我们提供了中间件来满足需求。</p>\n<h2 id=\"redux中间件原理\"><a href=\"#redux中间件原理\" class=\"headerlink\" title=\"redux中间件原理\"></a>redux中间件原理</h2><p>redux 借鉴了 Koa里 middleware 的思想，即鼎鼎大名的洋葱模型。<br><img src=\"/img/redux/middleware.jpg\"></p>\n<p>不过这里请求对应的是dispatch的过程。  </p>\n<p>每次dispatch的过程中，都要依次将中间件执行一遍。<br>遇到阻塞或者操作完成，执行下个中间件，直到执行完成，以便我们事先日志，监控、异常上报等功能。<br>那么redux 又是如何支持中间件的呢。这就离不开applyMiddleware了。<br>这里前面的</p>\n<h3 id=\"applyMiddleware实现思路\"><a href=\"#applyMiddleware实现思路\" class=\"headerlink\" title=\"applyMiddleware实现思路\"></a>applyMiddleware实现思路</h3><p>实现思想比较简单,通过科里化和compose，为符合规范的中间件分配访问dispatch和store的途径，以便在不同阶段来自定义数据更新。<br>例如异步操作，返回的不是对象，那么就执行返回的函数，然后调用下一个中间件。等异步请求结束，再次dispatch 对应的action。   </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">createStore</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = createStore(...args)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dispatch = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">`Dispatching while constructing your middleware is not allowed. `</span> +</span><br><span class=\"line\">          <span class=\"string\">`Other middleware would not be applied to this dispatch.`</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 赋予每个中间件访问store的能力。</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> middlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      <span class=\"comment\">// 箭头函数保存dispatch，保证其的同步更新</span></span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 串联中间件，并赋予每个中间件访问dispatch的能力。</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\">    <span class=\"comment\">// 关联dispatch与中间件，组合调用之后得到类似下面的新对象</span></span><br><span class=\"line\">    <span class=\"comment\">// dispatch = f1(f2(f3(store.dispatch))));</span></span><br><span class=\"line\">    dispatch = compose(...chain)(store.dispatch)</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样执行之后返回的，对象就是增强之后的store了。</p>\n<h3 id=\"compose的实现\"><a href=\"#compose的实现\" class=\"headerlink\" title=\"compose的实现\"></a>compose的实现</h3><p>redux中compose是柯里化函数的一个示例，目的是将函数串联起来。 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 函数组合，科里化的串联</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">arg</span> =&gt;</span> arg</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> (...args) =&gt; a(b(...args)))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"结合redux-thunk示例\"><a href=\"#结合redux-thunk示例\" class=\"headerlink\" title=\"结合redux-thunk示例\"></a>结合redux-thunk示例</h3><p>redux-thunk源码，实现也很优雅，对于返回的function，将dispatch等参数传递进去，然后执行，等待回调异步完成再dispatch。对于正常对象则进行下一步。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createThunkMiddleware</span>(<span class=\"params\">extraArgument</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">&#123; dispatch, getState &#125;</span>) =&gt;</span> next =&gt; <span class=\"function\"><span class=\"params\">action</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 每次dispatch的时候都会进行判断，如果是个函数，那就执行函数，不再进行下一步吧，这样就避免了，函数不满足action要求的问题</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action === <span class=\"string\">'function'</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action(dispatch, getState, extraArgument);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> thunk = createThunkMiddleware();</span><br><span class=\"line\">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> thunk;</span><br></pre></td></tr></table></figure>\n<p>那么实际使用时,在createStore时加入该中间件即可：  </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; createStore, applyMiddleware &#125; <span class=\"keyword\">from</span> <span class=\"string\">'redux'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> thunk <span class=\"keyword\">from</span> <span class=\"string\">'redux-thunk'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> store = createStore(</span><br><span class=\"line\">  reducer,</span><br><span class=\"line\">  applyMiddleware(&#123;</span><br><span class=\"line\">  ...middleware,</span><br><span class=\"line\">  thunk&#125;)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n<p>那么到这里对于redux的中间件 也就是问题2，我想大家也比较清楚了。<br>对于常见中间件可以参考</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><h3 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h3><p><a href=\"http://cn.redux.js.org/docs/recipes/ServerRendering.html\" target=\"_blank\" rel=\"noopener\">redux中文文档</a><br><a href=\"http://product.dangdang.com/24135483.html\" target=\"_blank\" rel=\"noopener\">深入React技术栈</a>  </p>\n<p>加上<a href=\"https://juejin.im/post/5b208ef06fb9a01e615ed8cb#heading-8\" target=\"_blank\" rel=\"noopener\">重读redux源码一</a>和<a href=\"https://juejin.im/post/5ce25a76e51d4510835e01f3\" target=\"_blank\" rel=\"noopener\">带着问题看 react-redux 源码实现</a>总算将redux及react-redux重读了一遍。可能有人会说道这些源码，看完也会忘，有这个必要吗。我感觉分情况来看，如果我们只是使用，那么看官方文档就可以了，当遇到某些疑问好像找不到贴切解释的时候，不放一看。<br>此外也是学习大佬们的设计思路和实现方式，有的放矢才能开卷有益。  </p>"},{"title":"实现一个websocket服务器-node","date":"2017-11-21T16:00:00.000Z","_content":"早点时候翻译了篇[实现一个websocket服务器-理论篇 ](https://github.com/xiaoxiangdaiyu/chartroom/blob/master/src/websocket/README.md)，简单介绍了下理论基础，本来打算放在一起，但是感觉太长了大家可能都看不下去。不过发现如果拆开的话，还是不可避免的要提及理论部分。用到的地方就简要回顾一下好了。\n<!-- more -->\n## Websockt 基本通信流程\n在具体代码实现之前，我们需要大概理一下思路。回顾一下websocket的理论部分。简单的websocket流程如下(这里就不谈详细的过程了，大概描述一下)   \n\n1. 客户端发送握手请求\n2. 服务器响应、处理握手并返回 \n3. 客户端验证通过后，发送数据\n4. 服务器接收、处理数据，然后返回给客户端\n5. 客户端接收服务器的推送  \n\n作为一个服务器而言，我们主要的精力需要放在2，4这两个步骤。\n## 响应并处理握手   \n\n虽然websocket可以实现服务器推送，前提在于该连接已经建立。客户端仍然需要发起一个Websocket握手请求。 既然要响应该握手请求，我们需要了解一下该请求。\n### 客户端握手请求\n\n客户端的握手请求是一个标准的HTTP请求，大概像下面的例子。   \n \n    \n```\nGET / HTTP/1.1  //HTTP版本必须1.1及以上，请求方式为GET\nHost: localhost:8081 //本地项目\nConnection: Upgrade \nPragma: no-cache\nCache-Control: no-cache\nUpgrade: websocket //指定websocket协议\nOrigin: http://192.168.132.170:8000\nSec-WebSocket-Version: 13 //版本\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nCookie: optimizelyEndUserId=oeu1505722530441r0.5993643212774391; _ga=GA1.1.557695983.1505722531\nSec-WebSocket-Key: /2R6uuzPqLT/6z8fnZfN3w==   //握手返回基于该密钥\nSec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\n```\n上面列出了实际例子中的请求头，内容由浏览器生成，需要注意的部分如下。  \n\n* HTTP版本必须1.1及以上，请求方式为GET\n* Connection: Upgrade  \n* Upgrade: websocket //指定websocket  \n* Sec-WebSocket-Key  密钥 服务器处理握手的依据 \n\n  \n我们服务器处理握手时需要关注的就是上面四点。\n   \n### 响应握手请求\n\n服务器根据是否websocket的必须请求头，分下面两种情况：  \n  \n1. 不满足，作为http请求来响应。\n2. 满足，解析处理按照websocket规定的数据格式来响应 \n\n#### 返回格式  \n\n```\n    HTTP/1.1 101 Switching Protocols\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n```\n请注意每一个header以\\r\\n结尾并且在最后一个后面加入额外的\\r\\n。 \n\n这里的Sec-WebSocket-Accept 就是基于请求头中Sec-WebSocket-Key来生成。规则如下：  \nSec-WebSocket-Key 和\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"链接，通过SHA-1 hash获得结果，然后返回该结果的base64编码。\n代码如下：\n  \n```js\n// 指定拼接字符\nvar ws_key = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\n// 生成相应key\nfunction getAccpectKey(rSWKey) {\n    return crypto.createHash('sha1').update(rSWKey + ws_key).digest('base64')\n}\nfunction handShake(socket, headers) {\n    var reqSWKey = headers['Sec-WebSocket-Key'],\n        resSWKey = getAccpectKey(reqSWKey)\n    socket.write('HTTP/1.1 101 Switching Protocols\\r\\n');\n    socket.write('Upgrade: websocket\\r\\n');\n    socket.write('Connection: Upgrade\\r\\n');\n    socket.write('Sec-WebSocket-Accept: ' + resSWKey + '\\r\\n');\n    socket.write('\\r\\n');\n}\n```\n\n这样我们的握手协议就算完成了，此时会触发客户端websocket的onopen事件，即websocket打开，可以进行通信\n\n### 解析数据  \n#### 客户端发送帧格式\n握手协议完成之后，我们就该解析数据了，还是要把这张帧格式拿出来。  \n\n```  \n    帧格式:  \n​​\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-------+-+-------------+-------------------------------+\n     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n     |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n     | |1|2|3|       |K|             |                               |\n     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n     |     Extended payload length continued, if payload len == 127  |\n     + - - - - - - - - - - - - - - - +-------------------------------+\n     |                               |Masking-key, if MASK set to 1  |\n     +-------------------------------+-------------------------------+\n     | Masking-key (continued)       |          Payload Data         |\n     +-------------------------------- - - - - - - - - - - - - - - - +\n     :                     Payload Data continued ...                :\n     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n     |                     Payload Data continued ...                |\n     +---------------------------------------------------------------+\n\n```\n\n每个从客户端发送到服务器的数据帧都遵循上面的格式。  \n\n1. MASK位：只表明信息是否已进行掩码处理。来自客户端的消息必须经过处理，因此我们应该将其置为1   \n\n2. opcode字段定义如何解析有效的数据：  \n    * 0x0 继续处理\n    * 0x1 text(必须是UTF-8编码)  \n    * 0x2 二进制 和其他叫做控制代码的数据。\n    * 0x3-0x7 0xB-0xF 该版本的WebSockets无意义   \n\n3. FIN 表明是否是数据集合的最后一段消息，如果为0，服务器继续监听消息，以待消息剩余的部分。否则服务器认为消息已经完全发送。\n4. Payload len：有效数据长度  \n    * Payload len<126, 即为真实长度\n    * 126,说明真实长度大于125，后面2个字节的值为真实长度\n    * 127,真实长度大于65535，后面8字节值为真实长度 \n      \n\n#### 解析数据  \n所谓解析数据，肯定是基于上面的格式按照一定规则来进行处理。下面就是处理的规则。  \n  \n1. 获取有效数据长度  \n2. 获取掩码并依据规则进行反序列化数据\n\n直接看代码应该更加清晰。    \n\n```js\n// 解析接受的数据帧\nfunction decodeFrame(buffer) {\n    /**\n     * >>> 7 右移操作，即字节右移7位，目的是为了即只取第一位的值\n     * 10010030  ====>   00000001\n     * & 按位与  同1为1    \n     * 15二进制表示为：00001111  ,运算之后前四位即为0，得到后四位的值\n     * 11011000 & 00001111  ===》  00001000\n     *  \n     */\n    var fBite = buffer[0],\n        /**\n         * 获取Fin的值，\n         * 1传输结束\n         * 0 继续监听 \n         */\n        Fin = fBite >>> 7,\n        /**\n         * 获取opcode的值，opcode为fBite的4-7位\n         * & 按位与  同1为1    \n         * 15二进制表示为：00001111  ,运算之后前四位即为0，得到后四位的值\n         */\n        opcode = buffer[0] & 15,\n        /**\n         * 获取有效数据长度 \n         */\n        len = buffer[1] & 127,\n        // 是否进行掩码处理，客户端请求必须为1\n        Mask = buffer[1] >>> 7,\n        maskKey = null\n    // 获取数据长度\n    //真实长度大于125，读取后面2字节\n    if (len == 126) {\n        len = buffer.readUInt16BE(2)\n    } else if (len == 127) {\n        // 真实长度大于65535，读取后面8字节\n        len = buffer.readUInt64BE(2)\n    }\n    // 判断是否进行掩码处理\n    Mask && (maskKey = buffer.slice(2,5))\n    /**\n     * 反掩码处理 \n     * 循环遍历加密的字节（octets，text数据的单位）并且将其与第（i%4）位掩码字节(即i除以4取余)进行异或运算\n     */\n    if(Mask){\n        for (var i = 2;i<len ;i++){\n            buffer[i] = maskKey[(i - 2) % 4] ^ buffer[i];\n        }\n    }\n    var data = buffer.slice(2)\n    return {\n        Fin:Fin,\n        opcode:opcode,\n        data:data\n    }\n}\n```    \n\n#### 发送数据\n处理完接收到的数据之后，下面就是发送响应了。 \n响应数据不需要进行掩码运算，只需要根据帧的格式(即上面的帧)，将数据进行组装就好\n\n```js\n// 加密发送数据\nfunction encodeFrame(data){\n    var len = Buffer.byteLength(data),\n        // 2的64位\n        payload_len = len > 65535 ?10:(len > 125 ? 4 : 2),\n        buf = new Buffer(len+payload_len)\n    /**\n     * 首个字节，0x81 = 10000001 \n     *对应的Fin 为1 opcode为001 mask 为0 \n     * 即表明 返回数据为txt文本已经结束并未使用掩码处理\n     */\n    buf[0] = 0x81  \n    /**\n     * 根据真实数据长度设置payload_len位\n     */        \n    if(payload_len == 2){\n        buf[1] = len\n    }else if(payload_len == 4){\n        buf[1] = 126;\n        buf.writeUInt16BE(payload_len, 2);\n    }else {\n        buf[1] = 127;\n        buf.writeUInt32BE(payload_len >>> 32, 2);\n        buf.writeUInt32BE(payload_len & 0xFFFFFFFF, 6);\n    }  \n    buf.write(data, payload_len);\n    return buf;\n}    \n```    \n\n#### 心跳响应  \n当收到opcode 为 9时即ping请求，直接返回具有完全相同有效数据的pong即可。\nPings的opcode为0x9，pong是0xA，所以可以直接如下   \n\n```js\n// ping请求\nif(opcode == 9){\n   console.log(\"ping相应\");\n   /**\n    * ping pong最大长度为125，所以可以直接拼接\n    * 前两位数据为10001010+数据长度\n    * 即传输完毕的pong响应，数据肯定小于125\n    */\n    socke.write(Buffer.concat([new Buffer([0x8A, data.length]), data]))\n}\n```  \n\n## 结束语 \n至此，一个websocket服务器的简单实现就完成了[更多细节请查看](https://github.com/xiaoxiangdaiyu/chartroom/blob/master/src/websocket/ws.js)。当然成熟的websocket库处理各种情况是比较完善的，更推荐大家使用，这里只是简单实践，更多的是满足一下自己的好奇心，知其然，也要知其所以然，希望大家共同学习和进步\n","source":"_posts/websocket/node.md","raw":"---\ntitle: 实现一个websocket服务器-node  \ndate: 2017-11-22\n---\n早点时候翻译了篇[实现一个websocket服务器-理论篇 ](https://github.com/xiaoxiangdaiyu/chartroom/blob/master/src/websocket/README.md)，简单介绍了下理论基础，本来打算放在一起，但是感觉太长了大家可能都看不下去。不过发现如果拆开的话，还是不可避免的要提及理论部分。用到的地方就简要回顾一下好了。\n<!-- more -->\n## Websockt 基本通信流程\n在具体代码实现之前，我们需要大概理一下思路。回顾一下websocket的理论部分。简单的websocket流程如下(这里就不谈详细的过程了，大概描述一下)   \n\n1. 客户端发送握手请求\n2. 服务器响应、处理握手并返回 \n3. 客户端验证通过后，发送数据\n4. 服务器接收、处理数据，然后返回给客户端\n5. 客户端接收服务器的推送  \n\n作为一个服务器而言，我们主要的精力需要放在2，4这两个步骤。\n## 响应并处理握手   \n\n虽然websocket可以实现服务器推送，前提在于该连接已经建立。客户端仍然需要发起一个Websocket握手请求。 既然要响应该握手请求，我们需要了解一下该请求。\n### 客户端握手请求\n\n客户端的握手请求是一个标准的HTTP请求，大概像下面的例子。   \n \n    \n```\nGET / HTTP/1.1  //HTTP版本必须1.1及以上，请求方式为GET\nHost: localhost:8081 //本地项目\nConnection: Upgrade \nPragma: no-cache\nCache-Control: no-cache\nUpgrade: websocket //指定websocket协议\nOrigin: http://192.168.132.170:8000\nSec-WebSocket-Version: 13 //版本\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nCookie: optimizelyEndUserId=oeu1505722530441r0.5993643212774391; _ga=GA1.1.557695983.1505722531\nSec-WebSocket-Key: /2R6uuzPqLT/6z8fnZfN3w==   //握手返回基于该密钥\nSec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\n```\n上面列出了实际例子中的请求头，内容由浏览器生成，需要注意的部分如下。  \n\n* HTTP版本必须1.1及以上，请求方式为GET\n* Connection: Upgrade  \n* Upgrade: websocket //指定websocket  \n* Sec-WebSocket-Key  密钥 服务器处理握手的依据 \n\n  \n我们服务器处理握手时需要关注的就是上面四点。\n   \n### 响应握手请求\n\n服务器根据是否websocket的必须请求头，分下面两种情况：  \n  \n1. 不满足，作为http请求来响应。\n2. 满足，解析处理按照websocket规定的数据格式来响应 \n\n#### 返回格式  \n\n```\n    HTTP/1.1 101 Switching Protocols\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n```\n请注意每一个header以\\r\\n结尾并且在最后一个后面加入额外的\\r\\n。 \n\n这里的Sec-WebSocket-Accept 就是基于请求头中Sec-WebSocket-Key来生成。规则如下：  \nSec-WebSocket-Key 和\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"链接，通过SHA-1 hash获得结果，然后返回该结果的base64编码。\n代码如下：\n  \n```js\n// 指定拼接字符\nvar ws_key = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';\n// 生成相应key\nfunction getAccpectKey(rSWKey) {\n    return crypto.createHash('sha1').update(rSWKey + ws_key).digest('base64')\n}\nfunction handShake(socket, headers) {\n    var reqSWKey = headers['Sec-WebSocket-Key'],\n        resSWKey = getAccpectKey(reqSWKey)\n    socket.write('HTTP/1.1 101 Switching Protocols\\r\\n');\n    socket.write('Upgrade: websocket\\r\\n');\n    socket.write('Connection: Upgrade\\r\\n');\n    socket.write('Sec-WebSocket-Accept: ' + resSWKey + '\\r\\n');\n    socket.write('\\r\\n');\n}\n```\n\n这样我们的握手协议就算完成了，此时会触发客户端websocket的onopen事件，即websocket打开，可以进行通信\n\n### 解析数据  \n#### 客户端发送帧格式\n握手协议完成之后，我们就该解析数据了，还是要把这张帧格式拿出来。  \n\n```  \n    帧格式:  \n​​\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-------+-+-------------+-------------------------------+\n     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n     |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n     | |1|2|3|       |K|             |                               |\n     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n     |     Extended payload length continued, if payload len == 127  |\n     + - - - - - - - - - - - - - - - +-------------------------------+\n     |                               |Masking-key, if MASK set to 1  |\n     +-------------------------------+-------------------------------+\n     | Masking-key (continued)       |          Payload Data         |\n     +-------------------------------- - - - - - - - - - - - - - - - +\n     :                     Payload Data continued ...                :\n     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n     |                     Payload Data continued ...                |\n     +---------------------------------------------------------------+\n\n```\n\n每个从客户端发送到服务器的数据帧都遵循上面的格式。  \n\n1. MASK位：只表明信息是否已进行掩码处理。来自客户端的消息必须经过处理，因此我们应该将其置为1   \n\n2. opcode字段定义如何解析有效的数据：  \n    * 0x0 继续处理\n    * 0x1 text(必须是UTF-8编码)  \n    * 0x2 二进制 和其他叫做控制代码的数据。\n    * 0x3-0x7 0xB-0xF 该版本的WebSockets无意义   \n\n3. FIN 表明是否是数据集合的最后一段消息，如果为0，服务器继续监听消息，以待消息剩余的部分。否则服务器认为消息已经完全发送。\n4. Payload len：有效数据长度  \n    * Payload len<126, 即为真实长度\n    * 126,说明真实长度大于125，后面2个字节的值为真实长度\n    * 127,真实长度大于65535，后面8字节值为真实长度 \n      \n\n#### 解析数据  \n所谓解析数据，肯定是基于上面的格式按照一定规则来进行处理。下面就是处理的规则。  \n  \n1. 获取有效数据长度  \n2. 获取掩码并依据规则进行反序列化数据\n\n直接看代码应该更加清晰。    \n\n```js\n// 解析接受的数据帧\nfunction decodeFrame(buffer) {\n    /**\n     * >>> 7 右移操作，即字节右移7位，目的是为了即只取第一位的值\n     * 10010030  ====>   00000001\n     * & 按位与  同1为1    \n     * 15二进制表示为：00001111  ,运算之后前四位即为0，得到后四位的值\n     * 11011000 & 00001111  ===》  00001000\n     *  \n     */\n    var fBite = buffer[0],\n        /**\n         * 获取Fin的值，\n         * 1传输结束\n         * 0 继续监听 \n         */\n        Fin = fBite >>> 7,\n        /**\n         * 获取opcode的值，opcode为fBite的4-7位\n         * & 按位与  同1为1    \n         * 15二进制表示为：00001111  ,运算之后前四位即为0，得到后四位的值\n         */\n        opcode = buffer[0] & 15,\n        /**\n         * 获取有效数据长度 \n         */\n        len = buffer[1] & 127,\n        // 是否进行掩码处理，客户端请求必须为1\n        Mask = buffer[1] >>> 7,\n        maskKey = null\n    // 获取数据长度\n    //真实长度大于125，读取后面2字节\n    if (len == 126) {\n        len = buffer.readUInt16BE(2)\n    } else if (len == 127) {\n        // 真实长度大于65535，读取后面8字节\n        len = buffer.readUInt64BE(2)\n    }\n    // 判断是否进行掩码处理\n    Mask && (maskKey = buffer.slice(2,5))\n    /**\n     * 反掩码处理 \n     * 循环遍历加密的字节（octets，text数据的单位）并且将其与第（i%4）位掩码字节(即i除以4取余)进行异或运算\n     */\n    if(Mask){\n        for (var i = 2;i<len ;i++){\n            buffer[i] = maskKey[(i - 2) % 4] ^ buffer[i];\n        }\n    }\n    var data = buffer.slice(2)\n    return {\n        Fin:Fin,\n        opcode:opcode,\n        data:data\n    }\n}\n```    \n\n#### 发送数据\n处理完接收到的数据之后，下面就是发送响应了。 \n响应数据不需要进行掩码运算，只需要根据帧的格式(即上面的帧)，将数据进行组装就好\n\n```js\n// 加密发送数据\nfunction encodeFrame(data){\n    var len = Buffer.byteLength(data),\n        // 2的64位\n        payload_len = len > 65535 ?10:(len > 125 ? 4 : 2),\n        buf = new Buffer(len+payload_len)\n    /**\n     * 首个字节，0x81 = 10000001 \n     *对应的Fin 为1 opcode为001 mask 为0 \n     * 即表明 返回数据为txt文本已经结束并未使用掩码处理\n     */\n    buf[0] = 0x81  \n    /**\n     * 根据真实数据长度设置payload_len位\n     */        \n    if(payload_len == 2){\n        buf[1] = len\n    }else if(payload_len == 4){\n        buf[1] = 126;\n        buf.writeUInt16BE(payload_len, 2);\n    }else {\n        buf[1] = 127;\n        buf.writeUInt32BE(payload_len >>> 32, 2);\n        buf.writeUInt32BE(payload_len & 0xFFFFFFFF, 6);\n    }  \n    buf.write(data, payload_len);\n    return buf;\n}    \n```    \n\n#### 心跳响应  \n当收到opcode 为 9时即ping请求，直接返回具有完全相同有效数据的pong即可。\nPings的opcode为0x9，pong是0xA，所以可以直接如下   \n\n```js\n// ping请求\nif(opcode == 9){\n   console.log(\"ping相应\");\n   /**\n    * ping pong最大长度为125，所以可以直接拼接\n    * 前两位数据为10001010+数据长度\n    * 即传输完毕的pong响应，数据肯定小于125\n    */\n    socke.write(Buffer.concat([new Buffer([0x8A, data.length]), data]))\n}\n```  \n\n## 结束语 \n至此，一个websocket服务器的简单实现就完成了[更多细节请查看](https://github.com/xiaoxiangdaiyu/chartroom/blob/master/src/websocket/ws.js)。当然成熟的websocket库处理各种情况是比较完善的，更推荐大家使用，这里只是简单实践，更多的是满足一下自己的好奇心，知其然，也要知其所以然，希望大家共同学习和进步\n","slug":"websocket/node","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt7y001igw929d9n1nad","content":"<p>早点时候翻译了篇<a href=\"https://github.com/xiaoxiangdaiyu/chartroom/blob/master/src/websocket/README.md\" target=\"_blank\" rel=\"noopener\">实现一个websocket服务器-理论篇 </a>，简单介绍了下理论基础，本来打算放在一起，但是感觉太长了大家可能都看不下去。不过发现如果拆开的话，还是不可避免的要提及理论部分。用到的地方就简要回顾一下好了。<br><a id=\"more\"></a></p>\n<h2 id=\"Websockt-基本通信流程\"><a href=\"#Websockt-基本通信流程\" class=\"headerlink\" title=\"Websockt 基本通信流程\"></a>Websockt 基本通信流程</h2><p>在具体代码实现之前，我们需要大概理一下思路。回顾一下websocket的理论部分。简单的websocket流程如下(这里就不谈详细的过程了，大概描述一下)   </p>\n<ol>\n<li>客户端发送握手请求</li>\n<li>服务器响应、处理握手并返回 </li>\n<li>客户端验证通过后，发送数据</li>\n<li>服务器接收、处理数据，然后返回给客户端</li>\n<li>客户端接收服务器的推送  </li>\n</ol>\n<p>作为一个服务器而言，我们主要的精力需要放在2，4这两个步骤。</p>\n<h2 id=\"响应并处理握手\"><a href=\"#响应并处理握手\" class=\"headerlink\" title=\"响应并处理握手\"></a>响应并处理握手</h2><p>虽然websocket可以实现服务器推送，前提在于该连接已经建立。客户端仍然需要发起一个Websocket握手请求。 既然要响应该握手请求，我们需要了解一下该请求。</p>\n<h3 id=\"客户端握手请求\"><a href=\"#客户端握手请求\" class=\"headerlink\" title=\"客户端握手请求\"></a>客户端握手请求</h3><p>客户端的握手请求是一个标准的HTTP请求，大概像下面的例子。   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1  //HTTP版本必须1.1及以上，请求方式为GET</span><br><span class=\"line\">Host: localhost:8081 //本地项目</span><br><span class=\"line\">Connection: Upgrade </span><br><span class=\"line\">Pragma: no-cache</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\">Upgrade: websocket //指定websocket协议</span><br><span class=\"line\">Origin: http://192.168.132.170:8000</span><br><span class=\"line\">Sec-WebSocket-Version: 13 //版本</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class=\"line\">Cookie: optimizelyEndUserId=oeu1505722530441r0.5993643212774391; _ga=GA1.1.557695983.1505722531</span><br><span class=\"line\">Sec-WebSocket-Key: /2R6uuzPqLT/6z8fnZfN3w==   //握手返回基于该密钥</span><br><span class=\"line\">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure>\n<p>上面列出了实际例子中的请求头，内容由浏览器生成，需要注意的部分如下。  </p>\n<ul>\n<li>HTTP版本必须1.1及以上，请求方式为GET</li>\n<li>Connection: Upgrade  </li>\n<li>Upgrade: websocket //指定websocket  </li>\n<li>Sec-WebSocket-Key  密钥 服务器处理握手的依据 </li>\n</ul>\n<p>我们服务器处理握手时需要关注的就是上面四点。</p>\n<h3 id=\"响应握手请求\"><a href=\"#响应握手请求\" class=\"headerlink\" title=\"响应握手请求\"></a>响应握手请求</h3><p>服务器根据是否websocket的必须请求头，分下面两种情况：  </p>\n<ol>\n<li>不满足，作为http请求来响应。</li>\n<li>满足，解析处理按照websocket规定的数据格式来响应 </li>\n</ol>\n<h4 id=\"返回格式\"><a href=\"#返回格式\" class=\"headerlink\" title=\"返回格式\"></a>返回格式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 101 Switching Protocols</span><br><span class=\"line\">Upgrade: websocket</span><br><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>\n<p>请注意每一个header以\\r\\n结尾并且在最后一个后面加入额外的\\r\\n。 </p>\n<p>这里的Sec-WebSocket-Accept 就是基于请求头中Sec-WebSocket-Key来生成。规则如下：<br>Sec-WebSocket-Key 和”258EAFA5-E914-47DA-95CA-C5AB0DC85B11”链接，通过SHA-1 hash获得结果，然后返回该结果的base64编码。<br>代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定拼接字符</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ws_key = <span class=\"string\">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 生成相应key</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAccpectKey</span>(<span class=\"params\">rSWKey</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> crypto.createHash(<span class=\"string\">'sha1'</span>).update(rSWKey + ws_key).digest(<span class=\"string\">'base64'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handShake</span>(<span class=\"params\">socket, headers</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reqSWKey = headers[<span class=\"string\">'Sec-WebSocket-Key'</span>],</span><br><span class=\"line\">        resSWKey = getAccpectKey(reqSWKey)</span><br><span class=\"line\">    socket.write(<span class=\"string\">'HTTP/1.1 101 Switching Protocols\\r\\n'</span>);</span><br><span class=\"line\">    socket.write(<span class=\"string\">'Upgrade: websocket\\r\\n'</span>);</span><br><span class=\"line\">    socket.write(<span class=\"string\">'Connection: Upgrade\\r\\n'</span>);</span><br><span class=\"line\">    socket.write(<span class=\"string\">'Sec-WebSocket-Accept: '</span> + resSWKey + <span class=\"string\">'\\r\\n'</span>);</span><br><span class=\"line\">    socket.write(<span class=\"string\">'\\r\\n'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们的握手协议就算完成了，此时会触发客户端websocket的onopen事件，即websocket打开，可以进行通信</p>\n<h3 id=\"解析数据\"><a href=\"#解析数据\" class=\"headerlink\" title=\"解析数据\"></a>解析数据</h3><h4 id=\"客户端发送帧格式\"><a href=\"#客户端发送帧格式\" class=\"headerlink\" title=\"客户端发送帧格式\"></a>客户端发送帧格式</h4><p>握手协议完成之后，我们就该解析数据了，还是要把这张帧格式拿出来。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    帧格式:  </span><br><span class=\"line\">​​</span><br><span class=\"line\">      0                   1                   2                   3</span><br><span class=\"line\">      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">     +-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class=\"line\">     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class=\"line\">     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class=\"line\">     |N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class=\"line\">     | |1|2|3|       |K|             |                               |</span><br><span class=\"line\">     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     |     Extended payload length continued, if payload len == 127  |</span><br><span class=\"line\">     + - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class=\"line\">     |                               |Masking-key, if MASK set to 1  |</span><br><span class=\"line\">     +-------------------------------+-------------------------------+</span><br><span class=\"line\">     | Masking-key (continued)       |          Payload Data         |</span><br><span class=\"line\">     +-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     :                     Payload Data continued ...                :</span><br><span class=\"line\">     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     |                     Payload Data continued ...                |</span><br><span class=\"line\">     +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n<p>每个从客户端发送到服务器的数据帧都遵循上面的格式。  </p>\n<ol>\n<li><p>MASK位：只表明信息是否已进行掩码处理。来自客户端的消息必须经过处理，因此我们应该将其置为1   </p>\n</li>\n<li><p>opcode字段定义如何解析有效的数据：  </p>\n<ul>\n<li>0x0 继续处理</li>\n<li>0x1 text(必须是UTF-8编码)  </li>\n<li>0x2 二进制 和其他叫做控制代码的数据。</li>\n<li>0x3-0x7 0xB-0xF 该版本的WebSockets无意义   </li>\n</ul>\n</li>\n<li><p>FIN 表明是否是数据集合的最后一段消息，如果为0，服务器继续监听消息，以待消息剩余的部分。否则服务器认为消息已经完全发送。</p>\n</li>\n<li>Payload len：有效数据长度  <ul>\n<li>Payload len&lt;126, 即为真实长度</li>\n<li>126,说明真实长度大于125，后面2个字节的值为真实长度</li>\n<li>127,真实长度大于65535，后面8字节值为真实长度 </li>\n</ul>\n</li>\n</ol>\n<h4 id=\"解析数据-1\"><a href=\"#解析数据-1\" class=\"headerlink\" title=\"解析数据\"></a>解析数据</h4><p>所谓解析数据，肯定是基于上面的格式按照一定规则来进行处理。下面就是处理的规则。  </p>\n<ol>\n<li>获取有效数据长度  </li>\n<li>获取掩码并依据规则进行反序列化数据</li>\n</ol>\n<p>直接看代码应该更加清晰。    </p>\n<pre><code class=\"js\"><span class=\"comment\">// 解析接受的数据帧</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decodeFrame</span>(<span class=\"params\">buffer</span>) </span>{\n    <span class=\"comment\">/**</span>\n<span class=\"comment\">     * &gt;&gt;&gt; 7 右移操作，即字节右移7位，目的是为了即只取第一位的值</span>\n<span class=\"comment\">     * 10010030  ====&gt;   00000001</span>\n<span class=\"comment\">     * &amp; 按位与  同1为1    </span>\n<span class=\"comment\">     * 15二进制表示为：00001111  ,运算之后前四位即为0，得到后四位的值</span>\n<span class=\"comment\">     * 11011000 &amp; 00001111  ===》  00001000</span>\n<span class=\"comment\">     *  </span>\n<span class=\"comment\">     */</span>\n    <span class=\"keyword\">var</span> fBite = buffer[<span class=\"number\">0</span>],\n        <span class=\"comment\">/**</span>\n<span class=\"comment\">         * 获取Fin的值，</span>\n<span class=\"comment\">         * 1传输结束</span>\n<span class=\"comment\">         * 0 继续监听 </span>\n<span class=\"comment\">         */</span>\n        Fin = fBite &gt;&gt;&gt; <span class=\"number\">7</span>,\n        <span class=\"comment\">/**</span>\n<span class=\"comment\">         * 获取opcode的值，opcode为fBite的4-7位</span>\n<span class=\"comment\">         * &amp; 按位与  同1为1    </span>\n<span class=\"comment\">         * 15二进制表示为：00001111  ,运算之后前四位即为0，得到后四位的值</span>\n<span class=\"comment\">         */</span>\n        opcode = buffer[<span class=\"number\">0</span>] &amp; <span class=\"number\">15</span>,\n        <span class=\"comment\">/**</span>\n<span class=\"comment\">         * 获取有效数据长度 </span>\n<span class=\"comment\">         */</span>\n        len = buffer[<span class=\"number\">1</span>] &amp; <span class=\"number\">127</span>,\n        <span class=\"comment\">// 是否进行掩码处理，客户端请求必须为1</span>\n        Mask = buffer[<span class=\"number\">1</span>] &gt;&gt;&gt; <span class=\"number\">7</span>,\n        maskKey = <span class=\"literal\">null</span>\n    <span class=\"comment\">// 获取数据长度</span>\n    <span class=\"comment\">//真实长度大于125，读取后面2字节</span>\n    <span class=\"keyword\">if</span> (len == <span class=\"number\">126</span>) {\n        len = buffer.readUInt16BE(<span class=\"number\">2</span>)\n    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len == <span class=\"number\">127</span>) {\n        <span class=\"comment\">// 真实长度大于65535，读取后面8字节</span>\n        len = buffer.readUInt64BE(<span class=\"number\">2</span>)\n    }\n    <span class=\"comment\">// 判断是否进行掩码处理</span>\n    Mask &amp;&amp; (maskKey = buffer.slice(<span class=\"number\">2</span>,<span class=\"number\">5</span>))\n    <span class=\"comment\">/**</span>\n<span class=\"comment\">     * 反掩码处理 </span>\n<span class=\"comment\">     * 循环遍历加密的字节（octets，text数据的单位）并且将其与第（i%4）位掩码字节(即i除以4取余)进行异或运算</span>\n<span class=\"comment\">     */</span>\n    <span class=\"keyword\">if</span>(Mask){\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">2</span>;i&lt;len ;i++){\n            buffer[i] = maskKey[(i - <span class=\"number\">2</span>) % <span class=\"number\">4</span>] ^ buffer[i];\n        }\n    }\n    <span class=\"keyword\">var</span> data = buffer.slice(<span class=\"number\">2</span>)\n    <span class=\"keyword\">return</span> {\n        Fin:Fin,\n        opcode:opcode,\n        data:data\n    }\n}\n</code></pre>\n<h4 id=\"发送数据\"><a href=\"#发送数据\" class=\"headerlink\" title=\"发送数据\"></a>发送数据</h4><p>处理完接收到的数据之后，下面就是发送响应了。<br>响应数据不需要进行掩码运算，只需要根据帧的格式(即上面的帧)，将数据进行组装就好</p>\n<pre><code class=\"js\"><span class=\"comment\">// 加密发送数据</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">encodeFrame</span>(<span class=\"params\">data</span>)</span>{\n    <span class=\"keyword\">var</span> len = Buffer.byteLength(data),\n        <span class=\"comment\">// 2的64位</span>\n        payload_len = len &gt; <span class=\"number\">65535</span> ?<span class=\"number\">10</span>:(len &gt; <span class=\"number\">125</span> ? <span class=\"number\">4</span> : <span class=\"number\">2</span>),\n        buf = <span class=\"keyword\">new</span> Buffer(len+payload_len)\n    <span class=\"comment\">/**</span>\n<span class=\"comment\">     * 首个字节，0x81 = 10000001 </span>\n<span class=\"comment\">     *对应的Fin 为1 opcode为001 mask 为0 </span>\n<span class=\"comment\">     * 即表明 返回数据为txt文本已经结束并未使用掩码处理</span>\n<span class=\"comment\">     */</span>\n    buf[<span class=\"number\">0</span>] = <span class=\"number\">0x81</span>  \n    <span class=\"comment\">/**</span>\n<span class=\"comment\">     * 根据真实数据长度设置payload_len位</span>\n<span class=\"comment\">     */</span>        \n    <span class=\"keyword\">if</span>(payload_len == <span class=\"number\">2</span>){\n        buf[<span class=\"number\">1</span>] = len\n    }<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(payload_len == <span class=\"number\">4</span>){\n        buf[<span class=\"number\">1</span>] = <span class=\"number\">126</span>;\n        buf.writeUInt16BE(payload_len, <span class=\"number\">2</span>);\n    }<span class=\"keyword\">else</span> {\n        buf[<span class=\"number\">1</span>] = <span class=\"number\">127</span>;\n        buf.writeUInt32BE(payload_len &gt;&gt;&gt; <span class=\"number\">32</span>, <span class=\"number\">2</span>);\n        buf.writeUInt32BE(payload_len &amp; <span class=\"number\">0xFFFFFFFF</span>, <span class=\"number\">6</span>);\n    }  \n    buf.write(data, payload_len);\n    <span class=\"keyword\">return</span> buf;\n}    \n</code></pre>\n<h4 id=\"心跳响应\"><a href=\"#心跳响应\" class=\"headerlink\" title=\"心跳响应\"></a>心跳响应</h4><p>当收到opcode 为 9时即ping请求，直接返回具有完全相同有效数据的pong即可。<br>Pings的opcode为0x9，pong是0xA，所以可以直接如下   </p>\n<pre><code class=\"js\"><span class=\"comment\">// ping请求</span>\n<span class=\"keyword\">if</span>(opcode == <span class=\"number\">9</span>){\n   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"ping相应\"</span>);\n   <span class=\"comment\">/**</span>\n<span class=\"comment\">    * ping pong最大长度为125，所以可以直接拼接</span>\n<span class=\"comment\">    * 前两位数据为10001010+数据长度</span>\n<span class=\"comment\">    * 即传输完毕的pong响应，数据肯定小于125</span>\n<span class=\"comment\">    */</span>\n    socke.write(Buffer.concat([<span class=\"keyword\">new</span> Buffer([<span class=\"number\">0x8A</span>, data.length]), data]))\n}\n</code></pre>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>至此，一个websocket服务器的简单实现就完成了<a href=\"https://github.com/xiaoxiangdaiyu/chartroom/blob/master/src/websocket/ws.js\" target=\"_blank\" rel=\"noopener\">更多细节请查看</a>。当然成熟的websocket库处理各种情况是比较完善的，更推荐大家使用，这里只是简单实践，更多的是满足一下自己的好奇心，知其然，也要知其所以然，希望大家共同学习和进步</p>\n","site":{"data":{}},"excerpt":"<p>早点时候翻译了篇<a href=\"https://github.com/xiaoxiangdaiyu/chartroom/blob/master/src/websocket/README.md\" target=\"_blank\" rel=\"noopener\">实现一个websocket服务器-理论篇 </a>，简单介绍了下理论基础，本来打算放在一起，但是感觉太长了大家可能都看不下去。不过发现如果拆开的话，还是不可避免的要提及理论部分。用到的地方就简要回顾一下好了。<br>","more":"</p>\n<h2 id=\"Websockt-基本通信流程\"><a href=\"#Websockt-基本通信流程\" class=\"headerlink\" title=\"Websockt 基本通信流程\"></a>Websockt 基本通信流程</h2><p>在具体代码实现之前，我们需要大概理一下思路。回顾一下websocket的理论部分。简单的websocket流程如下(这里就不谈详细的过程了，大概描述一下)   </p>\n<ol>\n<li>客户端发送握手请求</li>\n<li>服务器响应、处理握手并返回 </li>\n<li>客户端验证通过后，发送数据</li>\n<li>服务器接收、处理数据，然后返回给客户端</li>\n<li>客户端接收服务器的推送  </li>\n</ol>\n<p>作为一个服务器而言，我们主要的精力需要放在2，4这两个步骤。</p>\n<h2 id=\"响应并处理握手\"><a href=\"#响应并处理握手\" class=\"headerlink\" title=\"响应并处理握手\"></a>响应并处理握手</h2><p>虽然websocket可以实现服务器推送，前提在于该连接已经建立。客户端仍然需要发起一个Websocket握手请求。 既然要响应该握手请求，我们需要了解一下该请求。</p>\n<h3 id=\"客户端握手请求\"><a href=\"#客户端握手请求\" class=\"headerlink\" title=\"客户端握手请求\"></a>客户端握手请求</h3><p>客户端的握手请求是一个标准的HTTP请求，大概像下面的例子。   </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET / HTTP/1.1  //HTTP版本必须1.1及以上，请求方式为GET</span><br><span class=\"line\">Host: localhost:8081 //本地项目</span><br><span class=\"line\">Connection: Upgrade </span><br><span class=\"line\">Pragma: no-cache</span><br><span class=\"line\">Cache-Control: no-cache</span><br><span class=\"line\">Upgrade: websocket //指定websocket协议</span><br><span class=\"line\">Origin: http://192.168.132.170:8000</span><br><span class=\"line\">Sec-WebSocket-Version: 13 //版本</span><br><span class=\"line\">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36</span><br><span class=\"line\">Accept-Encoding: gzip, deflate, br</span><br><span class=\"line\">Accept-Language: zh-CN,zh;q=0.9,en;q=0.8</span><br><span class=\"line\">Cookie: optimizelyEndUserId=oeu1505722530441r0.5993643212774391; _ga=GA1.1.557695983.1505722531</span><br><span class=\"line\">Sec-WebSocket-Key: /2R6uuzPqLT/6z8fnZfN3w==   //握手返回基于该密钥</span><br><span class=\"line\">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure>\n<p>上面列出了实际例子中的请求头，内容由浏览器生成，需要注意的部分如下。  </p>\n<ul>\n<li>HTTP版本必须1.1及以上，请求方式为GET</li>\n<li>Connection: Upgrade  </li>\n<li>Upgrade: websocket //指定websocket  </li>\n<li>Sec-WebSocket-Key  密钥 服务器处理握手的依据 </li>\n</ul>\n<p>我们服务器处理握手时需要关注的就是上面四点。</p>\n<h3 id=\"响应握手请求\"><a href=\"#响应握手请求\" class=\"headerlink\" title=\"响应握手请求\"></a>响应握手请求</h3><p>服务器根据是否websocket的必须请求头，分下面两种情况：  </p>\n<ol>\n<li>不满足，作为http请求来响应。</li>\n<li>满足，解析处理按照websocket规定的数据格式来响应 </li>\n</ol>\n<h4 id=\"返回格式\"><a href=\"#返回格式\" class=\"headerlink\" title=\"返回格式\"></a>返回格式</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 101 Switching Protocols</span><br><span class=\"line\">Upgrade: websocket</span><br><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>\n<p>请注意每一个header以\\r\\n结尾并且在最后一个后面加入额外的\\r\\n。 </p>\n<p>这里的Sec-WebSocket-Accept 就是基于请求头中Sec-WebSocket-Key来生成。规则如下：<br>Sec-WebSocket-Key 和”258EAFA5-E914-47DA-95CA-C5AB0DC85B11”链接，通过SHA-1 hash获得结果，然后返回该结果的base64编码。<br>代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 指定拼接字符</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> ws_key = <span class=\"string\">'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</span>;</span><br><span class=\"line\"><span class=\"comment\">// 生成相应key</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAccpectKey</span>(<span class=\"params\">rSWKey</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> crypto.createHash(<span class=\"string\">'sha1'</span>).update(rSWKey + ws_key).digest(<span class=\"string\">'base64'</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">handShake</span>(<span class=\"params\">socket, headers</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reqSWKey = headers[<span class=\"string\">'Sec-WebSocket-Key'</span>],</span><br><span class=\"line\">        resSWKey = getAccpectKey(reqSWKey)</span><br><span class=\"line\">    socket.write(<span class=\"string\">'HTTP/1.1 101 Switching Protocols\\r\\n'</span>);</span><br><span class=\"line\">    socket.write(<span class=\"string\">'Upgrade: websocket\\r\\n'</span>);</span><br><span class=\"line\">    socket.write(<span class=\"string\">'Connection: Upgrade\\r\\n'</span>);</span><br><span class=\"line\">    socket.write(<span class=\"string\">'Sec-WebSocket-Accept: '</span> + resSWKey + <span class=\"string\">'\\r\\n'</span>);</span><br><span class=\"line\">    socket.write(<span class=\"string\">'\\r\\n'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这样我们的握手协议就算完成了，此时会触发客户端websocket的onopen事件，即websocket打开，可以进行通信</p>\n<h3 id=\"解析数据\"><a href=\"#解析数据\" class=\"headerlink\" title=\"解析数据\"></a>解析数据</h3><h4 id=\"客户端发送帧格式\"><a href=\"#客户端发送帧格式\" class=\"headerlink\" title=\"客户端发送帧格式\"></a>客户端发送帧格式</h4><p>握手协议完成之后，我们就该解析数据了，还是要把这张帧格式拿出来。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    帧格式:  </span><br><span class=\"line\">​​</span><br><span class=\"line\">      0                   1                   2                   3</span><br><span class=\"line\">      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">     +-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class=\"line\">     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class=\"line\">     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class=\"line\">     |N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class=\"line\">     | |1|2|3|       |K|             |                               |</span><br><span class=\"line\">     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     |     Extended payload length continued, if payload len == 127  |</span><br><span class=\"line\">     + - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class=\"line\">     |                               |Masking-key, if MASK set to 1  |</span><br><span class=\"line\">     +-------------------------------+-------------------------------+</span><br><span class=\"line\">     | Masking-key (continued)       |          Payload Data         |</span><br><span class=\"line\">     +-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     :                     Payload Data continued ...                :</span><br><span class=\"line\">     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     |                     Payload Data continued ...                |</span><br><span class=\"line\">     +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n<p>每个从客户端发送到服务器的数据帧都遵循上面的格式。  </p>\n<ol>\n<li><p>MASK位：只表明信息是否已进行掩码处理。来自客户端的消息必须经过处理，因此我们应该将其置为1   </p>\n</li>\n<li><p>opcode字段定义如何解析有效的数据：  </p>\n<ul>\n<li>0x0 继续处理</li>\n<li>0x1 text(必须是UTF-8编码)  </li>\n<li>0x2 二进制 和其他叫做控制代码的数据。</li>\n<li>0x3-0x7 0xB-0xF 该版本的WebSockets无意义   </li>\n</ul>\n</li>\n<li><p>FIN 表明是否是数据集合的最后一段消息，如果为0，服务器继续监听消息，以待消息剩余的部分。否则服务器认为消息已经完全发送。</p>\n</li>\n<li>Payload len：有效数据长度  <ul>\n<li>Payload len&lt;126, 即为真实长度</li>\n<li>126,说明真实长度大于125，后面2个字节的值为真实长度</li>\n<li>127,真实长度大于65535，后面8字节值为真实长度 </li>\n</ul>\n</li>\n</ol>\n<h4 id=\"解析数据-1\"><a href=\"#解析数据-1\" class=\"headerlink\" title=\"解析数据\"></a>解析数据</h4><p>所谓解析数据，肯定是基于上面的格式按照一定规则来进行处理。下面就是处理的规则。  </p>\n<ol>\n<li>获取有效数据长度  </li>\n<li>获取掩码并依据规则进行反序列化数据</li>\n</ol>\n<p>直接看代码应该更加清晰。    </p>\n<pre><code class=\"js\"><span class=\"comment\">// 解析接受的数据帧</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">decodeFrame</span>(<span class=\"params\">buffer</span>) </span>{\n    <span class=\"comment\">/**</span>\n<span class=\"comment\">     * &gt;&gt;&gt; 7 右移操作，即字节右移7位，目的是为了即只取第一位的值</span>\n<span class=\"comment\">     * 10010030  ====&gt;   00000001</span>\n<span class=\"comment\">     * &amp; 按位与  同1为1    </span>\n<span class=\"comment\">     * 15二进制表示为：00001111  ,运算之后前四位即为0，得到后四位的值</span>\n<span class=\"comment\">     * 11011000 &amp; 00001111  ===》  00001000</span>\n<span class=\"comment\">     *  </span>\n<span class=\"comment\">     */</span>\n    <span class=\"keyword\">var</span> fBite = buffer[<span class=\"number\">0</span>],\n        <span class=\"comment\">/**</span>\n<span class=\"comment\">         * 获取Fin的值，</span>\n<span class=\"comment\">         * 1传输结束</span>\n<span class=\"comment\">         * 0 继续监听 </span>\n<span class=\"comment\">         */</span>\n        Fin = fBite &gt;&gt;&gt; <span class=\"number\">7</span>,\n        <span class=\"comment\">/**</span>\n<span class=\"comment\">         * 获取opcode的值，opcode为fBite的4-7位</span>\n<span class=\"comment\">         * &amp; 按位与  同1为1    </span>\n<span class=\"comment\">         * 15二进制表示为：00001111  ,运算之后前四位即为0，得到后四位的值</span>\n<span class=\"comment\">         */</span>\n        opcode = buffer[<span class=\"number\">0</span>] &amp; <span class=\"number\">15</span>,\n        <span class=\"comment\">/**</span>\n<span class=\"comment\">         * 获取有效数据长度 </span>\n<span class=\"comment\">         */</span>\n        len = buffer[<span class=\"number\">1</span>] &amp; <span class=\"number\">127</span>,\n        <span class=\"comment\">// 是否进行掩码处理，客户端请求必须为1</span>\n        Mask = buffer[<span class=\"number\">1</span>] &gt;&gt;&gt; <span class=\"number\">7</span>,\n        maskKey = <span class=\"literal\">null</span>\n    <span class=\"comment\">// 获取数据长度</span>\n    <span class=\"comment\">//真实长度大于125，读取后面2字节</span>\n    <span class=\"keyword\">if</span> (len == <span class=\"number\">126</span>) {\n        len = buffer.readUInt16BE(<span class=\"number\">2</span>)\n    } <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (len == <span class=\"number\">127</span>) {\n        <span class=\"comment\">// 真实长度大于65535，读取后面8字节</span>\n        len = buffer.readUInt64BE(<span class=\"number\">2</span>)\n    }\n    <span class=\"comment\">// 判断是否进行掩码处理</span>\n    Mask &amp;&amp; (maskKey = buffer.slice(<span class=\"number\">2</span>,<span class=\"number\">5</span>))\n    <span class=\"comment\">/**</span>\n<span class=\"comment\">     * 反掩码处理 </span>\n<span class=\"comment\">     * 循环遍历加密的字节（octets，text数据的单位）并且将其与第（i%4）位掩码字节(即i除以4取余)进行异或运算</span>\n<span class=\"comment\">     */</span>\n    <span class=\"keyword\">if</span>(Mask){\n        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">2</span>;i&lt;len ;i++){\n            buffer[i] = maskKey[(i - <span class=\"number\">2</span>) % <span class=\"number\">4</span>] ^ buffer[i];\n        }\n    }\n    <span class=\"keyword\">var</span> data = buffer.slice(<span class=\"number\">2</span>)\n    <span class=\"keyword\">return</span> {\n        Fin:Fin,\n        opcode:opcode,\n        data:data\n    }\n}\n</code></pre>\n<h4 id=\"发送数据\"><a href=\"#发送数据\" class=\"headerlink\" title=\"发送数据\"></a>发送数据</h4><p>处理完接收到的数据之后，下面就是发送响应了。<br>响应数据不需要进行掩码运算，只需要根据帧的格式(即上面的帧)，将数据进行组装就好</p>\n<pre><code class=\"js\"><span class=\"comment\">// 加密发送数据</span>\n<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">encodeFrame</span>(<span class=\"params\">data</span>)</span>{\n    <span class=\"keyword\">var</span> len = Buffer.byteLength(data),\n        <span class=\"comment\">// 2的64位</span>\n        payload_len = len &gt; <span class=\"number\">65535</span> ?<span class=\"number\">10</span>:(len &gt; <span class=\"number\">125</span> ? <span class=\"number\">4</span> : <span class=\"number\">2</span>),\n        buf = <span class=\"keyword\">new</span> Buffer(len+payload_len)\n    <span class=\"comment\">/**</span>\n<span class=\"comment\">     * 首个字节，0x81 = 10000001 </span>\n<span class=\"comment\">     *对应的Fin 为1 opcode为001 mask 为0 </span>\n<span class=\"comment\">     * 即表明 返回数据为txt文本已经结束并未使用掩码处理</span>\n<span class=\"comment\">     */</span>\n    buf[<span class=\"number\">0</span>] = <span class=\"number\">0x81</span>  \n    <span class=\"comment\">/**</span>\n<span class=\"comment\">     * 根据真实数据长度设置payload_len位</span>\n<span class=\"comment\">     */</span>        \n    <span class=\"keyword\">if</span>(payload_len == <span class=\"number\">2</span>){\n        buf[<span class=\"number\">1</span>] = len\n    }<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(payload_len == <span class=\"number\">4</span>){\n        buf[<span class=\"number\">1</span>] = <span class=\"number\">126</span>;\n        buf.writeUInt16BE(payload_len, <span class=\"number\">2</span>);\n    }<span class=\"keyword\">else</span> {\n        buf[<span class=\"number\">1</span>] = <span class=\"number\">127</span>;\n        buf.writeUInt32BE(payload_len &gt;&gt;&gt; <span class=\"number\">32</span>, <span class=\"number\">2</span>);\n        buf.writeUInt32BE(payload_len &amp; <span class=\"number\">0xFFFFFFFF</span>, <span class=\"number\">6</span>);\n    }  \n    buf.write(data, payload_len);\n    <span class=\"keyword\">return</span> buf;\n}    \n</code></pre>\n<h4 id=\"心跳响应\"><a href=\"#心跳响应\" class=\"headerlink\" title=\"心跳响应\"></a>心跳响应</h4><p>当收到opcode 为 9时即ping请求，直接返回具有完全相同有效数据的pong即可。<br>Pings的opcode为0x9，pong是0xA，所以可以直接如下   </p>\n<pre><code class=\"js\"><span class=\"comment\">// ping请求</span>\n<span class=\"keyword\">if</span>(opcode == <span class=\"number\">9</span>){\n   <span class=\"built_in\">console</span>.log(<span class=\"string\">\"ping相应\"</span>);\n   <span class=\"comment\">/**</span>\n<span class=\"comment\">    * ping pong最大长度为125，所以可以直接拼接</span>\n<span class=\"comment\">    * 前两位数据为10001010+数据长度</span>\n<span class=\"comment\">    * 即传输完毕的pong响应，数据肯定小于125</span>\n<span class=\"comment\">    */</span>\n    socke.write(Buffer.concat([<span class=\"keyword\">new</span> Buffer([<span class=\"number\">0x8A</span>, data.length]), data]))\n}\n</code></pre>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>至此，一个websocket服务器的简单实现就完成了<a href=\"https://github.com/xiaoxiangdaiyu/chartroom/blob/master/src/websocket/ws.js\" target=\"_blank\" rel=\"noopener\">更多细节请查看</a>。当然成熟的websocket库处理各种情况是比较完善的，更推荐大家使用，这里只是简单实践，更多的是满足一下自己的好奇心，知其然，也要知其所以然，希望大家共同学习和进步</p>"},{"title":"实现一个websocket服务器-理论篇","date":"2017-11-06T02:50:06.000Z","_content":"本文是Writing WebSocket servers的中文文档，翻译自MDN[Writing WebSocket servers](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers)。篇幅略长，个人能力有限难免有所错误，抛砖引玉共同进步。\n<!-- more -->\n## websocket服务器的本质\nWebSocket 服务器简单来说就是一个遵循特殊协议监听服务器任意端口的tcp应用。搭建一个定制服务器的任务通常会让让人们感到害怕。然而基于实现一个简单的Websocket服务器没有那么麻烦。   \n\n一个WebSocket server可以使用任意的服务端编程语言来实现，只要该语言能实现基本的Berkeley sockets（伯克利套接字）。例如c(++)、Python、PHP、服务端JavaScript(node.js)。下面不是关于特定语言的教程，而是一个促进我们搭建自己服务器的指南。   \n\n我们需要明白http如何工作并且有中等编程经验。基于特定语言的支持，了解TCP sockets 同样也是必要的。该篇教程的范围是介绍开发一个WebSocket server需要的最少知识。   \n\n该文章将会从很底层的观点来解释一个 WebSocket server。WebSocket servers 通常是独立的专门的servers(因为负载均衡和其他一些原因),因此通常使用一个反向代理（例如一个标准的HTTP server）来发现 WebSocket握手协议，预处理他们然后将客户端信息发送给真正的WebSocket server。这意味着WebSocket server不必充斥这cookie和签名的处理方法。完全可以放在代理中处理。   \n## websocket 握手规则    \n\n首先，服务器必须使用标准的TCPsocket来监听即将到来的socket连接。基于我们的平台，这些很可能被我们处理了(成熟的服务端语言提供了这些接口，使我们不必从头做起)。例如，假设我们的服务器监听example.com的8000端口，socket server响应/chat的GET请求。   \n\n警告：服务器可以选择监听任意端口，但是如果在80或443之外，可能会遇到防火墙或者代理的问题。443端口大多数情况下是可以的，当然需要一个安全连接(TLS/SSL)。此外，注意这一点，大多数浏览器不允许从安全的页面连接到不安全的Websocket服务器。  \n在WebSockets中握手是web，是HTTP想WS转化的桥梁。通过握手，连接的详情会被判断，并且在完成之前每一个部分都可以终端如果条件不满足。服务器必须谨慎解析客户端请求的所有信息，否则安全问题将会发生。  \n\n## 客户端握手请求   \n\n尽管我们在开发一个服务器，客户端仍然需要发起一个Websocket握手过程。因此我们必须知道如何解析客户端的请求。客户端将会发送一个标准的HTTP请求，大概像下面的例子(HTTP版本必须1.1及以上，请求方式为GET)。     \n```\n    GET /chat HTTP/1.1\n    Host: example.com:8000\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n    Sec-WebSocket-Version: 13 \n```\n\n此处客户端可以发起扩展或者子协议，在[Miscellaneous](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Miscellaneous)查看更多细节。同样，公共的headers像User-Agent, Referer, Cookie, or authentication等同样可以包括，一句话做你想做的。这些并不直接和WebSocket相关，忽略掉他们也是安全的，在很多公共的设置中，会有一个代理服务器来处理这些信息。 \n\n如果有的header不被识别或者有非法值，服务器应该发送'400 Bad Request'并立刻关闭socket，通常也会在HTTP返回体中给出握手失败的原因，不过这些信息可能不会被展示(因为浏览器不会展示他们)。如果服务器不识别WebSockets的版本，应该返回一个Sec-WebSocket-Version 消息头，指明可以接受的版本(最好是V13,及最新)。下面一起看一下最神秘的消息头Sec-WebSocket-Key。    \n\n### 提示  \n\n* 所有的浏览器将会发送一个Origin header,我们可以使用这个header来做安全限制（检查是否相同的origin）如果并不是期望的origin返回一个403 Forbidden。然后注意下那些非浏览器的客户端可以发送一个伪造的origin，很多应用将会拒绝没有该消息头的请求。  \n* 请求资源定位符(这里的/chat)在规范中没有明确的定义，所以很多人巧妙的使用它，让一个服务器处理多个WebSocket 应用。例如，example.com/chat可以指向一个多用户聊天app，而相同服务器上的/game指向多用户的游戏。即[相同域名下的路径可以指向不同应用]()。   \n* 规范的HTTP code只可以在握手之前使用，当握手成功之后，应该使用不同的code集合。请查看规范第7.4节   \n\n## 服务器握手返回  \n\n当服务器接受到请求时，应该发送一个相当奇怪的响应，看起来大概这个样子，不过仍然遵循HTTP规范。 请注意每一个header以\\r\\n结尾并且在最后一个后面加入额外的\\r\\n。 \n\n```\n    HTTP/1.1 101 Switching Protocols\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n```\n\n此外，服务器可以在这里决定扩展或者子协议请求。更多详情请查看[Miscellaneous](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Miscellaneous)。Sec-WebSocket-Accept 部分很有趣，服务器必须基于客户端请求的Sec-WebSocket-Key 中得到它，具体做法如下：将Sec-WebSocket-Key 和\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"链接，通过SHA-1 hash获得结果，然后返回该结果的base64编码。   \n\n### 提示  \n\n因为这个看似复杂的过程存在，所以客户端不用关心服务器是否支持websocket。另外，该过程的重要性还是在于安全性，如果一个服务器将一个Websocket连接作为http请求解析的话，将会有不小的问题。   \n\n因此，如果key是\"dGhlIHNhbXBsZSBub25jZQ==\"，Accept将会是\"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\"，一旦服务器发送这些消息头，握手协议就完成了。   \n\n服务器在回复握手之前，可以发送其他的header像Set-Cookie、要求签名、重定向等。   \n\n## 跟踪客户端  \n\n虽然并不直接与Websocket协议相关，但值得我们注意。服务器将会跟踪客户端的sockets，因此我们不必和已经完成握手协议的客户端再次进行握手。相同客户端的IP地址可以尝试多次连接(但是服务器可以选择拒绝，如果他们尝试多次连接以达到保存自己Denial-of-Service 踪迹的目的)  \n\n## FramesEdit 数据交换  \n\n客户端和服务器都可以在任意时间发送消息、这正是websocket的魔力所在。然而从数据帧中提取信息的过程就不那么充满魔力了。尽管所有的帧遵循相同的特定格式，从客户端发到服务器的数据通过X异或加密 (使用32位的密钥)进行处理，该规范的第五章详细描述了相关内容。\n \n     \n## 格式  \n每个从客户端发送到服务器的数据帧遵循下面的格式：  \n  \n```  \n    帧格式:  \n​​\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-------+-+-------------+-------------------------------+\n     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n     |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n     | |1|2|3|       |K|             |                               |\n     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n     |     Extended payload length continued, if payload len == 127  |\n     + - - - - - - - - - - - - - - - +-------------------------------+\n     |                               |Masking-key, if MASK set to 1  |\n     +-------------------------------+-------------------------------+\n     | Masking-key (continued)       |          Payload Data         |\n     +-------------------------------- - - - - - - - - - - - - - - - +\n     :                     Payload Data continued ...                :\n     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n     |                     Payload Data continued ...                |\n     +---------------------------------------------------------------+\n\n```\n\n\nMASK (掩码:一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。)位只表明信息是否已进行掩码处理。来自客户端的消息必须经过处理，因此我们应该将其置为1(事实上5.1节表明，如果客户端发送未掩码处理的消息，服务器必须断开连接)当发送一个帧至客户端时，不要处理数据并且不设置mask位。下面将会阐述原因。注意：我们必须处理消息即使用一个安全的socket。RSV1-3可以被忽略，这是待扩展位。   \n\nopcode字段定义如何解析有效的数据：  \n* 0x0 继续处理\n* 0x1 text(必须是UTF-8编码)  \n* 0x2 二进制 和其他叫做控制代码的数据。\n* 0x3-0x7 0xB-0xF 该版本的WebSockets无意义   \n\nFIN 表明是否是数据集合的最后一段消息，如果为0，服务器继续监听消息，以待消息剩余的部分。否则服务器认为消息已经完全发送。   \n\n## 有效编码数据长度  \n\n为了解析有效编码数据，我们必须知道何时结束。这是知道有效数据长度的重要所在。不幸的是，有一些复杂。让我们分步骤来看。  \n1. 阅读9-15位并且作为无符号整数解释，如果是小于等于125，这就是数据的长度。如果是126，请继续步骤2,如果是127请阅读，步骤3   \n2. 阅读后面16位并且作为无符号整数解读，结束  \n3. 阅读后面64位并且作为无符号整数解读，结束    \n\n\n## 读取并反掩码数据  \n\n如果MASK位被设置(当然它应该被设置，对于一个从客户端到服务器的消息)，读取后4字节（即32位），即加密的key。一旦数据长度和加密key被解码，我们可以直接从socket中读取成批的字节。获取编码的数据和掩码key，将其解码，循环遍历加密的字节（octets，text数据的单位）并且将其与第（i%4）位掩码字节(即i除以4取余)进行异或运算，如果用js就如下所示(该规则就是加密解密的规则而已，没必要深究，大家知道如何使用就好)。 \n\n```js\n    var DECODED = \"\";\n    for (var i = 0; i < ENCODED.length; i++) {\n        DECODED[i] = ENCODED[i] ^ MASK[i % 4];\n    }\n```\n现在我们可以知道我们应用上解码之后的数据具体含义了。\n\n## 消息分割\n\nFIN和opcode字段共同工作来讲一个消息分解为单独的帧，该过程叫做消息分割，只有在opcodes为0x0-0x2时才可用（前面也提到，当前版本其他数值无意义）。  \n\n回想一下，opcode指明了一个帧的将要做什么，如果是0x1，数据是text。如果是0x2，诗句是二进制数据。然而当其为0x0时，该帧是一个继续帧，表示服务器应该将该帧的有效数据和服务器收到的最后一帧链接起来。这是一个草图，指明了当客户端发送text消息时，第一个消息在一个单独的帧里发送，然而第二个消息却包括三个帧，服务器如何反应。FIN和opcode细节仅仅对客户端展示。看一下下面的例子应该会更容易理解。\n    \n```\nClient: FIN=1, opcode=0x1, msg=\"hello\"\nServer: (消息传输过程完成) Hi.\nClient: FIN=0, opcode=0x1, msg=\"and a\"\nServer: (监听，新的消息包含开始的文本)\nClient: FIN=0, opcode=0x0, msg=\"happy new\"\nServer: (监听，有效数据与上面的消息拼接)\nClient: FIN=1, opcode=0x0, msg=\"year!\"\nServer: (消息传输完成) Happy new year to you too!\n```\n \n注意:第一帧包括一个完全的消息(FIN=1并且opcode!=0x0)，因此当服务器发现结束时可以返回。第二帧有效数据为text(opcode=0x1)，但是完整的消息没有到达(FIN=0)。该消息所有剩下的部分通过继续帧发送(opcode=0x0)，并且最后以帧通过FIN=1表明身份。  \n\n## WebSockets 的心跳：ping和pong  \n\n在握手接受之后的任意点，不论是客户端还是服务器都可以选择发送ping给另一部分。当ping被接收时，接收方必须尽可能的返回一个pong。我们可以用该方式来确保连接依然有效。  \n\n一个ping或者pong只是一个规则的帧，但是是控制帧，Pings的opcode为0x9，pong是0xA。当我们得到ping时，返回具有完全相同有效数据的pong。(对ping和pong而言，最大有效数据长度是125)我们可能在没有发送ping的情况下，得到一个pong。这种情况请忽略。\n\n在发送pong之前，如果我们接收到不止一个ping，只需回应一个pong即可。  \n## 关闭连接  \n\n要关闭客户端和服务器之间的连接，我们可以发送一个包含特定控制队列的数据的控制帧来开始关闭的握手协议。当接收到该帧时，另一方发送一个关闭帧作为回应。然后前者会关闭连接。关闭连接之后接收到的数据都会被丢弃。\n\n## 更多  \n\nWebSocket 扩展和子协议在握手过程中通过headers进行约定。有时扩展和子协议太近似了以致于难以分别。最基本的区别是，扩展控制websocket 帧并且修改有效数据。然而子协议构成websocket有效数据并且从不修改任何事物。扩展是可选的广义的，子协议是必须的局限性的。\n\n### 扩展 \n\n将扩展看作压缩一个文件在发送之前，无论你如何做，你将发送相同的数据只不过帧不同而已。收件人最终将会受到与你本地拷贝相同的数据，不过以不同方式发送。这就是扩展做的事情。websockets定义了一个协议和基本的方式去发送数据，然而扩展例如压缩可以以更短的帧来阿松相同的数据。 \n\n### 子协议  \n\n将子协议看作定做的xml表或者文档类型说明。你在使用XML和它的语法，但是你被限制于你同意的结构。WebSocket子协议就是如此。他们不介绍其他一些华丽的东西，仅仅建立结构，像一个文档类型和表一样，两个部分(client & server)都同意该协议,和文档类型和表不同，子协议由服务器实现并且客户端不能对外引用。  \n一个客户端必须请求特定的子协议，为了达到目的，将会发送一些像下面的内容作为原始握手的一部分。  \n\n```\nGET /chat HTTP/1.1\n...\nSec-WebSocket-Protocol: soap, wamp\n//或者等价的写法   \n...\nSec-WebSocket-Protocol: soap\nSec-WebSocket-Protocol: wamp\n```\n\n现在，服务器必须选择客户端建议并且支持的一种协议。如果多余一个，发送客户端发送过来的第一个。想象我们的服务器可以使用soap和wamp中的一个，然后，返回的握手中将会发送如下形式。\n\n```\nSec-WebSocket-Protocol: soap\n```\n\n\n服务器不能发送超过一个的Sec-Websocket-Protocol消息头，如果服务器不想使用任一个子协议，应该不发送Sec-WebSocket-Protocol 消息头。发送一个空白的消息头是错误的。客户端可能会关闭连接如果不能获得期望的子协议。    \n\n如果我们希望我们的服务器遵守一定的子协议，自然地在我们的服务器需要额外的代码。想象我们使用一个子协议json，基于该子协议，所有的数据将会作为JSON传递，如果一个客户端征求子协议并且服务器想使用它，服务你需要有一个JSON解析。实话实说，将会有一个工具库，但是服务器也要需要传递数据。\n\n\n为了避免名称冲突，推荐选用domain的一部分作为子协议的名称。如果我们开发一个使用特定格式的聊天app，我们可能使用这样的名字:Sec-WebSocket-Protocol: chat.example.com  注意，这不是必须的。仅仅是一个可选的惯例，我们可以使用我们想用的任意字符。\n## 结束语 \n翻译这篇文档的初衷是看到关于websocket的中文大部分都是客户端相关的内容，自己又对服务器端的实现感兴趣，没有找到合适的资料，就只好自己阅读下英文，本着提高自己的目的将其翻译下来，希望对其他同学有所帮助，[原文查看](https://github.com/xiaoxiangdaiyu/chartroom/tree/master/src/websocket) 。后面请期待node实现websocket服务器的实践篇。\n## 源文档出处  \n翻译自MDN[Writing WebSocket servers](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers)","source":"_posts/websocket/frame.md","raw":"---\ntitle: 实现一个websocket服务器-理论篇 \ndate: 2017-11-06 10:50:06\n---\n本文是Writing WebSocket servers的中文文档，翻译自MDN[Writing WebSocket servers](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers)。篇幅略长，个人能力有限难免有所错误，抛砖引玉共同进步。\n<!-- more -->\n## websocket服务器的本质\nWebSocket 服务器简单来说就是一个遵循特殊协议监听服务器任意端口的tcp应用。搭建一个定制服务器的任务通常会让让人们感到害怕。然而基于实现一个简单的Websocket服务器没有那么麻烦。   \n\n一个WebSocket server可以使用任意的服务端编程语言来实现，只要该语言能实现基本的Berkeley sockets（伯克利套接字）。例如c(++)、Python、PHP、服务端JavaScript(node.js)。下面不是关于特定语言的教程，而是一个促进我们搭建自己服务器的指南。   \n\n我们需要明白http如何工作并且有中等编程经验。基于特定语言的支持，了解TCP sockets 同样也是必要的。该篇教程的范围是介绍开发一个WebSocket server需要的最少知识。   \n\n该文章将会从很底层的观点来解释一个 WebSocket server。WebSocket servers 通常是独立的专门的servers(因为负载均衡和其他一些原因),因此通常使用一个反向代理（例如一个标准的HTTP server）来发现 WebSocket握手协议，预处理他们然后将客户端信息发送给真正的WebSocket server。这意味着WebSocket server不必充斥这cookie和签名的处理方法。完全可以放在代理中处理。   \n## websocket 握手规则    \n\n首先，服务器必须使用标准的TCPsocket来监听即将到来的socket连接。基于我们的平台，这些很可能被我们处理了(成熟的服务端语言提供了这些接口，使我们不必从头做起)。例如，假设我们的服务器监听example.com的8000端口，socket server响应/chat的GET请求。   \n\n警告：服务器可以选择监听任意端口，但是如果在80或443之外，可能会遇到防火墙或者代理的问题。443端口大多数情况下是可以的，当然需要一个安全连接(TLS/SSL)。此外，注意这一点，大多数浏览器不允许从安全的页面连接到不安全的Websocket服务器。  \n在WebSockets中握手是web，是HTTP想WS转化的桥梁。通过握手，连接的详情会被判断，并且在完成之前每一个部分都可以终端如果条件不满足。服务器必须谨慎解析客户端请求的所有信息，否则安全问题将会发生。  \n\n## 客户端握手请求   \n\n尽管我们在开发一个服务器，客户端仍然需要发起一个Websocket握手过程。因此我们必须知道如何解析客户端的请求。客户端将会发送一个标准的HTTP请求，大概像下面的例子(HTTP版本必须1.1及以上，请求方式为GET)。     \n```\n    GET /chat HTTP/1.1\n    Host: example.com:8000\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n    Sec-WebSocket-Version: 13 \n```\n\n此处客户端可以发起扩展或者子协议，在[Miscellaneous](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Miscellaneous)查看更多细节。同样，公共的headers像User-Agent, Referer, Cookie, or authentication等同样可以包括，一句话做你想做的。这些并不直接和WebSocket相关，忽略掉他们也是安全的，在很多公共的设置中，会有一个代理服务器来处理这些信息。 \n\n如果有的header不被识别或者有非法值，服务器应该发送'400 Bad Request'并立刻关闭socket，通常也会在HTTP返回体中给出握手失败的原因，不过这些信息可能不会被展示(因为浏览器不会展示他们)。如果服务器不识别WebSockets的版本，应该返回一个Sec-WebSocket-Version 消息头，指明可以接受的版本(最好是V13,及最新)。下面一起看一下最神秘的消息头Sec-WebSocket-Key。    \n\n### 提示  \n\n* 所有的浏览器将会发送一个Origin header,我们可以使用这个header来做安全限制（检查是否相同的origin）如果并不是期望的origin返回一个403 Forbidden。然后注意下那些非浏览器的客户端可以发送一个伪造的origin，很多应用将会拒绝没有该消息头的请求。  \n* 请求资源定位符(这里的/chat)在规范中没有明确的定义，所以很多人巧妙的使用它，让一个服务器处理多个WebSocket 应用。例如，example.com/chat可以指向一个多用户聊天app，而相同服务器上的/game指向多用户的游戏。即[相同域名下的路径可以指向不同应用]()。   \n* 规范的HTTP code只可以在握手之前使用，当握手成功之后，应该使用不同的code集合。请查看规范第7.4节   \n\n## 服务器握手返回  \n\n当服务器接受到请求时，应该发送一个相当奇怪的响应，看起来大概这个样子，不过仍然遵循HTTP规范。 请注意每一个header以\\r\\n结尾并且在最后一个后面加入额外的\\r\\n。 \n\n```\n    HTTP/1.1 101 Switching Protocols\n    Upgrade: websocket\n    Connection: Upgrade\n    Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n```\n\n此外，服务器可以在这里决定扩展或者子协议请求。更多详情请查看[Miscellaneous](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Miscellaneous)。Sec-WebSocket-Accept 部分很有趣，服务器必须基于客户端请求的Sec-WebSocket-Key 中得到它，具体做法如下：将Sec-WebSocket-Key 和\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"链接，通过SHA-1 hash获得结果，然后返回该结果的base64编码。   \n\n### 提示  \n\n因为这个看似复杂的过程存在，所以客户端不用关心服务器是否支持websocket。另外，该过程的重要性还是在于安全性，如果一个服务器将一个Websocket连接作为http请求解析的话，将会有不小的问题。   \n\n因此，如果key是\"dGhlIHNhbXBsZSBub25jZQ==\"，Accept将会是\"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\"，一旦服务器发送这些消息头，握手协议就完成了。   \n\n服务器在回复握手之前，可以发送其他的header像Set-Cookie、要求签名、重定向等。   \n\n## 跟踪客户端  \n\n虽然并不直接与Websocket协议相关，但值得我们注意。服务器将会跟踪客户端的sockets，因此我们不必和已经完成握手协议的客户端再次进行握手。相同客户端的IP地址可以尝试多次连接(但是服务器可以选择拒绝，如果他们尝试多次连接以达到保存自己Denial-of-Service 踪迹的目的)  \n\n## FramesEdit 数据交换  \n\n客户端和服务器都可以在任意时间发送消息、这正是websocket的魔力所在。然而从数据帧中提取信息的过程就不那么充满魔力了。尽管所有的帧遵循相同的特定格式，从客户端发到服务器的数据通过X异或加密 (使用32位的密钥)进行处理，该规范的第五章详细描述了相关内容。\n \n     \n## 格式  \n每个从客户端发送到服务器的数据帧遵循下面的格式：  \n  \n```  \n    帧格式:  \n​​\n      0                   1                   2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-------+-+-------------+-------------------------------+\n     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |\n     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |\n     |N|V|V|V|       |S|             |   (if payload len==126/127)   |\n     | |1|2|3|       |K|             |                               |\n     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +\n     |     Extended payload length continued, if payload len == 127  |\n     + - - - - - - - - - - - - - - - +-------------------------------+\n     |                               |Masking-key, if MASK set to 1  |\n     +-------------------------------+-------------------------------+\n     | Masking-key (continued)       |          Payload Data         |\n     +-------------------------------- - - - - - - - - - - - - - - - +\n     :                     Payload Data continued ...                :\n     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +\n     |                     Payload Data continued ...                |\n     +---------------------------------------------------------------+\n\n```\n\n\nMASK (掩码:一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。)位只表明信息是否已进行掩码处理。来自客户端的消息必须经过处理，因此我们应该将其置为1(事实上5.1节表明，如果客户端发送未掩码处理的消息，服务器必须断开连接)当发送一个帧至客户端时，不要处理数据并且不设置mask位。下面将会阐述原因。注意：我们必须处理消息即使用一个安全的socket。RSV1-3可以被忽略，这是待扩展位。   \n\nopcode字段定义如何解析有效的数据：  \n* 0x0 继续处理\n* 0x1 text(必须是UTF-8编码)  \n* 0x2 二进制 和其他叫做控制代码的数据。\n* 0x3-0x7 0xB-0xF 该版本的WebSockets无意义   \n\nFIN 表明是否是数据集合的最后一段消息，如果为0，服务器继续监听消息，以待消息剩余的部分。否则服务器认为消息已经完全发送。   \n\n## 有效编码数据长度  \n\n为了解析有效编码数据，我们必须知道何时结束。这是知道有效数据长度的重要所在。不幸的是，有一些复杂。让我们分步骤来看。  \n1. 阅读9-15位并且作为无符号整数解释，如果是小于等于125，这就是数据的长度。如果是126，请继续步骤2,如果是127请阅读，步骤3   \n2. 阅读后面16位并且作为无符号整数解读，结束  \n3. 阅读后面64位并且作为无符号整数解读，结束    \n\n\n## 读取并反掩码数据  \n\n如果MASK位被设置(当然它应该被设置，对于一个从客户端到服务器的消息)，读取后4字节（即32位），即加密的key。一旦数据长度和加密key被解码，我们可以直接从socket中读取成批的字节。获取编码的数据和掩码key，将其解码，循环遍历加密的字节（octets，text数据的单位）并且将其与第（i%4）位掩码字节(即i除以4取余)进行异或运算，如果用js就如下所示(该规则就是加密解密的规则而已，没必要深究，大家知道如何使用就好)。 \n\n```js\n    var DECODED = \"\";\n    for (var i = 0; i < ENCODED.length; i++) {\n        DECODED[i] = ENCODED[i] ^ MASK[i % 4];\n    }\n```\n现在我们可以知道我们应用上解码之后的数据具体含义了。\n\n## 消息分割\n\nFIN和opcode字段共同工作来讲一个消息分解为单独的帧，该过程叫做消息分割，只有在opcodes为0x0-0x2时才可用（前面也提到，当前版本其他数值无意义）。  \n\n回想一下，opcode指明了一个帧的将要做什么，如果是0x1，数据是text。如果是0x2，诗句是二进制数据。然而当其为0x0时，该帧是一个继续帧，表示服务器应该将该帧的有效数据和服务器收到的最后一帧链接起来。这是一个草图，指明了当客户端发送text消息时，第一个消息在一个单独的帧里发送，然而第二个消息却包括三个帧，服务器如何反应。FIN和opcode细节仅仅对客户端展示。看一下下面的例子应该会更容易理解。\n    \n```\nClient: FIN=1, opcode=0x1, msg=\"hello\"\nServer: (消息传输过程完成) Hi.\nClient: FIN=0, opcode=0x1, msg=\"and a\"\nServer: (监听，新的消息包含开始的文本)\nClient: FIN=0, opcode=0x0, msg=\"happy new\"\nServer: (监听，有效数据与上面的消息拼接)\nClient: FIN=1, opcode=0x0, msg=\"year!\"\nServer: (消息传输完成) Happy new year to you too!\n```\n \n注意:第一帧包括一个完全的消息(FIN=1并且opcode!=0x0)，因此当服务器发现结束时可以返回。第二帧有效数据为text(opcode=0x1)，但是完整的消息没有到达(FIN=0)。该消息所有剩下的部分通过继续帧发送(opcode=0x0)，并且最后以帧通过FIN=1表明身份。  \n\n## WebSockets 的心跳：ping和pong  \n\n在握手接受之后的任意点，不论是客户端还是服务器都可以选择发送ping给另一部分。当ping被接收时，接收方必须尽可能的返回一个pong。我们可以用该方式来确保连接依然有效。  \n\n一个ping或者pong只是一个规则的帧，但是是控制帧，Pings的opcode为0x9，pong是0xA。当我们得到ping时，返回具有完全相同有效数据的pong。(对ping和pong而言，最大有效数据长度是125)我们可能在没有发送ping的情况下，得到一个pong。这种情况请忽略。\n\n在发送pong之前，如果我们接收到不止一个ping，只需回应一个pong即可。  \n## 关闭连接  \n\n要关闭客户端和服务器之间的连接，我们可以发送一个包含特定控制队列的数据的控制帧来开始关闭的握手协议。当接收到该帧时，另一方发送一个关闭帧作为回应。然后前者会关闭连接。关闭连接之后接收到的数据都会被丢弃。\n\n## 更多  \n\nWebSocket 扩展和子协议在握手过程中通过headers进行约定。有时扩展和子协议太近似了以致于难以分别。最基本的区别是，扩展控制websocket 帧并且修改有效数据。然而子协议构成websocket有效数据并且从不修改任何事物。扩展是可选的广义的，子协议是必须的局限性的。\n\n### 扩展 \n\n将扩展看作压缩一个文件在发送之前，无论你如何做，你将发送相同的数据只不过帧不同而已。收件人最终将会受到与你本地拷贝相同的数据，不过以不同方式发送。这就是扩展做的事情。websockets定义了一个协议和基本的方式去发送数据，然而扩展例如压缩可以以更短的帧来阿松相同的数据。 \n\n### 子协议  \n\n将子协议看作定做的xml表或者文档类型说明。你在使用XML和它的语法，但是你被限制于你同意的结构。WebSocket子协议就是如此。他们不介绍其他一些华丽的东西，仅仅建立结构，像一个文档类型和表一样，两个部分(client & server)都同意该协议,和文档类型和表不同，子协议由服务器实现并且客户端不能对外引用。  \n一个客户端必须请求特定的子协议，为了达到目的，将会发送一些像下面的内容作为原始握手的一部分。  \n\n```\nGET /chat HTTP/1.1\n...\nSec-WebSocket-Protocol: soap, wamp\n//或者等价的写法   \n...\nSec-WebSocket-Protocol: soap\nSec-WebSocket-Protocol: wamp\n```\n\n现在，服务器必须选择客户端建议并且支持的一种协议。如果多余一个，发送客户端发送过来的第一个。想象我们的服务器可以使用soap和wamp中的一个，然后，返回的握手中将会发送如下形式。\n\n```\nSec-WebSocket-Protocol: soap\n```\n\n\n服务器不能发送超过一个的Sec-Websocket-Protocol消息头，如果服务器不想使用任一个子协议，应该不发送Sec-WebSocket-Protocol 消息头。发送一个空白的消息头是错误的。客户端可能会关闭连接如果不能获得期望的子协议。    \n\n如果我们希望我们的服务器遵守一定的子协议，自然地在我们的服务器需要额外的代码。想象我们使用一个子协议json，基于该子协议，所有的数据将会作为JSON传递，如果一个客户端征求子协议并且服务器想使用它，服务你需要有一个JSON解析。实话实说，将会有一个工具库，但是服务器也要需要传递数据。\n\n\n为了避免名称冲突，推荐选用domain的一部分作为子协议的名称。如果我们开发一个使用特定格式的聊天app，我们可能使用这样的名字:Sec-WebSocket-Protocol: chat.example.com  注意，这不是必须的。仅仅是一个可选的惯例，我们可以使用我们想用的任意字符。\n## 结束语 \n翻译这篇文档的初衷是看到关于websocket的中文大部分都是客户端相关的内容，自己又对服务器端的实现感兴趣，没有找到合适的资料，就只好自己阅读下英文，本着提高自己的目的将其翻译下来，希望对其他同学有所帮助，[原文查看](https://github.com/xiaoxiangdaiyu/chartroom/tree/master/src/websocket) 。后面请期待node实现websocket服务器的实践篇。\n## 源文档出处  \n翻译自MDN[Writing WebSocket servers](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers)","slug":"websocket/frame","published":1,"updated":"2018-08-24T07:48:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4tbvt7z001kgw921piii6hk","content":"<p>本文是Writing WebSocket servers的中文文档，翻译自MDN<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers\" target=\"_blank\" rel=\"noopener\">Writing WebSocket servers</a>。篇幅略长，个人能力有限难免有所错误，抛砖引玉共同进步。<br><a id=\"more\"></a></p>\n<h2 id=\"websocket服务器的本质\"><a href=\"#websocket服务器的本质\" class=\"headerlink\" title=\"websocket服务器的本质\"></a>websocket服务器的本质</h2><p>WebSocket 服务器简单来说就是一个遵循特殊协议监听服务器任意端口的tcp应用。搭建一个定制服务器的任务通常会让让人们感到害怕。然而基于实现一个简单的Websocket服务器没有那么麻烦。   </p>\n<p>一个WebSocket server可以使用任意的服务端编程语言来实现，只要该语言能实现基本的Berkeley sockets（伯克利套接字）。例如c(++)、Python、PHP、服务端JavaScript(node.js)。下面不是关于特定语言的教程，而是一个促进我们搭建自己服务器的指南。   </p>\n<p>我们需要明白http如何工作并且有中等编程经验。基于特定语言的支持，了解TCP sockets 同样也是必要的。该篇教程的范围是介绍开发一个WebSocket server需要的最少知识。   </p>\n<p>该文章将会从很底层的观点来解释一个 WebSocket server。WebSocket servers 通常是独立的专门的servers(因为负载均衡和其他一些原因),因此通常使用一个反向代理（例如一个标准的HTTP server）来发现 WebSocket握手协议，预处理他们然后将客户端信息发送给真正的WebSocket server。这意味着WebSocket server不必充斥这cookie和签名的处理方法。完全可以放在代理中处理。   </p>\n<h2 id=\"websocket-握手规则\"><a href=\"#websocket-握手规则\" class=\"headerlink\" title=\"websocket 握手规则\"></a>websocket 握手规则</h2><p>首先，服务器必须使用标准的TCPsocket来监听即将到来的socket连接。基于我们的平台，这些很可能被我们处理了(成熟的服务端语言提供了这些接口，使我们不必从头做起)。例如，假设我们的服务器监听example.com的8000端口，socket server响应/chat的GET请求。   </p>\n<p>警告：服务器可以选择监听任意端口，但是如果在80或443之外，可能会遇到防火墙或者代理的问题。443端口大多数情况下是可以的，当然需要一个安全连接(TLS/SSL)。此外，注意这一点，大多数浏览器不允许从安全的页面连接到不安全的Websocket服务器。<br>在WebSockets中握手是web，是HTTP想WS转化的桥梁。通过握手，连接的详情会被判断，并且在完成之前每一个部分都可以终端如果条件不满足。服务器必须谨慎解析客户端请求的所有信息，否则安全问题将会发生。  </p>\n<h2 id=\"客户端握手请求\"><a href=\"#客户端握手请求\" class=\"headerlink\" title=\"客户端握手请求\"></a>客户端握手请求</h2><p>尽管我们在开发一个服务器，客户端仍然需要发起一个Websocket握手过程。因此我们必须知道如何解析客户端的请求。客户端将会发送一个标准的HTTP请求，大概像下面的例子(HTTP版本必须1.1及以上，请求方式为GET)。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /chat HTTP/1.1</span><br><span class=\"line\">Host: example.com:8000</span><br><span class=\"line\">Upgrade: websocket</span><br><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class=\"line\">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></p>\n<p>此处客户端可以发起扩展或者子协议，在<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Miscellaneous\" target=\"_blank\" rel=\"noopener\">Miscellaneous</a>查看更多细节。同样，公共的headers像User-Agent, Referer, Cookie, or authentication等同样可以包括，一句话做你想做的。这些并不直接和WebSocket相关，忽略掉他们也是安全的，在很多公共的设置中，会有一个代理服务器来处理这些信息。 </p>\n<p>如果有的header不被识别或者有非法值，服务器应该发送’400 Bad Request’并立刻关闭socket，通常也会在HTTP返回体中给出握手失败的原因，不过这些信息可能不会被展示(因为浏览器不会展示他们)。如果服务器不识别WebSockets的版本，应该返回一个Sec-WebSocket-Version 消息头，指明可以接受的版本(最好是V13,及最新)。下面一起看一下最神秘的消息头Sec-WebSocket-Key。    </p>\n<h3 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h3><ul>\n<li>所有的浏览器将会发送一个Origin header,我们可以使用这个header来做安全限制（检查是否相同的origin）如果并不是期望的origin返回一个403 Forbidden。然后注意下那些非浏览器的客户端可以发送一个伪造的origin，很多应用将会拒绝没有该消息头的请求。  </li>\n<li>请求资源定位符(这里的/chat)在规范中没有明确的定义，所以很多人巧妙的使用它，让一个服务器处理多个WebSocket 应用。例如，example.com/chat可以指向一个多用户聊天app，而相同服务器上的/game指向多用户的游戏。即<a href=\"\">相同域名下的路径可以指向不同应用</a>。   </li>\n<li>规范的HTTP code只可以在握手之前使用，当握手成功之后，应该使用不同的code集合。请查看规范第7.4节   </li>\n</ul>\n<h2 id=\"服务器握手返回\"><a href=\"#服务器握手返回\" class=\"headerlink\" title=\"服务器握手返回\"></a>服务器握手返回</h2><p>当服务器接受到请求时，应该发送一个相当奇怪的响应，看起来大概这个样子，不过仍然遵循HTTP规范。 请注意每一个header以\\r\\n结尾并且在最后一个后面加入额外的\\r\\n。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 101 Switching Protocols</span><br><span class=\"line\">Upgrade: websocket</span><br><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>\n<p>此外，服务器可以在这里决定扩展或者子协议请求。更多详情请查看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Miscellaneous\" target=\"_blank\" rel=\"noopener\">Miscellaneous</a>。Sec-WebSocket-Accept 部分很有趣，服务器必须基于客户端请求的Sec-WebSocket-Key 中得到它，具体做法如下：将Sec-WebSocket-Key 和”258EAFA5-E914-47DA-95CA-C5AB0DC85B11”链接，通过SHA-1 hash获得结果，然后返回该结果的base64编码。   </p>\n<h3 id=\"提示-1\"><a href=\"#提示-1\" class=\"headerlink\" title=\"提示\"></a>提示</h3><p>因为这个看似复杂的过程存在，所以客户端不用关心服务器是否支持websocket。另外，该过程的重要性还是在于安全性，如果一个服务器将一个Websocket连接作为http请求解析的话，将会有不小的问题。   </p>\n<p>因此，如果key是”dGhlIHNhbXBsZSBub25jZQ==”，Accept将会是”s3pPLMBiTxaQ9kYGzzhZRbK+xOo=”，一旦服务器发送这些消息头，握手协议就完成了。   </p>\n<p>服务器在回复握手之前，可以发送其他的header像Set-Cookie、要求签名、重定向等。   </p>\n<h2 id=\"跟踪客户端\"><a href=\"#跟踪客户端\" class=\"headerlink\" title=\"跟踪客户端\"></a>跟踪客户端</h2><p>虽然并不直接与Websocket协议相关，但值得我们注意。服务器将会跟踪客户端的sockets，因此我们不必和已经完成握手协议的客户端再次进行握手。相同客户端的IP地址可以尝试多次连接(但是服务器可以选择拒绝，如果他们尝试多次连接以达到保存自己Denial-of-Service 踪迹的目的)  </p>\n<h2 id=\"FramesEdit-数据交换\"><a href=\"#FramesEdit-数据交换\" class=\"headerlink\" title=\"FramesEdit 数据交换\"></a>FramesEdit 数据交换</h2><p>客户端和服务器都可以在任意时间发送消息、这正是websocket的魔力所在。然而从数据帧中提取信息的过程就不那么充满魔力了。尽管所有的帧遵循相同的特定格式，从客户端发到服务器的数据通过X异或加密 (使用32位的密钥)进行处理，该规范的第五章详细描述了相关内容。</p>\n<h2 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h2><p>每个从客户端发送到服务器的数据帧遵循下面的格式：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    帧格式:  </span><br><span class=\"line\">​​</span><br><span class=\"line\">      0                   1                   2                   3</span><br><span class=\"line\">      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">     +-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class=\"line\">     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class=\"line\">     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class=\"line\">     |N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class=\"line\">     | |1|2|3|       |K|             |                               |</span><br><span class=\"line\">     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     |     Extended payload length continued, if payload len == 127  |</span><br><span class=\"line\">     + - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class=\"line\">     |                               |Masking-key, if MASK set to 1  |</span><br><span class=\"line\">     +-------------------------------+-------------------------------+</span><br><span class=\"line\">     | Masking-key (continued)       |          Payload Data         |</span><br><span class=\"line\">     +-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     :                     Payload Data continued ...                :</span><br><span class=\"line\">     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     |                     Payload Data continued ...                |</span><br><span class=\"line\">     +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n<p>MASK (掩码:一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。)位只表明信息是否已进行掩码处理。来自客户端的消息必须经过处理，因此我们应该将其置为1(事实上5.1节表明，如果客户端发送未掩码处理的消息，服务器必须断开连接)当发送一个帧至客户端时，不要处理数据并且不设置mask位。下面将会阐述原因。注意：我们必须处理消息即使用一个安全的socket。RSV1-3可以被忽略，这是待扩展位。   </p>\n<p>opcode字段定义如何解析有效的数据：  </p>\n<ul>\n<li>0x0 继续处理</li>\n<li>0x1 text(必须是UTF-8编码)  </li>\n<li>0x2 二进制 和其他叫做控制代码的数据。</li>\n<li>0x3-0x7 0xB-0xF 该版本的WebSockets无意义   </li>\n</ul>\n<p>FIN 表明是否是数据集合的最后一段消息，如果为0，服务器继续监听消息，以待消息剩余的部分。否则服务器认为消息已经完全发送。   </p>\n<h2 id=\"有效编码数据长度\"><a href=\"#有效编码数据长度\" class=\"headerlink\" title=\"有效编码数据长度\"></a>有效编码数据长度</h2><p>为了解析有效编码数据，我们必须知道何时结束。这是知道有效数据长度的重要所在。不幸的是，有一些复杂。让我们分步骤来看。  </p>\n<ol>\n<li>阅读9-15位并且作为无符号整数解释，如果是小于等于125，这就是数据的长度。如果是126，请继续步骤2,如果是127请阅读，步骤3   </li>\n<li>阅读后面16位并且作为无符号整数解读，结束  </li>\n<li>阅读后面64位并且作为无符号整数解读，结束    </li>\n</ol>\n<h2 id=\"读取并反掩码数据\"><a href=\"#读取并反掩码数据\" class=\"headerlink\" title=\"读取并反掩码数据\"></a>读取并反掩码数据</h2><p>如果MASK位被设置(当然它应该被设置，对于一个从客户端到服务器的消息)，读取后4字节（即32位），即加密的key。一旦数据长度和加密key被解码，我们可以直接从socket中读取成批的字节。获取编码的数据和掩码key，将其解码，循环遍历加密的字节（octets，text数据的单位）并且将其与第（i%4）位掩码字节(即i除以4取余)进行异或运算，如果用js就如下所示(该规则就是加密解密的规则而已，没必要深究，大家知道如何使用就好)。 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> DECODED = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; ENCODED.length; i++) &#123;</span><br><span class=\"line\">    DECODED[i] = ENCODED[i] ^ MASK[i % <span class=\"number\">4</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以知道我们应用上解码之后的数据具体含义了。</p>\n<h2 id=\"消息分割\"><a href=\"#消息分割\" class=\"headerlink\" title=\"消息分割\"></a>消息分割</h2><p>FIN和opcode字段共同工作来讲一个消息分解为单独的帧，该过程叫做消息分割，只有在opcodes为0x0-0x2时才可用（前面也提到，当前版本其他数值无意义）。  </p>\n<p>回想一下，opcode指明了一个帧的将要做什么，如果是0x1，数据是text。如果是0x2，诗句是二进制数据。然而当其为0x0时，该帧是一个继续帧，表示服务器应该将该帧的有效数据和服务器收到的最后一帧链接起来。这是一个草图，指明了当客户端发送text消息时，第一个消息在一个单独的帧里发送，然而第二个消息却包括三个帧，服务器如何反应。FIN和opcode细节仅仅对客户端展示。看一下下面的例子应该会更容易理解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Client: FIN=1, opcode=0x1, msg=&quot;hello&quot;</span><br><span class=\"line\">Server: (消息传输过程完成) Hi.</span><br><span class=\"line\">Client: FIN=0, opcode=0x1, msg=&quot;and a&quot;</span><br><span class=\"line\">Server: (监听，新的消息包含开始的文本)</span><br><span class=\"line\">Client: FIN=0, opcode=0x0, msg=&quot;happy new&quot;</span><br><span class=\"line\">Server: (监听，有效数据与上面的消息拼接)</span><br><span class=\"line\">Client: FIN=1, opcode=0x0, msg=&quot;year!&quot;</span><br><span class=\"line\">Server: (消息传输完成) Happy new year to you too!</span><br></pre></td></tr></table></figure>\n<p>注意:第一帧包括一个完全的消息(FIN=1并且opcode!=0x0)，因此当服务器发现结束时可以返回。第二帧有效数据为text(opcode=0x1)，但是完整的消息没有到达(FIN=0)。该消息所有剩下的部分通过继续帧发送(opcode=0x0)，并且最后以帧通过FIN=1表明身份。  </p>\n<h2 id=\"WebSockets-的心跳：ping和pong\"><a href=\"#WebSockets-的心跳：ping和pong\" class=\"headerlink\" title=\"WebSockets 的心跳：ping和pong\"></a>WebSockets 的心跳：ping和pong</h2><p>在握手接受之后的任意点，不论是客户端还是服务器都可以选择发送ping给另一部分。当ping被接收时，接收方必须尽可能的返回一个pong。我们可以用该方式来确保连接依然有效。  </p>\n<p>一个ping或者pong只是一个规则的帧，但是是控制帧，Pings的opcode为0x9，pong是0xA。当我们得到ping时，返回具有完全相同有效数据的pong。(对ping和pong而言，最大有效数据长度是125)我们可能在没有发送ping的情况下，得到一个pong。这种情况请忽略。</p>\n<p>在发送pong之前，如果我们接收到不止一个ping，只需回应一个pong即可。  </p>\n<h2 id=\"关闭连接\"><a href=\"#关闭连接\" class=\"headerlink\" title=\"关闭连接\"></a>关闭连接</h2><p>要关闭客户端和服务器之间的连接，我们可以发送一个包含特定控制队列的数据的控制帧来开始关闭的握手协议。当接收到该帧时，另一方发送一个关闭帧作为回应。然后前者会关闭连接。关闭连接之后接收到的数据都会被丢弃。</p>\n<h2 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h2><p>WebSocket 扩展和子协议在握手过程中通过headers进行约定。有时扩展和子协议太近似了以致于难以分别。最基本的区别是，扩展控制websocket 帧并且修改有效数据。然而子协议构成websocket有效数据并且从不修改任何事物。扩展是可选的广义的，子协议是必须的局限性的。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>将扩展看作压缩一个文件在发送之前，无论你如何做，你将发送相同的数据只不过帧不同而已。收件人最终将会受到与你本地拷贝相同的数据，不过以不同方式发送。这就是扩展做的事情。websockets定义了一个协议和基本的方式去发送数据，然而扩展例如压缩可以以更短的帧来阿松相同的数据。 </p>\n<h3 id=\"子协议\"><a href=\"#子协议\" class=\"headerlink\" title=\"子协议\"></a>子协议</h3><p>将子协议看作定做的xml表或者文档类型说明。你在使用XML和它的语法，但是你被限制于你同意的结构。WebSocket子协议就是如此。他们不介绍其他一些华丽的东西，仅仅建立结构，像一个文档类型和表一样，两个部分(client &amp; server)都同意该协议,和文档类型和表不同，子协议由服务器实现并且客户端不能对外引用。<br>一个客户端必须请求特定的子协议，为了达到目的，将会发送一些像下面的内容作为原始握手的一部分。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /chat HTTP/1.1</span><br><span class=\"line\">...</span><br><span class=\"line\">Sec-WebSocket-Protocol: soap, wamp</span><br><span class=\"line\">//或者等价的写法   </span><br><span class=\"line\">...</span><br><span class=\"line\">Sec-WebSocket-Protocol: soap</span><br><span class=\"line\">Sec-WebSocket-Protocol: wamp</span><br></pre></td></tr></table></figure>\n<p>现在，服务器必须选择客户端建议并且支持的一种协议。如果多余一个，发送客户端发送过来的第一个。想象我们的服务器可以使用soap和wamp中的一个，然后，返回的握手中将会发送如下形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sec-WebSocket-Protocol: soap</span><br></pre></td></tr></table></figure>\n<p>服务器不能发送超过一个的Sec-Websocket-Protocol消息头，如果服务器不想使用任一个子协议，应该不发送Sec-WebSocket-Protocol 消息头。发送一个空白的消息头是错误的。客户端可能会关闭连接如果不能获得期望的子协议。    </p>\n<p>如果我们希望我们的服务器遵守一定的子协议，自然地在我们的服务器需要额外的代码。想象我们使用一个子协议json，基于该子协议，所有的数据将会作为JSON传递，如果一个客户端征求子协议并且服务器想使用它，服务你需要有一个JSON解析。实话实说，将会有一个工具库，但是服务器也要需要传递数据。</p>\n<p>为了避免名称冲突，推荐选用domain的一部分作为子协议的名称。如果我们开发一个使用特定格式的聊天app，我们可能使用这样的名字:Sec-WebSocket-Protocol: chat.example.com  注意，这不是必须的。仅仅是一个可选的惯例，我们可以使用我们想用的任意字符。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>翻译这篇文档的初衷是看到关于websocket的中文大部分都是客户端相关的内容，自己又对服务器端的实现感兴趣，没有找到合适的资料，就只好自己阅读下英文，本着提高自己的目的将其翻译下来，希望对其他同学有所帮助，<a href=\"https://github.com/xiaoxiangdaiyu/chartroom/tree/master/src/websocket\" target=\"_blank\" rel=\"noopener\">原文查看</a> 。后面请期待node实现websocket服务器的实践篇。</p>\n<h2 id=\"源文档出处\"><a href=\"#源文档出处\" class=\"headerlink\" title=\"源文档出处\"></a>源文档出处</h2><p>翻译自MDN<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers\" target=\"_blank\" rel=\"noopener\">Writing WebSocket servers</a></p>\n","site":{"data":{}},"excerpt":"<p>本文是Writing WebSocket servers的中文文档，翻译自MDN<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers\" target=\"_blank\" rel=\"noopener\">Writing WebSocket servers</a>。篇幅略长，个人能力有限难免有所错误，抛砖引玉共同进步。<br>","more":"</p>\n<h2 id=\"websocket服务器的本质\"><a href=\"#websocket服务器的本质\" class=\"headerlink\" title=\"websocket服务器的本质\"></a>websocket服务器的本质</h2><p>WebSocket 服务器简单来说就是一个遵循特殊协议监听服务器任意端口的tcp应用。搭建一个定制服务器的任务通常会让让人们感到害怕。然而基于实现一个简单的Websocket服务器没有那么麻烦。   </p>\n<p>一个WebSocket server可以使用任意的服务端编程语言来实现，只要该语言能实现基本的Berkeley sockets（伯克利套接字）。例如c(++)、Python、PHP、服务端JavaScript(node.js)。下面不是关于特定语言的教程，而是一个促进我们搭建自己服务器的指南。   </p>\n<p>我们需要明白http如何工作并且有中等编程经验。基于特定语言的支持，了解TCP sockets 同样也是必要的。该篇教程的范围是介绍开发一个WebSocket server需要的最少知识。   </p>\n<p>该文章将会从很底层的观点来解释一个 WebSocket server。WebSocket servers 通常是独立的专门的servers(因为负载均衡和其他一些原因),因此通常使用一个反向代理（例如一个标准的HTTP server）来发现 WebSocket握手协议，预处理他们然后将客户端信息发送给真正的WebSocket server。这意味着WebSocket server不必充斥这cookie和签名的处理方法。完全可以放在代理中处理。   </p>\n<h2 id=\"websocket-握手规则\"><a href=\"#websocket-握手规则\" class=\"headerlink\" title=\"websocket 握手规则\"></a>websocket 握手规则</h2><p>首先，服务器必须使用标准的TCPsocket来监听即将到来的socket连接。基于我们的平台，这些很可能被我们处理了(成熟的服务端语言提供了这些接口，使我们不必从头做起)。例如，假设我们的服务器监听example.com的8000端口，socket server响应/chat的GET请求。   </p>\n<p>警告：服务器可以选择监听任意端口，但是如果在80或443之外，可能会遇到防火墙或者代理的问题。443端口大多数情况下是可以的，当然需要一个安全连接(TLS/SSL)。此外，注意这一点，大多数浏览器不允许从安全的页面连接到不安全的Websocket服务器。<br>在WebSockets中握手是web，是HTTP想WS转化的桥梁。通过握手，连接的详情会被判断，并且在完成之前每一个部分都可以终端如果条件不满足。服务器必须谨慎解析客户端请求的所有信息，否则安全问题将会发生。  </p>\n<h2 id=\"客户端握手请求\"><a href=\"#客户端握手请求\" class=\"headerlink\" title=\"客户端握手请求\"></a>客户端握手请求</h2><p>尽管我们在开发一个服务器，客户端仍然需要发起一个Websocket握手过程。因此我们必须知道如何解析客户端的请求。客户端将会发送一个标准的HTTP请求，大概像下面的例子(HTTP版本必须1.1及以上，请求方式为GET)。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /chat HTTP/1.1</span><br><span class=\"line\">Host: example.com:8000</span><br><span class=\"line\">Upgrade: websocket</span><br><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==</span><br><span class=\"line\">Sec-WebSocket-Version: 13</span><br></pre></td></tr></table></figure></p>\n<p>此处客户端可以发起扩展或者子协议，在<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Miscellaneous\" target=\"_blank\" rel=\"noopener\">Miscellaneous</a>查看更多细节。同样，公共的headers像User-Agent, Referer, Cookie, or authentication等同样可以包括，一句话做你想做的。这些并不直接和WebSocket相关，忽略掉他们也是安全的，在很多公共的设置中，会有一个代理服务器来处理这些信息。 </p>\n<p>如果有的header不被识别或者有非法值，服务器应该发送’400 Bad Request’并立刻关闭socket，通常也会在HTTP返回体中给出握手失败的原因，不过这些信息可能不会被展示(因为浏览器不会展示他们)。如果服务器不识别WebSockets的版本，应该返回一个Sec-WebSocket-Version 消息头，指明可以接受的版本(最好是V13,及最新)。下面一起看一下最神秘的消息头Sec-WebSocket-Key。    </p>\n<h3 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h3><ul>\n<li>所有的浏览器将会发送一个Origin header,我们可以使用这个header来做安全限制（检查是否相同的origin）如果并不是期望的origin返回一个403 Forbidden。然后注意下那些非浏览器的客户端可以发送一个伪造的origin，很多应用将会拒绝没有该消息头的请求。  </li>\n<li>请求资源定位符(这里的/chat)在规范中没有明确的定义，所以很多人巧妙的使用它，让一个服务器处理多个WebSocket 应用。例如，example.com/chat可以指向一个多用户聊天app，而相同服务器上的/game指向多用户的游戏。即<a href=\"\">相同域名下的路径可以指向不同应用</a>。   </li>\n<li>规范的HTTP code只可以在握手之前使用，当握手成功之后，应该使用不同的code集合。请查看规范第7.4节   </li>\n</ul>\n<h2 id=\"服务器握手返回\"><a href=\"#服务器握手返回\" class=\"headerlink\" title=\"服务器握手返回\"></a>服务器握手返回</h2><p>当服务器接受到请求时，应该发送一个相当奇怪的响应，看起来大概这个样子，不过仍然遵循HTTP规范。 请注意每一个header以\\r\\n结尾并且在最后一个后面加入额外的\\r\\n。 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 101 Switching Protocols</span><br><span class=\"line\">Upgrade: websocket</span><br><span class=\"line\">Connection: Upgrade</span><br><span class=\"line\">Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br></pre></td></tr></table></figure>\n<p>此外，服务器可以在这里决定扩展或者子协议请求。更多详情请查看<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#Miscellaneous\" target=\"_blank\" rel=\"noopener\">Miscellaneous</a>。Sec-WebSocket-Accept 部分很有趣，服务器必须基于客户端请求的Sec-WebSocket-Key 中得到它，具体做法如下：将Sec-WebSocket-Key 和”258EAFA5-E914-47DA-95CA-C5AB0DC85B11”链接，通过SHA-1 hash获得结果，然后返回该结果的base64编码。   </p>\n<h3 id=\"提示-1\"><a href=\"#提示-1\" class=\"headerlink\" title=\"提示\"></a>提示</h3><p>因为这个看似复杂的过程存在，所以客户端不用关心服务器是否支持websocket。另外，该过程的重要性还是在于安全性，如果一个服务器将一个Websocket连接作为http请求解析的话，将会有不小的问题。   </p>\n<p>因此，如果key是”dGhlIHNhbXBsZSBub25jZQ==”，Accept将会是”s3pPLMBiTxaQ9kYGzzhZRbK+xOo=”，一旦服务器发送这些消息头，握手协议就完成了。   </p>\n<p>服务器在回复握手之前，可以发送其他的header像Set-Cookie、要求签名、重定向等。   </p>\n<h2 id=\"跟踪客户端\"><a href=\"#跟踪客户端\" class=\"headerlink\" title=\"跟踪客户端\"></a>跟踪客户端</h2><p>虽然并不直接与Websocket协议相关，但值得我们注意。服务器将会跟踪客户端的sockets，因此我们不必和已经完成握手协议的客户端再次进行握手。相同客户端的IP地址可以尝试多次连接(但是服务器可以选择拒绝，如果他们尝试多次连接以达到保存自己Denial-of-Service 踪迹的目的)  </p>\n<h2 id=\"FramesEdit-数据交换\"><a href=\"#FramesEdit-数据交换\" class=\"headerlink\" title=\"FramesEdit 数据交换\"></a>FramesEdit 数据交换</h2><p>客户端和服务器都可以在任意时间发送消息、这正是websocket的魔力所在。然而从数据帧中提取信息的过程就不那么充满魔力了。尽管所有的帧遵循相同的特定格式，从客户端发到服务器的数据通过X异或加密 (使用32位的密钥)进行处理，该规范的第五章详细描述了相关内容。</p>\n<h2 id=\"格式\"><a href=\"#格式\" class=\"headerlink\" title=\"格式\"></a>格式</h2><p>每个从客户端发送到服务器的数据帧遵循下面的格式：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    帧格式:  </span><br><span class=\"line\">​​</span><br><span class=\"line\">      0                   1                   2                   3</span><br><span class=\"line\">      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</span><br><span class=\"line\">     +-+-+-+-+-------+-+-------------+-------------------------------+</span><br><span class=\"line\">     |F|R|R|R| opcode|M| Payload len |    Extended payload length    |</span><br><span class=\"line\">     |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |</span><br><span class=\"line\">     |N|V|V|V|       |S|             |   (if payload len==126/127)   |</span><br><span class=\"line\">     | |1|2|3|       |K|             |                               |</span><br><span class=\"line\">     +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     |     Extended payload length continued, if payload len == 127  |</span><br><span class=\"line\">     + - - - - - - - - - - - - - - - +-------------------------------+</span><br><span class=\"line\">     |                               |Masking-key, if MASK set to 1  |</span><br><span class=\"line\">     +-------------------------------+-------------------------------+</span><br><span class=\"line\">     | Masking-key (continued)       |          Payload Data         |</span><br><span class=\"line\">     +-------------------------------- - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     :                     Payload Data continued ...                :</span><br><span class=\"line\">     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +</span><br><span class=\"line\">     |                     Payload Data continued ...                |</span><br><span class=\"line\">     +---------------------------------------------------------------+</span><br></pre></td></tr></table></figure>\n<p>MASK (掩码:一串二进制代码对目标字段进行位与运算，屏蔽当前的输入位。)位只表明信息是否已进行掩码处理。来自客户端的消息必须经过处理，因此我们应该将其置为1(事实上5.1节表明，如果客户端发送未掩码处理的消息，服务器必须断开连接)当发送一个帧至客户端时，不要处理数据并且不设置mask位。下面将会阐述原因。注意：我们必须处理消息即使用一个安全的socket。RSV1-3可以被忽略，这是待扩展位。   </p>\n<p>opcode字段定义如何解析有效的数据：  </p>\n<ul>\n<li>0x0 继续处理</li>\n<li>0x1 text(必须是UTF-8编码)  </li>\n<li>0x2 二进制 和其他叫做控制代码的数据。</li>\n<li>0x3-0x7 0xB-0xF 该版本的WebSockets无意义   </li>\n</ul>\n<p>FIN 表明是否是数据集合的最后一段消息，如果为0，服务器继续监听消息，以待消息剩余的部分。否则服务器认为消息已经完全发送。   </p>\n<h2 id=\"有效编码数据长度\"><a href=\"#有效编码数据长度\" class=\"headerlink\" title=\"有效编码数据长度\"></a>有效编码数据长度</h2><p>为了解析有效编码数据，我们必须知道何时结束。这是知道有效数据长度的重要所在。不幸的是，有一些复杂。让我们分步骤来看。  </p>\n<ol>\n<li>阅读9-15位并且作为无符号整数解释，如果是小于等于125，这就是数据的长度。如果是126，请继续步骤2,如果是127请阅读，步骤3   </li>\n<li>阅读后面16位并且作为无符号整数解读，结束  </li>\n<li>阅读后面64位并且作为无符号整数解读，结束    </li>\n</ol>\n<h2 id=\"读取并反掩码数据\"><a href=\"#读取并反掩码数据\" class=\"headerlink\" title=\"读取并反掩码数据\"></a>读取并反掩码数据</h2><p>如果MASK位被设置(当然它应该被设置，对于一个从客户端到服务器的消息)，读取后4字节（即32位），即加密的key。一旦数据长度和加密key被解码，我们可以直接从socket中读取成批的字节。获取编码的数据和掩码key，将其解码，循环遍历加密的字节（octets，text数据的单位）并且将其与第（i%4）位掩码字节(即i除以4取余)进行异或运算，如果用js就如下所示(该规则就是加密解密的规则而已，没必要深究，大家知道如何使用就好)。 </p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> DECODED = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; ENCODED.length; i++) &#123;</span><br><span class=\"line\">    DECODED[i] = ENCODED[i] ^ MASK[i % <span class=\"number\">4</span>];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们可以知道我们应用上解码之后的数据具体含义了。</p>\n<h2 id=\"消息分割\"><a href=\"#消息分割\" class=\"headerlink\" title=\"消息分割\"></a>消息分割</h2><p>FIN和opcode字段共同工作来讲一个消息分解为单独的帧，该过程叫做消息分割，只有在opcodes为0x0-0x2时才可用（前面也提到，当前版本其他数值无意义）。  </p>\n<p>回想一下，opcode指明了一个帧的将要做什么，如果是0x1，数据是text。如果是0x2，诗句是二进制数据。然而当其为0x0时，该帧是一个继续帧，表示服务器应该将该帧的有效数据和服务器收到的最后一帧链接起来。这是一个草图，指明了当客户端发送text消息时，第一个消息在一个单独的帧里发送，然而第二个消息却包括三个帧，服务器如何反应。FIN和opcode细节仅仅对客户端展示。看一下下面的例子应该会更容易理解。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Client: FIN=1, opcode=0x1, msg=&quot;hello&quot;</span><br><span class=\"line\">Server: (消息传输过程完成) Hi.</span><br><span class=\"line\">Client: FIN=0, opcode=0x1, msg=&quot;and a&quot;</span><br><span class=\"line\">Server: (监听，新的消息包含开始的文本)</span><br><span class=\"line\">Client: FIN=0, opcode=0x0, msg=&quot;happy new&quot;</span><br><span class=\"line\">Server: (监听，有效数据与上面的消息拼接)</span><br><span class=\"line\">Client: FIN=1, opcode=0x0, msg=&quot;year!&quot;</span><br><span class=\"line\">Server: (消息传输完成) Happy new year to you too!</span><br></pre></td></tr></table></figure>\n<p>注意:第一帧包括一个完全的消息(FIN=1并且opcode!=0x0)，因此当服务器发现结束时可以返回。第二帧有效数据为text(opcode=0x1)，但是完整的消息没有到达(FIN=0)。该消息所有剩下的部分通过继续帧发送(opcode=0x0)，并且最后以帧通过FIN=1表明身份。  </p>\n<h2 id=\"WebSockets-的心跳：ping和pong\"><a href=\"#WebSockets-的心跳：ping和pong\" class=\"headerlink\" title=\"WebSockets 的心跳：ping和pong\"></a>WebSockets 的心跳：ping和pong</h2><p>在握手接受之后的任意点，不论是客户端还是服务器都可以选择发送ping给另一部分。当ping被接收时，接收方必须尽可能的返回一个pong。我们可以用该方式来确保连接依然有效。  </p>\n<p>一个ping或者pong只是一个规则的帧，但是是控制帧，Pings的opcode为0x9，pong是0xA。当我们得到ping时，返回具有完全相同有效数据的pong。(对ping和pong而言，最大有效数据长度是125)我们可能在没有发送ping的情况下，得到一个pong。这种情况请忽略。</p>\n<p>在发送pong之前，如果我们接收到不止一个ping，只需回应一个pong即可。  </p>\n<h2 id=\"关闭连接\"><a href=\"#关闭连接\" class=\"headerlink\" title=\"关闭连接\"></a>关闭连接</h2><p>要关闭客户端和服务器之间的连接，我们可以发送一个包含特定控制队列的数据的控制帧来开始关闭的握手协议。当接收到该帧时，另一方发送一个关闭帧作为回应。然后前者会关闭连接。关闭连接之后接收到的数据都会被丢弃。</p>\n<h2 id=\"更多\"><a href=\"#更多\" class=\"headerlink\" title=\"更多\"></a>更多</h2><p>WebSocket 扩展和子协议在握手过程中通过headers进行约定。有时扩展和子协议太近似了以致于难以分别。最基本的区别是，扩展控制websocket 帧并且修改有效数据。然而子协议构成websocket有效数据并且从不修改任何事物。扩展是可选的广义的，子协议是必须的局限性的。</p>\n<h3 id=\"扩展\"><a href=\"#扩展\" class=\"headerlink\" title=\"扩展\"></a>扩展</h3><p>将扩展看作压缩一个文件在发送之前，无论你如何做，你将发送相同的数据只不过帧不同而已。收件人最终将会受到与你本地拷贝相同的数据，不过以不同方式发送。这就是扩展做的事情。websockets定义了一个协议和基本的方式去发送数据，然而扩展例如压缩可以以更短的帧来阿松相同的数据。 </p>\n<h3 id=\"子协议\"><a href=\"#子协议\" class=\"headerlink\" title=\"子协议\"></a>子协议</h3><p>将子协议看作定做的xml表或者文档类型说明。你在使用XML和它的语法，但是你被限制于你同意的结构。WebSocket子协议就是如此。他们不介绍其他一些华丽的东西，仅仅建立结构，像一个文档类型和表一样，两个部分(client &amp; server)都同意该协议,和文档类型和表不同，子协议由服务器实现并且客户端不能对外引用。<br>一个客户端必须请求特定的子协议，为了达到目的，将会发送一些像下面的内容作为原始握手的一部分。  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /chat HTTP/1.1</span><br><span class=\"line\">...</span><br><span class=\"line\">Sec-WebSocket-Protocol: soap, wamp</span><br><span class=\"line\">//或者等价的写法   </span><br><span class=\"line\">...</span><br><span class=\"line\">Sec-WebSocket-Protocol: soap</span><br><span class=\"line\">Sec-WebSocket-Protocol: wamp</span><br></pre></td></tr></table></figure>\n<p>现在，服务器必须选择客户端建议并且支持的一种协议。如果多余一个，发送客户端发送过来的第一个。想象我们的服务器可以使用soap和wamp中的一个，然后，返回的握手中将会发送如下形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sec-WebSocket-Protocol: soap</span><br></pre></td></tr></table></figure>\n<p>服务器不能发送超过一个的Sec-Websocket-Protocol消息头，如果服务器不想使用任一个子协议，应该不发送Sec-WebSocket-Protocol 消息头。发送一个空白的消息头是错误的。客户端可能会关闭连接如果不能获得期望的子协议。    </p>\n<p>如果我们希望我们的服务器遵守一定的子协议，自然地在我们的服务器需要额外的代码。想象我们使用一个子协议json，基于该子协议，所有的数据将会作为JSON传递，如果一个客户端征求子协议并且服务器想使用它，服务你需要有一个JSON解析。实话实说，将会有一个工具库，但是服务器也要需要传递数据。</p>\n<p>为了避免名称冲突，推荐选用domain的一部分作为子协议的名称。如果我们开发一个使用特定格式的聊天app，我们可能使用这样的名字:Sec-WebSocket-Protocol: chat.example.com  注意，这不是必须的。仅仅是一个可选的惯例，我们可以使用我们想用的任意字符。</p>\n<h2 id=\"结束语\"><a href=\"#结束语\" class=\"headerlink\" title=\"结束语\"></a>结束语</h2><p>翻译这篇文档的初衷是看到关于websocket的中文大部分都是客户端相关的内容，自己又对服务器端的实现感兴趣，没有找到合适的资料，就只好自己阅读下英文，本着提高自己的目的将其翻译下来，希望对其他同学有所帮助，<a href=\"https://github.com/xiaoxiangdaiyu/chartroom/tree/master/src/websocket\" target=\"_blank\" rel=\"noopener\">原文查看</a> 。后面请期待node实现websocket服务器的实践篇。</p>\n<h2 id=\"源文档出处\"><a href=\"#源文档出处\" class=\"headerlink\" title=\"源文档出处\"></a>源文档出处</h2><p>翻译自MDN<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers\" target=\"_blank\" rel=\"noopener\">Writing WebSocket servers</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck4tbvt1b000agw92t3h9kmjg","tag_id":"ck4tbvt1f000egw92js3v59gk","_id":"ck4tbvt1n000lgw9242aeh262"},{"post_id":"ck4tbvt1j000hgw923edlvxr9","tag_id":"ck4tbvt1m000kgw92rwyt060a","_id":"ck4tbvt1q000pgw92npit62ax"},{"post_id":"ck4tbvt7v001dgw929xvckk02","tag_id":"ck4tbvt7x001fgw92ekl1ebbd","_id":"ck4tbvt7z001jgw92z7fgv42h"}],"Tag":[{"name":"前端 调试","_id":"ck4tbvt1f000egw92js3v59gk"},{"name":"前端 工程结构","_id":"ck4tbvt1m000kgw92rwyt060a"},{"name":"webpack","_id":"ck4tbvt7x001fgw92ekl1ebbd"}]}}